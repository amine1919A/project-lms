import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
    !(function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
    })(exports, (function() {
      "use strict";
      function e(e2, t2) {
        return t2.forEach((function(t3) {
          t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach((function(i2) {
            if ("default" !== i2 && !(i2 in e2)) {
              var n2 = Object.getOwnPropertyDescriptor(t3, i2);
              Object.defineProperty(e2, i2, n2.get ? n2 : { enumerable: true, get: function() {
                return t3[i2];
              } });
            }
          }));
        })), Object.freeze(e2);
      }
      var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function i(e2) {
        return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      var n = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, r = !n((function() {
        var e2 = (function() {
        }).bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      })), o = r, s = Function.prototype, a = s.call, c = o && s.bind.bind(a, a), d = o ? c : function(e2) {
        return function() {
          return a.apply(e2, arguments);
        };
      }, l = d({}.isPrototypeOf), u = function(e2) {
        return e2 && e2.Math === Math && e2;
      }, h = u("object" == typeof globalThis && globalThis) || u("object" == typeof window && window) || u("object" == typeof self && self) || u("object" == typeof t && t) || u("object" == typeof t && t) || /* @__PURE__ */ (function() {
        return this;
      })() || Function("return this")(), p = r, _ = Function.prototype, E = _.apply, m = _.call, f = "object" == typeof Reflect && Reflect.apply || (p ? m.bind(E) : function() {
        return m.apply(E, arguments);
      }), S = d, g = S({}.toString), T = S("".slice), R = function(e2) {
        return T(g(e2), 8, -1);
      }, C = R, v = d, y = function(e2) {
        if ("Function" === C(e2)) return v(e2);
      }, I = "object" == typeof document && document.all, A = void 0 === I && void 0 !== I ? function(e2) {
        return "function" == typeof e2 || e2 === I;
      } : function(e2) {
        return "function" == typeof e2;
      }, b = {}, w = !n((function() {
        return 7 !== Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      })), O = r, N = Function.prototype.call, D = O ? N.bind(N) : function() {
        return N.apply(N, arguments);
      }, P = {}, L = {}.propertyIsEnumerable, k = Object.getOwnPropertyDescriptor, M = k && !L.call({ 1: 2 }, 1);
      P.f = M ? function(e2) {
        var t2 = k(this, e2);
        return !!t2 && t2.enumerable;
      } : L;
      var U, V, x = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, F = n, B = R, j = Object, G = d("".split), W = F((function() {
        return !j("z").propertyIsEnumerable(0);
      })) ? function(e2) {
        return "String" === B(e2) ? G(e2, "") : j(e2);
      } : j, H = function(e2) {
        return null == e2;
      }, K = H, Y = TypeError, z = function(e2) {
        if (K(e2)) throw new Y("Can't call method on " + e2);
        return e2;
      }, q = W, X = z, J = function(e2) {
        return q(X(e2));
      }, Q = A, Z = function(e2) {
        return "object" == typeof e2 ? null !== e2 : Q(e2);
      }, $ = {}, ee = $, te = h, ie = A, ne = function(e2) {
        return ie(e2) ? e2 : void 0;
      }, re = function(e2, t2) {
        return arguments.length < 2 ? ne(ee[e2]) || ne(te[e2]) : ee[e2] && ee[e2][t2] || te[e2] && te[e2][t2];
      }, oe = h.navigator, se = oe && oe.userAgent, ae = se ? String(se) : "", ce = h, de = ae, le = ce.process, ue = ce.Deno, he = le && le.versions || ue && ue.version, pe = he && he.v8;
      pe && (V = (U = pe.split("."))[0] > 0 && U[0] < 4 ? 1 : +(U[0] + U[1])), !V && de && (!(U = de.match(/Edge\/(\d+)/)) || U[1] >= 74) && (U = de.match(/Chrome\/(\d+)/)) && (V = +U[1]);
      var _e = V, Ee = _e, me = n, fe = h.String, Se = !!Object.getOwnPropertySymbols && !me((function() {
        var e2 = Symbol("symbol detection");
        return !fe(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Ee && Ee < 41;
      })), ge = Se && !Symbol.sham && "symbol" == typeof Symbol.iterator, Te = re, Re = A, Ce = l, ve = Object, ye = ge ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t2 = Te("Symbol");
        return Re(t2) && Ce(t2.prototype, ve(e2));
      }, Ie = String, Ae = function(e2) {
        try {
          return Ie(e2);
        } catch (e3) {
          return "Object";
        }
      }, be = A, we = Ae, Oe = TypeError, Ne = function(e2) {
        if (be(e2)) return e2;
        throw new Oe(we(e2) + " is not a function");
      }, De = Ne, Pe = H, Le = function(e2, t2) {
        var i2 = e2[t2];
        return Pe(i2) ? void 0 : De(i2);
      }, ke = D, Me = A, Ue = Z, Ve = TypeError, xe = { exports: {} }, Fe = h, Be = Object.defineProperty, je = h, Ge = function(e2, t2) {
        try {
          Be(Fe, e2, { value: t2, configurable: true, writable: true });
        } catch (i2) {
          Fe[e2] = t2;
        }
        return t2;
      }, We = "__core-js_shared__", He = xe.exports = je[We] || Ge(We, {});
      (He.versions || (He.versions = [])).push({ version: "3.46.0", mode: "pure", copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)", license: "https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Ke = xe.exports, Ye = Ke, ze = function(e2, t2) {
        return Ye[e2] || (Ye[e2] = t2 || {});
      }, qe = z, Xe = Object, Je = function(e2) {
        return Xe(qe(e2));
      }, Qe = Je, Ze = d({}.hasOwnProperty), $e = Object.hasOwn || function(e2, t2) {
        return Ze(Qe(e2), t2);
      }, et = d, tt = 0, it = Math.random(), nt = et(1.1.toString), rt = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + nt(++tt + it, 36);
      }, ot = ze, st = $e, at = rt, ct = Se, dt = ge, lt = h.Symbol, ut = ot("wks"), ht = dt ? lt.for || lt : lt && lt.withoutSetter || at, pt = function(e2) {
        return st(ut, e2) || (ut[e2] = ct && st(lt, e2) ? lt[e2] : ht("Symbol." + e2)), ut[e2];
      }, _t = D, Et = Z, mt = ye, ft = Le, St = function(e2, t2) {
        var i2, n2;
        if ("string" === t2 && Me(i2 = e2.toString) && !Ue(n2 = ke(i2, e2))) return n2;
        if (Me(i2 = e2.valueOf) && !Ue(n2 = ke(i2, e2))) return n2;
        if ("string" !== t2 && Me(i2 = e2.toString) && !Ue(n2 = ke(i2, e2))) return n2;
        throw new Ve("Can't convert object to primitive value");
      }, gt = TypeError, Tt = pt("toPrimitive"), Rt = function(e2, t2) {
        if (!Et(e2) || mt(e2)) return e2;
        var i2, n2 = ft(e2, Tt);
        if (n2) {
          if (void 0 === t2 && (t2 = "default"), i2 = _t(n2, e2, t2), !Et(i2) || mt(i2)) return i2;
          throw new gt("Can't convert object to primitive value");
        }
        return void 0 === t2 && (t2 = "number"), St(e2, t2);
      }, Ct = ye, vt = function(e2) {
        var t2 = Rt(e2, "string");
        return Ct(t2) ? t2 : t2 + "";
      }, yt = Z, It = h.document, At = yt(It) && yt(It.createElement), bt = function(e2) {
        return At ? It.createElement(e2) : {};
      }, wt = bt, Ot = !w && !n((function() {
        return 7 !== Object.defineProperty(wt("div"), "a", { get: function() {
          return 7;
        } }).a;
      })), Nt = w, Dt = D, Pt = P, Lt = x, kt = J, Mt = vt, Ut = $e, Vt = Ot, xt = Object.getOwnPropertyDescriptor;
      b.f = Nt ? xt : function(e2, t2) {
        if (e2 = kt(e2), t2 = Mt(t2), Vt) try {
          return xt(e2, t2);
        } catch (e3) {
        }
        if (Ut(e2, t2)) return Lt(!Dt(Pt.f, e2, t2), e2[t2]);
      };
      var Ft = n, Bt = A, jt = /#|\.prototype\./, Gt = function(e2, t2) {
        var i2 = Ht[Wt(e2)];
        return i2 === Yt || i2 !== Kt && (Bt(t2) ? Ft(t2) : !!t2);
      }, Wt = Gt.normalize = function(e2) {
        return String(e2).replace(jt, ".").toLowerCase();
      }, Ht = Gt.data = {}, Kt = Gt.NATIVE = "N", Yt = Gt.POLYFILL = "P", zt = Gt, qt = Ne, Xt = r, Jt = y(y.bind), Qt = function(e2, t2) {
        return qt(e2), void 0 === t2 ? e2 : Xt ? Jt(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, Zt = {}, $t = w && n((function() {
        return 42 !== Object.defineProperty((function() {
        }), "prototype", { value: 42, writable: false }).prototype;
      })), ei = Z, ti = String, ii = TypeError, ni = function(e2) {
        if (ei(e2)) return e2;
        throw new ii(ti(e2) + " is not an object");
      }, ri = w, oi = Ot, si = $t, ai = ni, ci = vt, di = TypeError, li = Object.defineProperty, ui = Object.getOwnPropertyDescriptor, hi = "enumerable", pi = "configurable", _i = "writable";
      Zt.f = ri ? si ? function(e2, t2, i2) {
        if (ai(e2), t2 = ci(t2), ai(i2), "function" == typeof e2 && "prototype" === t2 && "value" in i2 && _i in i2 && !i2[_i]) {
          var n2 = ui(e2, t2);
          n2 && n2[_i] && (e2[t2] = i2.value, i2 = { configurable: pi in i2 ? i2[pi] : n2[pi], enumerable: hi in i2 ? i2[hi] : n2[hi], writable: false });
        }
        return li(e2, t2, i2);
      } : li : function(e2, t2, i2) {
        if (ai(e2), t2 = ci(t2), ai(i2), oi) try {
          return li(e2, t2, i2);
        } catch (e3) {
        }
        if ("get" in i2 || "set" in i2) throw new di("Accessors not supported");
        return "value" in i2 && (e2[t2] = i2.value), e2;
      };
      var Ei = Zt, mi = x, fi = w ? function(e2, t2, i2) {
        return Ei.f(e2, t2, mi(1, i2));
      } : function(e2, t2, i2) {
        return e2[t2] = i2, e2;
      }, Si = h, gi = f, Ti = y, Ri = A, Ci = b.f, vi = zt, yi = $, Ii = Qt, Ai = fi, bi = $e, wi = function(e2) {
        var t2 = function(i2, n2, r2) {
          if (this instanceof t2) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(i2);
              case 2:
                return new e2(i2, n2);
            }
            return new e2(i2, n2, r2);
          }
          return gi(e2, this, arguments);
        };
        return t2.prototype = e2.prototype, t2;
      }, Oi = function(e2, t2) {
        var i2, n2, r2, o2, s2, a2, c2, d2, l2, u2 = e2.target, h2 = e2.global, p2 = e2.stat, _2 = e2.proto, E2 = h2 ? Si : p2 ? Si[u2] : Si[u2] && Si[u2].prototype, m2 = h2 ? yi : yi[u2] || Ai(yi, u2, {})[u2], f2 = m2.prototype;
        for (o2 in t2) n2 = !(i2 = vi(h2 ? o2 : u2 + (p2 ? "." : "#") + o2, e2.forced)) && E2 && bi(E2, o2), a2 = m2[o2], n2 && (c2 = e2.dontCallGetSet ? (l2 = Ci(E2, o2)) && l2.value : E2[o2]), s2 = n2 && c2 ? c2 : t2[o2], (i2 || _2 || typeof a2 != typeof s2) && (d2 = e2.bind && n2 ? Ii(s2, Si) : e2.wrap && n2 ? wi(s2) : _2 && Ri(s2) ? Ti(s2) : s2, (e2.sham || s2 && s2.sham || a2 && a2.sham) && Ai(d2, "sham", true), Ai(m2, o2, d2), _2 && (bi(yi, r2 = u2 + "Prototype") || Ai(yi, r2, {}), Ai(yi[r2], o2, s2), e2.real && f2 && (i2 || !f2[o2]) && Ai(f2, o2, s2)));
      }, Ni = Math.ceil, Di = Math.floor, Pi = Math.trunc || function(e2) {
        var t2 = +e2;
        return (t2 > 0 ? Di : Ni)(t2);
      }, Li = Pi, ki = function(e2) {
        var t2 = +e2;
        return t2 != t2 || 0 === t2 ? 0 : Li(t2);
      }, Mi = ki, Ui = Math.max, Vi = Math.min, xi = function(e2, t2) {
        var i2 = Mi(e2);
        return i2 < 0 ? Ui(i2 + t2, 0) : Vi(i2, t2);
      }, Fi = ki, Bi = Math.min, ji = function(e2) {
        var t2 = Fi(e2);
        return t2 > 0 ? Bi(t2, 9007199254740991) : 0;
      }, Gi = ji, Wi = function(e2) {
        return Gi(e2.length);
      }, Hi = J, Ki = xi, Yi = Wi, zi = function(e2) {
        return function(t2, i2, n2) {
          var r2 = Hi(t2), o2 = Yi(r2);
          if (0 === o2) return !e2 && -1;
          var s2, a2 = Ki(n2, o2);
          if (e2 && i2 != i2) {
            for (; o2 > a2; ) if ((s2 = r2[a2++]) != s2) return true;
          } else for (; o2 > a2; a2++) if ((e2 || a2 in r2) && r2[a2] === i2) return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, qi = { includes: zi(true), indexOf: zi(false) }, Xi = qi.includes;
      Oi({ target: "Array", proto: true, forced: n((function() {
        return !Array(1).includes();
      })) }, { includes: function(e2) {
        return Xi(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Ji = h, Qi = $, Zi = function(e2, t2) {
        var i2 = Qi[e2 + "Prototype"], n2 = i2 && i2[t2];
        if (n2) return n2;
        var r2 = Ji[e2], o2 = r2 && r2.prototype;
        return o2 && o2[t2];
      }, $i = Zi("Array", "includes"), en = Z, tn = R, nn = pt("match"), rn = function(e2) {
        var t2;
        return en(e2) && (void 0 !== (t2 = e2[nn]) ? !!t2 : "RegExp" === tn(e2));
      }, on = rn, sn = TypeError, an = {};
      an[pt("toStringTag")] = "z";
      var cn = "[object z]" === String(an), dn = cn, ln = A, un = R, hn = pt("toStringTag"), pn = Object, _n = "Arguments" === un(/* @__PURE__ */ (function() {
        return arguments;
      })()), En = dn ? un : function(e2) {
        var t2, i2, n2;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = (function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        })(t2 = pn(e2), hn)) ? i2 : _n ? un(t2) : "Object" === (n2 = un(t2)) && ln(t2.callee) ? "Arguments" : n2;
      }, mn = En, fn = String, Sn = function(e2) {
        if ("Symbol" === mn(e2)) throw new TypeError("Cannot convert a Symbol value to a string");
        return fn(e2);
      }, gn = pt("match"), Tn = Oi, Rn = function(e2) {
        if (on(e2)) throw new sn("The method doesn't accept regular expressions");
        return e2;
      }, Cn = z, vn = Sn, yn = function(e2) {
        var t2 = /./;
        try {
          "/./"[e2](t2);
        } catch (i2) {
          try {
            return t2[gn] = false, "/./"[e2](t2);
          } catch (e3) {
          }
        }
        return false;
      }, In = d("".indexOf);
      Tn({ target: "String", proto: true, forced: !yn("includes") }, { includes: function(e2) {
        return !!~In(vn(Cn(this)), vn(Rn(e2)), arguments.length > 1 ? arguments[1] : void 0);
      } });
      var An = Zi("String", "includes"), bn = l, wn = $i, On = An, Nn = Array.prototype, Dn = String.prototype, Pn = function(e2) {
        var t2 = e2.includes;
        return e2 === Nn || bn(Nn, e2) && t2 === Nn.includes ? wn : "string" == typeof e2 || e2 === Dn || bn(Dn, e2) && t2 === Dn.includes ? On : t2;
      }, Ln = i(Pn), kn = Ne, Mn = Je, Un = W, Vn = Wi, xn = TypeError, Fn = "Reduce of empty array with no initial value", Bn = function(e2) {
        return function(t2, i2, n2, r2) {
          var o2 = Mn(t2), s2 = Un(o2), a2 = Vn(o2);
          if (kn(i2), 0 === a2 && n2 < 2) throw new xn(Fn);
          var c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
          if (n2 < 2) for (; ; ) {
            if (c2 in s2) {
              r2 = s2[c2], c2 += d2;
              break;
            }
            if (c2 += d2, e2 ? c2 < 0 : a2 <= c2) throw new xn(Fn);
          }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2) c2 in s2 && (r2 = i2(r2, s2[c2], c2, o2));
          return r2;
        };
      }, jn = { left: Bn(false), right: Bn(true) }, Gn = n, Wn = function(e2, t2) {
        var i2 = [][e2];
        return !!i2 && Gn((function() {
          i2.call(null, t2 || function() {
            return 1;
          }, 1);
        }));
      }, Hn = h, Kn = ae, Yn = R, zn = function(e2) {
        return Kn.slice(0, e2.length) === e2;
      }, qn = zn("Bun/") ? "BUN" : zn("Cloudflare-Workers") ? "CLOUDFLARE" : zn("Deno/") ? "DENO" : zn("Node.js/") ? "NODE" : Hn.Bun && "string" == typeof Bun.version ? "BUN" : Hn.Deno && "object" == typeof Deno.version ? "DENO" : "process" === Yn(Hn.process) ? "NODE" : Hn.window && Hn.document ? "BROWSER" : "REST", Xn = "NODE" === qn, Jn = jn.left;
      Oi({ target: "Array", proto: true, forced: !Xn && _e > 79 && _e < 83 || !Wn("reduce") }, { reduce: function(e2) {
        var t2 = arguments.length;
        return Jn(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var Qn = Zi("Array", "reduce"), Zn = l, $n = Qn, er = Array.prototype, tr = function(e2) {
        var t2 = e2.reduce;
        return e2 === er || Zn(er, e2) && t2 === er.reduce ? $n : t2;
      }, ir = tr, nr = i(ir), rr = R, or = Array.isArray || function(e2) {
        return "Array" === rr(e2);
      }, sr = Oi, ar = or, cr = d([].reverse), dr = [1, 2];
      sr({ target: "Array", proto: true, forced: String(dr) === String(dr.reverse()) }, { reverse: function() {
        return ar(this) && (this.length = this.length), cr(this);
      } });
      var lr = Zi("Array", "reverse"), ur = l, hr = lr, pr = Array.prototype, _r = function(e2) {
        var t2 = e2.reverse;
        return e2 === pr || ur(pr, e2) && t2 === pr.reverse ? hr : t2;
      }, Er = _r, mr = i(Er), fr = rt, Sr = ze("keys"), gr = function(e2) {
        return Sr[e2] || (Sr[e2] = fr(e2));
      }, Tr = !n((function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      })), Rr = $e, Cr = A, vr = Je, yr = Tr, Ir = gr("IE_PROTO"), Ar = Object, br = Ar.prototype, wr = yr ? Ar.getPrototypeOf : function(e2) {
        var t2 = vr(e2);
        if (Rr(t2, Ir)) return t2[Ir];
        var i2 = t2.constructor;
        return Cr(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof Ar ? br : null;
      }, Or = d, Nr = Ne, Dr = Z, Pr = function(e2) {
        return Dr(e2) || null === e2;
      }, Lr = String, kr = TypeError, Mr = function(e2, t2, i2) {
        try {
          return Or(Nr(Object.getOwnPropertyDescriptor(e2, t2)[i2]));
        } catch (e3) {
        }
      }, Ur = Z, Vr = z, xr = function(e2) {
        if (Pr(e2)) return e2;
        throw new kr("Can't set " + Lr(e2) + " as a prototype");
      }, Fr = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
        var e2, t2 = false, i2 = {};
        try {
          (e2 = Mr(Object.prototype, "__proto__", "set"))(i2, []), t2 = i2 instanceof Array;
        } catch (e3) {
        }
        return function(i3, n2) {
          return Vr(i3), xr(n2), Ur(i3) ? (t2 ? e2(i3, n2) : i3.__proto__ = n2, i3) : i3;
        };
      })() : void 0), Br = {}, jr = {}, Gr = $e, Wr = J, Hr = qi.indexOf, Kr = jr, Yr = d([].push), zr = function(e2, t2) {
        var i2, n2 = Wr(e2), r2 = 0, o2 = [];
        for (i2 in n2) !Gr(Kr, i2) && Gr(n2, i2) && Yr(o2, i2);
        for (; t2.length > r2; ) Gr(n2, i2 = t2[r2++]) && (~Hr(o2, i2) || Yr(o2, i2));
        return o2;
      }, qr = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Xr = zr, Jr = qr.concat("length", "prototype");
      Br.f = Object.getOwnPropertyNames || function(e2) {
        return Xr(e2, Jr);
      };
      var Qr = {};
      Qr.f = Object.getOwnPropertySymbols;
      var Zr = re, $r = Br, eo = Qr, to = ni, io = d([].concat), no = Zr("Reflect", "ownKeys") || function(e2) {
        var t2 = $r.f(to(e2)), i2 = eo.f;
        return i2 ? io(t2, i2(e2)) : t2;
      }, ro = $e, oo = no, so = b, ao = Zt, co = {}, lo = zr, uo = qr, ho = Object.keys || function(e2) {
        return lo(e2, uo);
      }, po = w, _o = $t, Eo = Zt, mo = ni, fo = J, So = ho;
      co.f = po && !_o ? Object.defineProperties : function(e2, t2) {
        mo(e2);
        for (var i2, n2 = fo(t2), r2 = So(t2), o2 = r2.length, s2 = 0; o2 > s2; ) Eo.f(e2, i2 = r2[s2++], n2[i2]);
        return e2;
      };
      var go, To = re("document", "documentElement"), Ro = ni, Co = co, vo = qr, yo = jr, Io = To, Ao = bt, bo = "prototype", wo = "script", Oo = gr("IE_PROTO"), No = function() {
      }, Do = function(e2) {
        return "<" + wo + ">" + e2 + "</" + wo + ">";
      }, Po = function(e2) {
        e2.write(Do("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, Lo = function() {
        try {
          go = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2, i2;
        Lo = "undefined" != typeof document ? document.domain && go ? Po(go) : (t2 = Ao("iframe"), i2 = "java" + wo + ":", t2.style.display = "none", Io.appendChild(t2), t2.src = String(i2), (e2 = t2.contentWindow.document).open(), e2.write(Do("document.F=Object")), e2.close(), e2.F) : Po(go);
        for (var n2 = vo.length; n2--; ) delete Lo[bo][vo[n2]];
        return Lo();
      };
      yo[Oo] = true;
      var ko = Object.create || function(e2, t2) {
        var i2;
        return null !== e2 ? (No[bo] = Ro(e2), i2 = new No(), No[bo] = null, i2[Oo] = e2) : i2 = Lo(), void 0 === t2 ? i2 : Co.f(i2, t2);
      }, Mo = Z, Uo = fi, Vo = Error, xo = d("".replace), Fo = String(new Vo("zxcasd").stack), Bo = /\n\s*at [^:]*:[^\n]*/, jo = Bo.test(Fo), Go = x, Wo = !n((function() {
        var e2 = new Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", Go(1, 7)), 7 !== e2.stack);
      })), Ho = fi, Ko = function(e2, t2) {
        if (jo && "string" == typeof e2 && !Vo.prepareStackTrace) for (; t2--; ) e2 = xo(e2, Bo, "");
        return e2;
      }, Yo = Wo, zo = Error.captureStackTrace, qo = {}, Xo = qo, Jo = pt("iterator"), Qo = Array.prototype, Zo = function(e2) {
        return void 0 !== e2 && (Xo.Array === e2 || Qo[Jo] === e2);
      }, $o = En, es = Le, ts = H, is = qo, ns = pt("iterator"), rs = function(e2) {
        if (!ts(e2)) return es(e2, ns) || es(e2, "@@iterator") || is[$o(e2)];
      }, os = D, ss = Ne, as = ni, cs = Ae, ds = rs, ls = TypeError, us = function(e2, t2) {
        var i2 = arguments.length < 2 ? ds(e2) : t2;
        if (ss(i2)) return as(os(i2, e2));
        throw new ls(cs(e2) + " is not iterable");
      }, hs = D, ps = ni, _s = Le, Es = function(e2, t2, i2) {
        var n2, r2;
        ps(e2);
        try {
          if (!(n2 = _s(e2, "return"))) {
            if ("throw" === t2) throw i2;
            return i2;
          }
          n2 = hs(n2, e2);
        } catch (e3) {
          r2 = true, n2 = e3;
        }
        if ("throw" === t2) throw i2;
        if (r2) throw n2;
        return ps(n2), i2;
      }, ms = Qt, fs = D, Ss = ni, gs = Ae, Ts = Zo, Rs = Wi, Cs = l, vs = us, ys = rs, Is = Es, As = TypeError, bs = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, ws = bs.prototype, Os = function(e2, t2, i2) {
        var n2, r2, o2, s2, a2, c2, d2, l2 = i2 && i2.that, u2 = !(!i2 || !i2.AS_ENTRIES), h2 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), _2 = !(!i2 || !i2.INTERRUPTED), E2 = ms(t2, l2), m2 = function(e3) {
          return n2 && Is(n2, "normal"), new bs(true, e3);
        }, f2 = function(e3) {
          return u2 ? (Ss(e3), _2 ? E2(e3[0], e3[1], m2) : E2(e3[0], e3[1])) : _2 ? E2(e3, m2) : E2(e3);
        };
        if (h2) n2 = e2.iterator;
        else if (p2) n2 = e2;
        else {
          if (!(r2 = ys(e2))) throw new As(gs(e2) + " is not iterable");
          if (Ts(r2)) {
            for (o2 = 0, s2 = Rs(e2); s2 > o2; o2++) if ((a2 = f2(e2[o2])) && Cs(ws, a2)) return a2;
            return new bs(false);
          }
          n2 = vs(e2, r2);
        }
        for (c2 = h2 ? e2.next : n2.next; !(d2 = fs(c2, n2)).done; ) {
          try {
            a2 = f2(d2.value);
          } catch (e3) {
            Is(n2, "throw", e3);
          }
          if ("object" == typeof a2 && a2 && Cs(ws, a2)) return a2;
        }
        return new bs(false);
      }, Ns = Sn, Ds = Oi, Ps = l, Ls = wr, ks = Fr, Ms = function(e2, t2, i2) {
        for (var n2 = oo(t2), r2 = ao.f, o2 = so.f, s2 = 0; s2 < n2.length; s2++) {
          var a2 = n2[s2];
          ro(e2, a2) || i2 && ro(i2, a2) || r2(e2, a2, o2(t2, a2));
        }
      }, Us = ko, Vs = fi, xs = x, Fs = function(e2, t2) {
        Mo(t2) && "cause" in t2 && Uo(e2, "cause", t2.cause);
      }, Bs = function(e2, t2, i2, n2) {
        Yo && (zo ? zo(e2, t2) : Ho(e2, "stack", Ko(i2, n2)));
      }, js = Os, Gs = function(e2, t2) {
        return void 0 === e2 ? arguments.length < 2 ? "" : t2 : Ns(e2);
      }, Ws = pt("toStringTag"), Hs = Error, Ks = [].push, Ys = function(e2, t2) {
        var i2, n2 = Ps(zs, this);
        ks ? i2 = ks(new Hs(), n2 ? Ls(this) : zs) : (i2 = n2 ? this : Us(zs), Vs(i2, Ws, "Error")), void 0 !== t2 && Vs(i2, "message", Gs(t2)), Bs(i2, Ys, i2.stack, 1), arguments.length > 2 && Fs(i2, arguments[2]);
        var r2 = [];
        return js(e2, Ks, { that: r2 }), Vs(i2, "errors", r2), i2;
      };
      ks ? ks(Ys, Hs) : Ms(Ys, Hs, { name: true });
      var zs = Ys.prototype = Us(Hs.prototype, { constructor: xs(1, Ys), message: xs(1, ""), name: xs(1, "AggregateError") });
      Ds({ global: true, constructor: true, arity: 2 }, { AggregateError: Ys });
      var qs, Xs, Js, Qs = A, Zs = h.WeakMap, $s = Qs(Zs) && /native code/.test(String(Zs)), ea = h, ta = Z, ia = fi, na = $e, ra = Ke, oa = gr, sa = jr, aa = "Object already initialized", ca = ea.TypeError, da = ea.WeakMap;
      if ($s || ra.state) {
        var la = ra.state || (ra.state = new da());
        la.get = la.get, la.has = la.has, la.set = la.set, qs = function(e2, t2) {
          if (la.has(e2)) throw new ca(aa);
          return t2.facade = e2, la.set(e2, t2), t2;
        }, Xs = function(e2) {
          return la.get(e2) || {};
        }, Js = function(e2) {
          return la.has(e2);
        };
      } else {
        var ua = oa("state");
        sa[ua] = true, qs = function(e2, t2) {
          if (na(e2, ua)) throw new ca(aa);
          return t2.facade = e2, ia(e2, ua, t2), t2;
        }, Xs = function(e2) {
          return na(e2, ua) ? e2[ua] : {};
        }, Js = function(e2) {
          return na(e2, ua);
        };
      }
      var ha, pa, _a, Ea = { set: qs, get: Xs, has: Js, enforce: function(e2) {
        return Js(e2) ? Xs(e2) : qs(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var i2;
          if (!ta(t2) || (i2 = Xs(t2)).type !== e2) throw new ca("Incompatible receiver, " + e2 + " required");
          return i2;
        };
      } }, ma = w, fa = $e, Sa = Function.prototype, ga = ma && Object.getOwnPropertyDescriptor, Ta = fa(Sa, "name"), Ra = { EXISTS: Ta, PROPER: Ta && "something" === (function() {
      }).name, CONFIGURABLE: Ta && (!ma || ma && ga(Sa, "name").configurable) }, Ca = fi, va = function(e2, t2, i2, n2) {
        return n2 && n2.enumerable ? e2[t2] = i2 : Ca(e2, t2, i2), e2;
      }, ya = n, Ia = A, Aa = Z, ba = ko, wa = wr, Oa = va, Na = pt("iterator"), Da = false;
      [].keys && ("next" in (_a = [].keys()) ? (pa = wa(wa(_a))) !== Object.prototype && (ha = pa) : Da = true);
      var Pa = !Aa(ha) || ya((function() {
        var e2 = {};
        return ha[Na].call(e2) !== e2;
      }));
      Ia((ha = Pa ? {} : ba(ha))[Na]) || Oa(ha, Na, (function() {
        return this;
      }));
      var La = { IteratorPrototype: ha, BUGGY_SAFARI_ITERATORS: Da }, ka = En, Ma = cn ? {}.toString : function() {
        return "[object " + ka(this) + "]";
      }, Ua = cn, Va = Zt.f, xa = fi, Fa = $e, Ba = Ma, ja = pt("toStringTag"), Ga = function(e2, t2, i2, n2) {
        var r2 = i2 ? e2 : e2 && e2.prototype;
        r2 && (Fa(r2, ja) || Va(r2, ja, { configurable: true, value: t2 }), n2 && !Ua && xa(r2, "toString", Ba));
      }, Wa = La.IteratorPrototype, Ha = ko, Ka = x, Ya = Ga, za = qo, qa = function() {
        return this;
      }, Xa = function(e2, t2, i2, n2) {
        var r2 = t2 + " Iterator";
        return e2.prototype = Ha(Wa, { next: Ka(+!n2, i2) }), Ya(e2, r2, false, true), za[r2] = qa, e2;
      }, Ja = Oi, Qa = D, Za = Ra, $a = Xa, ec = wr, tc = Ga, ic = va, nc = qo, rc = La, oc = Za.PROPER, sc = rc.BUGGY_SAFARI_ITERATORS, ac = pt("iterator"), cc = "keys", dc = "values", lc = "entries", uc = function() {
        return this;
      }, hc = function(e2, t2, i2, n2, r2, o2, s2) {
        $a(i2, t2, n2);
        var a2, c2, d2, l2 = function(e3) {
          if (e3 === r2 && E2) return E2;
          if (!sc && e3 && e3 in p2) return p2[e3];
          switch (e3) {
            case cc:
            case dc:
            case lc:
              return function() {
                return new i2(this, e3);
              };
          }
          return function() {
            return new i2(this);
          };
        }, u2 = t2 + " Iterator", h2 = false, p2 = e2.prototype, _2 = p2[ac] || p2["@@iterator"] || r2 && p2[r2], E2 = !sc && _2 || l2(r2), m2 = "Array" === t2 && p2.entries || _2;
        if (m2 && (a2 = ec(m2.call(new e2()))) !== Object.prototype && a2.next && (tc(a2, u2, true, true), nc[u2] = uc), oc && r2 === dc && _2 && _2.name !== dc && (h2 = true, E2 = function() {
          return Qa(_2, this);
        }), r2) if (c2 = { values: l2(dc), keys: o2 ? E2 : l2(cc), entries: l2(lc) }, s2) for (d2 in c2) (sc || h2 || !(d2 in p2)) && ic(p2, d2, c2[d2]);
        else Ja({ target: t2, proto: true, forced: sc || h2 }, c2);
        return s2 && p2[ac] !== E2 && ic(p2, ac, E2, { name: r2 }), nc[t2] = E2, c2;
      }, pc = function(e2, t2) {
        return { value: e2, done: t2 };
      }, _c = J, Ec = qo, mc = Ea;
      Zt.f;
      var fc = hc, Sc = pc, gc = "Array Iterator", Tc = mc.set, Rc = mc.getterFor(gc);
      fc(Array, "Array", (function(e2, t2) {
        Tc(this, { type: gc, target: _c(e2), index: 0, kind: t2 });
      }), (function() {
        var e2 = Rc(this), t2 = e2.target, i2 = e2.index++;
        if (!t2 || i2 >= t2.length) return e2.target = null, Sc(void 0, true);
        switch (e2.kind) {
          case "keys":
            return Sc(i2, false);
          case "values":
            return Sc(t2[i2], false);
        }
        return Sc([i2, t2[i2]], false);
      }), "values"), Ec.Arguments = Ec.Array;
      var Cc = Zt, vc = function(e2, t2, i2) {
        return Cc.f(e2, t2, i2);
      }, yc = re, Ic = vc, Ac = w, bc = pt("species"), wc = l, Oc = TypeError, Nc = function(e2, t2) {
        if (wc(t2, e2)) return e2;
        throw new Oc("Incorrect invocation");
      }, Dc = A, Pc = Ke, Lc = d(Function.toString);
      Dc(Pc.inspectSource) || (Pc.inspectSource = function(e2) {
        return Lc(e2);
      });
      var kc = Pc.inspectSource, Mc = d, Uc = n, Vc = A, xc = En, Fc = kc, Bc = function() {
      }, jc = re("Reflect", "construct"), Gc = /^\s*(?:class|function)\b/, Wc = Mc(Gc.exec), Hc = !Gc.test(Bc), Kc = function(e2) {
        if (!Vc(e2)) return false;
        try {
          return jc(Bc, [], e2), true;
        } catch (e3) {
          return false;
        }
      }, Yc = function(e2) {
        if (!Vc(e2)) return false;
        switch (xc(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return Hc || !!Wc(Gc, Fc(e2));
        } catch (e3) {
          return true;
        }
      };
      Yc.sham = true;
      var zc, qc, Xc, Jc, Qc = !jc || Uc((function() {
        var e2;
        return Kc(Kc.call) || !Kc(Object) || !Kc((function() {
          e2 = true;
        })) || e2;
      })) ? Yc : Kc, Zc = Qc, $c = Ae, ed = TypeError, td = ni, id = function(e2) {
        if (Zc(e2)) return e2;
        throw new ed($c(e2) + " is not a constructor");
      }, nd = H, rd = pt("species"), od = function(e2, t2) {
        var i2, n2 = td(e2).constructor;
        return void 0 === n2 || nd(i2 = td(n2)[rd]) ? t2 : id(i2);
      }, sd = d([].slice), ad = TypeError, cd = function(e2, t2) {
        if (e2 < t2) throw new ad("Not enough arguments");
        return e2;
      }, dd = /(?:ipad|iphone|ipod).*applewebkit/i.test(ae), ld = h, ud = f, hd = Qt, pd = A, _d = $e, Ed = n, md = To, fd = sd, Sd = bt, gd = cd, Td = dd, Rd = Xn, Cd = ld.setImmediate, vd = ld.clearImmediate, yd = ld.process, Id = ld.Dispatch, Ad = ld.Function, bd = ld.MessageChannel, wd = ld.String, Od = 0, Nd = {}, Dd = "onreadystatechange";
      Ed((function() {
        zc = ld.location;
      }));
      var Pd = function(e2) {
        if (_d(Nd, e2)) {
          var t2 = Nd[e2];
          delete Nd[e2], t2();
        }
      }, Ld = function(e2) {
        return function() {
          Pd(e2);
        };
      }, kd = function(e2) {
        Pd(e2.data);
      }, Md = function(e2) {
        ld.postMessage(wd(e2), zc.protocol + "//" + zc.host);
      };
      Cd && vd || (Cd = function(e2) {
        gd(arguments.length, 1);
        var t2 = pd(e2) ? e2 : Ad(e2), i2 = fd(arguments, 1);
        return Nd[++Od] = function() {
          ud(t2, void 0, i2);
        }, qc(Od), Od;
      }, vd = function(e2) {
        delete Nd[e2];
      }, Rd ? qc = function(e2) {
        yd.nextTick(Ld(e2));
      } : Id && Id.now ? qc = function(e2) {
        Id.now(Ld(e2));
      } : bd && !Td ? (Jc = (Xc = new bd()).port2, Xc.port1.onmessage = kd, qc = hd(Jc.postMessage, Jc)) : ld.addEventListener && pd(ld.postMessage) && !ld.importScripts && zc && "file:" !== zc.protocol && !Ed(Md) ? (qc = Md, ld.addEventListener("message", kd, false)) : qc = Dd in Sd("script") ? function(e2) {
        md.appendChild(Sd("script"))[Dd] = function() {
          md.removeChild(this), Pd(e2);
        };
      } : function(e2) {
        setTimeout(Ld(e2), 0);
      });
      var Ud = { set: Cd, clear: vd }, Vd = h, xd = w, Fd = Object.getOwnPropertyDescriptor, Bd = function(e2) {
        if (!xd) return Vd[e2];
        var t2 = Fd(Vd, e2);
        return t2 && t2.value;
      }, jd = function() {
        this.head = null, this.tail = null;
      };
      jd.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null }, i2 = this.tail;
        i2 ? i2.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2) return null === (this.head = e2.next) && (this.tail = null), e2.item;
      } };
      var Gd, Wd, Hd, Kd, Yd, zd = jd, qd = /ipad|iphone|ipod/i.test(ae) && "undefined" != typeof Pebble, Xd = /web0s(?!.*chrome)/i.test(ae), Jd = h, Qd = Bd, Zd = Qt, $d = Ud.set, el = zd, tl = dd, il = qd, nl = Xd, rl = Xn, ol = Jd.MutationObserver || Jd.WebKitMutationObserver, sl = Jd.document, al = Jd.process, cl = Jd.Promise, dl = Qd("queueMicrotask");
      if (!dl) {
        var ll = new el(), ul = function() {
          var e2, t2;
          for (rl && (e2 = al.domain) && e2.exit(); t2 = ll.get(); ) try {
            t2();
          } catch (e3) {
            throw ll.head && Gd(), e3;
          }
          e2 && e2.enter();
        };
        tl || rl || nl || !ol || !sl ? !il && cl && cl.resolve ? ((Kd = cl.resolve(void 0)).constructor = cl, Yd = Zd(Kd.then, Kd), Gd = function() {
          Yd(ul);
        }) : rl ? Gd = function() {
          al.nextTick(ul);
        } : ($d = Zd($d, Jd), Gd = function() {
          $d(ul);
        }) : (Wd = true, Hd = sl.createTextNode(""), new ol(ul).observe(Hd, { characterData: true }), Gd = function() {
          Hd.data = Wd = !Wd;
        }), dl = function(e2) {
          ll.head || Gd(), ll.add(e2);
        };
      }
      var hl = dl, pl = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, _l = h.Promise, El = h, ml = _l, fl = A, Sl = zt, gl = kc, Tl = pt, Rl = qn, Cl = _e, vl = ml && ml.prototype, yl = Tl("species"), Il = false, Al = fl(El.PromiseRejectionEvent), bl = Sl("Promise", (function() {
        var e2 = gl(ml), t2 = e2 !== String(ml);
        if (!t2 && 66 === Cl) return true;
        if (!vl.catch || !vl.finally) return true;
        if (!Cl || Cl < 51 || !/native code/.test(e2)) {
          var i2 = new ml((function(e3) {
            e3(1);
          })), n2 = function(e3) {
            e3((function() {
            }), (function() {
            }));
          };
          if ((i2.constructor = {})[yl] = n2, !(Il = i2.then((function() {
          })) instanceof n2)) return true;
        }
        return !(t2 || "BROWSER" !== Rl && "DENO" !== Rl || Al);
      })), wl = { CONSTRUCTOR: bl, REJECTION_EVENT: Al, SUBCLASSING: Il }, Ol = {}, Nl = Ne, Dl = TypeError, Pl = function(e2) {
        var t2, i2;
        this.promise = new e2((function(e3, n2) {
          if (void 0 !== t2 || void 0 !== i2) throw new Dl("Bad Promise constructor");
          t2 = e3, i2 = n2;
        })), this.resolve = Nl(t2), this.reject = Nl(i2);
      };
      Ol.f = function(e2) {
        return new Pl(e2);
      };
      var Ll, kl, Ml, Ul = Oi, Vl = Xn, xl = h, Fl = $, Bl = D, jl = va, Gl = Ga, Wl = function(e2) {
        var t2 = yc(e2);
        Ac && t2 && !t2[bc] && Ic(t2, bc, { configurable: true, get: function() {
          return this;
        } });
      }, Hl = Ne, Kl = A, Yl = Z, zl = Nc, ql = od, Xl = Ud.set, Jl = hl, Ql = function(e2, t2) {
        try {
          1 === arguments.length ? console.error(e2) : console.error(e2, t2);
        } catch (e3) {
        }
      }, Zl = pl, $l = zd, eu = Ea, tu = _l, iu = wl, nu = Ol, ru = "Promise", ou = iu.CONSTRUCTOR, su = iu.REJECTION_EVENT, au = eu.getterFor(ru), cu = eu.set, du = tu && tu.prototype, lu = tu, uu = du, hu = xl.TypeError, pu = xl.document, _u = xl.process, Eu = nu.f, mu = Eu, fu = !!(pu && pu.createEvent && xl.dispatchEvent), Su = "unhandledrejection", gu = function(e2) {
        var t2;
        return !(!Yl(e2) || !Kl(t2 = e2.then)) && t2;
      }, Tu = function(e2, t2) {
        var i2, n2, r2, o2 = t2.value, s2 = 1 === t2.state, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, l2 = e2.domain;
        try {
          a2 ? (s2 || (2 === t2.rejection && Iu(t2), t2.rejection = 1), true === a2 ? i2 = o2 : (l2 && l2.enter(), i2 = a2(o2), l2 && (l2.exit(), r2 = true)), i2 === e2.promise ? d2(new hu("Promise-chain cycle")) : (n2 = gu(i2)) ? Bl(n2, i2, c2, d2) : c2(i2)) : d2(o2);
        } catch (e3) {
          l2 && !r2 && l2.exit(), d2(e3);
        }
      }, Ru = function(e2, t2) {
        e2.notified || (e2.notified = true, Jl((function() {
          for (var i2, n2 = e2.reactions; i2 = n2.get(); ) Tu(i2, e2);
          e2.notified = false, t2 && !e2.rejection && vu(e2);
        })));
      }, Cu = function(e2, t2, i2) {
        var n2, r2;
        fu ? ((n2 = pu.createEvent("Event")).promise = t2, n2.reason = i2, n2.initEvent(e2, false, true), xl.dispatchEvent(n2)) : n2 = { promise: t2, reason: i2 }, !su && (r2 = xl["on" + e2]) ? r2(n2) : e2 === Su && Ql("Unhandled promise rejection", i2);
      }, vu = function(e2) {
        Bl(Xl, xl, (function() {
          var t2, i2 = e2.facade, n2 = e2.value;
          if (yu(e2) && (t2 = Zl((function() {
            Vl ? _u.emit("unhandledRejection", n2, i2) : Cu(Su, i2, n2);
          })), e2.rejection = Vl || yu(e2) ? 2 : 1, t2.error)) throw t2.value;
        }));
      }, yu = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, Iu = function(e2) {
        Bl(Xl, xl, (function() {
          var t2 = e2.facade;
          Vl ? _u.emit("rejectionHandled", t2) : Cu("rejectionhandled", t2, e2.value);
        }));
      }, Au = function(e2, t2, i2) {
        return function(n2) {
          e2(t2, n2, i2);
        };
      }, bu = function(e2, t2, i2) {
        e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t2, e2.state = 2, Ru(e2, true));
      }, wu = function(e2, t2, i2) {
        if (!e2.done) {
          e2.done = true, i2 && (e2 = i2);
          try {
            if (e2.facade === t2) throw new hu("Promise can't be resolved itself");
            var n2 = gu(t2);
            n2 ? Jl((function() {
              var i3 = { done: false };
              try {
                Bl(n2, t2, Au(wu, i3, e2), Au(bu, i3, e2));
              } catch (t3) {
                bu(i3, t3, e2);
              }
            })) : (e2.value = t2, e2.state = 1, Ru(e2, false));
          } catch (t3) {
            bu({ done: false }, t3, e2);
          }
        }
      };
      ou && (uu = (lu = function(e2) {
        zl(this, uu), Hl(e2), Bl(Ll, this);
        var t2 = au(this);
        try {
          e2(Au(wu, t2), Au(bu, t2));
        } catch (e3) {
          bu(t2, e3);
        }
      }).prototype, (Ll = function(e2) {
        cu(this, { type: ru, done: false, notified: false, parent: false, reactions: new $l(), rejection: false, state: 0, value: null });
      }).prototype = jl(uu, "then", (function(e2, t2) {
        var i2 = au(this), n2 = Eu(ql(this, lu));
        return i2.parent = true, n2.ok = !Kl(e2) || e2, n2.fail = Kl(t2) && t2, n2.domain = Vl ? _u.domain : void 0, 0 === i2.state ? i2.reactions.add(n2) : Jl((function() {
          Tu(n2, i2);
        })), n2.promise;
      })), kl = function() {
        var e2 = new Ll(), t2 = au(e2);
        this.promise = e2, this.resolve = Au(wu, t2), this.reject = Au(bu, t2);
      }, nu.f = Eu = function(e2) {
        return e2 === lu || e2 === Ml ? new kl(e2) : mu(e2);
      }), Ul({ global: true, constructor: true, wrap: true, forced: ou }, { Promise: lu }), Ml = Fl.Promise, Gl(lu, ru, false, true), Wl(ru);
      var Ou = pt("iterator"), Nu = false;
      try {
        var Du = 0, Pu = { next: function() {
          return { done: !!Du++ };
        }, return: function() {
          Nu = true;
        } };
        Pu[Ou] = function() {
          return this;
        }, Array.from(Pu, (function() {
          throw 2;
        }));
      } catch (e2) {
      }
      var Lu = _l, ku = function(e2, t2) {
        try {
          if (!t2 && !Nu) return false;
        } catch (e3) {
          return false;
        }
        var i2 = false;
        try {
          var n2 = {};
          n2[Ou] = function() {
            return { next: function() {
              return { done: i2 = true };
            } };
          }, e2(n2);
        } catch (e3) {
        }
        return i2;
      }, Mu = wl.CONSTRUCTOR || !ku((function(e2) {
        Lu.all(e2).then(void 0, (function() {
        }));
      })), Uu = D, Vu = Ne, xu = Ol, Fu = pl, Bu = Os;
      Oi({ target: "Promise", stat: true, forced: Mu }, { all: function(e2) {
        var t2 = this, i2 = xu.f(t2), n2 = i2.resolve, r2 = i2.reject, o2 = Fu((function() {
          var i3 = Vu(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          Bu(e2, (function(e3) {
            var c2 = s2++, d2 = false;
            a2++, Uu(i3, t2, e3).then((function(e4) {
              d2 || (d2 = true, o3[c2] = e4, --a2 || n2(o3));
            }), r2);
          })), --a2 || n2(o3);
        }));
        return o2.error && r2(o2.value), i2.promise;
      } });
      var ju = Oi, Gu = wl.CONSTRUCTOR;
      _l && _l.prototype, ju({ target: "Promise", proto: true, forced: Gu, real: true }, { catch: function(e2) {
        return this.then(void 0, e2);
      } });
      var Wu = D, Hu = Ne, Ku = Ol, Yu = pl, zu = Os;
      Oi({ target: "Promise", stat: true, forced: Mu }, { race: function(e2) {
        var t2 = this, i2 = Ku.f(t2), n2 = i2.reject, r2 = Yu((function() {
          var r3 = Hu(t2.resolve);
          zu(e2, (function(e3) {
            Wu(r3, t2, e3).then(i2.resolve, n2);
          }));
        }));
        return r2.error && n2(r2.value), i2.promise;
      } });
      var qu = Ol;
      Oi({ target: "Promise", stat: true, forced: wl.CONSTRUCTOR }, { reject: function(e2) {
        var t2 = qu.f(this);
        return (0, t2.reject)(e2), t2.promise;
      } });
      var Xu = ni, Ju = Z, Qu = Ol, Zu = function(e2, t2) {
        if (Xu(e2), Ju(t2) && t2.constructor === e2) return t2;
        var i2 = Qu.f(e2);
        return (0, i2.resolve)(t2), i2.promise;
      }, $u = Oi, eh = _l, th = wl.CONSTRUCTOR, ih = Zu, nh = re("Promise"), rh = !th;
      $u({ target: "Promise", stat: true, forced: true }, { resolve: function(e2) {
        return ih(rh && this === nh ? eh : this, e2);
      } });
      var oh = D, sh = Ne, ah = Ol, ch = pl, dh = Os;
      Oi({ target: "Promise", stat: true, forced: Mu }, { allSettled: function(e2) {
        var t2 = this, i2 = ah.f(t2), n2 = i2.resolve, r2 = i2.reject, o2 = ch((function() {
          var i3 = sh(t2.resolve), r3 = [], o3 = 0, s2 = 1;
          dh(e2, (function(e3) {
            var a2 = o3++, c2 = false;
            s2++, oh(i3, t2, e3).then((function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --s2 || n2(r3));
            }), (function(e4) {
              c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --s2 || n2(r3));
            }));
          })), --s2 || n2(r3);
        }));
        return o2.error && r2(o2.value), i2.promise;
      } });
      var lh = D, uh = Ne, hh = re, ph = Ol, _h = pl, Eh = Os, mh = "No one promise resolved";
      Oi({ target: "Promise", stat: true, forced: Mu }, { any: function(e2) {
        var t2 = this, i2 = hh("AggregateError"), n2 = ph.f(t2), r2 = n2.resolve, o2 = n2.reject, s2 = _h((function() {
          var n3 = uh(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
          Eh(e2, (function(e3) {
            var l2 = a2++, u2 = false;
            c2++, lh(n3, t2, e3).then((function(e4) {
              u2 || d2 || (d2 = true, r2(e4));
            }), (function(e4) {
              u2 || d2 || (u2 = true, s3[l2] = e4, --c2 || o2(new i2(s3, mh)));
            }));
          })), --c2 || o2(new i2(s3, mh));
        }));
        return s2.error && o2(s2.value), n2.promise;
      } });
      var fh = Oi, Sh = f, gh = sd, Th = Ol, Rh = Ne, Ch = pl, vh = h.Promise, yh = false;
      fh({ target: "Promise", stat: true, forced: !vh || !vh.try || Ch((function() {
        vh.try((function(e2) {
          yh = 8 === e2;
        }), 8);
      })).error || !yh }, { try: function(e2) {
        var t2 = arguments.length > 1 ? gh(arguments, 1) : [], i2 = Th.f(this), n2 = Ch((function() {
          return Sh(Rh(e2), void 0, t2);
        }));
        return (n2.error ? i2.reject : i2.resolve)(n2.value), i2.promise;
      } });
      var Ih = Ol;
      Oi({ target: "Promise", stat: true }, { withResolvers: function() {
        var e2 = Ih.f(this);
        return { promise: e2.promise, resolve: e2.resolve, reject: e2.reject };
      } });
      var Ah = Oi, bh = _l, wh = n, Oh = re, Nh = A, Dh = od, Ph = Zu, Lh = bh && bh.prototype;
      Ah({ target: "Promise", proto: true, real: true, forced: !!bh && wh((function() {
        Lh.finally.call({ then: function() {
        } }, (function() {
        }));
      })) }, { finally: function(e2) {
        var t2 = Dh(this, Oh("Promise")), i2 = Nh(e2);
        return this.then(i2 ? function(i3) {
          return Ph(t2, e2()).then((function() {
            return i3;
          }));
        } : e2, i2 ? function(i3) {
          return Ph(t2, e2()).then((function() {
            throw i3;
          }));
        } : e2);
      } });
      var kh = d, Mh = ki, Uh = Sn, Vh = z, xh = kh("".charAt), Fh = kh("".charCodeAt), Bh = kh("".slice), jh = function(e2) {
        return function(t2, i2) {
          var n2, r2, o2 = Uh(Vh(t2)), s2 = Mh(i2), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (n2 = Fh(o2, s2)) < 55296 || n2 > 56319 || s2 + 1 === a2 || (r2 = Fh(o2, s2 + 1)) < 56320 || r2 > 57343 ? e2 ? xh(o2, s2) : n2 : e2 ? Bh(o2, s2, s2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
        };
      }, Gh = { codeAt: jh(false), charAt: jh(true) }, Wh = Gh.charAt, Hh = Sn, Kh = Ea, Yh = hc, zh = pc, qh = "String Iterator", Xh = Kh.set, Jh = Kh.getterFor(qh);
      Yh(String, "String", (function(e2) {
        Xh(this, { type: qh, string: Hh(e2), index: 0 });
      }), (function() {
        var e2, t2 = Jh(this), i2 = t2.string, n2 = t2.index;
        return n2 >= i2.length ? zh(void 0, true) : (e2 = Wh(i2, n2), t2.index += e2.length, zh(e2, false));
      }));
      var Qh = $.Promise, Zh = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, $h = h, ep = Ga, tp = qo;
      for (var ip in Zh) ep($h[ip], ip), tp[ip] = tp.Array;
      var np = Qh, rp = i(np), op = Zi("Array", "values"), sp = En, ap = $e, cp = l, dp = op, lp = Array.prototype, up = { DOMTokenList: true, NodeList: true }, hp = function(e2) {
        var t2 = e2.values;
        return e2 === lp || cp(lp, e2) && t2 === lp.values || ap(up, sp(e2)) ? dp : t2;
      }, pp = i(hp), _p = Ae, Ep = TypeError, mp = sd, fp = Math.floor, Sp = function(e2, t2) {
        var i2 = e2.length;
        if (i2 < 8) for (var n2, r2, o2 = 1; o2 < i2; ) {
          for (r2 = o2, n2 = e2[o2]; r2 && t2(e2[r2 - 1], n2) > 0; ) e2[r2] = e2[--r2];
          r2 !== o2++ && (e2[r2] = n2);
        }
        else for (var s2 = fp(i2 / 2), a2 = Sp(mp(e2, 0, s2), t2), c2 = Sp(mp(e2, s2), t2), d2 = a2.length, l2 = c2.length, u2 = 0, h2 = 0; u2 < d2 || h2 < l2; ) e2[u2 + h2] = u2 < d2 && h2 < l2 ? t2(a2[u2], c2[h2]) <= 0 ? a2[u2++] : c2[h2++] : u2 < d2 ? a2[u2++] : c2[h2++];
        return e2;
      }, gp = Sp, Tp = ae.match(/firefox\/(\d+)/i), Rp = !!Tp && +Tp[1], Cp = /MSIE|Trident/.test(ae), vp = ae.match(/AppleWebKit\/(\d+)\./), yp = !!vp && +vp[1], Ip = Oi, Ap = d, bp = Ne, wp = Je, Op = Wi, Np = function(e2, t2) {
        if (!delete e2[t2]) throw new Ep("Cannot delete property " + _p(t2) + " of " + _p(e2));
      }, Dp = Sn, Pp = n, Lp = gp, kp = Wn, Mp = Rp, Up = Cp, Vp = _e, xp = yp, Fp = [], Bp = Ap(Fp.sort), jp = Ap(Fp.push), Gp = Pp((function() {
        Fp.sort(void 0);
      })), Wp = Pp((function() {
        Fp.sort(null);
      })), Hp = kp("sort"), Kp = !Pp((function() {
        if (Vp) return Vp < 70;
        if (!(Mp && Mp > 3)) {
          if (Up) return true;
          if (xp) return xp < 603;
          var e2, t2, i2, n2, r2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i2 = 3;
                break;
              case 68:
              case 71:
                i2 = 4;
                break;
              default:
                i2 = 2;
            }
            for (n2 = 0; n2 < 47; n2++) Fp.push({ k: t2 + n2, v: i2 });
          }
          for (Fp.sort((function(e3, t3) {
            return t3.v - e3.v;
          })), n2 = 0; n2 < Fp.length; n2++) t2 = Fp[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
          return "DGBEFHACIJK" !== r2;
        }
      }));
      Ip({ target: "Array", proto: true, forced: Gp || !Wp || !Hp || !Kp }, { sort: function(e2) {
        void 0 !== e2 && bp(e2);
        var t2 = wp(this);
        if (Kp) return void 0 === e2 ? Bp(t2) : Bp(t2, e2);
        var i2, n2, r2 = [], o2 = Op(t2);
        for (n2 = 0; n2 < o2; n2++) n2 in t2 && jp(r2, t2[n2]);
        for (Lp(r2, /* @__PURE__ */ (function(e3) {
          return function(t3, i3) {
            return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i3) || 0 : Dp(t3) > Dp(i3) ? 1 : -1;
          };
        })(e2)), i2 = Op(r2), n2 = 0; n2 < i2; ) t2[n2] = r2[n2++];
        for (; n2 < o2; ) Np(t2, n2++);
        return t2;
      } });
      var Yp = Zi("Array", "sort"), zp = l, qp = Yp, Xp = Array.prototype, Jp = function(e2) {
        var t2 = e2.sort;
        return e2 === Xp || zp(Xp, e2) && t2 === Xp.sort ? qp : t2;
      }, Qp = i(Jp), Zp = Oi, $p = d, e_ = xi, t_ = RangeError, i_ = String.fromCharCode, n_ = String.fromCodePoint, r_ = $p([].join);
      Zp({ target: "String", stat: true, arity: 1, forced: !!n_ && 1 !== n_.length }, { fromCodePoint: function(e2) {
        for (var t2, i2 = [], n2 = arguments.length, r2 = 0; n2 > r2; ) {
          if (t2 = +arguments[r2++], e_(t2, 1114111) !== t2) throw new t_(t2 + " is not a valid code point");
          i2[r2] = t2 < 65536 ? i_(t2) : i_(55296 + ((t2 -= 65536) >> 10), t2 % 1024 + 56320);
        }
        return r_(i2, "");
      } });
      var o_ = n, s_ = pt("iterator"), a_ = !o_((function() {
        var e2 = new URL("b?a=1&b=2&c=3", "https://a"), t2 = e2.searchParams, i2 = new URLSearchParams("a=1&a=2&b=3"), n2 = "";
        return e2.pathname = "c%20d", t2.forEach((function(e3, i3) {
          t2.delete("b"), n2 += i3 + e3;
        })), i2.delete("a", 2), i2.delete("b", void 0), !e2.toJSON || !i2.has("a", 1) || i2.has("a", 2) || !i2.has("a", void 0) || i2.has("b") || !t2.size && true || !t2.sort || "https://a/c%20d?a=1&c=3" !== e2.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[s_] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("https://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("https://a#Ð±").hash || "a1c3" !== n2 || "x" !== new URL("https://x", void 0).host;
      })), c_ = va, d_ = Oi, l_ = h, u_ = Bd, h_ = re, p_ = D, __ = d, E_ = w, m_ = a_, f_ = va, S_ = vc, g_ = function(e2, t2, i2) {
        for (var n2 in t2) i2 && i2.unsafe && e2[n2] ? e2[n2] = t2[n2] : c_(e2, n2, t2[n2], i2);
        return e2;
      }, T_ = Ga, R_ = Xa, C_ = Ea, v_ = Nc, y_ = A, I_ = $e, A_ = Qt, b_ = En, w_ = ni, O_ = Z, N_ = Sn, D_ = ko, P_ = x, L_ = us, k_ = rs, M_ = pc, U_ = cd, V_ = gp, x_ = pt("iterator"), F_ = "URLSearchParams", B_ = F_ + "Iterator", j_ = C_.set, G_ = C_.getterFor(F_), W_ = C_.getterFor(B_), H_ = u_("fetch"), K_ = u_("Request"), Y_ = u_("Headers"), z_ = K_ && K_.prototype, q_ = Y_ && Y_.prototype, X_ = l_.TypeError, J_ = l_.encodeURIComponent, Q_ = String.fromCharCode, Z_ = h_("String", "fromCodePoint"), $_ = parseInt, eE = __("".charAt), tE = __([].join), iE = __([].push), nE = __("".replace), rE = __([].shift), oE = __([].splice), sE = __("".split), aE = __("".slice), cE = __(/./.exec), dE = /\+/g, lE = /^[0-9a-f]+$/i, uE = function(e2, t2) {
        var i2 = aE(e2, t2, t2 + 2);
        return cE(lE, i2) ? $_(i2, 16) : NaN;
      }, hE = function(e2) {
        for (var t2 = 0, i2 = 128; i2 > 0 && 0 != (e2 & i2); i2 >>= 1) t2++;
        return t2;
      }, pE = function(e2) {
        var t2 = null;
        switch (e2.length) {
          case 1:
            t2 = e2[0];
            break;
          case 2:
            t2 = (31 & e2[0]) << 6 | 63 & e2[1];
            break;
          case 3:
            t2 = (15 & e2[0]) << 12 | (63 & e2[1]) << 6 | 63 & e2[2];
            break;
          case 4:
            t2 = (7 & e2[0]) << 18 | (63 & e2[1]) << 12 | (63 & e2[2]) << 6 | 63 & e2[3];
        }
        return t2 > 1114111 ? null : t2;
      }, _E = function(e2) {
        for (var t2 = (e2 = nE(e2, dE, " ")).length, i2 = "", n2 = 0; n2 < t2; ) {
          var r2 = eE(e2, n2);
          if ("%" === r2) {
            if ("%" === eE(e2, n2 + 1) || n2 + 3 > t2) {
              i2 += "%", n2++;
              continue;
            }
            var o2 = uE(e2, n2 + 1);
            if (o2 != o2) {
              i2 += r2, n2++;
              continue;
            }
            n2 += 2;
            var s2 = hE(o2);
            if (0 === s2) r2 = Q_(o2);
            else {
              if (1 === s2 || s2 > 4) {
                i2 += "ï¿½", n2++;
                continue;
              }
              for (var a2 = [o2], c2 = 1; c2 < s2 && !(++n2 + 3 > t2 || "%" !== eE(e2, n2)); ) {
                var d2 = uE(e2, n2 + 1);
                if (d2 != d2) {
                  n2 += 3;
                  break;
                }
                if (d2 > 191 || d2 < 128) break;
                iE(a2, d2), n2 += 2, c2++;
              }
              if (a2.length !== s2) {
                i2 += "ï¿½";
                continue;
              }
              var l2 = pE(a2);
              null === l2 ? i2 += "ï¿½" : r2 = Z_(l2);
            }
          }
          i2 += r2, n2++;
        }
        return i2;
      }, EE = /[!'()~]|%20/g, mE = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, fE = function(e2) {
        return mE[e2];
      }, SE = function(e2) {
        return nE(J_(e2), EE, fE);
      }, gE = R_((function(e2, t2) {
        j_(this, { type: B_, target: G_(e2).entries, index: 0, kind: t2 });
      }), F_, (function() {
        var e2 = W_(this), t2 = e2.target, i2 = e2.index++;
        if (!t2 || i2 >= t2.length) return e2.target = null, M_(void 0, true);
        var n2 = t2[i2];
        switch (e2.kind) {
          case "keys":
            return M_(n2.key, false);
          case "values":
            return M_(n2.value, false);
        }
        return M_([n2.key, n2.value], false);
      }), true), TE = function(e2) {
        this.entries = [], this.url = null, void 0 !== e2 && (O_(e2) ? this.parseObject(e2) : this.parseQuery("string" == typeof e2 ? "?" === eE(e2, 0) ? aE(e2, 1) : e2 : N_(e2)));
      };
      TE.prototype = { type: F_, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t2, i2, n2, r2, o2, s2, a2, c2 = this.entries, d2 = k_(e2);
        if (d2) for (i2 = (t2 = L_(e2, d2)).next; !(n2 = p_(i2, t2)).done; ) {
          if (o2 = (r2 = L_(w_(n2.value))).next, (s2 = p_(o2, r2)).done || (a2 = p_(o2, r2)).done || !p_(o2, r2).done) throw new X_("Expected sequence with length 2");
          iE(c2, { key: N_(s2.value), value: N_(a2.value) });
        }
        else for (var l2 in e2) I_(e2, l2) && iE(c2, { key: l2, value: N_(e2[l2]) });
      }, parseQuery: function(e2) {
        if (e2) for (var t2, i2, n2 = this.entries, r2 = sE(e2, "&"), o2 = 0; o2 < r2.length; ) (t2 = r2[o2++]).length && (i2 = sE(t2, "="), iE(n2, { key: _E(rE(i2)), value: _E(tE(i2, "=")) }));
      }, serialize: function() {
        for (var e2, t2 = this.entries, i2 = [], n2 = 0; n2 < t2.length; ) e2 = t2[n2++], iE(i2, SE(e2.key) + "=" + SE(e2.value));
        return tE(i2, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var RE = function() {
        v_(this, CE);
        var e2 = j_(this, new TE(arguments.length > 0 ? arguments[0] : void 0));
        E_ || (this.size = e2.entries.length);
      }, CE = RE.prototype;
      if (g_(CE, { append: function(e2, t2) {
        var i2 = G_(this);
        U_(arguments.length, 2), iE(i2.entries, { key: N_(e2), value: N_(t2) }), E_ || this.length++, i2.updateURL();
      }, delete: function(e2) {
        for (var t2 = G_(this), i2 = U_(arguments.length, 1), n2 = t2.entries, r2 = N_(e2), o2 = i2 < 2 ? void 0 : arguments[1], s2 = void 0 === o2 ? o2 : N_(o2), a2 = 0; a2 < n2.length; ) {
          var c2 = n2[a2];
          if (c2.key !== r2 || void 0 !== s2 && c2.value !== s2) a2++;
          else if (oE(n2, a2, 1), void 0 !== s2) break;
        }
        E_ || (this.size = n2.length), t2.updateURL();
      }, get: function(e2) {
        var t2 = G_(this).entries;
        U_(arguments.length, 1);
        for (var i2 = N_(e2), n2 = 0; n2 < t2.length; n2++) if (t2[n2].key === i2) return t2[n2].value;
        return null;
      }, getAll: function(e2) {
        var t2 = G_(this).entries;
        U_(arguments.length, 1);
        for (var i2 = N_(e2), n2 = [], r2 = 0; r2 < t2.length; r2++) t2[r2].key === i2 && iE(n2, t2[r2].value);
        return n2;
      }, has: function(e2) {
        for (var t2 = G_(this).entries, i2 = U_(arguments.length, 1), n2 = N_(e2), r2 = i2 < 2 ? void 0 : arguments[1], o2 = void 0 === r2 ? r2 : N_(r2), s2 = 0; s2 < t2.length; ) {
          var a2 = t2[s2++];
          if (a2.key === n2 && (void 0 === o2 || a2.value === o2)) return true;
        }
        return false;
      }, set: function(e2, t2) {
        var i2 = G_(this);
        U_(arguments.length, 1);
        for (var n2, r2 = i2.entries, o2 = false, s2 = N_(e2), a2 = N_(t2), c2 = 0; c2 < r2.length; c2++) (n2 = r2[c2]).key === s2 && (o2 ? oE(r2, c2--, 1) : (o2 = true, n2.value = a2));
        o2 || iE(r2, { key: s2, value: a2 }), E_ || (this.size = r2.length), i2.updateURL();
      }, sort: function() {
        var e2 = G_(this);
        V_(e2.entries, (function(e3, t2) {
          return e3.key > t2.key ? 1 : -1;
        })), e2.updateURL();
      }, forEach: function(e2) {
        for (var t2, i2 = G_(this).entries, n2 = A_(e2, arguments.length > 1 ? arguments[1] : void 0), r2 = 0; r2 < i2.length; ) n2((t2 = i2[r2++]).value, t2.key, this);
      }, keys: function() {
        return new gE(this, "keys");
      }, values: function() {
        return new gE(this, "values");
      }, entries: function() {
        return new gE(this, "entries");
      } }, { enumerable: true }), f_(CE, x_, CE.entries, { name: "entries" }), f_(CE, "toString", (function() {
        return G_(this).serialize();
      }), { enumerable: true }), E_ && S_(CE, "size", { get: function() {
        return G_(this).entries.length;
      }, configurable: true, enumerable: true }), T_(RE, F_), d_({ global: true, constructor: true, forced: !m_ }, { URLSearchParams: RE }), !m_ && y_(Y_)) {
        var vE = __(q_.has), yE = __(q_.set), IE = function(e2) {
          if (O_(e2)) {
            var t2, i2 = e2.body;
            if (b_(i2) === F_) return t2 = e2.headers ? new Y_(e2.headers) : new Y_(), vE(t2, "content-type") || yE(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), D_(e2, { body: P_(0, N_(i2)), headers: P_(0, t2) });
          }
          return e2;
        };
        if (y_(H_) && d_({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e2) {
          return H_(e2, arguments.length > 1 ? IE(arguments[1]) : {});
        } }), y_(K_)) {
          var AE = function(e2) {
            return v_(this, z_), new K_(e2, arguments.length > 1 ? IE(arguments[1]) : {});
          };
          z_.constructor = AE, AE.prototype = z_, d_({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: AE });
        }
      }
      var bE, wE = { URLSearchParams: RE, getState: G_ }, OE = $.URLSearchParams, NE = w, DE = d, PE = D, LE = n, kE = ho, ME = Qr, UE = P, VE = Je, xE = W, FE = Object.assign, BE = Object.defineProperty, jE = DE([].concat), GE = !FE || LE((function() {
        if (NE && 1 !== FE({ b: 1 }, FE(BE({}, "a", { enumerable: true, get: function() {
          BE(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b) return true;
        var e2 = {}, t2 = {}, i2 = Symbol("assign detection"), n2 = "abcdefghijklmnopqrst";
        return e2[i2] = 7, n2.split("").forEach((function(e3) {
          t2[e3] = e3;
        })), 7 !== FE({}, e2)[i2] || kE(FE({}, t2)).join("") !== n2;
      })) ? function(e2, t2) {
        for (var i2 = VE(e2), n2 = arguments.length, r2 = 1, o2 = ME.f, s2 = UE.f; n2 > r2; ) for (var a2, c2 = xE(arguments[r2++]), d2 = o2 ? jE(kE(c2), o2(c2)) : kE(c2), l2 = d2.length, u2 = 0; l2 > u2; ) a2 = d2[u2++], NE && !PE(s2, c2, a2) || (i2[a2] = c2[a2]);
        return i2;
      } : FE, WE = ni, HE = Es, KE = w, YE = Zt, zE = x, qE = function(e2, t2, i2) {
        KE ? YE.f(e2, t2, zE(0, i2)) : e2[t2] = i2;
      }, XE = Qt, JE = D, QE = Je, ZE = function(e2, t2, i2, n2) {
        try {
          return n2 ? t2(WE(i2)[0], i2[1]) : t2(i2);
        } catch (t3) {
          HE(e2, "throw", t3);
        }
      }, $E = Zo, em = Qc, tm = Wi, im = qE, nm = us, rm = rs, om = Array, sm = d, am = 2147483647, cm = /[^\0-\u007E]/, dm = /[.\u3002\uFF0E\uFF61]/g, lm = "Overflow: input needs wider integers to process", um = RangeError, hm = sm(dm.exec), pm = Math.floor, _m = String.fromCharCode, Em = sm("".charCodeAt), mm = sm([].join), fm = sm([].push), Sm = sm("".replace), gm = sm("".split), Tm = sm("".toLowerCase), Rm = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, Cm = function(e2, t2, i2) {
        var n2 = 0;
        for (e2 = i2 ? pm(e2 / 700) : e2 >> 1, e2 += pm(e2 / t2); e2 > 455; ) e2 = pm(e2 / 35), n2 += 36;
        return pm(n2 + 36 * e2 / (e2 + 38));
      }, vm = function(e2) {
        var t2 = [];
        e2 = (function(e3) {
          for (var t3 = [], i3 = 0, n3 = e3.length; i3 < n3; ) {
            var r3 = Em(e3, i3++);
            if (r3 >= 55296 && r3 <= 56319 && i3 < n3) {
              var o3 = Em(e3, i3++);
              56320 == (64512 & o3) ? fm(t3, ((1023 & r3) << 10) + (1023 & o3) + 65536) : (fm(t3, r3), i3--);
            } else fm(t3, r3);
          }
          return t3;
        })(e2);
        var i2, n2, r2 = e2.length, o2 = 128, s2 = 0, a2 = 72;
        for (i2 = 0; i2 < e2.length; i2++) (n2 = e2[i2]) < 128 && fm(t2, _m(n2));
        var c2 = t2.length, d2 = c2;
        for (c2 && fm(t2, "-"); d2 < r2; ) {
          var l2 = am;
          for (i2 = 0; i2 < e2.length; i2++) (n2 = e2[i2]) >= o2 && n2 < l2 && (l2 = n2);
          var u2 = d2 + 1;
          if (l2 - o2 > pm((am - s2) / u2)) throw new um(lm);
          for (s2 += (l2 - o2) * u2, o2 = l2, i2 = 0; i2 < e2.length; i2++) {
            if ((n2 = e2[i2]) < o2 && ++s2 > am) throw new um(lm);
            if (n2 === o2) {
              for (var h2 = s2, p2 = 36; ; ) {
                var _2 = p2 <= a2 ? 1 : p2 >= a2 + 26 ? 26 : p2 - a2;
                if (h2 < _2) break;
                var E2 = h2 - _2, m2 = 36 - _2;
                fm(t2, _m(Rm(_2 + E2 % m2))), h2 = pm(E2 / m2), p2 += 36;
              }
              fm(t2, _m(Rm(h2))), a2 = Cm(s2, u2, d2 === c2), s2 = 0, d2++;
            }
          }
          s2++, o2++;
        }
        return mm(t2, "");
      }, ym = Oi, Im = w, Am = a_, bm = h, wm = Qt, Om = d, Nm = va, Dm = vc, Pm = Nc, Lm = $e, km = GE, Mm = function(e2) {
        var t2 = QE(e2), i2 = em(this), n2 = arguments.length, r2 = n2 > 1 ? arguments[1] : void 0, o2 = void 0 !== r2;
        o2 && (r2 = XE(r2, n2 > 2 ? arguments[2] : void 0));
        var s2, a2, c2, d2, l2, u2, h2 = rm(t2), p2 = 0;
        if (!h2 || this === om && $E(h2)) for (s2 = tm(t2), a2 = i2 ? new this(s2) : om(s2); s2 > p2; p2++) u2 = o2 ? r2(t2[p2], p2) : t2[p2], im(a2, p2, u2);
        else for (a2 = i2 ? new this() : [], l2 = (d2 = nm(t2, h2)).next; !(c2 = JE(l2, d2)).done; p2++) u2 = o2 ? ZE(d2, r2, [c2.value, p2], true) : c2.value, im(a2, p2, u2);
        return a2.length = p2, a2;
      }, Um = sd, Vm = Gh.codeAt, xm = function(e2) {
        var t2, i2, n2 = [], r2 = gm(Sm(Tm(e2), dm, "."), ".");
        for (t2 = 0; t2 < r2.length; t2++) i2 = r2[t2], fm(n2, hm(cm, i2) ? "xn--" + vm(i2) : i2);
        return mm(n2, ".");
      }, Fm = Sn, Bm = Ga, jm = cd, Gm = wE, Wm = Ea, Hm = Wm.set, Km = Wm.getterFor("URL"), Ym = Gm.URLSearchParams, zm = Gm.getState, qm = bm.URL, Xm = bm.TypeError, Jm = bm.parseInt, Qm = Math.floor, Zm = Math.pow, $m = Om("".charAt), ef = Om(/./.exec), tf = Om([].join), nf = Om(1.1.toString), rf = Om([].pop), of = Om([].push), sf = Om("".replace), af = Om([].shift), cf = Om("".split), df = Om("".slice), lf = Om("".toLowerCase), uf = Om([].unshift), hf = "Invalid scheme", pf = "Invalid host", _f = "Invalid port", Ef = /[a-z]/i, mf = /[\d+-.a-z]/i, ff = /\d/, Sf = /^0x/i, gf = /^[0-7]+$/, Tf = /^\d+$/, Rf = /^[\da-f]+$/i, Cf = /[\0\t\n\r #%/:<>?@[\\\]^|]/, vf = /[\0\t\n\r #/:<>?@[\\\]^|]/, yf = /^[\u0000-\u0020]+/, If = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, Af = /[\t\n\r]/g, bf = function(e2) {
        var t2, i2, n2, r2;
        if ("number" == typeof e2) {
          for (t2 = [], i2 = 0; i2 < 4; i2++) uf(t2, e2 % 256), e2 = Qm(e2 / 256);
          return tf(t2, ".");
        }
        if ("object" == typeof e2) {
          for (t2 = "", n2 = (function(e3) {
            for (var t3 = null, i3 = 1, n3 = null, r3 = 0, o2 = 0; o2 < 8; o2++) 0 !== e3[o2] ? (r3 > i3 && (t3 = n3, i3 = r3), n3 = null, r3 = 0) : (null === n3 && (n3 = o2), ++r3);
            return r3 > i3 ? n3 : t3;
          })(e2), i2 = 0; i2 < 8; i2++) r2 && 0 === e2[i2] || (r2 && (r2 = false), n2 === i2 ? (t2 += i2 ? ":" : "::", r2 = true) : (t2 += nf(e2[i2], 16), i2 < 7 && (t2 += ":")));
          return "[" + t2 + "]";
        }
        return e2;
      }, wf = {}, Of = km({}, wf, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), Nf = km({}, Of, { "#": 1, "?": 1, "{": 1, "}": 1 }), Df = km({}, Nf, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), Pf = function(e2, t2) {
        var i2 = Vm(e2, 0);
        return i2 > 32 && i2 < 127 && !Lm(t2, e2) ? e2 : encodeURIComponent(e2);
      }, Lf = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, kf = function(e2, t2) {
        var i2;
        return 2 === e2.length && ef(Ef, $m(e2, 0)) && (":" === (i2 = $m(e2, 1)) || !t2 && "|" === i2);
      }, Mf = function(e2) {
        var t2;
        return e2.length > 1 && kf(df(e2, 0, 2)) && (2 === e2.length || "/" === (t2 = $m(e2, 2)) || "\\" === t2 || "?" === t2 || "#" === t2);
      }, Uf = function(e2) {
        return "." === e2 || "%2e" === lf(e2);
      }, Vf = {}, xf = {}, Ff = {}, Bf = {}, jf = {}, Gf = {}, Wf = {}, Hf = {}, Kf = {}, Yf = {}, zf = {}, qf = {}, Xf = {}, Jf = {}, Qf = {}, Zf = {}, $f = {}, eS = {}, tS = {}, iS = {}, nS = {}, rS = function(e2, t2, i2) {
        var n2, r2, o2, s2 = Fm(e2);
        if (t2) {
          if (r2 = this.parse(s2)) throw new Xm(r2);
          this.searchParams = null;
        } else {
          if (void 0 !== i2 && (n2 = new rS(i2, true)), r2 = this.parse(s2, null, n2)) throw new Xm(r2);
          (o2 = zm(new Ym())).bindURL(this), this.searchParams = o2;
        }
      };
      rS.prototype = { type: "URL", parse: function(e2, t2, i2) {
        var n2, r2, o2, s2, a2, c2 = this, d2 = t2 || Vf, l2 = 0, u2 = "", h2 = false, p2 = false, _2 = false;
        for (e2 = Fm(e2), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e2 = sf(e2, yf, ""), e2 = sf(e2, If, "$1")), e2 = sf(e2, Af, ""), n2 = Mm(e2); l2 <= n2.length; ) {
          switch (r2 = n2[l2], d2) {
            case Vf:
              if (!r2 || !ef(Ef, r2)) {
                if (t2) return hf;
                d2 = Ff;
                continue;
              }
              u2 += lf(r2), d2 = xf;
              break;
            case xf:
              if (r2 && (ef(mf, r2) || "+" === r2 || "-" === r2 || "." === r2)) u2 += lf(r2);
              else {
                if (":" !== r2) {
                  if (t2) return hf;
                  u2 = "", d2 = Ff, l2 = 0;
                  continue;
                }
                if (t2 && (c2.isSpecial() !== Lm(Lf, u2) || "file" === u2 && (c2.includesCredentials() || null !== c2.port) || "file" === c2.scheme && !c2.host)) return;
                if (c2.scheme = u2, t2) return void (c2.isSpecial() && Lf[c2.scheme] === c2.port && (c2.port = null));
                u2 = "", "file" === c2.scheme ? d2 = Jf : c2.isSpecial() && i2 && i2.scheme === c2.scheme ? d2 = Bf : c2.isSpecial() ? d2 = Hf : "/" === n2[l2 + 1] ? (d2 = jf, l2++) : (c2.cannotBeABaseURL = true, of(c2.path, ""), d2 = tS);
              }
              break;
            case Ff:
              if (!i2 || i2.cannotBeABaseURL && "#" !== r2) return hf;
              if (i2.cannotBeABaseURL && "#" === r2) {
                c2.scheme = i2.scheme, c2.path = Um(i2.path), c2.query = i2.query, c2.fragment = "", c2.cannotBeABaseURL = true, d2 = nS;
                break;
              }
              d2 = "file" === i2.scheme ? Jf : Gf;
              continue;
            case Bf:
              if ("/" !== r2 || "/" !== n2[l2 + 1]) {
                d2 = Gf;
                continue;
              }
              d2 = Kf, l2++;
              break;
            case jf:
              if ("/" === r2) {
                d2 = Yf;
                break;
              }
              d2 = eS;
              continue;
            case Gf:
              if (c2.scheme = i2.scheme, r2 === bE) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Um(i2.path), c2.query = i2.query;
              else if ("/" === r2 || "\\" === r2 && c2.isSpecial()) d2 = Wf;
              else if ("?" === r2) c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Um(i2.path), c2.query = "", d2 = iS;
              else {
                if ("#" !== r2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Um(i2.path), c2.path.length--, d2 = eS;
                  continue;
                }
                c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = Um(i2.path), c2.query = i2.query, c2.fragment = "", d2 = nS;
              }
              break;
            case Wf:
              if (!c2.isSpecial() || "/" !== r2 && "\\" !== r2) {
                if ("/" !== r2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, d2 = eS;
                  continue;
                }
                d2 = Yf;
              } else d2 = Kf;
              break;
            case Hf:
              if (d2 = Kf, "/" !== r2 || "/" !== $m(u2, l2 + 1)) continue;
              l2++;
              break;
            case Kf:
              if ("/" !== r2 && "\\" !== r2) {
                d2 = Yf;
                continue;
              }
              break;
            case Yf:
              if ("@" === r2) {
                h2 && (u2 = "%40" + u2), h2 = true, o2 = Mm(u2);
                for (var E2 = 0; E2 < o2.length; E2++) {
                  var m2 = o2[E2];
                  if (":" !== m2 || _2) {
                    var f2 = Pf(m2, Df);
                    _2 ? c2.password += f2 : c2.username += f2;
                  } else _2 = true;
                }
                u2 = "";
              } else if (r2 === bE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c2.isSpecial()) {
                if (h2 && "" === u2) return "Invalid authority";
                l2 -= Mm(u2).length + 1, u2 = "", d2 = zf;
              } else u2 += r2;
              break;
            case zf:
            case qf:
              if (t2 && "file" === c2.scheme) {
                d2 = Zf;
                continue;
              }
              if (":" !== r2 || p2) {
                if (r2 === bE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c2.isSpecial()) {
                  if (c2.isSpecial() && "" === u2) return pf;
                  if (t2 && "" === u2 && (c2.includesCredentials() || null !== c2.port)) return;
                  if (s2 = c2.parseHost(u2)) return s2;
                  if (u2 = "", d2 = $f, t2) return;
                  continue;
                }
                "[" === r2 ? p2 = true : "]" === r2 && (p2 = false), u2 += r2;
              } else {
                if ("" === u2) return pf;
                if (s2 = c2.parseHost(u2)) return s2;
                if (u2 = "", d2 = Xf, t2 === qf) return;
              }
              break;
            case Xf:
              if (!ef(ff, r2)) {
                if (r2 === bE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c2.isSpecial() || t2) {
                  if ("" !== u2) {
                    var S2 = Jm(u2, 10);
                    if (S2 > 65535) return _f;
                    c2.port = c2.isSpecial() && S2 === Lf[c2.scheme] ? null : S2, u2 = "";
                  }
                  if (t2) return;
                  d2 = $f;
                  continue;
                }
                return _f;
              }
              u2 += r2;
              break;
            case Jf:
              if (c2.scheme = "file", "/" === r2 || "\\" === r2) d2 = Qf;
              else {
                if (!i2 || "file" !== i2.scheme) {
                  d2 = eS;
                  continue;
                }
                switch (r2) {
                  case bE:
                    c2.host = i2.host, c2.path = Um(i2.path), c2.query = i2.query;
                    break;
                  case "?":
                    c2.host = i2.host, c2.path = Um(i2.path), c2.query = "", d2 = iS;
                    break;
                  case "#":
                    c2.host = i2.host, c2.path = Um(i2.path), c2.query = i2.query, c2.fragment = "", d2 = nS;
                    break;
                  default:
                    Mf(tf(Um(n2, l2), "")) || (c2.host = i2.host, c2.path = Um(i2.path), c2.shortenPath()), d2 = eS;
                    continue;
                }
              }
              break;
            case Qf:
              if ("/" === r2 || "\\" === r2) {
                d2 = Zf;
                break;
              }
              i2 && "file" === i2.scheme && !Mf(tf(Um(n2, l2), "")) && (kf(i2.path[0], true) ? of(c2.path, i2.path[0]) : c2.host = i2.host), d2 = eS;
              continue;
            case Zf:
              if (r2 === bE || "/" === r2 || "\\" === r2 || "?" === r2 || "#" === r2) {
                if (!t2 && kf(u2)) d2 = eS;
                else if ("" === u2) {
                  if (c2.host = "", t2) return;
                  d2 = $f;
                } else {
                  if (s2 = c2.parseHost(u2)) return s2;
                  if ("localhost" === c2.host && (c2.host = ""), t2) return;
                  u2 = "", d2 = $f;
                }
                continue;
              }
              u2 += r2;
              break;
            case $f:
              if (c2.isSpecial()) {
                if (d2 = eS, "/" !== r2 && "\\" !== r2) continue;
              } else if (t2 || "?" !== r2) if (t2 || "#" !== r2) {
                if (r2 !== bE && (d2 = eS, "/" !== r2)) continue;
              } else c2.fragment = "", d2 = nS;
              else c2.query = "", d2 = iS;
              break;
            case eS:
              if (r2 === bE || "/" === r2 || "\\" === r2 && c2.isSpecial() || !t2 && ("?" === r2 || "#" === r2)) {
                if (".." === (a2 = lf(a2 = u2)) || "%2e." === a2 || ".%2e" === a2 || "%2e%2e" === a2 ? (c2.shortenPath(), "/" === r2 || "\\" === r2 && c2.isSpecial() || of(c2.path, "")) : Uf(u2) ? "/" === r2 || "\\" === r2 && c2.isSpecial() || of(c2.path, "") : ("file" === c2.scheme && !c2.path.length && kf(u2) && (c2.host && (c2.host = ""), u2 = $m(u2, 0) + ":"), of(c2.path, u2)), u2 = "", "file" === c2.scheme && (r2 === bE || "?" === r2 || "#" === r2)) for (; c2.path.length > 1 && "" === c2.path[0]; ) af(c2.path);
                "?" === r2 ? (c2.query = "", d2 = iS) : "#" === r2 && (c2.fragment = "", d2 = nS);
              } else u2 += Pf(r2, Nf);
              break;
            case tS:
              "?" === r2 ? (c2.query = "", d2 = iS) : "#" === r2 ? (c2.fragment = "", d2 = nS) : r2 !== bE && (c2.path[0] += Pf(r2, wf));
              break;
            case iS:
              t2 || "#" !== r2 ? r2 !== bE && ("'" === r2 && c2.isSpecial() ? c2.query += "%27" : c2.query += "#" === r2 ? "%23" : Pf(r2, wf)) : (c2.fragment = "", d2 = nS);
              break;
            case nS:
              r2 !== bE && (c2.fragment += Pf(r2, Of));
          }
          l2++;
        }
      }, parseHost: function(e2) {
        var t2, i2, n2;
        if ("[" === $m(e2, 0)) {
          if ("]" !== $m(e2, e2.length - 1)) return pf;
          if (t2 = (function(e3) {
            var t3, i3, n3, r2, o2, s2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, l2 = null, u2 = 0, h2 = function() {
              return $m(e3, u2);
            };
            if (":" === h2()) {
              if (":" !== $m(e3, 1)) return;
              u2 += 2, l2 = ++d2;
            }
            for (; h2(); ) {
              if (8 === d2) return;
              if (":" !== h2()) {
                for (t3 = i3 = 0; i3 < 4 && ef(Rf, h2()); ) t3 = 16 * t3 + Jm(h2(), 16), u2++, i3++;
                if ("." === h2()) {
                  if (0 === i3) return;
                  if (u2 -= i3, d2 > 6) return;
                  for (n3 = 0; h2(); ) {
                    if (r2 = null, n3 > 0) {
                      if (!("." === h2() && n3 < 4)) return;
                      u2++;
                    }
                    if (!ef(ff, h2())) return;
                    for (; ef(ff, h2()); ) {
                      if (o2 = Jm(h2(), 10), null === r2) r2 = o2;
                      else {
                        if (0 === r2) return;
                        r2 = 10 * r2 + o2;
                      }
                      if (r2 > 255) return;
                      u2++;
                    }
                    c2[d2] = 256 * c2[d2] + r2, 2 != ++n3 && 4 !== n3 || d2++;
                  }
                  if (4 !== n3) return;
                  break;
                }
                if (":" === h2()) {
                  if (u2++, !h2()) return;
                } else if (h2()) return;
                c2[d2++] = t3;
              } else {
                if (null !== l2) return;
                u2++, l2 = ++d2;
              }
            }
            if (null !== l2) for (s2 = d2 - l2, d2 = 7; 0 !== d2 && s2 > 0; ) a2 = c2[d2], c2[d2--] = c2[l2 + s2 - 1], c2[l2 + --s2] = a2;
            else if (8 !== d2) return;
            return c2;
          })(df(e2, 1, -1)), !t2) return pf;
          this.host = t2;
        } else if (this.isSpecial()) {
          if (e2 = xm(e2), ef(Cf, e2)) return pf;
          if (t2 = (function(e3) {
            var t3, i3, n3, r2, o2, s2, a2, c2 = cf(e3, ".");
            if (c2.length && "" === c2[c2.length - 1] && c2.length--, (t3 = c2.length) > 4) return e3;
            for (i3 = [], n3 = 0; n3 < t3; n3++) {
              if ("" === (r2 = c2[n3])) return e3;
              if (o2 = 10, r2.length > 1 && "0" === $m(r2, 0) && (o2 = ef(Sf, r2) ? 16 : 8, r2 = df(r2, 8 === o2 ? 1 : 2)), "" === r2) s2 = 0;
              else {
                if (!ef(10 === o2 ? Tf : 8 === o2 ? gf : Rf, r2)) return e3;
                s2 = Jm(r2, o2);
              }
              of(i3, s2);
            }
            for (n3 = 0; n3 < t3; n3++) if (s2 = i3[n3], n3 === t3 - 1) {
              if (s2 >= Zm(256, 5 - t3)) return null;
            } else if (s2 > 255) return null;
            for (a2 = rf(i3), n3 = 0; n3 < i3.length; n3++) a2 += i3[n3] * Zm(256, 3 - n3);
            return a2;
          })(e2), null === t2) return pf;
          this.host = t2;
        } else {
          if (ef(vf, e2)) return pf;
          for (t2 = "", i2 = Mm(e2), n2 = 0; n2 < i2.length; n2++) t2 += Pf(i2[n2], wf);
          this.host = t2;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" === this.scheme;
      }, includesCredentials: function() {
        return "" !== this.username || "" !== this.password;
      }, isSpecial: function() {
        return Lm(Lf, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t2 = e2.length;
        !t2 || "file" === this.scheme && 1 === t2 && kf(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t2 = e2.scheme, i2 = e2.username, n2 = e2.password, r2 = e2.host, o2 = e2.port, s2 = e2.path, a2 = e2.query, c2 = e2.fragment, d2 = t2 + ":";
        return null !== r2 ? (d2 += "//", e2.includesCredentials() && (d2 += i2 + (n2 ? ":" + n2 : "") + "@"), d2 += bf(r2), null !== o2 && (d2 += ":" + o2)) : "file" === t2 && (d2 += "//"), d2 += e2.cannotBeABaseURL ? s2[0] : s2.length ? "/" + tf(s2, "/") : "", null !== a2 && (d2 += "?" + a2), null !== c2 && (d2 += "#" + c2), d2;
      }, setHref: function(e2) {
        var t2 = this.parse(e2);
        if (t2) throw new Xm(t2);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t2 = this.port;
        if ("blob" === e2) try {
          return new oS(e2.path[0]).origin;
        } catch (e3) {
          return "null";
        }
        return "file" !== e2 && this.isSpecial() ? e2 + "://" + bf(this.host) + (null !== t2 ? ":" + t2 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(Fm(e2) + ":", Vf);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t2 = Mm(Fm(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i2 = 0; i2 < t2.length; i2++) this.username += Pf(t2[i2], Df);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t2 = Mm(Fm(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i2 = 0; i2 < t2.length; i2++) this.password += Pf(t2[i2], Df);
        }
      }, getHost: function() {
        var e2 = this.host, t2 = this.port;
        return null === e2 ? "" : null === t2 ? bf(e2) : bf(e2) + ":" + t2;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, zf);
      }, getHostname: function() {
        var e2 = this.host;
        return null === e2 ? "" : bf(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, qf);
      }, getPort: function() {
        var e2 = this.port;
        return null === e2 ? "" : Fm(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ("" === (e2 = Fm(e2)) ? this.port = null : this.parse(e2, Xf));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + tf(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, $f));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        "" === (e2 = Fm(e2)) ? this.query = null : ("?" === $m(e2, 0) && (e2 = df(e2, 1)), this.query = "", this.parse(e2, iS)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        "" !== (e2 = Fm(e2)) ? ("#" === $m(e2, 0) && (e2 = df(e2, 1)), this.fragment = "", this.parse(e2, nS)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var oS = function(e2) {
        var t2 = Pm(this, sS), i2 = jm(arguments.length, 1) > 1 ? arguments[1] : void 0, n2 = Hm(t2, new rS(e2, false, i2));
        Im || (t2.href = n2.serialize(), t2.origin = n2.getOrigin(), t2.protocol = n2.getProtocol(), t2.username = n2.getUsername(), t2.password = n2.getPassword(), t2.host = n2.getHost(), t2.hostname = n2.getHostname(), t2.port = n2.getPort(), t2.pathname = n2.getPathname(), t2.search = n2.getSearch(), t2.searchParams = n2.getSearchParams(), t2.hash = n2.getHash());
      }, sS = oS.prototype, aS = function(e2, t2) {
        return { get: function() {
          return Km(this)[e2]();
        }, set: t2 && function(e3) {
          return Km(this)[t2](e3);
        }, configurable: true, enumerable: true };
      };
      if (Im && (Dm(sS, "href", aS("serialize", "setHref")), Dm(sS, "origin", aS("getOrigin")), Dm(sS, "protocol", aS("getProtocol", "setProtocol")), Dm(sS, "username", aS("getUsername", "setUsername")), Dm(sS, "password", aS("getPassword", "setPassword")), Dm(sS, "host", aS("getHost", "setHost")), Dm(sS, "hostname", aS("getHostname", "setHostname")), Dm(sS, "port", aS("getPort", "setPort")), Dm(sS, "pathname", aS("getPathname", "setPathname")), Dm(sS, "search", aS("getSearch", "setSearch")), Dm(sS, "searchParams", aS("getSearchParams")), Dm(sS, "hash", aS("getHash", "setHash"))), Nm(sS, "toJSON", (function() {
        return Km(this).serialize();
      }), { enumerable: true }), Nm(sS, "toString", (function() {
        return Km(this).serialize();
      }), { enumerable: true }), qm) {
        var cS = qm.createObjectURL, dS = qm.revokeObjectURL;
        cS && Nm(oS, "createObjectURL", wm(cS, qm)), dS && Nm(oS, "revokeObjectURL", wm(dS, qm));
      }
      Bm(oS, "URL"), ym({ global: true, constructor: true, forced: !Am, sham: !Im }, { URL: oS });
      var lS = Oi, uS = n, hS = cd, pS = Sn, _S = a_, ES = re("URL"), mS = _S && uS((function() {
        ES.canParse();
      })), fS = uS((function() {
        return 1 !== ES.canParse.length;
      }));
      lS({ target: "URL", stat: true, forced: !mS || fS }, { canParse: function(e2) {
        var t2 = hS(arguments.length, 1), i2 = pS(e2), n2 = t2 < 2 || void 0 === arguments[1] ? void 0 : pS(arguments[1]);
        try {
          return !!new ES(i2, n2);
        } catch (e3) {
          return false;
        }
      } });
      var SS = Oi, gS = cd, TS = Sn, RS = a_, CS = re("URL");
      SS({ target: "URL", stat: true, forced: !RS }, { parse: function(e2) {
        var t2 = gS(arguments.length, 1), i2 = TS(e2), n2 = t2 < 2 || void 0 === arguments[1] ? void 0 : TS(arguments[1]);
        try {
          return new CS(i2, n2);
        } catch (e3) {
          return null;
        }
      } });
      var vS = i($.URL);
      let yS = true, IS = true;
      function AS(e2, t2, i2) {
        const n2 = e2.match(t2);
        return n2 && n2.length >= i2 && parseInt(n2[i2], 10);
      }
      function bS(e2, t2, i2) {
        if (!e2.RTCPeerConnection) return;
        const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
        n2.addEventListener = function(e3, n3) {
          if (e3 !== t2) return r2.apply(this, arguments);
          const o3 = (e4) => {
            const t3 = i2(e4);
            t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, o3), r2.apply(this, [e3, o3]);
        };
        const o2 = n2.removeEventListener;
        n2.removeEventListener = function(e3, i3) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2]) return o2.apply(this, arguments);
          if (!this._eventMap[t2].has(i3)) return o2.apply(this, arguments);
          const n3 = this._eventMap[t2].get(i3);
          return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, n3]);
        }, Object.defineProperty(n2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function wS(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (yS = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function OS(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (IS = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function NS() {
        if ("object" == typeof window) {
          if (yS) return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function DS(e2, t2) {
        IS && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function PS(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function LS(e2) {
        var t2;
        return PS(e2) ? nr(t2 = Object.keys(e2)).call(t2, (function(t3, i2) {
          const n2 = PS(e2[i2]), r2 = n2 ? LS(e2[i2]) : e2[i2], o2 = n2 && !Object.keys(r2).length;
          return void 0 === r2 || o2 ? t3 : Object.assign(t3, { [i2]: r2 });
        }), {}) : e2;
      }
      function kS(e2, t2, i2) {
        t2 && !i2.has(t2.id) && (i2.set(t2.id, t2), Object.keys(t2).forEach(((n2) => {
          n2.endsWith("Id") ? kS(e2, e2.get(t2[n2]), i2) : n2.endsWith("Ids") && t2[n2].forEach(((t3) => {
            kS(e2, e2.get(t3), i2);
          }));
        })));
      }
      function MS(e2, t2, i2) {
        const n2 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
        if (null === t2) return r2;
        const o2 = [];
        return e2.forEach(((e3) => {
          "track" === e3.type && e3.trackIdentifier === t2.id && o2.push(e3);
        })), o2.forEach(((t3) => {
          e2.forEach(((i3) => {
            i3.type === n2 && i3.trackId === t3.id && kS(e2, i3, r2);
          }));
        })), r2;
      }
      const US = NS;
      function VS(e2, t2) {
        const i2 = e2 && e2.navigator;
        if (!i2.mediaDevices) return;
        const n2 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional) return e3;
          const t3 = {};
          return Object.keys(e3).forEach(((i3) => {
            if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3) return;
            const n3 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
            void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
            const r3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
            };
            if (void 0 !== n3.ideal) {
              t3.optional = t3.optional || [];
              let e4 = {};
              "number" == typeof n3.ideal ? (e4[r3("min", i3)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i3)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i3)] = n3.ideal, t3.optional.push(e4));
            }
            void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i3)] = n3.exact) : ["min", "max"].forEach(((e4) => {
              void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i3)] = n3[e4]);
            }));
          })), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, r2 = function(e3, r3) {
          if (t2.version >= 61) return r3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t3 = function(e4, t4, i3) {
              t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let o3 = e3.video.facingMode;
            o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
            const s2 = t2.version < 66;
            if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t3;
              if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3) return i2.mediaDevices.enumerateDevices().then(((i3) => {
                i3 = i3.filter(((e4) => "videoinput" === e4.kind));
                let s3 = i3.find(((e4) => t3.some(((t4) => {
                  var i4;
                  return Ln(i4 = e4.label.toLowerCase()).call(i4, t4);
                }))));
                return !s3 && i3.length && Ln(t3).call(t3, "back") && (s3 = i3[i3.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = n2(e3.video), US("chrome: " + JSON.stringify(e3)), r3(e3);
              }));
            }
            e3.video = n2(e3.video);
          }
          return US("chrome: " + JSON.stringify(e3)), r3(e3);
        }, o2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i2.getUserMedia = (function(e3, t3, n3) {
          r2(e3, ((e4) => {
            i2.webkitGetUserMedia(e4, t3, ((e5) => {
              n3 && n3(o2(e5));
            }));
          }));
        }).bind(i2), i2.mediaDevices.getUserMedia) {
          const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          i2.mediaDevices.getUserMedia = function(t3) {
            return r2(t3, ((t4) => e3(t4).then(((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length) throw e4.getTracks().forEach(((e5) => {
                e5.stop();
              })), new DOMException("", "NotFoundError");
              return e4;
            }), ((e4) => rp.reject(o2(e4))))));
          };
        }
      }
      function xS(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function FS(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", ((i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(((e3) => e3.track && e3.track.id === i2.track.id)) : { track: i2.track };
                const r2 = new Event("track");
                r2.track = i2.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              })), t3.stream.getTracks().forEach(((i2) => {
                let n2;
                n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(((e3) => e3.track && e3.track.id === i2.id)) : { track: i2 };
                const r2 = new Event("track");
                r2.track = i2, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
              }));
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else bS(e2, "track", ((e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3)));
      }
      function BS(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
              let r2 = i3.apply(this, arguments);
              return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
            };
            const n3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              n3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              -1 !== t3 && this._senders.splice(t3, 1);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach(((e4) => {
              this._senders.push(t2(this, e4));
            }));
          };
          const n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach(((e4) => {
              const t3 = this._senders.find(((t4) => t4.track === e4));
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            }));
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach(((e4) => e4._pc = this)), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function jS(e2) {
        if (!e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i2, n2] = arguments;
          if (arguments.length > 0 && "function" == typeof e3) return t2.apply(this, arguments);
          if (0 === t2.length && (0 === arguments.length || "function" != typeof e3)) return t2.apply(this, []);
          const r2 = function(e4) {
            const t3 = {};
            return e4.result().forEach(((e5) => {
              const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach(((t4) => {
                i3[t4] = e5.stat(t4);
              })), t3[i3.id] = i3;
            })), t3;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map(((t3) => [t3, e4[t3]])));
          };
          if (arguments.length >= 2) {
            const n3 = function(e4) {
              i2(o2(r2(e4)));
            };
            return t2.apply(this, [n3, e3]);
          }
          return new rp(((e4, i3) => {
            t2.apply(this, [function(t3) {
              e4(o2(r2(t3)));
            }, i3]);
          })).then(i2, n2);
        };
      }
      function GS(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver)) return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach(((e4) => e4._pc = this)), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then(((t4) => MS(t4, e3.track, true)));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach(((e4) => e4._pc = this)), e3;
          }), bS(e2, "track", ((e3) => (e3.receiver._pc = e3.srcElement, e3))), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then(((t4) => MS(t4, e3.track, false)));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype)) return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, i2, n2;
            return this.getSenders().forEach(((i3) => {
              i3.track === e3 && (t3 ? n2 = true : t3 = i3);
            })), this.getReceivers().forEach(((t4) => (t4.track === e3 && (i2 ? n2 = true : i2 = t4), t4.track === e3))), n2 || t3 && i2 ? rp.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : rp.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function WS(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(((e3) => this._shimmedLocalStreams[e3][0]));
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
          if (!i3) return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const n3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n3) && this._shimmedLocalStreams[i3.id].push(n3) : this._shimmedLocalStreams[i3.id] = [i3, n3], n3;
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach(((e4) => {
            const t4 = this.getSenders().find(((t5) => t5.track === e4));
            if (t4) throw new DOMException("Track already exists.", "InvalidAccessError");
          }));
          const t3 = this.getSenders();
          i2.apply(this, arguments);
          const n3 = this.getSenders().filter(((e4) => -1 === t3.indexOf(e4)));
          this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach(((t3) => {
            const i3 = this._shimmedLocalStreams[t3].indexOf(e3);
            -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
          })), r2.apply(this, arguments);
        };
      }
      function HS(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65) return WS(e2);
        const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map(((e4) => this._reverseStreams[e4.id]));
        };
        const n2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach(((e3) => {
            const t4 = this.getSenders().find(((t5) => t5.track === e3));
            if (t4) throw new DOMException("Track already exists.", "InvalidAccessError");
          })), !this._reverseStreams[t3.id]) {
            const i3 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
          }
          n2.apply(this, [t3]);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t3) {
          let i3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach(((t4) => {
            const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
            i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
          })), new RTCSessionDescription({ type: t3.type, sdp: i3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const n3 = [].slice.call(arguments, 1);
          if (1 !== n3.length || !n3[0].getTracks().find(((e3) => e3 === t3))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const r3 = this.getSenders().find(((e3) => e3.track === t3));
          if (r3) throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o3 = this._streams[i3.id];
          if (o3) o3.addTrack(t3), rp.resolve().then((() => {
            this.dispatchEvent(new Event("negotiationneeded"));
          }));
          else {
            const n4 = new e2.MediaStream([t3]);
            this._streams[i3.id] = n4, this._reverseStreams[n4.id] = i3, this.addStream(n4);
          }
          return this.getSenders().find(((e3) => e3.track === t3));
        }, ["createOffer", "createAnswer"].forEach((function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
              const i4 = o2(this, t4);
              e3[0].apply(null, [i4]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : i3.apply(this, arguments).then(((e4) => o2(this, e4)));
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        }));
        const s2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = (function(e3, t3) {
            let i3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach(((t4) => {
              const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
              i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
            })), new RTCSessionDescription({ type: t3.type, sdp: i3 });
          })(this, arguments[0]), s2.apply(this, arguments)) : s2.apply(this, arguments);
        };
        const a2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = a2.get.apply(this);
          return "" === e3.type ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach(((i3) => {
            this._streams[i3].getTracks().find(((t4) => e3.track === t4)) && (t3 = this._streams[i3]);
          })), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function KS(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t3) {
          const i2 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n2[t3];
        }));
      }
      function YS(e2, t2) {
        bS(e2, "negotiationneeded", ((e3) => {
          const i2 = e3.target;
          if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState) return e3;
        }));
      }
      var zS = Object.freeze({ __proto__: null, fixNegotiationNeeded: YS, shimAddTrackRemoveTrack: HS, shimAddTrackRemoveTrackWithNative: WS, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          return t2(i2).then(((t3) => {
            const n2 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, o2 = i2.video && i2.video.frameRate;
            return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, n2 && (i2.video.mandatory.maxWidth = n2), r2 && (i2.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i2);
          }));
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      }, shimGetSendersWithDtmf: BS, shimGetStats: jS, shimGetUserMedia: VS, shimMediaStream: xS, shimOnTrack: FS, shimPeerConnection: KS, shimSenderReceiverGetStats: GS });
      function qS(e2, t2) {
        const i2 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
        if (i2.getUserMedia = function(e3, t3, n3) {
          DS("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t3, n3);
        }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, i3) {
            t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
          }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          if (i2.mediaDevices.getUserMedia = function(i3) {
            return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
          }, n2 && n2.prototype.getSettings) {
            const t4 = n2.prototype.getSettings;
            n2.prototype.getSettings = function() {
              const i3 = t4.apply(this, arguments);
              return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
            };
          }
          if (n2 && n2.prototype.applyConstraints) {
            const t4 = n2.prototype.applyConstraints;
            n2.prototype.applyConstraints = function(i3) {
              return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
            };
          }
        }
      }
      function XS(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function JS(e2, t2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection) return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = n3[t3];
        }));
        const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, o2] = arguments;
          return n2.apply(this, [e3 || null]).then(((e4) => {
            if (t2.version < 53 && !r2) try {
              e4.forEach(((e5) => {
                e5.type = i2[e5.type] || e5.type;
              }));
            } catch (t3) {
              if ("TypeError" !== t3.name) throw t3;
              e4.forEach(((t4, n3) => {
                e4.set(n3, Object.assign({}, t4, { type: i2[t4.type] || t4.type }));
              }));
            }
            return e4;
          })).then(r2, o2);
        };
      }
      function QS(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach(((e4) => e4._pc = this)), e3;
        });
        const i2 = e2.RTCPeerConnection.prototype.addTrack;
        i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : rp.resolve(/* @__PURE__ */ new Map());
        };
      }
      function ZS(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach(((e4) => e4._pc = this)), e3;
        }), bS(e2, "track", ((e3) => (e3.receiver._pc = e3.srcElement, e3))), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function $S(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          DS("removeStream", "removeTrack"), this.getSenders().forEach(((t2) => {
            var i2;
            t2.track && Ln(i2 = e3.getTracks()).call(i2, t2.track) && this.removeTrack(t2);
          }));
        });
      }
      function eg(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function tg(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i2 = e3.length > 0;
          i2 && e3.forEach(((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid)) throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
          }));
          const n2 = t2.apply(this, arguments);
          if (i2) {
            const { sender: t3 } = n2, i3 = t3.getParameters();
            (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i3).then((() => {
              delete t3.sendEncodings;
            })).catch((() => {
              delete t3.sendEncodings;
            }))));
          }
          return n2;
        });
      }
      function ig(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender) return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function ng(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? rp.all(this.setParametersPromises).then((() => t2.apply(this, arguments))).finally((() => {
            this.setParametersPromises = [];
          })) : t2.apply(this, arguments);
        };
      }
      function rg(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? rp.all(this.setParametersPromises).then((() => t2.apply(this, arguments))).finally((() => {
            this.setParametersPromises = [];
          })) : t2.apply(this, arguments);
        };
      }
      var og = Object.freeze({ __proto__: null, shimAddTransceiver: tg, shimCreateAnswer: rg, shimCreateOffer: ng, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          if (!i2 || !i2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, rp.reject(e3);
          }
          return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i2);
        });
      }, shimGetParameters: ig, shimGetUserMedia: qS, shimOnTrack: XS, shimPeerConnection: JS, shimRTCDataChannel: eg, shimReceiverGetStats: ZS, shimRemoveStream: $S, shimSenderGetStats: QS });
      function sg(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              var i2;
              this._localStreams || (this._localStreams = []), Ln(i2 = this._localStreams).call(i2, e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach(((i3) => t2.call(this, i3, e3))), e3.getVideoTracks().forEach(((i3) => t2.call(this, i3, e3)));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
              for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
              return n2 && n2.forEach(((e4) => {
                var t3;
                this._localStreams ? Ln(t3 = this._localStreams).call(t3, e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              })), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (-1 === t2) return;
            this._localStreams.splice(t2, 1);
            const i2 = e3.getTracks();
            this.getSenders().forEach(((e4) => {
              Ln(i2).call(i2, e4.track) && this.removeTrack(e4);
            }));
          });
        }
      }
      function ag(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach(((e5) => {
                var t3;
                if (this._remoteStreams || (this._remoteStreams = []), Ln(t3 = this._remoteStreams).call(t3, e5)) return;
                this._remoteStreams.push(e5);
                const i2 = new Event("addstream");
                i2.stream = e5, this.dispatchEvent(i2);
              }));
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach(((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0) return;
                e3._remoteStreams.push(t4);
                const i2 = new Event("addstream");
                i2.stream = t4, e3.dispatchEvent(i2);
              }));
            }), t2.apply(e3, arguments);
          };
        }
      }
      function cg(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection.prototype, i2 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n3]);
          return t3 ? (r3.then(e3, t3), rp.resolve()) : r3;
        }, t2.createAnswer = function(e3, t3) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i3]);
          return t3 ? (r3.then(e3, t3), rp.resolve()) : r3;
        };
        let a2 = function(e3, t3, i3) {
          const n3 = r2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), rp.resolve()) : n3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = o2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), rp.resolve()) : n3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i3) {
          const n3 = s2.apply(this, [e3]);
          return i3 ? (n3.then(t3, i3), rp.resolve()) : n3;
        }, t2.addIceCandidate = a2;
      }
      function dg(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, i2 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => i2(lg(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e3, i2, n2) {
          t2.mediaDevices.getUserMedia(e3).then(i2, n2);
        }).bind(t2));
      }
      function lg(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: LS(e2.video) }) : e2;
      }
      function ug(e2) {
        if (!e2.RTCPeerConnection) return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i2) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
              let n2 = e3.iceServers[i3];
              !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (DS("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i3]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, i2);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function hg(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function pg(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find(((e4) => "audio" === e4.receiver.track.kind));
            false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i2 = this.getTransceivers().find(((e4) => "video" === e4.receiver.track.kind));
            false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t2.apply(this, arguments);
        };
      }
      function _g(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var Eg = Object.freeze({ __proto__: null, shimAudioContext: _g, shimCallbacksAPI: cg, shimConstraints: lg, shimCreateOfferLegacy: pg, shimGetUserMedia: dg, shimLocalStreamsAPI: sg, shimRTCIceServerUrls: ug, shimRemoteStreamsAPI: ag, shimTrackEventTransceiver: hg }), mg = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF", fg = z, Sg = Sn, gg = mg, Tg = d("".replace), Rg = RegExp("^[" + gg + "]+"), Cg = RegExp("(^|[^" + gg + "])[" + gg + "]+$"), vg = function(e2) {
        return function(t2) {
          var i2 = Sg(fg(t2));
          return 1 & e2 && (i2 = Tg(i2, Rg, "")), 2 & e2 && (i2 = Tg(i2, Cg, "$1")), i2;
        };
      }, yg = { start: vg(1), end: vg(2), trim: vg(3) }, Ig = Ra.PROPER, Ag = n, bg = mg, wg = yg.trim;
      Oi({ target: "String", proto: true, forced: (function(e2) {
        return Ag((function() {
          return !!bg[e2]() || "âÂá " !== "âÂá "[e2]() || Ig && bg[e2].name !== e2;
        }));
      })("trim") }, { trim: function() {
        return wg(this);
      } });
      var Og = Zi("String", "trim"), Ng = l, Dg = Og, Pg = String.prototype, Lg = function(e2) {
        var t2 = e2.trim;
        return "string" == typeof e2 || e2 === Pg || Ng(Pg, e2) && t2 === Pg.trim ? Dg : t2;
      }, kg = i(Lg), Mg = { exports: {} };
      !(function(e2) {
        const t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substring(2, 12);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return e3.trim().split("\n").map(((e4) => e4.trim()));
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map(((e4, t3) => (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n"));
        }, t2.getDescription = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2 && i2[0];
        }, t2.getMediaSections = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2.shift(), i2;
        }, t2.matchPrefix = function(e3, i2) {
          return t2.splitLines(e3).filter(((e4) => 0 === e4.indexOf(i2)));
        }, t2.parseCandidate = function(e3) {
          let t3;
          t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
          for (let e4 = 8; e4 < t3.length; e4 += 2) switch (t3[e4]) {
            case "raddr":
              i2.relatedAddress = t3[e4 + 1];
              break;
            case "rport":
              i2.relatedPort = parseInt(t3[e4 + 1], 10);
              break;
            case "tcptype":
              i2.tcpType = t3[e4 + 1];
              break;
            case "ufrag":
              i2.ufrag = t3[e4 + 1], i2.usernameFragment = t3[e4 + 1];
              break;
            default:
              void 0 === i2[t3[e4]] && (i2[t3[e4]] = t3[e4 + 1]);
          }
          return i2;
        }, t2.writeCandidate = function(e3) {
          const t3 = [];
          t3.push(e3.foundation);
          const i2 = e3.component;
          "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          const n2 = e3.type;
          return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substring(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          let t3 = e3.substring(9).split(" ");
          const i2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
        }, t2.writeRtpMap = function(e3) {
          let t3 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
          const i2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
        }, t2.parseFmtp = function(e3) {
          const t3 = {};
          let i2;
          const n2 = e3.substring(e3.indexOf(" ") + 1).split(";");
          for (let e4 = 0; e4 < n2.length; e4++) i2 = n2[e4].trim().split("="), t3[i2[0].trim()] = i2[1];
          return t3;
        }, t2.writeFmtp = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const n2 = [];
            Object.keys(e3.parameters).forEach(((t4) => {
              void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
            })), t3 += "a=fmtp:" + i2 + " " + n2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          const t3 = e3.substring(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach(((e4) => {
            t3 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          })), t3;
        }, t2.parseSsrcMedia = function(e3) {
          const t3 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substring(7, t3), 10) }, n2 = e3.indexOf(":", t3);
          return n2 > -1 ? (i2.attribute = e3.substring(t3 + 1, n2), i2.value = e3.substring(n2 + 1)) : i2.attribute = e3.substring(t3 + 1), i2;
        }, t2.parseSsrcGroup = function(e3) {
          const t3 = e3.substring(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map(((e4) => parseInt(e4, 10))) };
        }, t2.getMid = function(e3) {
          const i2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (i2) return i2.substring(6);
        }, t2.parseFingerprint = function(e3) {
          const t3 = e3.substring(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
        }, t2.getDtlsParameters = function(e3, i2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          let i2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach(((e4) => {
            i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          })), i2;
        }, t2.parseCryptoLine = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:")) return null;
          const t3 = e3.substring(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, i2) {
          return t2.matchPrefix(e3 + i2, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, i2) {
          const n2 = t2.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
          return n2 && r2 ? { usernameFragment: n2.substring(12), password: r2.substring(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
        }, t2.parseRtpParameters = function(e3) {
          const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
          i2.profile = n2[2];
          for (let r3 = 3; r3 < n2.length; r3++) {
            const o2 = n2[r3], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              const n3 = t2.parseRtpMap(s2), r4 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (n3.parameters = r4.length ? t2.parseFmtp(r4[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), i2.codecs.push(n3), n3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i2.fecMechanisms.push(n3.name.toUpperCase());
              }
            }
          }
          t2.matchPrefix(e3, "a=extmap:").forEach(((e4) => {
            i2.headerExtensions.push(t2.parseExtmap(e4));
          }));
          const r2 = t2.matchPrefix(e3, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
          return i2.codecs.forEach(((e4) => {
            r2.forEach(((t3) => {
              e4.rtcpFeedback.find(((e5) => e5.type === t3.type && e5.parameter === t3.parameter)) || e4.rtcpFeedback.push(t3);
            }));
          })), i2;
        }, t2.writeRtpDescription = function(e3, i2) {
          let n2 = "";
          n2 += "m=" + e3 + " ", n2 += i2.codecs.length > 0 ? "9" : "0", n2 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", n2 += i2.codecs.map(((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType)).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach(((e4) => {
            n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
          }));
          let r2 = 0;
          return i2.codecs.forEach(((e4) => {
            e4.maxptime > r2 && (r2 = e4.maxptime);
          })), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach(((e4) => {
            n2 += t2.writeExtmap(e4);
          })), n2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          const i2 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), o2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e3, "a=ssrc:").map(((e4) => t2.parseSsrcMedia(e4))).filter(((e4) => "cname" === e4.attribute)), a2 = s2.length > 0 && s2[0].ssrc;
          let c2;
          const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map(((e4) => e4.substring(17).split(" ").map(((e5) => parseInt(e5, 10)))));
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach(((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          })), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
          let l2 = t2.matchPrefix(e3, "b=");
          return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach(((e4) => {
            e4.maxBitrate = l2;
          }))), i2;
        }, t2.parseRtcpParameters = function(e3) {
          const i2 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map(((e4) => t2.parseSsrcMedia(e4))).filter(((e4) => "cname" === e4.attribute))[0];
          n2 && (i2.cname = n2.value, i2.ssrc = n2.ssrc);
          const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
          const o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return i2.mux = o2.length > 0, i2;
        }, t2.writeRtcpParameters = function(e3) {
          let t3 = "";
          return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
        }, t2.parseMsid = function(e3) {
          let i2;
          const n2 = t2.matchPrefix(e3, "a=msid:");
          if (1 === n2.length) return i2 = n2[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
          const r2 = t2.matchPrefix(e3, "a=ssrc:").map(((e4) => t2.parseSsrcMedia(e4))).filter(((e4) => "msid" === e4.attribute));
          return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
        }, t2.parseSctpDescription = function(e3) {
          const i2 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
          let r2;
          n2.length > 0 && (r2 = parseInt(n2[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
          const o2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0) return { port: parseInt(o2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
          const s2 = t2.matchPrefix(e3, "a=sctpmap:");
          if (s2.length > 0) {
            const e4 = s2[0].substring(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          let i2 = [];
          return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 22);
        }, t2.writeSessionBoilerplate = function(e3, i2, n2) {
          let r2;
          const o2 = void 0 !== i2 ? i2 : 2;
          r2 = e3 || t2.generateSessionId();
          return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.getDirection = function(e3, i2) {
          const n2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < n2.length; e4++) switch (n2[e4]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return n2[e4].substring(2);
          }
          return i2 ? t2.getDirection(i2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substring(2);
        }, t2.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t2.parseMLine = function(e3) {
          const i2 = t2.splitLines(e3)[0].substring(2).split(" ");
          return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          const i2 = t2.matchPrefix(e3, "o=")[0].substring(2).split(" ");
          return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
        }, t2.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length) return false;
          const i2 = t2.splitLines(e3);
          for (let e4 = 0; e4 < i2.length; e4++) if (i2[e4].length < 2 || "=" !== i2[e4].charAt(1)) return false;
          return true;
        }, e2.exports = t2;
      })(Mg);
      var Ug = Mg.exports, Vg = i(Ug), xg = e({ __proto__: null, default: Vg }, [Ug]);
      function Fg(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype) return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const i2 = new t2(e3), n2 = Vg.parseCandidate(e3.candidate), r2 = Object.assign(i2, n2);
            return r2.toJSON = function() {
              return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
            }, r2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, bS(e2, "icecandidate", ((t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3)));
      }
      function Bg(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || bS(e2, "icecandidate", ((e3) => {
          if (e3.candidate) {
            const t2 = Vg.parseCandidate(e3.candidate.candidate);
            "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
          }
          return e3;
        }));
      }
      function jg(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i2 = function(e3) {
          if (!e3 || !e3.sdp) return false;
          const t3 = Vg.splitSections(e3.sdp);
          return t3.shift(), t3.some(((e4) => {
            const t4 = Vg.parseMLine(e4);
            return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
          }));
        }, n2 = function(e3) {
          const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t3 || t3.length < 2) return -1;
          const i3 = parseInt(t3[1], 10);
          return i3 != i3 ? -1 : i3;
        }, r2 = function(e3) {
          let i3 = 65536;
          return "firefox" === t2.browser && (i3 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i3;
        }, o2 = function(e3, i3) {
          let n3 = 65536;
          "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
          const r3 = Vg.matchPrefix(e3.sdp, "a=max-message-size:");
          return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i3 && (n3 = 2147483637), n3;
        }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i2(arguments[0])) {
            const e3 = n2(arguments[0]), t3 = r2(e3), i3 = o2(arguments[0], e3);
            let s3;
            s3 = 0 === t3 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i3 ? Math.max(t3, i3) : Math.min(t3, i3);
            const a2 = {};
            Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
          }
          return s2.apply(this, arguments);
        };
      }
      function Gg(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype)) return;
        function t2(e3, t3) {
          const i3 = e3.send;
          e3.send = function() {
            const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
            if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return i3.apply(e3, arguments);
          };
        }
        const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i2.apply(this, arguments);
          return t2(e3, this), e3;
        }, bS(e2, "datachannel", ((e3) => (t2(e3.channel, e3.target), e3)));
      }
      function Wg(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype) return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach(((e3) => {
          const i2 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const i3 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(i3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
          };
        }));
      }
      function Hg(e2, t2) {
        if (!e2.RTCPeerConnection) return;
        if ("chrome" === t2.browser && t2.version >= 71) return;
        if ("safari" === t2.browser && t2.version >= 605) return;
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i3 = t3.sdp.split("\n").filter(((e3) => "a=extmap-allow-mixed" !== kg(e3).call(e3))).join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
          }
          return i2.apply(this, arguments);
        };
      }
      function Kg(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? rp.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), rp.resolve());
        });
      }
      function Yg(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp) return i2.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type) switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              e3.type = "offer";
              break;
            default:
              e3.type = "answer";
          }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type) return i2.apply(this, [e3]);
          return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then(((e4) => i2.apply(this, [e4])));
        });
      }
      var zg = Object.freeze({ __proto__: null, removeExtmapAllowMixed: Hg, shimAddIceCandidateNullOrEmpty: Kg, shimConnectionState: Wg, shimMaxMessageSize: jg, shimParameterlessSetLocalDescription: Yg, shimRTCIceCandidate: Fg, shimRTCIceCandidateRelayProtocol: Bg, shimSendThrowTypeError: Gg });
      !(function() {
        let { window: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
        const i2 = NS, n2 = (function(e3) {
          const t3 = { browser: null, version: null };
          if (void 0 === e3 || !e3.navigator) return t3.browser = "Not a browser.", t3;
          const { navigator: i3 } = e3;
          if (i3.mozGetUserMedia) t3.browser = "firefox", t3.version = AS(i3.userAgent, /Firefox\/(\d+)\./, 1);
          else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection) t3.browser = "chrome", t3.version = AS(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else {
            if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./)) return t3.browser = "Not a supported browser.", t3;
            t3.browser = "safari", t3.version = AS(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
          }
          return t3;
        })(e2), r2 = { browserDetails: n2, commonShim: zg, extractVersion: AS, disableLog: wS, disableWarnings: OS, sdp: xg };
        switch (n2.browser) {
          case "chrome":
            if (!zS || !KS || !t2.shimChrome) return i2("Chrome shim is not included in this adapter release."), r2;
            if (null === n2.version) return i2("Chrome shim can not determine version, not shimming."), r2;
            i2("adapter.js shimming chrome."), r2.browserShim = zS, Kg(e2, n2), Yg(e2), VS(e2, n2), xS(e2), KS(e2, n2), FS(e2), HS(e2, n2), BS(e2), jS(e2), GS(e2), YS(e2, n2), Fg(e2), Bg(e2), Wg(e2), jg(e2, n2), Gg(e2), Hg(e2, n2);
            break;
          case "firefox":
            if (!og || !JS || !t2.shimFirefox) return i2("Firefox shim is not included in this adapter release."), r2;
            i2("adapter.js shimming firefox."), r2.browserShim = og, Kg(e2, n2), Yg(e2), qS(e2, n2), JS(e2, n2), XS(e2), $S(e2), QS(e2), ZS(e2), eg(e2), tg(e2), ig(e2), ng(e2), rg(e2), Fg(e2), Wg(e2), jg(e2, n2), Gg(e2);
            break;
          case "safari":
            if (!Eg || !t2.shimSafari) return i2("Safari shim is not included in this adapter release."), r2;
            i2("adapter.js shimming safari."), r2.browserShim = Eg, Kg(e2, n2), Yg(e2), ug(e2), pg(e2), cg(e2), sg(e2), ag(e2), hg(e2), dg(e2), _g(e2), Fg(e2), Bg(e2), jg(e2, n2), Gg(e2), Hg(e2, n2);
            break;
          default:
            i2("Unsupported browser!");
        }
      })({ window: "undefined" == typeof window ? void 0 : window });
      var qg = n, Xg = h.RegExp, Jg = !qg((function() {
        var e2 = true;
        try {
          Xg(".", "d");
        } catch (t3) {
          e2 = false;
        }
        var t2 = {}, i2 = "", n2 = e2 ? "dgimsy" : "gimsy", r2 = function(e3, n3) {
          Object.defineProperty(t2, e3, { get: function() {
            return i2 += n3, true;
          } });
        }, o2 = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
        for (var s2 in e2 && (o2.hasIndices = "d"), o2) r2(s2, o2[s2]);
        return Object.getOwnPropertyDescriptor(Xg.prototype, "flags").get.call(t2) !== n2 || i2 !== n2;
      })), Qg = ni, Zg = D, $g = $e, eT = l, tT = { correct: Jg }, iT = function() {
        var e2 = Qg(this), t2 = "";
        return e2.hasIndices && (t2 += "d"), e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.unicodeSets && (t2 += "v"), e2.sticky && (t2 += "y"), t2;
      }, nT = RegExp.prototype, rT = tT.correct ? function(e2) {
        return e2.flags;
      } : function(e2) {
        return tT.correct || !eT(nT, e2) || $g(e2, "flags") ? e2.flags : Zg(iT, e2);
      }, oT = d, sT = Je, aT = Math.floor, cT = oT("".charAt), dT = oT("".replace), lT = oT("".slice), uT = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, hT = /\$([$&'`]|\d{1,2})/g, pT = Oi, _T = D, ET = d, mT = z, fT = A, ST = Z, gT = rn, TT = Sn, RT = Le, CT = rT, vT = function(e2, t2, i2, n2, r2, o2) {
        var s2 = i2 + e2.length, a2 = n2.length, c2 = hT;
        return void 0 !== r2 && (r2 = sT(r2), c2 = uT), dT(o2, c2, (function(o3, c3) {
          var d2;
          switch (cT(c3, 0)) {
            case "$":
              return "$";
            case "&":
              return e2;
            case "`":
              return lT(t2, 0, i2);
            case "'":
              return lT(t2, s2);
            case "<":
              d2 = r2[lT(c3, 1, -1)];
              break;
            default:
              var l2 = +c3;
              if (0 === l2) return o3;
              if (l2 > a2) {
                var u2 = aT(l2 / 10);
                return 0 === u2 ? o3 : u2 <= a2 ? void 0 === n2[u2 - 1] ? cT(c3, 1) : n2[u2 - 1] + cT(c3, 1) : o3;
              }
              d2 = n2[l2 - 1];
          }
          return void 0 === d2 ? "" : d2;
        }));
      }, yT = pt("replace"), IT = TypeError, AT = ET("".indexOf), bT = ET("".replace), wT = ET("".slice), OT = Math.max;
      pT({ target: "String", proto: true }, { replaceAll: function(e2, t2) {
        var i2, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2 = mT(this), p2 = 0, _2 = "";
        if (ST(e2)) {
          if ((i2 = gT(e2)) && (n2 = TT(mT(CT(e2))), !~AT(n2, "g"))) throw new IT("`.replaceAll` does not allow non-global regexes");
          if (r2 = RT(e2, yT)) return _T(r2, e2, h2, t2);
          if (i2) return bT(TT(h2), e2, t2);
        }
        for (o2 = TT(h2), s2 = TT(e2), (a2 = fT(t2)) || (t2 = TT(t2)), c2 = s2.length, d2 = OT(1, c2), l2 = AT(o2, s2); -1 !== l2; ) u2 = a2 ? TT(t2(s2, l2, o2)) : vT(s2, o2, l2, [], void 0, t2), _2 += wT(o2, p2, l2) + u2, p2 = l2 + c2, l2 = l2 + d2 > o2.length ? -1 : AT(o2, s2, l2 + d2);
        return p2 < o2.length && (_2 += wT(o2, p2)), _2;
      } });
      var NT = Zi("String", "replaceAll"), DT = l, PT = NT, LT = String.prototype, kT = function(e2) {
        var t2 = e2.replaceAll;
        return "string" == typeof e2 || e2 === LT || DT(LT, e2) && t2 === LT.replaceAll ? PT : t2;
      }, MT = i(kT), UT = h;
      Oi({ global: true, forced: UT.globalThis !== UT }, { globalThis: UT });
      var VT = i(h), xT = { exports: {} };
      !(function(e2, i2) {
        !(function(t2, n2) {
          var r2 = "function", o2 = "undefined", s2 = "object", a2 = "string", c2 = "major", d2 = "model", l2 = "name", u2 = "type", h2 = "vendor", p2 = "version", _2 = "architecture", E2 = "console", m2 = "mobile", f2 = "tablet", S2 = "smarttv", g2 = "wearable", T2 = "embedded", R2 = "Amazon", C2 = "Apple", v2 = "ASUS", y2 = "BlackBerry", I2 = "Browser", A2 = "Chrome", b2 = "Firefox", w2 = "Google", O2 = "Honor", N2 = "Huawei", D2 = "LG", P2 = "Microsoft", L2 = "Motorola", k2 = "Nvidia", M2 = "OnePlus", U2 = "Opera", V2 = "OPPO", x2 = "Samsung", F2 = "Sharp", B2 = "Sony", j2 = "Xiaomi", G2 = "Zebra", W2 = "Facebook", H2 = "Chromium OS", K2 = "Mac OS", Y2 = " Browser", z2 = function(e3) {
            for (var t3 = {}, i3 = 0; i3 < e3.length; i3++) t3[e3[i3].toUpperCase()] = e3[i3];
            return t3;
          }, q2 = function(e3, t3) {
            return typeof e3 === a2 && -1 !== X2(t3).indexOf(X2(e3));
          }, X2 = function(e3) {
            return e3.toLowerCase();
          }, J2 = function(e3, t3) {
            if (typeof e3 === a2) return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === o2 ? e3 : e3.substring(0, 500);
          }, Q2 = function(e3, t3) {
            for (var i3, o3, a3, c3, d3, l3, u3 = 0; u3 < t3.length && !d3; ) {
              var h3 = t3[u3], p3 = t3[u3 + 1];
              for (i3 = o3 = 0; i3 < h3.length && !d3 && h3[i3]; ) if (d3 = h3[i3++].exec(e3)) for (a3 = 0; a3 < p3.length; a3++) l3 = d3[++o3], typeof (c3 = p3[a3]) === s2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, l3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = l3 ? l3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = l3 ? c3[1].call(this, l3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = l3 ? c3[3].call(this, l3.replace(c3[1], c3[2])) : n2) : this[c3] = l3 || n2;
              u3 += 2;
            }
          }, Z2 = function(e3, t3) {
            for (var i3 in t3) if (typeof t3[i3] === s2 && t3[i3].length > 0) {
              for (var r3 = 0; r3 < t3[i3].length; r3++) if (q2(t3[i3][r3], e3)) return "?" === i3 ? n2 : i3;
            } else if (q2(t3[i3], e3)) return "?" === i3 ? n2 : i3;
            return t3.hasOwnProperty("*") ? t3["*"] : e3;
          }, $2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ee2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p2, [l2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p2, [l2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l2, p2], [/opios[\/ ]+([\w\.]+)/i], [p2, [l2, U2 + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [p2, [l2, U2 + " GX"]], [/\bopr\/([\w\.]+)/i], [p2, [l2, U2]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [p2, [l2, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [p2, [l2, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [l2, p2], [/quark(?:pc)?\/([-\w\.]+)/i], [p2, [l2, "Quark"]], [/\bddg\/([\w\.]+)/i], [p2, [l2, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p2, [l2, "UC" + I2]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [p2, [l2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p2, [l2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p2, [l2, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [p2, [l2, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [p2, [l2, "Smart Lenovo " + I2]], [/(avast|avg)\/([\w\.]+)/i], [[l2, /(.+)/, "$1 Secure " + I2], p2], [/\bfocus\/([\w\.]+)/i], [p2, [l2, b2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [p2, [l2, U2 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p2, [l2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p2, [l2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p2, [l2, U2 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [p2, [l2, "MIUI" + Y2]], [/fxios\/([\w\.-]+)/i], [p2, [l2, b2]], [/\bqihoobrowser\/?([\w\.]*)/i], [p2, [l2, "360"]], [/\b(qq)\/([\w\.]+)/i], [[l2, /(.+)/, "$1Browser"], p2], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[l2, /(.+)/, "$1" + Y2], p2], [/samsungbrowser\/([\w\.]+)/i], [p2, [l2, x2 + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [p2, [l2, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[l2, "Sogou Mobile"], p2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [l2, p2], [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i], [l2], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [p2, l2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l2, W2], p2], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /(daum)apps[\/ ]([\w\.]+)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [l2, p2], [/\bgsa\/([\w\.]+) .*safari\//i], [p2, [l2, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [p2, [l2, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p2, [l2, A2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l2, A2 + " WebView"], p2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p2, [l2, "Android " + I2]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l2, p2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p2, [l2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p2, l2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l2, [p2, Z2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l2, p2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l2, "Netscape"], p2], [/(wolvic|librewolf)\/([\w\.]+)/i], [l2, p2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p2, [l2, b2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /\b(links) \(([\w\.]+)/i], [l2, [p2, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [l2, [p2, /master.|lts./, ""]]], cpu: [[/\b((amd|x|x86[-_]?|wow|win)64)\b/i], [[_2, "amd64"]], [/(ia32(?=;))/i, /\b((i[346]|x)86)(pc)?\b/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?[89]e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i], [[_2, "arm"]], [/((ppc|powerpc)(64)?)( mac|;|\))/i], [[_2, /ower/, "", X2]], [/ sun4\w[;\)]/i], [[_2, "sparc"]], [/\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i], [[_2, X2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h2, x2], [u2, f2]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h2, x2], [u2, m2]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [d2, [h2, C2], [u2, m2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h2, C2], [u2, f2]], [/(macintosh);/i], [d2, [h2, C2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h2, F2], [u2, m2]], [/\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i], [d2, [h2, O2], [u2, f2]], [/honor([-\w ]+)[;\)]/i], [d2, [h2, O2], [u2, m2]], [/\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i], [d2, [h2, N2], [u2, f2]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h2, N2], [u2, m2]], [/oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i, /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i], [[d2, /_/g, " "], [h2, j2], [u2, f2]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, / ([\w ]+) miui\/v?\d/i], [[d2, /_/g, " "], [h2, j2], [u2, m2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h2, V2], [u2, m2]], [/\b(opd2(\d{3}a?))(?: bui|\))/i], [d2, [h2, Z2, { OnePlus: ["304", "403", "203"], "*": V2 }], [u2, f2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h2, "Vivo"], [u2, m2]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [d2, [h2, "Realme"], [u2, m2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h2, L2], [u2, m2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h2, L2], [u2, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h2, D2], [u2, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h2, D2], [u2, m2]], [/(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i, /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i], [d2, [h2, "Lenovo"], [u2, f2]], [/(nokia) (t[12][01])/i], [h2, d2, [u2, f2]], [/(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i, /nokia[-_ ]?(([-\w\. ]*))/i], [[d2, /_/g, " "], [u2, m2], [h2, "Nokia"]], [/(pixel (c|tablet))\b/i], [d2, [h2, w2], [u2, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h2, w2], [u2, m2]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h2, B2], [u2, m2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h2, B2], [u2, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h2, M2], [u2, m2]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h2, R2], [u2, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h2, R2], [u2, m2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h2, [u2, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h2, y2], [u2, m2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h2, v2], [u2, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h2, v2], [u2, m2]], [/(nexus 9)/i], [d2, [h2, "HTC"], [u2, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h2, [d2, /_/g, " "], [u2, m2]], [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [d2, [h2, "TCL"], [u2, f2]], [/(itel) ((\w+))/i], [[h2, X2], d2, [u2, Z2, { tablet: ["p10001l", "w7001"], "*": "mobile" }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h2, "Acer"], [u2, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h2, "Meizu"], [u2, m2]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [d2, [h2, "Ulefone"], [u2, m2]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [d2, [h2, "Energizer"], [u2, m2]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [d2, [h2, "Cat"], [u2, m2]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [d2, [h2, "Smartfren"], [u2, m2]], [/droid.+; (a(?:015|06[35]|142p?))/i], [d2, [h2, "Nothing"], [u2, m2]], [/; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i, /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i], [d2, [h2, "Archos"], [u2, f2]], [/archos ([\w ]+)( b|\))/i, /; (ac[3-6]\d\w{2,8})( b|\))/i], [d2, [h2, "Archos"], [u2, m2]], [/(imo) (tab \w+)/i, /(infinix) (x1101b?)/i], [h2, d2, [u2, f2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (hmd|imo) ([\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i, /(oppo) ?([\w ]+) bui/i], [h2, d2, [u2, m2]], [/(kobo)\s(ereader|touch)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h2, d2, [u2, f2]], [/(surface duo)/i], [d2, [h2, P2], [u2, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h2, "Fairphone"], [u2, m2]], [/(u304aa)/i], [d2, [h2, "AT&T"], [u2, m2]], [/\bsie-(\w*)/i], [d2, [h2, "Siemens"], [u2, m2]], [/\b(rct\w+) b/i], [d2, [h2, "RCA"], [u2, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h2, "Dell"], [u2, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h2, "Verizon"], [u2, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h2, "Barnes & Noble"], [u2, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [h2, "NuVision"], [u2, f2]], [/\b(k88) b/i], [d2, [h2, "ZTE"], [u2, f2]], [/\b(nx\d{3}j) b/i], [d2, [h2, "ZTE"], [u2, m2]], [/\b(gen\d{3}) b.+49h/i], [d2, [h2, "Swiss"], [u2, m2]], [/\b(zur\d{3}) b/i], [d2, [h2, "Swiss"], [u2, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h2, "Zeki"], [u2, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h2, "Dragon Touch"], d2, [u2, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h2, "Insignia"], [u2, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h2, "NextBook"], [u2, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h2, "Voice"], d2, [u2, m2]], [/\b(lvtel\-)?(v1[12]) b/i], [[h2, "LvTel"], d2, [u2, m2]], [/\b(ph-1) /i], [d2, [h2, "Essential"], [u2, m2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h2, "Envizen"], [u2, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h2, "MachSpeed"], [u2, f2]], [/\btu_(1491) b/i], [d2, [h2, "Rotor"], [u2, f2]], [/((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i], [d2, [h2, k2], [u2, f2]], [/(sprint) (\w+)/i], [h2, d2, [u2, m2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h2, P2], [u2, m2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h2, G2], [u2, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h2, G2], [u2, m2]], [/smart-tv.+(samsung)/i], [h2, [u2, S2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h2, x2], [u2, S2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h2, D2], [u2, S2]], [/(apple) ?tv/i], [h2, [d2, C2 + " TV"], [u2, S2]], [/crkey/i], [[d2, A2 + "cast"], [h2, w2], [u2, S2]], [/droid.+aft(\w+)( bui|\))/i], [d2, [h2, R2], [u2, S2]], [/(shield \w+ tv)/i], [d2, [h2, k2], [u2, S2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h2, F2], [u2, S2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h2, B2], [u2, S2]], [/(mi(tv|box)-?\w+) bui/i], [d2, [h2, j2], [u2, S2]], [/Hbbtv.*(technisat) (.*);/i], [h2, d2, [u2, S2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h2, J2], [d2, J2], [u2, S2]], [/droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i], [d2, [u2, S2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[u2, S2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h2, d2, [u2, E2]], [/droid.+; (shield)( bui|\))/i], [d2, [h2, k2], [u2, E2]], [/(playstation \w+)/i], [d2, [h2, B2], [u2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h2, P2], [u2, E2]], [/\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i], [d2, [h2, x2], [u2, g2]], [/((pebble))app/i, /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i], [h2, d2, [u2, g2]], [/(ow(?:19|20)?we?[1-3]{1,3})/i], [d2, [h2, V2], [u2, g2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h2, C2], [u2, g2]], [/(opwwe\d{3})/i], [d2, [h2, M2], [u2, g2]], [/(moto 360)/i], [d2, [h2, L2], [u2, g2]], [/(smartwatch 3)/i], [d2, [h2, B2], [u2, g2]], [/(g watch r)/i], [d2, [h2, D2], [u2, g2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h2, G2], [u2, g2]], [/droid.+; (glass) \d/i], [d2, [h2, w2], [u2, g2]], [/(pico) (4|neo3(?: link|pro)?)/i], [h2, d2, [u2, g2]], [/; (quest( \d| pro)?)/i], [d2, [h2, W2], [u2, g2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h2, [u2, T2]], [/(aeobc)\b/i], [d2, [h2, R2], [u2, T2]], [/(homepod).+mac os/i], [d2, [h2, C2], [u2, T2]], [/windows iot/i], [[u2, T2]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [d2, [u2, m2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [u2, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[u2, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[u2, m2]], [/droid .+?; ([\w\. -]+)( bui|\))/i], [d2, [h2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p2, [l2, "EdgeHTML"]], [/(arkweb)\/([\w\.]+)/i], [l2, p2], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p2, [l2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [l2, p2], [/ladybird\//i], [[l2, "LibWeb"]], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p2, l2]], os: [[/microsoft (windows) (vista|xp)/i], [l2, p2], [/(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i], [l2, [p2, Z2, $2]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[p2, Z2, $2], [l2, "Windows"]], [/[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[p2, /_/g, "."], [l2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l2, K2], [p2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p2, l2], [/(ubuntu) ([\w\.]+) like android/i], [[l2, /(.+)/, "$1 Touch"], p2], [/(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i], [l2, p2], [/\(bb(10);/i], [p2, [l2, y2]], [/(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i], [p2, [l2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p2, [l2, b2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p2, [l2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p2, [l2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p2, [l2, A2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l2, H2], p2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l2, p2], [/(sunos) ?([\w\.\d]*)/i], [[l2, "Solaris"], p2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [l2, p2]] }, te2 = function(e3, i3) {
            if (typeof e3 === s2 && (i3 = e3, e3 = n2), !(this instanceof te2)) return new te2(e3, i3).getResult();
            var E3 = typeof t2 !== o2 && t2.navigator ? t2.navigator : n2, S3 = e3 || (E3 && E3.userAgent ? E3.userAgent : ""), g3 = E3 && E3.userAgentData ? E3.userAgentData : n2, T3 = i3 ? (function(e4, t3) {
              var i4 = {};
              for (var n3 in e4) t3[n3] && t3[n3].length % 2 == 0 ? i4[n3] = t3[n3].concat(e4[n3]) : i4[n3] = e4[n3];
              return i4;
            })(ee2, i3) : ee2, R3 = E3 && E3.userAgent == S3;
            return this.getBrowser = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Q2.call(e4, S3, T3.browser), e4[c2] = (function(e5) {
                return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
              })(e4[p2]), R3 && E3 && E3.brave && typeof E3.brave.isBrave == r2 && (e4[l2] = "Brave"), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4[_2] = n2, Q2.call(e4, S3, T3.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4[h2] = n2, e4[d2] = n2, e4[u2] = n2, Q2.call(e4, S3, T3.device), R3 && !e4[u2] && g3 && g3.mobile && (e4[u2] = m2), R3 && "Macintosh" == e4[d2] && E3 && typeof E3.standalone !== o2 && E3.maxTouchPoints && E3.maxTouchPoints > 2 && (e4[d2] = "iPad", e4[u2] = f2), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Q2.call(e4, S3, T3.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4[l2] = n2, e4[p2] = n2, Q2.call(e4, S3, T3.os), R3 && !e4[l2] && g3 && g3.platform && "Unknown" != g3.platform && (e4[l2] = g3.platform.replace(/chrome os/i, H2).replace(/macos/i, K2)), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return S3;
            }, this.setUA = function(e4) {
              return S3 = typeof e4 === a2 && e4.length > 500 ? J2(e4, 500) : e4, this;
            }, this.setUA(S3), this;
          };
          te2.VERSION = "0.7.41", te2.BROWSER = z2([l2, p2, c2]), te2.CPU = z2([_2]), te2.DEVICE = z2([d2, h2, u2, E2, m2, S2, f2, g2, T2]), te2.ENGINE = te2.OS = z2([l2, p2]), e2.exports && (i2 = e2.exports = te2), i2.UAParser = te2;
          var ie2 = typeof t2 !== o2 && (t2.jQuery || t2.Zepto);
          if (ie2 && !ie2.ua) {
            var ne2 = new te2();
            ie2.ua = ne2.getResult(), ie2.ua.get = function() {
              return ne2.getUA();
            }, ie2.ua.set = function(e3) {
              ne2.setUA(e3);
              var t3 = ne2.getResult();
              for (var i3 in t3) ie2.ua[i3] = t3[i3];
            };
          }
        })("object" == typeof window ? window : t);
      })(xT, xT.exports);
      var FT = i(xT.exports), BT = Ud.clear;
      Oi({ global: true, bind: true, enumerable: true, forced: h.clearImmediate !== BT }, { clearImmediate: BT });
      var jT = h, GT = f, WT = A, HT = qn, KT = ae, YT = sd, zT = cd, qT = jT.Function, XT = /MSIE .\./.test(KT) || "BUN" === HT && (function() {
        var e2 = jT.Bun.version.split(".");
        return e2.length < 3 || "0" === e2[0] && (e2[1] < 3 || "3" === e2[1] && "0" === e2[2]);
      })(), JT = Oi, QT = h, ZT = Ud.set, $T = function(e2, t2) {
        var i2 = t2 ? 2 : 1;
        return XT ? function(n2, r2) {
          var o2 = zT(arguments.length, 1) > i2, s2 = WT(n2) ? n2 : qT(n2), a2 = o2 ? YT(arguments, i2) : [], c2 = o2 ? function() {
            GT(s2, this, a2);
          } : s2;
          return t2 ? e2(c2, r2) : e2(c2);
        } : e2;
      }, eR = QT.setImmediate ? $T(ZT, false) : ZT;
      JT({ global: true, bind: true, enumerable: true, forced: QT.setImmediate !== eR }, { setImmediate: eR });
      var tR = i($.setImmediate), iR = h, nR = hl, rR = Ne, oR = cd, sR = w;
      Oi({ global: true, enumerable: true, dontCallGetSet: true, forced: n((function() {
        return sR && 1 !== Object.getOwnPropertyDescriptor(iR, "queueMicrotask").value.length;
      })) }, { queueMicrotask: function(e2) {
        oR(arguments.length, 1), nR(rR(e2));
      } });
      var aR = i($.queueMicrotask);
      function cR(e2, t2) {
        return function() {
          return e2.apply(t2, arguments);
        };
      }
      const { toString: dR } = Object.prototype, { getPrototypeOf: lR } = Object, { iterator: uR, toStringTag: hR } = Symbol, pR = (_R = /* @__PURE__ */ Object.create(null), (e2) => {
        const t2 = dR.call(e2);
        return _R[t2] || (_R[t2] = t2.slice(8, -1).toLowerCase());
      });
      var _R;
      const ER = (e2) => (e2 = e2.toLowerCase(), (t2) => pR(t2) === e2), mR = (e2) => (t2) => typeof t2 === e2, { isArray: fR } = Array, SR = mR("undefined");
      function gR(e2) {
        return null !== e2 && !SR(e2) && null !== e2.constructor && !SR(e2.constructor) && CR(e2.constructor.isBuffer) && e2.constructor.isBuffer(e2);
      }
      const TR = ER("ArrayBuffer");
      const RR = mR("string"), CR = mR("function"), vR = mR("number"), yR = (e2) => null !== e2 && "object" == typeof e2, IR = (e2) => {
        if ("object" !== pR(e2)) return false;
        const t2 = lR(e2);
        return !(null !== t2 && t2 !== Object.prototype && null !== Object.getPrototypeOf(t2) || hR in e2 || uR in e2);
      }, AR = ER("Date"), bR = ER("File"), wR = ER("Blob"), OR = ER("FileList"), NR = ER("URLSearchParams"), [DR, PR, LR, kR] = ["ReadableStream", "Request", "Response", "Headers"].map(ER);
      function MR(e2, t2) {
        let i2, n2, { allOwnKeys: r2 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (null != e2) if ("object" != typeof e2 && (e2 = [e2]), fR(e2)) for (i2 = 0, n2 = e2.length; i2 < n2; i2++) t2.call(null, e2[i2], i2, e2);
        else {
          if (gR(e2)) return;
          const n3 = r2 ? Object.getOwnPropertyNames(e2) : Object.keys(e2), o2 = n3.length;
          let s2;
          for (i2 = 0; i2 < o2; i2++) s2 = n3[i2], t2.call(null, e2[s2], s2, e2);
        }
      }
      function UR(e2, t2) {
        if (gR(e2)) return null;
        t2 = t2.toLowerCase();
        const i2 = Object.keys(e2);
        let n2, r2 = i2.length;
        for (; r2-- > 0; ) if (n2 = i2[r2], t2 === n2.toLowerCase()) return n2;
        return null;
      }
      const VR = void 0 !== VT ? VT : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, xR = (e2) => !SR(e2) && e2 !== VR;
      const FR = (BR = "undefined" != typeof Uint8Array && lR(Uint8Array), (e2) => BR && e2 instanceof BR);
      var BR;
      const jR = ER("HTMLFormElement"), GR = ((e2) => {
        let { hasOwnProperty: t2 } = e2;
        return (e3, i2) => t2.call(e3, i2);
      })(Object.prototype), WR = ER("RegExp"), HR = (e2, t2) => {
        const i2 = Object.getOwnPropertyDescriptors(e2), n2 = {};
        MR(i2, ((i3, r2) => {
          let o2;
          false !== (o2 = t2(i3, r2, e2)) && (n2[r2] = o2 || i3);
        })), Object.defineProperties(e2, n2);
      };
      const KR = ER("AsyncFunction"), YR = (zR = "function" == typeof tR, qR = CR(VR.postMessage), zR ? tR : qR ? (XR = "axios@".concat(Math.random()), JR = [], VR.addEventListener("message", ((e2) => {
        let { source: t2, data: i2 } = e2;
        t2 === VR && i2 === XR && JR.length && JR.shift()();
      }), false), (e2) => {
        JR.push(e2), VR.postMessage(XR, "*");
      }) : (e2) => setTimeout(e2));
      var zR, qR, XR, JR;
      const QR = void 0 !== aR ? aR.bind(VR) : "undefined" != typeof process && process.nextTick || YR;
      var ZR = { isArray: fR, isArrayBuffer: TR, isBuffer: gR, isFormData: (e2) => {
        let t2;
        return e2 && ("function" == typeof FormData && e2 instanceof FormData || CR(e2.append) && ("formdata" === (t2 = pR(e2)) || "object" === t2 && CR(e2.toString) && "[object FormData]" === e2.toString()));
      }, isArrayBufferView: function(e2) {
        let t2;
        return t2 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && TR(e2.buffer), t2;
      }, isString: RR, isNumber: vR, isBoolean: (e2) => true === e2 || false === e2, isObject: yR, isPlainObject: IR, isEmptyObject: (e2) => {
        if (!yR(e2) || gR(e2)) return false;
        try {
          return 0 === Object.keys(e2).length && Object.getPrototypeOf(e2) === Object.prototype;
        } catch (e3) {
          return false;
        }
      }, isReadableStream: DR, isRequest: PR, isResponse: LR, isHeaders: kR, isUndefined: SR, isDate: AR, isFile: bR, isBlob: wR, isRegExp: WR, isFunction: CR, isStream: (e2) => yR(e2) && CR(e2.pipe), isURLSearchParams: NR, isTypedArray: FR, isFileList: OR, forEach: MR, merge: function e2() {
        const { caseless: t2, skipUndefined: i2 } = xR(this) && this || {}, n2 = {}, r2 = (r3, o2) => {
          const s2 = t2 && UR(n2, o2) || o2;
          IR(n2[s2]) && IR(r3) ? n2[s2] = e2(n2[s2], r3) : IR(r3) ? n2[s2] = e2({}, r3) : fR(r3) ? n2[s2] = r3.slice() : i2 && SR(r3) || (n2[s2] = r3);
        };
        for (let e3 = 0, t3 = arguments.length; e3 < t3; e3++) arguments[e3] && MR(arguments[e3], r2);
        return n2;
      }, extend: function(e2, t2, i2) {
        let { allOwnKeys: n2 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        return MR(t2, ((t3, n3) => {
          i2 && CR(t3) ? e2[n3] = cR(t3, i2) : e2[n3] = t3;
        }), { allOwnKeys: n2 }), e2;
      }, trim: (e2) => kg(e2) ? kg(e2).call(e2) : e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e2) => (65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2), inherits: (e2, t2, i2, n2) => {
        e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, Object.defineProperty(e2, "super", { value: t2.prototype }), i2 && Object.assign(e2.prototype, i2);
      }, toFlatObject: (e2, t2, i2, n2) => {
        let r2, o2, s2;
        const a2 = {};
        if (t2 = t2 || {}, null == e2) return t2;
        do {
          for (r2 = Object.getOwnPropertyNames(e2), o2 = r2.length; o2-- > 0; ) s2 = r2[o2], n2 && !n2(s2, e2, t2) || a2[s2] || (t2[s2] = e2[s2], a2[s2] = true);
          e2 = false !== i2 && lR(e2);
        } while (e2 && (!i2 || i2(e2, t2)) && e2 !== Object.prototype);
        return t2;
      }, kindOf: pR, kindOfTest: ER, endsWith: (e2, t2, i2) => {
        e2 = String(e2), (void 0 === i2 || i2 > e2.length) && (i2 = e2.length), i2 -= t2.length;
        const n2 = e2.indexOf(t2, i2);
        return -1 !== n2 && n2 === i2;
      }, toArray: (e2) => {
        if (!e2) return null;
        if (fR(e2)) return e2;
        let t2 = e2.length;
        if (!vR(t2)) return null;
        const i2 = new Array(t2);
        for (; t2-- > 0; ) i2[t2] = e2[t2];
        return i2;
      }, forEachEntry: (e2, t2) => {
        const i2 = (e2 && e2[uR]).call(e2);
        let n2;
        for (; (n2 = i2.next()) && !n2.done; ) {
          const i3 = n2.value;
          t2.call(e2, i3[0], i3[1]);
        }
      }, matchAll: (e2, t2) => {
        let i2;
        const n2 = [];
        for (; null !== (i2 = e2.exec(t2)); ) n2.push(i2);
        return n2;
      }, isHTMLForm: jR, hasOwnProperty: GR, hasOwnProp: GR, reduceDescriptors: HR, freezeMethods: (e2) => {
        HR(e2, ((t2, i2) => {
          if (CR(e2) && -1 !== ["arguments", "caller", "callee"].indexOf(i2)) return false;
          const n2 = e2[i2];
          CR(n2) && (t2.enumerable = false, "writable" in t2 ? t2.writable = false : t2.set || (t2.set = () => {
            throw Error("Can not rewrite read-only method '" + i2 + "'");
          }));
        }));
      }, toObjectSet: (e2, t2) => {
        const i2 = {}, n2 = (e3) => {
          e3.forEach(((e4) => {
            i2[e4] = true;
          }));
        };
        return fR(e2) ? n2(e2) : n2(String(e2).split(t2)), i2;
      }, toCamelCase: (e2) => e2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e3, t2, i2) {
        return t2.toUpperCase() + i2;
      })), noop: () => {
      }, toFiniteNumber: (e2, t2) => null != e2 && Number.isFinite(e2 = +e2) ? e2 : t2, findKey: UR, global: VR, isContextDefined: xR, isSpecCompliantForm: function(e2) {
        return !!(e2 && CR(e2.append) && "FormData" === e2[hR] && e2[uR]);
      }, toJSONObject: (e2) => {
        const t2 = new Array(10), i2 = (e3, n2) => {
          if (yR(e3)) {
            if (t2.indexOf(e3) >= 0) return;
            if (gR(e3)) return e3;
            if (!("toJSON" in e3)) {
              t2[n2] = e3;
              const r2 = fR(e3) ? [] : {};
              return MR(e3, ((e4, t3) => {
                const o2 = i2(e4, n2 + 1);
                !SR(o2) && (r2[t3] = o2);
              })), t2[n2] = void 0, r2;
            }
          }
          return e3;
        };
        return i2(e2, 0);
      }, isAsyncFn: KR, isThenable: (e2) => e2 && (yR(e2) || CR(e2)) && CR(e2.then) && CR(e2.catch), setImmediate: YR, asap: QR, isIterable: (e2) => null != e2 && CR(e2[uR]) };
      function $R(e2, t2, i2, n2, r2) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e2, this.name = "AxiosError", t2 && (this.code = t2), i2 && (this.config = i2), n2 && (this.request = n2), r2 && (this.response = r2, this.status = r2.status ? r2.status : null);
      }
      ZR.inherits($R, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: ZR.toJSONObject(this.config), code: this.code, status: this.status };
      } });
      const eC = $R.prototype, tC = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(((e2) => {
        tC[e2] = { value: e2 };
      })), Object.defineProperties($R, tC), Object.defineProperty(eC, "isAxiosError", { value: true }), $R.from = (e2, t2, i2, n2, r2, o2) => {
        const s2 = Object.create(eC);
        ZR.toFlatObject(e2, s2, (function(e3) {
          return e3 !== Error.prototype;
        }), ((e3) => "isAxiosError" !== e3));
        const a2 = e2 && e2.message ? e2.message : "Error", c2 = null == t2 && e2 ? e2.code : t2;
        return $R.call(s2, a2, c2, i2, n2, r2), e2 && null == s2.cause && Object.defineProperty(s2, "cause", { value: e2, configurable: true }), s2.name = e2 && e2.name || "Error", o2 && Object.assign(s2, o2), s2;
      };
      function iC(e2) {
        return ZR.isPlainObject(e2) || ZR.isArray(e2);
      }
      function nC(e2) {
        return ZR.endsWith(e2, "[]") ? e2.slice(0, -2) : e2;
      }
      function rC(e2, t2, i2) {
        return e2 ? e2.concat(t2).map((function(e3, t3) {
          return e3 = nC(e3), !i2 && t3 ? "[" + e3 + "]" : e3;
        })).join(i2 ? "." : "") : t2;
      }
      const oC = ZR.toFlatObject(ZR, {}, null, (function(e2) {
        return /^is[A-Z]/.test(e2);
      }));
      function sC(e2, t2, i2) {
        if (!ZR.isObject(e2)) throw new TypeError("target must be an object");
        t2 = t2 || new FormData();
        const n2 = (i2 = ZR.toFlatObject(i2, { metaTokens: true, dots: false, indexes: false }, false, (function(e3, t3) {
          return !ZR.isUndefined(t3[e3]);
        }))).metaTokens, r2 = i2.visitor || d2, o2 = i2.dots, s2 = i2.indexes, a2 = (i2.Blob || "undefined" != typeof Blob && Blob) && ZR.isSpecCompliantForm(t2);
        if (!ZR.isFunction(r2)) throw new TypeError("visitor must be a function");
        function c2(e3) {
          if (null === e3) return "";
          if (ZR.isDate(e3)) return e3.toISOString();
          if (ZR.isBoolean(e3)) return e3.toString();
          if (!a2 && ZR.isBlob(e3)) throw new $R("Blob is not supported. Use a Buffer instead.");
          return ZR.isArrayBuffer(e3) || ZR.isTypedArray(e3) ? a2 && "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
        }
        function d2(e3, i3, r3) {
          let a3 = e3;
          if (e3 && !r3 && "object" == typeof e3) {
            if (ZR.endsWith(i3, "{}")) i3 = n2 ? i3 : i3.slice(0, -2), e3 = JSON.stringify(e3);
            else if (ZR.isArray(e3) && (function(e4) {
              return ZR.isArray(e4) && !e4.some(iC);
            })(e3) || (ZR.isFileList(e3) || ZR.endsWith(i3, "[]")) && (a3 = ZR.toArray(e3))) return i3 = nC(i3), a3.forEach((function(e4, n3) {
              !ZR.isUndefined(e4) && null !== e4 && t2.append(true === s2 ? rC([i3], n3, o2) : null === s2 ? i3 : i3 + "[]", c2(e4));
            })), false;
          }
          return !!iC(e3) || (t2.append(rC(r3, i3, o2), c2(e3)), false);
        }
        const l2 = [], u2 = Object.assign(oC, { defaultVisitor: d2, convertValue: c2, isVisitable: iC });
        if (!ZR.isObject(e2)) throw new TypeError("data must be an object");
        return (function e3(i3, n3) {
          if (!ZR.isUndefined(i3)) {
            if (-1 !== l2.indexOf(i3)) throw Error("Circular reference detected in " + n3.join("."));
            l2.push(i3), ZR.forEach(i3, (function(i4, o3) {
              true === (!(ZR.isUndefined(i4) || null === i4) && r2.call(t2, i4, ZR.isString(o3) ? kg(o3).call(o3) : o3, n3, u2)) && e3(i4, n3 ? n3.concat(o3) : [o3]);
            })), l2.pop();
          }
        })(e2), t2;
      }
      function aC(e2) {
        const t2 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(e2).replace(/[!'()~]|%20|%00/g, (function(e3) {
          return t2[e3];
        }));
      }
      function cC(e2, t2) {
        this._pairs = [], e2 && sC(e2, this, t2);
      }
      const dC = cC.prototype;
      function lC(e2) {
        return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
      }
      function uC(e2, t2, i2) {
        if (!t2) return e2;
        const n2 = i2 && i2.encode || lC;
        ZR.isFunction(i2) && (i2 = { serialize: i2 });
        const r2 = i2 && i2.serialize;
        let o2;
        if (o2 = r2 ? r2(t2, i2) : ZR.isURLSearchParams(t2) ? t2.toString() : new cC(t2, i2).toString(n2), o2) {
          const t3 = e2.indexOf("#");
          -1 !== t3 && (e2 = e2.slice(0, t3)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + o2;
        }
        return e2;
      }
      dC.append = function(e2, t2) {
        this._pairs.push([e2, t2]);
      }, dC.toString = function(e2) {
        const t2 = e2 ? function(t3) {
          return e2.call(this, t3, aC);
        } : aC;
        return this._pairs.map((function(e3) {
          return t2(e3[0]) + "=" + t2(e3[1]);
        }), "").join("&");
      };
      var hC = class {
        constructor() {
          this.handlers = [];
        }
        use(e2, t2, i2) {
          return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
        }
        eject(e2) {
          this.handlers[e2] && (this.handlers[e2] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(e2) {
          ZR.forEach(this.handlers, (function(t2) {
            null !== t2 && e2(t2);
          }));
        }
      }, pC = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, _C = { exports: {} }, EC = Oi, mC = w, fC = Zt.f;
      EC({ target: "Object", stat: true, forced: Object.defineProperty !== fC, sham: !mC }, { defineProperty: fC });
      var SC = $.Object, gC = _C.exports = function(e2, t2, i2) {
        return SC.defineProperty(e2, t2, i2);
      };
      SC.defineProperty.sham && (gC.sham = true);
      var TC = i(_C.exports), RC = TypeError, CC = or, vC = Qc, yC = Z, IC = pt("species"), AC = Array, bC = function(e2) {
        var t2;
        return CC(e2) && (t2 = e2.constructor, (vC(t2) && (t2 === AC || CC(t2.prototype)) || yC(t2) && null === (t2 = t2[IC])) && (t2 = void 0)), void 0 === t2 ? AC : t2;
      }, wC = function(e2, t2) {
        return new (bC(e2))(0 === t2 ? 0 : t2);
      }, OC = n, NC = _e, DC = pt("species"), PC = function(e2) {
        return NC >= 51 || !OC((function() {
          var t2 = [];
          return (t2.constructor = {})[DC] = function() {
            return { foo: 1 };
          }, 1 !== t2[e2](Boolean).foo;
        }));
      }, LC = Oi, kC = n, MC = or, UC = Z, VC = Je, xC = Wi, FC = function(e2) {
        if (e2 > 9007199254740991) throw RC("Maximum allowed index exceeded");
        return e2;
      }, BC = qE, jC = wC, GC = PC, WC = _e, HC = pt("isConcatSpreadable"), KC = WC >= 51 || !kC((function() {
        var e2 = [];
        return e2[HC] = false, e2.concat()[0] !== e2;
      })), YC = function(e2) {
        if (!UC(e2)) return false;
        var t2 = e2[HC];
        return void 0 !== t2 ? !!t2 : MC(e2);
      };
      LC({ target: "Array", proto: true, arity: 1, forced: !KC || !GC("concat") }, { concat: function(e2) {
        var t2, i2, n2, r2, o2, s2 = VC(this), a2 = jC(s2, 0), c2 = 0;
        for (t2 = -1, n2 = arguments.length; t2 < n2; t2++) if (YC(o2 = -1 === t2 ? s2 : arguments[t2])) for (r2 = xC(o2), FC(c2 + r2), i2 = 0; i2 < r2; i2++, c2++) i2 in o2 && BC(a2, c2, o2[i2]);
        else FC(c2 + 1), BC(a2, c2++, o2);
        return a2.length = c2, a2;
      } });
      var zC = {}, qC = R, XC = J, JC = Br.f, QC = sd, ZC = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      zC.f = function(e2) {
        return ZC && "Window" === qC(e2) ? (function(e3) {
          try {
            return JC(e3);
          } catch (e4) {
            return QC(ZC);
          }
        })(e2) : JC(XC(e2));
      };
      var $C = {}, ev = pt;
      $C.f = ev;
      var tv = $, iv = $e, nv = $C, rv = Zt.f, ov = function(e2) {
        var t2 = tv.Symbol || (tv.Symbol = {});
        iv(t2, e2) || rv(t2, e2, { value: nv.f(e2) });
      }, sv = D, av = re, cv = pt, dv = va, lv = function() {
        var e2 = av("Symbol"), t2 = e2 && e2.prototype, i2 = t2 && t2.valueOf, n2 = cv("toPrimitive");
        t2 && !t2[n2] && dv(t2, n2, (function(e3) {
          return sv(i2, this);
        }), { arity: 1 });
      }, uv = Qt, hv = W, pv = Je, _v = Wi, Ev = wC, mv = d([].push), fv = function(e2) {
        var t2 = 1 === e2, i2 = 2 === e2, n2 = 3 === e2, r2 = 4 === e2, o2 = 6 === e2, s2 = 7 === e2, a2 = 5 === e2 || o2;
        return function(c2, d2, l2, u2) {
          for (var h2, p2, _2 = pv(c2), E2 = hv(_2), m2 = _v(E2), f2 = uv(d2, l2), S2 = 0, g2 = u2 || Ev, T2 = t2 ? g2(c2, m2) : i2 || s2 ? g2(c2, 0) : void 0; m2 > S2; S2++) if ((a2 || S2 in E2) && (p2 = f2(h2 = E2[S2], S2, _2), e2)) if (t2) T2[S2] = p2;
          else if (p2) switch (e2) {
            case 3:
              return true;
            case 5:
              return h2;
            case 6:
              return S2;
            case 2:
              mv(T2, h2);
          }
          else switch (e2) {
            case 4:
              return false;
            case 7:
              mv(T2, h2);
          }
          return o2 ? -1 : n2 || r2 ? r2 : T2;
        };
      }, Sv = { forEach: fv(0), map: fv(1), filter: fv(2), some: fv(3), every: fv(4), find: fv(5), findIndex: fv(6), filterReject: fv(7) }, gv = Oi, Tv = h, Rv = D, Cv = d, vv = w, yv = Se, Iv = n, Av = $e, bv = l, wv = ni, Ov = J, Nv = vt, Dv = Sn, Pv = x, Lv = ko, kv = ho, Mv = Br, Uv = zC, Vv = Qr, xv = b, Fv = Zt, Bv = co, jv = P, Gv = va, Wv = vc, Hv = ze, Kv = jr, Yv = rt, zv = pt, qv = $C, Xv = ov, Jv = lv, Qv = Ga, Zv = Ea, $v = Sv.forEach, ey = gr("hidden"), ty = "Symbol", iy = "prototype", ny = Zv.set, ry = Zv.getterFor(ty), oy = Object[iy], sy = Tv.Symbol, ay = sy && sy[iy], cy = Tv.RangeError, dy = Tv.TypeError, ly = Tv.QObject, uy = xv.f, hy = Fv.f, py = Uv.f, _y = jv.f, Ey = Cv([].push), my = Hv("symbols"), fy = Hv("op-symbols"), Sy = Hv("wks"), gy = !ly || !ly[iy] || !ly[iy].findChild, Ty = function(e2, t2, i2) {
        var n2 = uy(oy, t2);
        n2 && delete oy[t2], hy(e2, t2, i2), n2 && e2 !== oy && hy(oy, t2, n2);
      }, Ry = vv && Iv((function() {
        return 7 !== Lv(hy({}, "a", { get: function() {
          return hy(this, "a", { value: 7 }).a;
        } })).a;
      })) ? Ty : hy, Cy = function(e2, t2) {
        var i2 = my[e2] = Lv(ay);
        return ny(i2, { type: ty, tag: e2, description: t2 }), vv || (i2.description = t2), i2;
      }, vy = function(e2, t2, i2) {
        e2 === oy && vy(fy, t2, i2), wv(e2);
        var n2 = Nv(t2);
        return wv(i2), Av(my, n2) ? (i2.enumerable ? (Av(e2, ey) && e2[ey][n2] && (e2[ey][n2] = false), i2 = Lv(i2, { enumerable: Pv(0, false) })) : (Av(e2, ey) || hy(e2, ey, Pv(1, Lv(null))), e2[ey][n2] = true), Ry(e2, n2, i2)) : hy(e2, n2, i2);
      }, yy = function(e2, t2) {
        wv(e2);
        var i2 = Ov(t2), n2 = kv(i2).concat(wy(i2));
        return $v(n2, (function(t3) {
          vv && !Rv(Iy, i2, t3) || vy(e2, t3, i2[t3]);
        })), e2;
      }, Iy = function(e2) {
        var t2 = Nv(e2), i2 = Rv(_y, this, t2);
        return !(this === oy && Av(my, t2) && !Av(fy, t2)) && (!(i2 || !Av(this, t2) || !Av(my, t2) || Av(this, ey) && this[ey][t2]) || i2);
      }, Ay = function(e2, t2) {
        var i2 = Ov(e2), n2 = Nv(t2);
        if (i2 !== oy || !Av(my, n2) || Av(fy, n2)) {
          var r2 = uy(i2, n2);
          return !r2 || !Av(my, n2) || Av(i2, ey) && i2[ey][n2] || (r2.enumerable = true), r2;
        }
      }, by = function(e2) {
        var t2 = py(Ov(e2)), i2 = [];
        return $v(t2, (function(e3) {
          Av(my, e3) || Av(Kv, e3) || Ey(i2, e3);
        })), i2;
      }, wy = function(e2) {
        var t2 = e2 === oy, i2 = py(t2 ? fy : Ov(e2)), n2 = [];
        return $v(i2, (function(e3) {
          !Av(my, e3) || t2 && !Av(oy, e3) || Ey(n2, my[e3]);
        })), n2;
      };
      yv || (sy = function() {
        if (bv(ay, this)) throw new dy("Symbol is not a constructor");
        var e2 = arguments.length && void 0 !== arguments[0] ? Dv(arguments[0]) : void 0, t2 = Yv(e2), i2 = function(e3) {
          var n2 = void 0 === this ? Tv : this;
          n2 === oy && Rv(i2, fy, e3), Av(n2, ey) && Av(n2[ey], t2) && (n2[ey][t2] = false);
          var r2 = Pv(1, e3);
          try {
            Ry(n2, t2, r2);
          } catch (e4) {
            if (!(e4 instanceof cy)) throw e4;
            Ty(n2, t2, r2);
          }
        };
        return vv && gy && Ry(oy, t2, { configurable: true, set: i2 }), Cy(t2, e2);
      }, Gv(ay = sy[iy], "toString", (function() {
        return ry(this).tag;
      })), Gv(sy, "withoutSetter", (function(e2) {
        return Cy(Yv(e2), e2);
      })), jv.f = Iy, Fv.f = vy, Bv.f = yy, xv.f = Ay, Mv.f = Uv.f = by, Vv.f = wy, qv.f = function(e2) {
        return Cy(zv(e2), e2);
      }, vv && Wv(ay, "description", { configurable: true, get: function() {
        return ry(this).description;
      } })), gv({ global: true, constructor: true, wrap: true, forced: !yv, sham: !yv }, { Symbol: sy }), $v(kv(Sy), (function(e2) {
        Xv(e2);
      })), gv({ target: ty, stat: true, forced: !yv }, { useSetter: function() {
        gy = true;
      }, useSimple: function() {
        gy = false;
      } }), gv({ target: "Object", stat: true, forced: !yv, sham: !vv }, { create: function(e2, t2) {
        return void 0 === t2 ? Lv(e2) : yy(Lv(e2), t2);
      }, defineProperty: vy, defineProperties: yy, getOwnPropertyDescriptor: Ay }), gv({ target: "Object", stat: true, forced: !yv }, { getOwnPropertyNames: by }), Jv(), Qv(sy, ty), Kv[ey] = true;
      var Oy = Se && !!Symbol.for && !!Symbol.keyFor, Ny = Oi, Dy = re, Py = $e, Ly = Sn, ky = ze, My = Oy, Uy = ky("string-to-symbol-registry"), Vy = ky("symbol-to-string-registry");
      Ny({ target: "Symbol", stat: true, forced: !My }, { for: function(e2) {
        var t2 = Ly(e2);
        if (Py(Uy, t2)) return Uy[t2];
        var i2 = Dy("Symbol")(t2);
        return Uy[t2] = i2, Vy[i2] = t2, i2;
      } });
      var xy = Oi, Fy = $e, By = ye, jy = Ae, Gy = Oy, Wy = ze("symbol-to-string-registry");
      xy({ target: "Symbol", stat: true, forced: !Gy }, { keyFor: function(e2) {
        if (!By(e2)) throw new TypeError(jy(e2) + " is not a symbol");
        if (Fy(Wy, e2)) return Wy[e2];
      } });
      var Hy = or, Ky = A, Yy = R, zy = Sn, qy = d([].push), Xy = Oi, Jy = re, Qy = f, Zy = D, $y = d, eI = n, tI = A, iI = ye, nI = sd, rI = function(e2) {
        if (Ky(e2)) return e2;
        if (Hy(e2)) {
          for (var t2 = e2.length, i2 = [], n2 = 0; n2 < t2; n2++) {
            var r2 = e2[n2];
            "string" == typeof r2 ? qy(i2, r2) : "number" != typeof r2 && "Number" !== Yy(r2) && "String" !== Yy(r2) || qy(i2, zy(r2));
          }
          var o2 = i2.length, s2 = true;
          return function(e3, t3) {
            if (s2) return s2 = false, t3;
            if (Hy(this)) return t3;
            for (var n3 = 0; n3 < o2; n3++) if (i2[n3] === e3) return t3;
          };
        }
      }, oI = Se, sI = String, aI = Jy("JSON", "stringify"), cI = $y(/./.exec), dI = $y("".charAt), lI = $y("".charCodeAt), uI = $y("".replace), hI = $y(1.1.toString), pI = /[\uD800-\uDFFF]/g, _I = /^[\uD800-\uDBFF]$/, EI = /^[\uDC00-\uDFFF]$/, mI = !oI || eI((function() {
        var e2 = Jy("Symbol")("stringify detection");
        return "[null]" !== aI([e2]) || "{}" !== aI({ a: e2 }) || "{}" !== aI(Object(e2));
      })), fI = eI((function() {
        return '"\\udf06\\ud834"' !== aI("\uDF06\uD834") || '"\\udead"' !== aI("\uDEAD");
      })), SI = function(e2, t2) {
        var i2 = nI(arguments), n2 = rI(t2);
        if (tI(n2) || void 0 !== e2 && !iI(e2)) return i2[1] = function(e3, t3) {
          if (tI(n2) && (t3 = Zy(n2, this, sI(e3), t3)), !iI(t3)) return t3;
        }, Qy(aI, null, i2);
      }, gI = function(e2, t2, i2) {
        var n2 = dI(i2, t2 - 1), r2 = dI(i2, t2 + 1);
        return cI(_I, e2) && !cI(EI, r2) || cI(EI, e2) && !cI(_I, n2) ? "\\u" + hI(lI(e2, 0), 16) : e2;
      };
      aI && Xy({ target: "JSON", stat: true, arity: 3, forced: mI || fI }, { stringify: function(e2, t2, i2) {
        var n2 = nI(arguments), r2 = Qy(mI ? SI : aI, null, n2);
        return fI && "string" == typeof r2 ? uI(r2, pI, gI) : r2;
      } });
      var TI = Qr, RI = Je;
      Oi({ target: "Object", stat: true, forced: !Se || n((function() {
        TI.f(1);
      })) }, { getOwnPropertySymbols: function(e2) {
        var t2 = TI.f;
        return t2 ? t2(RI(e2)) : [];
      } }), ov("asyncDispose"), ov("asyncIterator"), ov("dispose"), ov("hasInstance"), ov("isConcatSpreadable"), ov("iterator"), ov("match"), ov("matchAll"), ov("replace"), ov("search"), ov("species"), ov("split");
      var CI = lv;
      ov("toPrimitive"), CI();
      var vI = re, yI = Ga;
      ov("toStringTag"), yI(vI("Symbol"), "Symbol"), ov("unscopables"), Ga(h.JSON, "JSON", true);
      var II = $.Symbol, AI = pt, bI = Zt.f, wI = AI("metadata"), OI = Function.prototype;
      void 0 === OI[wI] && bI(OI, wI, { value: null }), ov("metadata");
      var NI = II, DI = d, PI = re("Symbol"), LI = PI.keyFor, kI = DI(PI.prototype.valueOf), MI = PI.isRegisteredSymbol || function(e2) {
        try {
          return void 0 !== LI(kI(e2));
        } catch (e3) {
          return false;
        }
      };
      Oi({ target: "Symbol", stat: true }, { isRegisteredSymbol: MI });
      for (var UI = ze, VI = re, xI = d, FI = ye, BI = pt, jI = VI("Symbol"), GI = jI.isWellKnownSymbol, WI = VI("Object", "getOwnPropertyNames"), HI = xI(jI.prototype.valueOf), KI = UI("wks"), YI = 0, zI = WI(jI), qI = zI.length; YI < qI; YI++) try {
        var XI = zI[YI];
        FI(jI[XI]) && BI(XI);
      } catch (e2) {
      }
      var JI = function(e2) {
        if (GI && GI(e2)) return true;
        try {
          for (var t2 = HI(e2), i2 = 0, n2 = WI(KI), r2 = n2.length; i2 < r2; i2++) if (KI[n2[i2]] == t2) return true;
        } catch (e3) {
        }
        return false;
      };
      Oi({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: JI }), ov("customMatcher"), ov("observable"), Oi({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: MI }), Oi({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: JI }), ov("matcher"), ov("metadataKey"), ov("patternMatch"), ov("replaceAll");
      var QI = i(NI), ZI = i($C.f("iterator"));
      function $I(e2) {
        return $I = "function" == typeof QI && "symbol" == typeof ZI ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof QI && e3.constructor === QI && e3 !== QI.prototype ? "symbol" : typeof e3;
        }, $I(e2);
      }
      var eA = i($C.f("toPrimitive"));
      function tA(e2) {
        var t2 = (function(e3, t3) {
          if ("object" != $I(e3) || !e3) return e3;
          var i2 = e3[eA];
          if (void 0 !== i2) {
            var n2 = i2.call(e3, t3 || "default");
            if ("object" != $I(n2)) return n2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t3 ? String : Number)(e3);
        })(e2, "string");
        return "symbol" == $I(t2) ? t2 : t2 + "";
      }
      function iA(e2, t2, i2) {
        return (t2 = tA(t2)) in e2 ? TC(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      var nA = i(OE), rA = { isBrowser: true, classes: { URLSearchParams: void 0 !== nA ? nA : cC, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
      const oA = "undefined" != typeof window && "undefined" != typeof document, sA = "object" == typeof navigator && navigator || void 0, aA = oA && (!sA || ["ReactNative", "NativeScript", "NS"].indexOf(sA.product) < 0), cA = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, dA = oA && window.location.href || "http://localhost";
      function lA(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function uA(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? lA(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : lA(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      var hA = uA(uA({}, Object.freeze({ __proto__: null, hasBrowserEnv: oA, hasStandardBrowserEnv: aA, hasStandardBrowserWebWorkerEnv: cA, navigator: sA, origin: dA })), rA);
      function pA(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function _A(e2, t2) {
        return sC(e2, new hA.classes.URLSearchParams(), (function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i2 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? pA(Object(i2), true).forEach((function(t4) {
              iA(e3, t4, i2[t4]);
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : pA(Object(i2)).forEach((function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i2, t4));
            }));
          }
          return e3;
        })({ visitor: function(e3, t3, i2, n2) {
          return hA.isNode && ZR.isBuffer(e3) ? (this.append(t3, e3.toString("base64")), false) : n2.defaultVisitor.apply(this, arguments);
        } }, t2));
      }
      var EA = Gh.charAt, mA = D, fA = ni, SA = A, gA = R, TA = /./.exec, RA = TypeError, CA = Oi, vA = D, yA = y, IA = Xa, AA = pc, bA = z, wA = ji, OA = Sn, NA = ni, DA = Z, PA = R, LA = rn, kA = rT, MA = Le, UA = n, VA = od, xA = function(e2, t2, i2) {
        return t2 + (i2 ? EA(e2, t2).length : 1);
      }, FA = function(e2, t2) {
        var i2 = e2.exec;
        if (SA(i2)) {
          var n2 = mA(i2, e2, t2);
          return null !== n2 && fA(n2), n2;
        }
        if ("RegExp" === gA(e2)) return mA(TA, e2, t2);
        throw new RA("RegExp#exec called on incompatible receiver");
      }, BA = Ea, jA = pt("matchAll"), GA = "RegExp String", WA = GA + " Iterator", HA = BA.set, KA = BA.getterFor(WA), YA = TypeError, zA = yA("".indexOf), qA = yA("".matchAll), XA = !!qA && !UA((function() {
        qA("a", /./);
      })), JA = IA((function(e2, t2, i2, n2) {
        HA(this, { type: WA, regexp: e2, string: t2, global: i2, unicode: n2, done: false });
      }), GA, (function() {
        var e2 = KA(this);
        if (e2.done) return AA(void 0, true);
        var t2 = e2.regexp, i2 = e2.string, n2 = FA(t2, i2);
        return null === n2 ? (e2.done = true, AA(void 0, true)) : e2.global ? ("" === OA(n2[0]) && (t2.lastIndex = xA(i2, wA(t2.lastIndex), e2.unicode)), AA(n2, false)) : (e2.done = true, AA(n2, false));
      })), QA = function(e2) {
        var t2, i2, n2, r2 = NA(this), o2 = OA(e2), s2 = VA(r2, RegExp), a2 = OA(kA(r2));
        return t2 = new s2(s2 === RegExp ? r2.source : r2, a2), i2 = !!~zA(a2, "g"), n2 = !!~zA(a2, "u"), t2.lastIndex = wA(r2.lastIndex), new JA(t2, o2, i2, n2);
      };
      CA({ target: "String", proto: true, forced: XA }, { matchAll: function(e2) {
        var t2, i2, n2, r2, o2 = bA(this);
        if (DA(e2)) {
          if (LA(e2) && (t2 = OA(bA(kA(e2))), !~zA(t2, "g"))) throw new YA("`.matchAll` does not allow non-global regexes");
          if (XA) return qA(o2, e2);
          if (void 0 === (n2 = MA(e2, jA)) && "RegExp" === PA(e2) && (n2 = QA), n2) return vA(n2, e2, o2);
        } else if (XA) return qA(o2, e2);
        return i2 = OA(o2), r2 = new RegExp(e2, "g"), vA(QA, r2, i2);
      } });
      var ZA = Zi("String", "matchAll"), $A = l, eb = ZA, tb = String.prototype, ib = function(e2) {
        var t2 = e2.matchAll;
        return "string" == typeof e2 || e2 === tb || $A(tb, e2) && t2 === tb.matchAll ? eb : t2;
      }, nb = i(ib);
      function rb(e2) {
        function t2(e3, i2, n2, r2) {
          let o2 = e3[r2++];
          if ("__proto__" === o2) return true;
          const s2 = Number.isFinite(+o2), a2 = r2 >= e3.length;
          if (o2 = !o2 && ZR.isArray(n2) ? n2.length : o2, a2) return ZR.hasOwnProp(n2, o2) ? n2[o2] = [n2[o2], i2] : n2[o2] = i2, !s2;
          n2[o2] && ZR.isObject(n2[o2]) || (n2[o2] = []);
          return t2(e3, i2, n2[o2], r2) && ZR.isArray(n2[o2]) && (n2[o2] = (function(e4) {
            const t3 = {}, i3 = Object.keys(e4);
            let n3;
            const r3 = i3.length;
            let o3;
            for (n3 = 0; n3 < r3; n3++) o3 = i3[n3], t3[o3] = e4[o3];
            return t3;
          })(n2[o2])), !s2;
        }
        if (ZR.isFormData(e2) && ZR.isFunction(e2.entries)) {
          const i2 = {};
          return ZR.forEachEntry(e2, ((e3, n2) => {
            t2((function(e4) {
              return nb(ZR).call(ZR, /\w+|\[(\w*)]/g, e4).map(((e5) => "[]" === e5[0] ? "" : e5[1] || e5[0]));
            })(e3), n2, i2, 0);
          })), i2;
        }
        return null;
      }
      const ob = { transitional: pC, adapter: ["xhr", "http", "fetch"], transformRequest: [function(e2, t2) {
        const i2 = t2.getContentType() || "", n2 = i2.indexOf("application/json") > -1, r2 = ZR.isObject(e2);
        r2 && ZR.isHTMLForm(e2) && (e2 = new FormData(e2));
        if (ZR.isFormData(e2)) return n2 ? JSON.stringify(rb(e2)) : e2;
        if (ZR.isArrayBuffer(e2) || ZR.isBuffer(e2) || ZR.isStream(e2) || ZR.isFile(e2) || ZR.isBlob(e2) || ZR.isReadableStream(e2)) return e2;
        if (ZR.isArrayBufferView(e2)) return e2.buffer;
        if (ZR.isURLSearchParams(e2)) return t2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e2.toString();
        let o2;
        if (r2) {
          if (i2.indexOf("application/x-www-form-urlencoded") > -1) return _A(e2, this.formSerializer).toString();
          if ((o2 = ZR.isFileList(e2)) || i2.indexOf("multipart/form-data") > -1) {
            const t3 = this.env && this.env.FormData;
            return sC(o2 ? { "files[]": e2 } : e2, t3 && new t3(), this.formSerializer);
          }
        }
        return r2 || n2 ? (t2.setContentType("application/json", false), (function(e3, t3, i3) {
          if (ZR.isString(e3)) try {
            return (t3 || JSON.parse)(e3), kg(ZR).call(ZR, e3);
          } catch (e4) {
            if ("SyntaxError" !== e4.name) throw e4;
          }
          return (i3 || JSON.stringify)(e3);
        })(e2)) : e2;
      }], transformResponse: [function(e2) {
        const t2 = this.transitional || ob.transitional, i2 = t2 && t2.forcedJSONParsing, n2 = "json" === this.responseType;
        if (ZR.isResponse(e2) || ZR.isReadableStream(e2)) return e2;
        if (e2 && ZR.isString(e2) && (i2 && !this.responseType || n2)) {
          const i3 = !(t2 && t2.silentJSONParsing) && n2;
          try {
            return JSON.parse(e2, this.parseReviver);
          } catch (e3) {
            if (i3) {
              if ("SyntaxError" === e3.name) throw $R.from(e3, $R.ERR_BAD_RESPONSE, this, null, this.response);
              throw e3;
            }
          }
        }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: hA.classes.FormData, Blob: hA.classes.Blob }, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
      ZR.forEach(["delete", "get", "head", "post", "put", "patch"], ((e2) => {
        ob.headers[e2] = {};
      }));
      var sb = ob;
      const ab = ZR.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
      const cb = Symbol("internals");
      function db(e2) {
        var t2;
        return e2 && kg(t2 = String(e2)).call(t2).toLowerCase();
      }
      function lb(e2) {
        return false === e2 || null == e2 ? e2 : ZR.isArray(e2) ? e2.map(lb) : String(e2);
      }
      function ub(e2, t2, i2, n2, r2) {
        return ZR.isFunction(n2) ? n2.call(this, t2, i2) : (r2 && (t2 = i2), ZR.isString(t2) ? ZR.isString(n2) ? -1 !== t2.indexOf(n2) : ZR.isRegExp(n2) ? n2.test(t2) : void 0 : void 0);
      }
      class hb {
        constructor(e2) {
          e2 && this.set(e2);
        }
        set(e2, t2, i2) {
          const n2 = this;
          function r2(e3, t3, i3) {
            const r3 = db(t3);
            if (!r3) throw new Error("header name must be a non-empty string");
            const o3 = ZR.findKey(n2, r3);
            (!o3 || void 0 === n2[o3] || true === i3 || void 0 === i3 && false !== n2[o3]) && (n2[o3 || t3] = lb(e3));
          }
          const o2 = (e3, t3) => ZR.forEach(e3, ((e4, i3) => r2(e4, i3, t3)));
          if (ZR.isPlainObject(e2) || e2 instanceof this.constructor) o2(e2, t2);
          else if (ZR.isString(e2) && (e2 = kg(e2).call(e2)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(kg(s2 = e2).call(s2))) o2(((e3) => {
            const t3 = {};
            let i3, n3, r3;
            return e3 && e3.split("\n").forEach((function(e4) {
              var o3, s3;
              r3 = e4.indexOf(":"), i3 = kg(o3 = e4.substring(0, r3)).call(o3).toLowerCase(), n3 = kg(s3 = e4.substring(r3 + 1)).call(s3), !i3 || t3[i3] && ab[i3] || ("set-cookie" === i3 ? t3[i3] ? t3[i3].push(n3) : t3[i3] = [n3] : t3[i3] = t3[i3] ? t3[i3] + ", " + n3 : n3);
            })), t3;
          })(e2), t2);
          else if (ZR.isObject(e2) && ZR.isIterable(e2)) {
            let i3, n3, r3 = {};
            for (const t3 of e2) {
              if (!ZR.isArray(t3)) throw TypeError("Object iterator must return a key-value pair");
              r3[n3 = t3[0]] = (i3 = r3[n3]) ? ZR.isArray(i3) ? [...i3, t3[1]] : [i3, t3[1]] : t3[1];
            }
            o2(r3, t2);
          } else null != e2 && r2(t2, e2, i2);
          var s2;
          return this;
        }
        get(e2, t2) {
          if (e2 = db(e2)) {
            const i2 = ZR.findKey(this, e2);
            if (i2) {
              const e3 = this[i2];
              if (!t2) return e3;
              if (true === t2) return (function(e4) {
                const t3 = /* @__PURE__ */ Object.create(null), i3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let n2;
                for (; n2 = i3.exec(e4); ) t3[n2[1]] = n2[2];
                return t3;
              })(e3);
              if (ZR.isFunction(t2)) return t2.call(this, e3, i2);
              if (ZR.isRegExp(t2)) return t2.exec(e3);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e2, t2) {
          if (e2 = db(e2)) {
            const i2 = ZR.findKey(this, e2);
            return !(!i2 || void 0 === this[i2] || t2 && !ub(0, this[i2], i2, t2));
          }
          return false;
        }
        delete(e2, t2) {
          const i2 = this;
          let n2 = false;
          function r2(e3) {
            if (e3 = db(e3)) {
              const r3 = ZR.findKey(i2, e3);
              !r3 || t2 && !ub(0, i2[r3], r3, t2) || (delete i2[r3], n2 = true);
            }
          }
          return ZR.isArray(e2) ? e2.forEach(r2) : r2(e2), n2;
        }
        clear(e2) {
          const t2 = Object.keys(this);
          let i2 = t2.length, n2 = false;
          for (; i2--; ) {
            const r2 = t2[i2];
            e2 && !ub(0, this[r2], r2, e2, true) || (delete this[r2], n2 = true);
          }
          return n2;
        }
        normalize(e2) {
          const t2 = this, i2 = {};
          return ZR.forEach(this, ((n2, r2) => {
            var o2;
            const s2 = ZR.findKey(i2, r2);
            if (s2) return t2[s2] = lb(n2), void delete t2[r2];
            const a2 = e2 ? (function(e3) {
              return kg(e3).call(e3).toLowerCase().replace(/([a-z\d])(\w*)/g, ((e4, t3, i3) => t3.toUpperCase() + i3));
            })(r2) : kg(o2 = String(r2)).call(o2);
            a2 !== r2 && delete t2[r2], t2[a2] = lb(n2), i2[a2] = true;
          })), this;
        }
        concat() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          return this.constructor.concat(this, ...t2);
        }
        toJSON(e2) {
          const t2 = /* @__PURE__ */ Object.create(null);
          return ZR.forEach(this, ((i2, n2) => {
            null != i2 && false !== i2 && (t2[n2] = e2 && ZR.isArray(i2) ? i2.join(", ") : i2);
          })), t2;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(((e2) => {
            let [t2, i2] = e2;
            return t2 + ": " + i2;
          })).join("\n");
        }
        getSetCookie() {
          return this.get("set-cookie") || [];
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e2) {
          return e2 instanceof this ? e2 : new this(e2);
        }
        static concat(e2) {
          const t2 = new this(e2);
          for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
          return n2.forEach(((e3) => t2.set(e3))), t2;
        }
        static accessor(e2) {
          const t2 = (this[cb] = this[cb] = { accessors: {} }).accessors, i2 = this.prototype;
          function n2(e3) {
            const n3 = db(e3);
            t2[n3] || (!(function(e4, t3) {
              const i3 = ZR.toCamelCase(" " + t3);
              ["get", "set", "has"].forEach(((n4) => {
                Object.defineProperty(e4, n4 + i3, { value: function(e5, i4, r2) {
                  return this[n4].call(this, t3, e5, i4, r2);
                }, configurable: true });
              }));
            })(i2, e3), t2[n3] = true);
          }
          return ZR.isArray(e2) ? e2.forEach(n2) : n2(e2), this;
        }
      }
      hb.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), ZR.reduceDescriptors(hb.prototype, ((e2, t2) => {
        let { value: i2 } = e2, n2 = t2[0].toUpperCase() + t2.slice(1);
        return { get: () => i2, set(e3) {
          this[n2] = e3;
        } };
      })), ZR.freezeMethods(hb);
      var pb = hb;
      function _b(e2, t2) {
        const i2 = this || sb, n2 = t2 || i2, r2 = pb.from(n2.headers);
        let o2 = n2.data;
        return ZR.forEach(e2, (function(e3) {
          o2 = e3.call(i2, o2, r2.normalize(), t2 ? t2.status : void 0);
        })), r2.normalize(), o2;
      }
      function Eb(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }
      function mb(e2, t2, i2) {
        $R.call(this, null == e2 ? "canceled" : e2, $R.ERR_CANCELED, t2, i2), this.name = "CanceledError";
      }
      function fb(e2, t2, i2) {
        const n2 = i2.config.validateStatus;
        i2.status && n2 && !n2(i2.status) ? t2(new $R("Request failed with status code " + i2.status, [$R.ERR_BAD_REQUEST, $R.ERR_BAD_RESPONSE][Math.floor(i2.status / 100) - 4], i2.config, i2.request, i2)) : e2(i2);
      }
      ZR.inherits(mb, $R, { __CANCEL__: true });
      const Sb = function(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n2 = 0;
        const r2 = (function(e3, t3) {
          e3 = e3 || 10;
          const i3 = new Array(e3), n3 = new Array(e3);
          let r3, o2 = 0, s2 = 0;
          return t3 = void 0 !== t3 ? t3 : 1e3, function(a2) {
            const c2 = Date.now(), d2 = n3[s2];
            r3 || (r3 = c2), i3[o2] = a2, n3[o2] = c2;
            let l2 = s2, u2 = 0;
            for (; l2 !== o2; ) u2 += i3[l2++], l2 %= e3;
            if (o2 = (o2 + 1) % e3, o2 === s2 && (s2 = (s2 + 1) % e3), c2 - r3 < t3) return;
            const h2 = d2 && c2 - d2;
            return h2 ? Math.round(1e3 * u2 / h2) : void 0;
          };
        })(50, 250);
        return (function(e3, t3) {
          let i3, n3, r3 = 0, o2 = 1e3 / t3;
          const s2 = function(t4) {
            let o3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
            r3 = o3, i3 = null, n3 && (clearTimeout(n3), n3 = null), e3(...t4);
          };
          return [function() {
            const e4 = Date.now(), t4 = e4 - r3;
            for (var a2 = arguments.length, c2 = new Array(a2), d2 = 0; d2 < a2; d2++) c2[d2] = arguments[d2];
            t4 >= o2 ? s2(c2, e4) : (i3 = c2, n3 || (n3 = setTimeout((() => {
              n3 = null, s2(i3);
            }), o2 - t4)));
          }, () => i3 && s2(i3)];
        })(((i3) => {
          const o2 = i3.loaded, s2 = i3.lengthComputable ? i3.total : void 0, a2 = o2 - n2, c2 = r2(a2);
          n2 = o2;
          e2({ loaded: o2, total: s2, progress: s2 ? o2 / s2 : void 0, bytes: a2, rate: c2 || void 0, estimated: c2 && s2 && o2 <= s2 ? (s2 - o2) / c2 : void 0, event: i3, lengthComputable: null != s2, [t2 ? "download" : "upload"]: true });
        }), i2);
      }, gb = (e2, t2) => {
        const i2 = null != e2;
        return [(n2) => t2[0]({ lengthComputable: i2, total: e2, loaded: n2 }), t2[1]];
      }, Tb = (e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), n2 = 0; n2 < t2; n2++) i2[n2] = arguments[n2];
        return ZR.asap((() => e2(...i2)));
      };
      var Rb = hA.hasStandardBrowserEnv ? /* @__PURE__ */ ((e2, t2) => (i2) => (i2 = new vS(i2, hA.origin), e2.protocol === i2.protocol && e2.host === i2.host && (t2 || e2.port === i2.port)))(new vS(hA.origin), hA.navigator && /(msie|trident)/i.test(hA.navigator.userAgent)) : () => true, Cb = hA.hasStandardBrowserEnv ? { write(e2, t2, i2, n2, r2, o2, s2) {
        if ("undefined" == typeof document) return;
        const a2 = ["".concat(e2, "=").concat(encodeURIComponent(t2))];
        ZR.isNumber(i2) && a2.push("expires=".concat(new Date(i2).toUTCString())), ZR.isString(n2) && a2.push("path=".concat(n2)), ZR.isString(r2) && a2.push("domain=".concat(r2)), true === o2 && a2.push("secure"), ZR.isString(s2) && a2.push("SameSite=".concat(s2)), document.cookie = a2.join("; ");
      }, read(e2) {
        if ("undefined" == typeof document) return null;
        const t2 = document.cookie.match(new RegExp("(?:^|; )" + e2 + "=([^;]*)"));
        return t2 ? decodeURIComponent(t2[1]) : null;
      }, remove(e2) {
        this.write(e2, "", Date.now() - 864e5, "/");
      } } : { write() {
      }, read: () => null, remove() {
      } };
      function vb(e2, t2, i2) {
        let n2 = !(function(e3) {
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e3);
        })(t2);
        return e2 && (n2 || 0 == i2) ? (function(e3, t3) {
          return t3 ? e3.replace(/\/?\/$/, "") + "/" + t3.replace(/^\/+/, "") : e3;
        })(e2, t2) : t2;
      }
      function yb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Ib(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? yb(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yb(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const Ab = (e2) => e2 instanceof pb ? Ib({}, e2) : e2;
      function bb(e2, t2) {
        t2 = t2 || {};
        const i2 = {};
        function n2(e3, t3, i3, n3) {
          return ZR.isPlainObject(e3) && ZR.isPlainObject(t3) ? ZR.merge.call({ caseless: n3 }, e3, t3) : ZR.isPlainObject(t3) ? ZR.merge({}, t3) : ZR.isArray(t3) ? t3.slice() : t3;
        }
        function r2(e3, t3, i3, r3) {
          return ZR.isUndefined(t3) ? ZR.isUndefined(e3) ? void 0 : n2(void 0, e3, 0, r3) : n2(e3, t3, 0, r3);
        }
        function o2(e3, t3) {
          if (!ZR.isUndefined(t3)) return n2(void 0, t3);
        }
        function s2(e3, t3) {
          return ZR.isUndefined(t3) ? ZR.isUndefined(e3) ? void 0 : n2(void 0, e3) : n2(void 0, t3);
        }
        function a2(i3, r3, o3) {
          return o3 in t2 ? n2(i3, r3) : o3 in e2 ? n2(void 0, i3) : void 0;
        }
        const c2 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, withXSRFToken: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a2, headers: (e3, t3, i3) => r2(Ab(e3), Ab(t3), 0, true) };
        return ZR.forEach(Object.keys(Ib(Ib({}, e2), t2)), (function(n3) {
          const o3 = c2[n3] || r2, s3 = o3(e2[n3], t2[n3], n3);
          ZR.isUndefined(s3) && o3 !== a2 || (i2[n3] = s3);
        })), i2;
      }
      var wb = (e2) => {
        const t2 = bb({}, e2);
        let { data: i2, withXSRFToken: n2, xsrfHeaderName: r2, xsrfCookieName: o2, headers: s2, auth: a2 } = t2;
        if (t2.headers = s2 = pb.from(s2), t2.url = uC(vb(t2.baseURL, t2.url, t2.allowAbsoluteUrls), e2.params, e2.paramsSerializer), a2 && s2.set("Authorization", "Basic " + btoa((a2.username || "") + ":" + (a2.password ? unescape(encodeURIComponent(a2.password)) : ""))), ZR.isFormData(i2)) {
          if (hA.hasStandardBrowserEnv || hA.hasStandardBrowserWebWorkerEnv) s2.setContentType(void 0);
          else if (ZR.isFunction(i2.getHeaders)) {
            const e3 = i2.getHeaders(), t3 = ["content-type", "content-length"];
            Object.entries(e3).forEach(((e4) => {
              let [i3, n3] = e4;
              Ln(t3).call(t3, i3.toLowerCase()) && s2.set(i3, n3);
            }));
          }
        }
        if (hA.hasStandardBrowserEnv && (n2 && ZR.isFunction(n2) && (n2 = n2(t2)), n2 || false !== n2 && Rb(t2.url))) {
          const e3 = r2 && o2 && Cb.read(o2);
          e3 && s2.set(r2, e3);
        }
        return t2;
      };
      var Ob = "undefined" != typeof XMLHttpRequest && function(e2) {
        return new rp((function(t2, i2) {
          const n2 = wb(e2);
          let r2 = n2.data;
          const o2 = pb.from(n2.headers).normalize();
          let s2, a2, c2, d2, l2, { responseType: u2, onUploadProgress: h2, onDownloadProgress: p2 } = n2;
          function _2() {
            d2 && d2(), l2 && l2(), n2.cancelToken && n2.cancelToken.unsubscribe(s2), n2.signal && n2.signal.removeEventListener("abort", s2);
          }
          let E2 = new XMLHttpRequest();
          function m2() {
            if (!E2) return;
            const n3 = pb.from("getAllResponseHeaders" in E2 && E2.getAllResponseHeaders());
            fb((function(e3) {
              t2(e3), _2();
            }), (function(e3) {
              i2(e3), _2();
            }), { data: u2 && "text" !== u2 && "json" !== u2 ? E2.response : E2.responseText, status: E2.status, statusText: E2.statusText, headers: n3, config: e2, request: E2 }), E2 = null;
          }
          E2.open(n2.method.toUpperCase(), n2.url, true), E2.timeout = n2.timeout, "onloadend" in E2 ? E2.onloadend = m2 : E2.onreadystatechange = function() {
            E2 && 4 === E2.readyState && (0 !== E2.status || E2.responseURL && 0 === E2.responseURL.indexOf("file:")) && setTimeout(m2);
          }, E2.onabort = function() {
            E2 && (i2(new $R("Request aborted", $R.ECONNABORTED, e2, E2)), E2 = null);
          }, E2.onerror = function(t3) {
            const n3 = new $R(t3 && t3.message ? t3.message : "Network Error", $R.ERR_NETWORK, e2, E2);
            n3.event = t3 || null, i2(n3), E2 = null;
          }, E2.ontimeout = function() {
            let t3 = n2.timeout ? "timeout of " + n2.timeout + "ms exceeded" : "timeout exceeded";
            const r3 = n2.transitional || pC;
            n2.timeoutErrorMessage && (t3 = n2.timeoutErrorMessage), i2(new $R(t3, r3.clarifyTimeoutError ? $R.ETIMEDOUT : $R.ECONNABORTED, e2, E2)), E2 = null;
          }, void 0 === r2 && o2.setContentType(null), "setRequestHeader" in E2 && ZR.forEach(o2.toJSON(), (function(e3, t3) {
            E2.setRequestHeader(t3, e3);
          })), ZR.isUndefined(n2.withCredentials) || (E2.withCredentials = !!n2.withCredentials), u2 && "json" !== u2 && (E2.responseType = n2.responseType), p2 && ([c2, l2] = Sb(p2, true), E2.addEventListener("progress", c2)), h2 && E2.upload && ([a2, d2] = Sb(h2), E2.upload.addEventListener("progress", a2), E2.upload.addEventListener("loadend", d2)), (n2.cancelToken || n2.signal) && (s2 = (t3) => {
            E2 && (i2(!t3 || t3.type ? new mb(null, e2, E2) : t3), E2.abort(), E2 = null);
          }, n2.cancelToken && n2.cancelToken.subscribe(s2), n2.signal && (n2.signal.aborted ? s2() : n2.signal.addEventListener("abort", s2)));
          const f2 = (function(e3) {
            const t3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e3);
            return t3 && t3[1] || "";
          })(n2.url);
          f2 && -1 === hA.protocols.indexOf(f2) ? i2(new $R("Unsupported protocol " + f2 + ":", $R.ERR_BAD_REQUEST, e2)) : E2.send(r2 || null);
        }));
      };
      var Nb = (e2, t2) => {
        const { length: i2 } = e2 = e2 ? e2.filter(Boolean) : [];
        if (t2 || i2) {
          let i3, n2 = new AbortController();
          const r2 = function(e3) {
            if (!i3) {
              i3 = true, s2();
              const t3 = e3 instanceof Error ? e3 : this.reason;
              n2.abort(t3 instanceof $R ? t3 : new mb(t3 instanceof Error ? t3.message : t3));
            }
          };
          let o2 = t2 && setTimeout((() => {
            o2 = null, r2(new $R("timeout ".concat(t2, " of ms exceeded"), $R.ETIMEDOUT));
          }), t2);
          const s2 = () => {
            e2 && (o2 && clearTimeout(o2), o2 = null, e2.forEach(((e3) => {
              e3.unsubscribe ? e3.unsubscribe(r2) : e3.removeEventListener("abort", r2);
            })), e2 = null);
          };
          e2.forEach(((e3) => e3.addEventListener("abort", r2)));
          const { signal: a2 } = n2;
          return a2.unsubscribe = () => ZR.asap(s2), a2;
        }
      }, Db = i(np), Pb = $C.f("asyncIterator"), Lb = i(Pb);
      function kb(e2, t2) {
        this.v = e2, this.k = t2;
      }
      function Mb(e2) {
        return function() {
          return new Ub(e2.apply(this, arguments));
        };
      }
      function Ub(e2) {
        var t2, i2;
        function n2(t3, i3) {
          try {
            var o2 = e2[t3](i3), s2 = o2.value, a2 = s2 instanceof kb;
            Db.resolve(a2 ? s2.v : s2).then((function(i4) {
              if (a2) {
                var c2 = "return" === t3 ? "return" : "next";
                if (!s2.k || i4.done) return n2(c2, i4);
                i4 = e2[c2](i4).value;
              }
              r2(o2.done ? "return" : "normal", i4);
            }), (function(e3) {
              n2("throw", e3);
            }));
          } catch (e3) {
            r2("throw", e3);
          }
        }
        function r2(e3, r3) {
          switch (e3) {
            case "return":
              t2.resolve({ value: r3, done: true });
              break;
            case "throw":
              t2.reject(r3);
              break;
            default:
              t2.resolve({ value: r3, done: false });
          }
          (t2 = t2.next) ? n2(t2.key, t2.arg) : i2 = null;
        }
        this._invoke = function(e3, r3) {
          return new Db((function(o2, s2) {
            var a2 = { key: e3, arg: r3, resolve: o2, reject: s2, next: null };
            i2 ? i2 = i2.next = a2 : (t2 = i2 = a2, n2(e3, r3));
          }));
        }, "function" != typeof e2.return && (this.return = void 0);
      }
      function Vb(e2) {
        return new kb(e2, 0);
      }
      function xb(e2) {
        var t2 = {}, i2 = false;
        function n2(t3, n3) {
          return i2 = true, n3 = new Db((function(i3) {
            i3(e2[t3](n3));
          })), { done: false, value: new kb(n3, 1) };
        }
        return t2[void 0 !== QI && ZI || "@@iterator"] = function() {
          return this;
        }, t2.next = function(e3) {
          return i2 ? (i2 = false, e3) : n2("next", e3);
        }, "function" == typeof e2.throw && (t2.throw = function(e3) {
          if (i2) throw i2 = false, e3;
          return n2("throw", e3);
        }), "function" == typeof e2.return && (t2.return = function(e3) {
          return i2 ? (i2 = false, e3) : n2("return", e3);
        }), t2;
      }
      Ub.prototype["function" == typeof QI && Lb || "@@asyncIterator"] = function() {
        return this;
      }, Ub.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, Ub.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, Ub.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var Fb = i(Pb);
      function Bb(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = Fb, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2])) return t2.call(e2);
          if (n2 && null != (t2 = e2[n2])) return new jb(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function jb(e2) {
        function t2(e3) {
          if (Object(e3) !== e3) return rp.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return rp.resolve(e3.value).then((function(e4) {
            return { value: e4, done: t3 };
          }));
        }
        return jb = function(e3) {
          this.s = e3, this.n = e3.next;
        }, jb.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new jb(e2);
      }
      const Gb = function* (e2, t2) {
        let i2 = e2.byteLength;
        if (!t2 || i2 < t2) return void (yield e2);
        let n2, r2 = 0;
        for (; r2 < i2; ) n2 = r2 + t2, yield e2.slice(r2, n2), r2 = n2;
      }, Wb = (function() {
        var e2 = Mb((function* (e3, t2) {
          var i2, n2 = false, r2 = false;
          try {
            for (var o2, s2 = Bb(Hb(e3)); n2 = !(o2 = yield Vb(s2.next())).done; n2 = false) {
              const e4 = o2.value;
              yield* xb(Bb(Gb(e4, t2)));
            }
          } catch (e4) {
            r2 = true, i2 = e4;
          } finally {
            try {
              n2 && null != s2.return && (yield Vb(s2.return()));
            } finally {
              if (r2) throw i2;
            }
          }
        }));
        return function(t2, i2) {
          return e2.apply(this, arguments);
        };
      })(), Hb = (function() {
        var e2 = Mb((function* (e3) {
          if (e3[Fb]) return void (yield* xb(Bb(e3)));
          const t2 = e3.getReader();
          try {
            for (; ; ) {
              const { done: e4, value: i2 } = yield Vb(t2.read());
              if (e4) break;
              yield i2;
            }
          } finally {
            yield Vb(t2.cancel());
          }
        }));
        return function(t2) {
          return e2.apply(this, arguments);
        };
      })(), Kb = (e2, t2, i2, n2) => {
        const r2 = Wb(e2, t2);
        let o2, s2 = 0, a2 = (e3) => {
          o2 || (o2 = true, n2 && n2(e3));
        };
        return new ReadableStream({ async pull(e3) {
          try {
            const { done: t3, value: n3 } = await r2.next();
            if (t3) return a2(), void e3.close();
            let o3 = n3.byteLength;
            if (i2) {
              let e4 = s2 += o3;
              i2(e4);
            }
            e3.enqueue(new Uint8Array(n3));
          } catch (e4) {
            throw a2(e4), e4;
          }
        }, cancel: (e3) => (a2(e3), r2.return()) }, { highWaterMark: 2 });
      };
      function Yb(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function zb(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Yb(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Yb(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const { isFunction: qb } = ZR, Xb = ((e2) => {
        let { Request: t2, Response: i2 } = e2;
        return { Request: t2, Response: i2 };
      })(ZR.global), { ReadableStream: Jb, TextEncoder: Qb } = ZR.global, Zb = function(e2) {
        try {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
          return !!e2(...i2);
        } catch (e3) {
          return false;
        }
      }, $b = (e2) => {
        e2 = ZR.merge.call({ skipUndefined: true }, Xb, e2);
        const { fetch: t2, Request: i2, Response: n2 } = e2, r2 = t2 ? qb(t2) : "function" == typeof fetch, o2 = qb(i2), s2 = qb(n2);
        if (!r2) return false;
        const a2 = r2 && qb(Jb), c2 = r2 && ("function" == typeof Qb ? (d2 = new Qb(), (e3) => d2.encode(e3)) : async (e3) => new Uint8Array(await new i2(e3).arrayBuffer()));
        var d2;
        const l2 = o2 && a2 && Zb((() => {
          let e3 = false;
          const t3 = new i2(hA.origin, { body: new Jb(), method: "POST", get duplex() {
            return e3 = true, "half";
          } }).headers.has("Content-Type");
          return e3 && !t3;
        })), u2 = s2 && a2 && Zb((() => ZR.isReadableStream(new n2("").body))), h2 = { stream: u2 && ((e3) => e3.body) };
        r2 && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(((e3) => {
          !h2[e3] && (h2[e3] = (t3, i3) => {
            let n3 = t3 && t3[e3];
            if (n3) return n3.call(t3);
            throw new $R("Response type '".concat(e3, "' is not supported"), $R.ERR_NOT_SUPPORT, i3);
          });
        }));
        const p2 = async (e3, t3) => {
          const n3 = ZR.toFiniteNumber(e3.getContentLength());
          return null == n3 ? (async (e4) => {
            if (null == e4) return 0;
            if (ZR.isBlob(e4)) return e4.size;
            if (ZR.isSpecCompliantForm(e4)) {
              const t4 = new i2(hA.origin, { method: "POST", body: e4 });
              return (await t4.arrayBuffer()).byteLength;
            }
            return ZR.isArrayBufferView(e4) || ZR.isArrayBuffer(e4) ? e4.byteLength : (ZR.isURLSearchParams(e4) && (e4 += ""), ZR.isString(e4) ? (await c2(e4)).byteLength : void 0);
          })(t3) : n3;
        };
        return async (e3) => {
          let { url: r3, method: s3, data: a3, signal: c3, cancelToken: d3, timeout: _2, onDownloadProgress: E2, onUploadProgress: m2, responseType: f2, headers: S2, withCredentials: g2 = "same-origin", fetchOptions: T2 } = wb(e3), R2 = t2 || fetch;
          f2 = f2 ? (f2 + "").toLowerCase() : "text";
          let C2 = Nb([c3, d3 && d3.toAbortSignal()], _2), v2 = null;
          const y2 = C2 && C2.unsubscribe && (() => {
            C2.unsubscribe();
          });
          let I2;
          try {
            if (m2 && l2 && "get" !== s3 && "head" !== s3 && 0 !== (I2 = await p2(S2, a3))) {
              let e4, t4 = new i2(r3, { method: "POST", body: a3, duplex: "half" });
              if (ZR.isFormData(a3) && (e4 = t4.headers.get("content-type")) && S2.setContentType(e4), t4.body) {
                const [e5, i3] = gb(I2, Sb(Tb(m2)));
                a3 = Kb(t4.body, 65536, e5, i3);
              }
            }
            ZR.isString(g2) || (g2 = g2 ? "include" : "omit");
            const t3 = o2 && "credentials" in i2.prototype, c4 = zb(zb({}, T2), {}, { signal: C2, method: s3.toUpperCase(), headers: S2.normalize().toJSON(), body: a3, duplex: "half", credentials: t3 ? g2 : void 0 });
            v2 = o2 && new i2(r3, c4);
            let d4 = await (o2 ? R2(v2, T2) : R2(r3, c4));
            const _3 = u2 && ("stream" === f2 || "response" === f2);
            if (u2 && (E2 || _3 && y2)) {
              const e4 = {};
              ["status", "statusText", "headers"].forEach(((t5) => {
                e4[t5] = d4[t5];
              }));
              const t4 = ZR.toFiniteNumber(d4.headers.get("content-length")), [i3, r4] = E2 && gb(t4, Sb(Tb(E2), true)) || [];
              d4 = new n2(Kb(d4.body, 65536, i3, (() => {
                r4 && r4(), y2 && y2();
              })), e4);
            }
            f2 = f2 || "text";
            let A2 = await h2[ZR.findKey(h2, f2) || "text"](d4, e3);
            return !_3 && y2 && y2(), await new rp(((t4, i3) => {
              fb(t4, i3, { data: A2, headers: pb.from(d4.headers), status: d4.status, statusText: d4.statusText, config: e3, request: v2 });
            }));
          } catch (t3) {
            if (y2 && y2(), t3 && "TypeError" === t3.name && /Load failed|fetch/i.test(t3.message)) throw Object.assign(new $R("Network Error", $R.ERR_NETWORK, e3, v2), { cause: t3.cause || t3 });
            throw $R.from(t3, t3 && t3.code, e3, v2);
          }
        };
      }, ew = /* @__PURE__ */ new Map(), tw = (e2) => {
        let t2 = e2 && e2.env || {};
        const { fetch: i2, Request: n2, Response: r2 } = t2, o2 = [n2, r2, i2];
        let s2, a2, c2 = o2.length, d2 = ew;
        for (; c2--; ) s2 = o2[c2], a2 = d2.get(s2), void 0 === a2 && d2.set(s2, a2 = c2 ? /* @__PURE__ */ new Map() : $b(t2)), d2 = a2;
        return a2;
      };
      tw();
      const iw = { http: null, xhr: Ob, fetch: { get: tw } };
      ZR.forEach(iw, ((e2, t2) => {
        if (e2) {
          try {
            Object.defineProperty(e2, "name", { value: t2 });
          } catch (e3) {
          }
          Object.defineProperty(e2, "adapterName", { value: t2 });
        }
      }));
      const nw = (e2) => "- ".concat(e2), rw = (e2) => ZR.isFunction(e2) || null === e2 || false === e2;
      var ow = { getAdapter: function(e2, t2) {
        e2 = ZR.isArray(e2) ? e2 : [e2];
        const { length: i2 } = e2;
        let n2, r2;
        const o2 = {};
        for (let s2 = 0; s2 < i2; s2++) {
          let i3;
          if (n2 = e2[s2], r2 = n2, !rw(n2) && (r2 = iw[(i3 = String(n2)).toLowerCase()], void 0 === r2)) throw new $R("Unknown adapter '".concat(i3, "'"));
          if (r2 && (ZR.isFunction(r2) || (r2 = r2.get(t2)))) break;
          o2[i3 || "#" + s2] = r2;
        }
        if (!r2) {
          const e3 = Object.entries(o2).map(((e4) => {
            let [t3, i3] = e4;
            return "adapter ".concat(t3, " ") + (false === i3 ? "is not supported by the environment" : "is not available in the build");
          }));
          throw new $R("There is no suitable adapter to dispatch the request " + (i2 ? e3.length > 1 ? "since :\n" + e3.map(nw).join("\n") : " " + nw(e3[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
        }
        return r2;
      }, adapters: iw };
      function sw(e2) {
        if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted) throw new mb(null, e2);
      }
      function aw(e2) {
        sw(e2), e2.headers = pb.from(e2.headers), e2.data = _b.call(e2, e2.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e2.method) && e2.headers.setContentType("application/x-www-form-urlencoded", false);
        return ow.getAdapter(e2.adapter || sb.adapter, e2)(e2).then((function(t2) {
          return sw(e2), t2.data = _b.call(e2, e2.transformResponse, t2), t2.headers = pb.from(t2.headers), t2;
        }), (function(t2) {
          return Eb(t2) || (sw(e2), t2 && t2.response && (t2.response.data = _b.call(e2, e2.transformResponse, t2.response), t2.response.headers = pb.from(t2.response.headers))), rp.reject(t2);
        }));
      }
      const cw = "1.13.2", dw = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(((e2, t2) => {
        dw[e2] = function(i2) {
          return typeof i2 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
        };
      }));
      const lw = {};
      dw.transitional = function(e2, t2, i2) {
        function n2(e3, t3) {
          return "[Axios v" + cw + "] Transitional option '" + e3 + "'" + t3 + (i2 ? ". " + i2 : "");
        }
        return (i3, r2, o2) => {
          if (false === e2) throw new $R(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), $R.ERR_DEPRECATED);
          return t2 && !lw[r2] && (lw[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i3, r2, o2);
        };
      }, dw.spelling = function(e2) {
        return (t2, i2) => (console.warn("".concat(i2, " is likely a misspelling of ").concat(e2)), true);
      };
      var uw = { assertOptions: function(e2, t2, i2) {
        if ("object" != typeof e2) throw new $R("options must be an object", $R.ERR_BAD_OPTION_VALUE);
        const n2 = Object.keys(e2);
        let r2 = n2.length;
        for (; r2-- > 0; ) {
          const o2 = n2[r2], s2 = t2[o2];
          if (s2) {
            const t3 = e2[o2], i3 = void 0 === t3 || s2(t3, o2, e2);
            if (true !== i3) throw new $R("option " + o2 + " must be " + i3, $R.ERR_BAD_OPTION_VALUE);
          } else if (true !== i2) throw new $R("Unknown option " + o2, $R.ERR_BAD_OPTION);
        }
      }, validators: dw };
      const hw = uw.validators;
      let pw = class {
        constructor(e2) {
          this.defaults = e2 || {}, this.interceptors = { request: new hC(), response: new hC() };
        }
        async request(e2, t2) {
          try {
            return await this._request(e2, t2);
          } catch (e3) {
            if (e3 instanceof Error) {
              let t3 = {};
              Error.captureStackTrace ? Error.captureStackTrace(t3) : t3 = new Error();
              const i2 = t3.stack ? t3.stack.replace(/^.+\n/, "") : "";
              try {
                e3.stack ? i2 && !String(e3.stack).endsWith(i2.replace(/^.+\n.+\n/, "")) && (e3.stack += "\n" + i2) : e3.stack = i2;
              } catch (e4) {
              }
            }
            throw e3;
          }
        }
        _request(e2, t2) {
          "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, t2 = bb(this.defaults, t2);
          const { transitional: i2, paramsSerializer: n2, headers: r2 } = t2;
          void 0 !== i2 && uw.assertOptions(i2, { silentJSONParsing: hw.transitional(hw.boolean), forcedJSONParsing: hw.transitional(hw.boolean), clarifyTimeoutError: hw.transitional(hw.boolean) }, false), null != n2 && (ZR.isFunction(n2) ? t2.paramsSerializer = { serialize: n2 } : uw.assertOptions(n2, { encode: hw.function, serialize: hw.function }, true)), void 0 !== t2.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t2.allowAbsoluteUrls = true), uw.assertOptions(t2, { baseUrl: hw.spelling("baseURL"), withXsrfToken: hw.spelling("withXSRFToken") }, true), t2.method = (t2.method || this.defaults.method || "get").toLowerCase();
          let o2 = r2 && ZR.merge(r2.common, r2[t2.method]);
          r2 && ZR.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ((e3) => {
            delete r2[e3];
          })), t2.headers = pb.concat(o2, r2);
          const s2 = [];
          let a2 = true;
          this.interceptors.request.forEach((function(e3) {
            "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (a2 = a2 && e3.synchronous, s2.unshift(e3.fulfilled, e3.rejected));
          }));
          const c2 = [];
          let d2;
          this.interceptors.response.forEach((function(e3) {
            c2.push(e3.fulfilled, e3.rejected);
          }));
          let l2, u2 = 0;
          if (!a2) {
            const e3 = [aw.bind(this), void 0];
            for (e3.unshift(...s2), e3.push(...c2), l2 = e3.length, d2 = rp.resolve(t2); u2 < l2; ) d2 = d2.then(e3[u2++], e3[u2++]);
            return d2;
          }
          l2 = s2.length;
          let h2 = t2;
          for (; u2 < l2; ) {
            const e3 = s2[u2++], t3 = s2[u2++];
            try {
              h2 = e3(h2);
            } catch (e4) {
              t3.call(this, e4);
              break;
            }
          }
          try {
            d2 = aw.call(this, h2);
          } catch (e3) {
            return rp.reject(e3);
          }
          for (u2 = 0, l2 = c2.length; u2 < l2; ) d2 = d2.then(c2[u2++], c2[u2++]);
          return d2;
        }
        getUri(e2) {
          return uC(vb((e2 = bb(this.defaults, e2)).baseURL, e2.url, e2.allowAbsoluteUrls), e2.params, e2.paramsSerializer);
        }
      };
      ZR.forEach(["delete", "get", "head", "options"], (function(e2) {
        pw.prototype[e2] = function(t2, i2) {
          return this.request(bb(i2 || {}, { method: e2, url: t2, data: (i2 || {}).data }));
        };
      })), ZR.forEach(["post", "put", "patch"], (function(e2) {
        function t2(t3) {
          return function(i2, n2, r2) {
            return this.request(bb(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
          };
        }
        pw.prototype[e2] = t2(), pw.prototype[e2 + "Form"] = t2(true);
      }));
      var _w = pw;
      class Ew {
        constructor(e2) {
          if ("function" != typeof e2) throw new TypeError("executor must be a function.");
          let t2;
          this.promise = new rp((function(e3) {
            t2 = e3;
          }));
          const i2 = this;
          this.promise.then(((e3) => {
            if (!i2._listeners) return;
            let t3 = i2._listeners.length;
            for (; t3-- > 0; ) i2._listeners[t3](e3);
            i2._listeners = null;
          })), this.promise.then = (e3) => {
            let t3;
            const n2 = new rp(((e4) => {
              i2.subscribe(e4), t3 = e4;
            })).then(e3);
            return n2.cancel = function() {
              i2.unsubscribe(t3);
            }, n2;
          }, e2((function(e3, n2, r2) {
            i2.reason || (i2.reason = new mb(e3, n2, r2), t2(i2.reason));
          }));
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(e2) {
          this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
        }
        unsubscribe(e2) {
          if (!this._listeners) return;
          const t2 = this._listeners.indexOf(e2);
          -1 !== t2 && this._listeners.splice(t2, 1);
        }
        toAbortSignal() {
          const e2 = new AbortController(), t2 = (t3) => {
            e2.abort(t3);
          };
          return this.subscribe(t2), e2.signal.unsubscribe = () => this.unsubscribe(t2), e2.signal;
        }
        static source() {
          let e2;
          const t2 = new Ew((function(t3) {
            e2 = t3;
          }));
          return { token: t2, cancel: e2 };
        }
      }
      var mw = Ew;
      const fw = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 };
      Object.entries(fw).forEach(((e2) => {
        let [t2, i2] = e2;
        fw[i2] = t2;
      }));
      var Sw = fw;
      const gw = (function e2(t2) {
        const i2 = new _w(t2), n2 = cR(_w.prototype.request, i2);
        return ZR.extend(n2, _w.prototype, i2, { allOwnKeys: true }), ZR.extend(n2, i2, null, { allOwnKeys: true }), n2.create = function(i3) {
          return e2(bb(t2, i3));
        }, n2;
      })(sb);
      gw.Axios = _w, gw.CanceledError = mb, gw.CancelToken = mw, gw.isCancel = Eb, gw.VERSION = cw, gw.toFormData = sC, gw.AxiosError = $R, gw.Cancel = gw.CanceledError, gw.all = function(e2) {
        return rp.all(e2);
      }, gw.spread = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      }, gw.isAxiosError = function(e2) {
        return ZR.isObject(e2) && true === e2.isAxiosError;
      }, gw.mergeConfig = bb, gw.AxiosHeaders = pb, gw.formToJSON = (e2) => rb(ZR.isHTMLForm(e2) ? new FormData(e2) : e2), gw.getAdapter = ow.getAdapter, gw.HttpStatusCode = Sw, gw.default = gw;
      var Tw = gw;
      const Rw = () => {
      };
      function Cw() {
        const e2 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: Rw };
        return e2.promise = new rp(((t2, i2) => {
          e2.resolve = (i3) => {
            e2.isFinished || (e2.isResolved = true, e2.isFinished = true, t2(i3), e2.value = i3);
          }, e2.reject = (t3) => {
            e2.isFinished || (e2.isRejected = true, e2.isFinished = true, i2(t3));
          };
        })), e2;
      }
      const vw = /* @__PURE__ */ new Map(), yw = /* @__PURE__ */ new Map(), Iw = /* @__PURE__ */ new Map();
      let Aw = (function(e2) {
        return e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.CHROMIUM_OS = "Chromium OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot", e2;
      })({}), bw = (function(e2) {
        return e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger", e2;
      })({});
      const ww = new FT();
      let Ow = ww.getResult(), Nw = null;
      function Dw(e2) {
        if (!Nw) {
          e2 && ww.setUA(e2), Ow = ww.getResult();
          const t2 = (function(e3) {
            if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name) return bw.CHROME;
            switch (e3.browser.name) {
              case "Chrome Headless":
              case "Chrome":
              case "Chromium":
                return bw.CHROME;
              case "Safari":
              case "Mobile Safari":
                return bw.SAFARI;
              case "Edge":
                return bw.EDGE;
              case "Firefox":
                return bw.FIREFOX;
              case "QQ":
              case "QQBrowser":
                return bw.QQ;
              case "Opera":
                return bw.OPERA;
              case "WeChat":
                return bw.WECHAT;
              default:
                return e3.browser.name || "";
            }
          })(Ow), i2 = Pw(Ow), n2 = (function(e3) {
            return "Windows" === e3.os.name ? e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name : e3.os.name || "";
          })(Ow), r2 = Ow.os.version, o2 = Pw(Ow, false), s2 = Ow.device.type;
          if (!(t2 && i2 && n2 && r2)) return { name: t2, version: i2, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
          Nw = { name: t2, version: i2, os: n2, osVersion: r2, browserVersion: o2, deviceType: s2 };
        }
        return Nw;
      }
      function Pw(e2) {
        let t2, i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return t2 = "Blink" === e2.engine.name ? e2.engine.version || "" : e2.browser.version || "", i2 ? t2.split(".")[0] : t2;
      }
      function Lw() {
        return Dw().os;
      }
      function kw() {
        const e2 = Dw();
        return "".concat(e2.os, " ").concat(e2.osVersion);
      }
      function Mw() {
        const e2 = Dw();
        return !!("WebKit" === Ow.engine.name && e2.os === Aw.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== bw.SAFARI || jw() && e2.name !== bw.SAFARI);
      }
      function Uw() {
        return Dw().name === bw.CHROME;
      }
      function Vw() {
        return Dw().name === bw.SAFARI;
      }
      function xw() {
        const e2 = Dw();
        if (e2.name !== bw.SAFARI || !e2.browserVersion) return false;
        const t2 = e2.browserVersion.split(".");
        return Number(t2[0]) > 15 || 15 === Number(t2[0]) && Number(t2[1]) >= 4;
      }
      function Fw() {
        return Dw().name === bw.EDGE;
      }
      function Bw() {
        return Dw().name === bw.FIREFOX;
      }
      function jw() {
        return Dw().os === Aw.IOS;
      }
      function Gw(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Ww(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.CHROME || !t2.osVersion) && Number(t2.version) < e2;
      }
      function Hw(e2, t2, i2) {
        const n2 = Dw();
        return !(n2.name !== e2 || !n2.osVersion) && (i2 ? Number(n2.version) >= t2 && Number(n2.version) <= i2 : Number(n2.version) === t2);
      }
      function Kw(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Yw(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.FIREFOX || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function zw(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.SAFARI || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function qw(e2, t2, i2) {
        const n2 = Dw();
        if (n2.os !== Aw.IOS || !n2.osVersion) return false;
        const r2 = n2.osVersion.split(".");
        return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) > t2 || Number(r2[0]) > e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) >= t2 || Number(r2[0]) > e2 : Number(r2[0]) >= e2;
      }
      function Xw(e2, t2, i2) {
        const n2 = Dw();
        if (n2.os !== Aw.IOS || !n2.osVersion) return false;
        const r2 = n2.osVersion.split(".");
        return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function Jw(e2, t2, i2) {
        const n2 = Dw();
        if (n2.name !== bw.SAFARI || !n2.osVersion || !n2.browserVersion) return false;
        const r2 = n2.browserVersion.split(".");
        return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function Qw(e2) {
        const t2 = Dw();
        return !(t2.name !== bw.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
      }
      function Zw() {
        const e2 = Dw();
        if (e2.os !== Aw.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
      }
      function $w() {
        const e2 = Dw();
        if (e2.os !== Aw.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]);
      }
      function eO() {
        const e2 = Dw();
        if (e2.os !== Aw.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 16 === Number(t2[0]);
      }
      function tO() {
        const e2 = Dw();
        if (e2.os !== Aw.IOS || !e2.osVersion) return false;
        const t2 = e2.osVersion.split(".");
        return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
      }
      function iO() {
        return Vw() && navigator.maxTouchPoints > 0;
      }
      function nO() {
        return Dw().name === bw.WECHAT;
      }
      function rO() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function oO() {
        const e2 = Lw();
        return (function() {
          const { deviceType: e3 } = Dw();
          return "mobile" === e3 || "tablet" === e3;
        })() || e2 === Aw.ANDROID || e2 === Aw.IOS || e2 === Aw.HARMONY_OS;
      }
      function sO() {
        const e2 = Dw();
        return e2.name !== bw.EDGE && e2.name !== bw.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function aO() {
        return Lw() === Aw.ANDROID;
      }
      function cO() {
        const e2 = Dw();
        return aO() && (e2.name === bw.CHROME || e2.name === bw.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      function dO(e2, t2, i2) {
        return (t2 = (function(e3) {
          var t3 = (function(e4, t4) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n2 = i3.call(e4, "string");
              if ("object" != typeof n2) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        })(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      function lO(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function uO(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? lO(Object(i2), true).forEach((function(t3) {
            dO(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : lO(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let hO = (function(e2) {
        return e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e2.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", e2.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", e2;
      })({}), pO = class extends Error {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
          super(t2), dO(this, "code", void 0), dO(this, "message", void 0), dO(this, "data", void 0), dO(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i2;
        }
        toString() {
          return this.data ? "".concat(this.message, "\ndata: ").concat(JSON.stringify(this.data)) : this.message;
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t2 = arguments.length > 1 ? arguments[1] : void 0;
          return "error" === e2 && (t2 || console).error(this.toString()), "warning" === e2 && (t2 || console).warn(this.toString()), this;
        }
        throw(e2) {
          throw this.print("error", e2), this;
        }
      };
      function _O(e2, t2) {
        if ("boolean" != typeof e2) throw new pO(hO.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
      }
      function EO(e2, t2, i2) {
        if (!Ln(i2).call(i2, e2)) throw new pO(hO.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i2)));
      }
      function mO(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
        if (e2 < i2 || e2 > n2 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !(function(e3) {
          return "number" == typeof e3 && e3 % 1 == 0;
        })(e2)) throw new pO(hO.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i2, ", ").concat(n2, "]. integer only"));
      }
      function fO(e2, t2) {
        if ("number" != typeof e2) {
          if (!(e2.min || e2.max || e2.ideal || e2.exact)) throw new pO(hO.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
          void 0 !== e2.min && mO(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && mO(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && mO(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && mO(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
        } else mO(e2, t2, 1, 1 / 0);
      }
      function SO(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e2) throw new pO(hO.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
        if (!RO(e2, i2, n2, r2)) throw new pO(hO.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i2, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
      }
      function gO(e2, t2) {
        if (!Array.isArray(e2)) throw new pO(hO.INVALID_PARAMS, "".concat(t2, " should be an array"));
      }
      function TO(e2) {
        return null == e2;
      }
      function RO(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e2 && e2.length <= i2 && e2.length >= t2 && (!n2 || (function(e3) {
          if ("string" != typeof e3) return false;
          for (let t3 = 0; t3 < e3.length; t3 += 1) {
            const i3 = e3.charCodeAt(t3);
            if (i3 < 0 || i3 > 255) return false;
          }
          return true;
        })(e2));
      }
      function CO(e2, t2, i2) {
        if ("getBigUint64" in DataView.prototype) return e2.getBigUint64(t2, i2);
        const n2 = e2.getUint32(t2, i2), r2 = e2.getUint32(t2 + 4, i2), o2 = Number(!!i2), s2 = Number(!i2);
        return BigInt(n2 * s2 + r2 * o2) << BigInt(32) | BigInt(n2 * o2 + r2 * s2);
      }
      function vO(e2, t2, i2, n2) {
        if ("setBigUint64" in DataView.prototype) return e2.setBigUint64(t2, i2, n2);
        const r2 = Number(i2 >> BigInt(32)), o2 = Number(i2 & BigInt(4294967295));
        n2 ? (e2.setUint32(t2 + 4, r2, n2), e2.setUint32(t2, o2, n2)) : (e2.setUint32(t2, r2, n2), e2.setUint32(t2 + 4, o2, n2));
      }
      var yO = (function(e2) {
        return e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE", e2;
      })(yO || {}), IO = (function(e2) {
        return e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT", e2;
      })(IO || {});
      const AO = new class {
        constructor() {
          dO(this, "_clientSize", null), dO(this, "getClientWidth", (() => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth)), dO(this, "getClientHeight", (() => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight)), dO(this, "getStyle", ((e2) => window.getComputedStyle(e2, null))), dO(this, "checkCssVisibleProperty", ((e2) => {
            var t2;
            let i2 = true;
            const n2 = this.getStyle(e2), { display: r2, visibility: o2, opacity: s2, filter: a2 } = n2;
            return ("none" === r2 || Ln(t2 = ["hidden", "collapse"]).call(t2, o2) || Number(s2) < 0.1) && (i2 = false), !!i2 && (a2 && a2.split(" ").filter(((e3) => {
              var t3;
              const i3 = e3.split("(")[0];
              return Ln(t3 = ["brightness", "blur", "opacity"]).call(t3, i3);
            })).map(((e3) => {
              const [t3, i3] = e3.split(/\(|\)/);
              return [t3, Number(i3.match(/^[0-9\.]+/))];
            })).forEach(((e3) => {
              const [t3, n3] = e3;
              switch (t3) {
                case "brightness":
                  (n3 < 0.1 || n3 > 3) && (i2 = false);
                  break;
                case "blur":
                  n3 > 3 && (i2 = false);
                  break;
                case "opacity":
                  n3 < 0.1 && (i2 = false);
              }
            })), i2);
          })), dO(this, "checkPropertyUpToAllParentNodes", ((e2, t2) => {
            let i2 = true, n2 = true;
            const r2 = (e3) => t2(e3);
            let o2 = e2;
            for (; o2 && n2; ) r2(o2) || (i2 = false, n2 = false), o2 = o2.parentElement, o2 || (n2 = false);
            return i2;
          })), dO(this, "checkActualCssVisibleIncludeInherit", ((e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty))), dO(this, "getSizeAboutClient", ((e2) => {
            const { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
            return { width: t2, height: i2, left: n2, right: r2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
          })), dO(this, "checkActualSize", (() => {
            const { width: e2, height: t2, clientMin: i2 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t2, i2);
          })), dO(this, "elementFromPoint", ((e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null)), dO(this, "checkCoverForAPoint", ((e2, t2, i2) => {
            const n2 = this.elementFromPoint(e2, t2);
            return null !== n2 && n2 !== i2;
          })), dO(this, "getPointPositionList", (() => {
            const { width: e2, height: t2, left: i2, top: n2 } = this._clientSize, r2 = e2 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++) for (let t3 = 0; t3 < 5; t3++) {
              const c2 = (i2 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
              s2.push({ x: c2, y: d2 });
            }
            return [...s2];
          })), dO(this, "checkElementCover", ((e2) => this.getPointPositionList().map(((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2))).filter(((e3) => !!e3)).length > 6)), dO(this, "checkSizeIsVisible", ((e2, t2, i2) => (e2 > 50 || i2 / e2 <= 10) && (t2 > 50 || i2 / t2 <= 10))), dO(this, "checkSizeOfPartInClient", (() => {
            const { left: e2, right: t2, top: i2, bottom: n2, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
            let a2, c2, d2, l2;
            if (e2 < 0) a2 = 0;
            else {
              if (!(e2 < o2)) return false;
              a2 = e2;
            }
            if (t2 < 0) return false;
            if (c2 = t2 < o2 ? t2 : o2, i2 < 0) d2 = 0;
            else {
              if (!(i2 < r2)) return false;
              d2 = i2;
            }
            if (n2 < 0) return false;
            l2 = n2 < r2 ? n2 : r2;
            const u2 = c2 - a2, h2 = l2 - d2;
            return this.checkSizeIsVisible(u2, h2, s2);
          })), dO(this, "returnHiddenResult", ((e2) => (this._clientSize = null, { visible: false, reason: e2 }))), dO(this, "checkOneElementVisible", ((e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2)) return this.returnHiddenResult(yO.COVERED);
                  {
                    const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                    return e3 && !t2 ? this.returnHiddenResult(yO.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(yO.SIZE);
                  }
                }
                return this.returnHiddenResult(yO.STYLE);
              }
              return this.returnHiddenResult(IO.UNMOUNTED);
            }
            return this.returnHiddenResult(IO.INVALID_HTML_ELEMENT);
          })), dO(this, "checkElementIsMountedOnDom", ((e2) => this.checkPropertyUpToAllParentNodes(e2, ((e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement))));
        }
      }();
      function bO(e2) {
        return new TextEncoder().encode(e2);
      }
      const wO = function(e2, t2) {
        const i2 = new Uint8Array(e2.byteLength + t2.byteLength);
        return i2.set(new Uint8Array(e2), 0), i2.set(new Uint8Array(t2), e2.byteLength), i2;
      };
      const OO = async (e2) => (function(e3, t2) {
        let i2 = "";
        return new Uint8Array(e3).forEach(((e4) => {
          i2 += e4.toString(t2).padStart(2, "0");
        })), i2;
      })(await crypto.subtle.digest("SHA-256", bO(e2)), 16);
      let NO = class {
        constructor() {
          dO(this, "_events", {}), dO(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map(((e3) => e3.listener)) : [];
        }
        on(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: false });
        }
        once(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: true });
        }
        off(e2, t2) {
          if (!this._events[e2]) return;
          const i2 = this._events[e2], n2 = this._indexOfListener(i2, t2);
          -1 !== n2 && i2.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t2 = this._events[e2].map(((e3) => e3));
          for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n2[r2 - 1] = arguments[r2];
          for (let i3 = 0; i3 < t2.length; i3 += 1) {
            const r3 = t2[i3];
            r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
          }
        }
        safeEmit(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
          [...this._events[e2] || []].forEach(((t3) => {
            t3.once && this.off(e2, t3.listener);
            try {
              t3.listener.apply(this, i2);
            } catch (t4) {
              console.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
            }
          }));
        }
        _indexOfListener(e2, t2) {
          let i2 = e2.length;
          for (; i2--; ) if (e2[i2].listener === t2) return i2;
          return -1;
        }
      };
      let DO = null;
      function PO() {
        if (DO) return DO;
        if (window.electron) return DO = window.electron;
        if (!window.require) return null;
        try {
          return DO = window.require("electron"), DO;
        } catch (e2) {
          return null;
        }
      }
      let LO = (function(e2) {
        return e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.PRELOAD = "PRELOAD", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload", e2.REPUB_AFTER_PC_CONNECTED = "repubAfterPCConnected", e2.PRELOAD_MEDIA_FAILED = "preloadMediaFailed", e2.MISMATCH_DTLS_PARAMETERS = "mismatchDtlsParameters", e2.VOS_FALLBACK_CN = "vosFallbackCN", e2.DATACHANNEL_FAILBACK = "datachannelFailback", e2;
      })({}), kO = (function(e2) {
        return e2.TRACER = "tracer", e2;
      })({});
      function MO(e2) {
        return mO(e2.timeout, "config.timeout", 0, 1e5), mO(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), mO(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), mO(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      let UO = (function(e2) {
        return e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY", e2;
      })({}), VO = (function(e2) {
        return e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.FALLBACK = "FALLBACK", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2.FALLBACK_TO_HLS = "FALLBACK_TO_HLS", e2.UID_CONFLICT = "UID_CONFLICT", e2;
      })({});
      function xO(e2) {
        if (!Array.isArray(e2) || e2.length < 1) return false;
        try {
          e2.forEach(((e3) => {
            if (!e3.urls) throw Error();
          }));
        } catch (e3) {
          return false;
        }
        return true;
      }
      function FO(e2) {
        return SO(e2.turnServerURL, "turnServerURL"), SO(e2.username, "username"), SO(e2.password, "password"), e2.udpport && mO(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && _O(e2.forceturn, "forceturn"), e2.security && _O(e2.security, "security"), e2.tcpport && mO(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      let BO = (function(e2) {
        return e2[e2.AUTO_SIMULCAST_STREAM = -1] = "AUTO_SIMULCAST_STREAM", e2[e2.DISABLE_SIMULCAST_STREM = 0] = "DISABLE_SIMULCAST_STREM", e2[e2.ENABLE_SIMULCAST_STREAM = 1] = "ENABLE_SIMULCAST_STREAM", e2;
      })({});
      function jO(e2) {
        return void 0 !== e2.level && EO(e2.level, "level", [1, 2, 3]), void 0 !== e2.delay && mO(e2.delay, "delay", 0, 3e3, true), true;
      }
      let GO = (function(e2) {
        return e2.PEERCONNECTION_STATE_CHANGE = "peerconnection-state-change", e2.AUDIO_METADATA = "audio-metadata", e2.AUDIO_PTS = "audio-pts", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change", e2.FALLBACK_TO_HLS = "fallback-to-hls", e2.FIRST_VIDEO_BUFFER_READY = "first-video-buffer-ready", e2.FIRST_VIDEO_PRE_RENDER = "first-video-pre-render", e2.AV1_DECODABLE_RESULT = "av1-decodable-result", e2;
      })({}), WO = (function(e2) {
        return e2.CONFIG = "config", e2.VOSERROR = "vos_error", e2.AP_ERROR = "ap_error", e2;
      })({}), HO = (function(e2) {
        return e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK", e2.REGIONAL_DISTRIBUTION = "REGIONAL_DISTRIBUTION", e2;
      })({}), KO = (function(e2) {
        return e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      })({}), YO = (function(e2) {
        return e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      })({});
      function zO(e2, t2) {
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return 0 === e2.getListeners(t2).length ? rp.reject(new pO(hO.UNEXPECTED_ERROR, "can not emit promise")) : new rp(((i3, r3) => {
          e2.emit(t2, ...n2, i3, r3);
        }));
      }
      function qO(e2, t2) {
        if (0 === e2.getListeners(t2).length) return rp.resolve();
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return zO(e2, t2, ...n2);
      }
      function XO(e2, t2) {
        if (0 === e2.getListeners(t2).length) return null;
        for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n2[r2 - 2] = arguments[r2];
        return JO(e2, t2, ...n2);
      }
      function JO(e2, t2) {
        let i2 = null, n2 = null;
        for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++) o2[s2 - 2] = arguments[s2];
        if (e2.emit(t2, ...o2, ((e3) => {
          i2 = e3;
        }), ((e3) => {
          n2 = e3;
        })), null !== n2) throw n2;
        if (null === i2) throw new pO(hO.UNEXPECTED_ERROR, "handler is not sync");
        return i2;
      }
      const QO = new class extends NO {
        set networkState(e2) {
          this.emit(YO.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === KO.ONLINE ? this.emit(YO.ONLINE) : e2 === KO.OFFLINE && (this.onlineWaiter = new rp(((e3) => {
            this.once(YO.ONLINE, (() => {
              this.onlineWaiter = void 0, e3(KO.ONLINE);
            }));
          })), this.emit(YO.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        get isOnline() {
          return this._networkState === KO.ONLINE;
        }
        constructor() {
          super(), dO(this, "_moduleName", "network-indicator"), dO(this, "_networkState", KO.ONLINE), dO(this, "onlineWaiter", void 0), window.addEventListener("online", (() => {
            this.networkState = KO.ONLINE;
          })), window.addEventListener("offline", (() => {
            this.networkState = KO.OFFLINE;
          }));
        }
      }(), ZO = [];
      for (let e2 = 0; e2 < 256; ++e2) ZO.push((e2 + 256).toString(16).slice(1));
      const $O = "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      let eN;
      const tN = new Uint8Array(16);
      function iN() {
        return $O ? $O() : (function(e3, t3, i2) {
          var n2, r2, o2, s2;
          const a2 = null !== (n2 = null !== (r2 = (e3 = e3 || {}).random) && void 0 !== r2 ? r2 : null === (o2 = (s2 = e3).rng) || void 0 === o2 ? void 0 : o2.call(s2)) && void 0 !== n2 ? n2 : (function() {
            if (!eN) {
              if ("undefined" == typeof crypto || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
              eN = crypto.getRandomValues.bind(crypto);
            }
            return eN(tN);
          })();
          if (a2.length < 16) throw new Error("Random bytes length must be >= 16");
          if (a2[6] = 15 & a2[6] | 64, a2[8] = 63 & a2[8] | 128, t3) {
            if ((i2 = i2 || 0) < 0 || i2 + 16 > t3.length) throw new RangeError("UUID byte range ".concat(i2, ":").concat(i2 + 15, " is out of buffer bounds"));
            for (let e4 = 0; e4 < 16; ++e4) t3[i2 + e4] = a2[e4];
            return t3;
          }
          return (function(e4) {
            let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            return (ZO[e4[t4 + 0]] + ZO[e4[t4 + 1]] + ZO[e4[t4 + 2]] + ZO[e4[t4 + 3]] + "-" + ZO[e4[t4 + 4]] + ZO[e4[t4 + 5]] + "-" + ZO[e4[t4 + 6]] + ZO[e4[t4 + 7]] + "-" + ZO[e4[t4 + 8]] + ZO[e4[t4 + 9]] + "-" + ZO[e4[t4 + 10]] + ZO[e4[t4 + 11]] + ZO[e4[t4 + 12]] + ZO[e4[t4 + 13]] + ZO[e4[t4 + 14]] + ZO[e4[t4 + 15]]).toLowerCase();
          })(a2);
        })(e2, t2, void 0);
        var e2, t2;
      }
      function nN(e2, t2) {
        const i2 = e2.indexOf(t2);
        -1 !== i2 && e2.splice(i2, 1);
      }
      function rN(e2) {
        const t2 = [];
        return e2.forEach(((e3) => {
          -1 === t2.indexOf(e3) && t2.push(e3);
        })), t2;
      }
      function oN(e2) {
        void 0 !== rp ? rp.resolve().then(e2) : setTimeout(e2, 0);
      }
      function sN(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      function aN(e2) {
        try {
          return sN(e2);
        } catch (t2) {
          return e2;
        }
      }
      const cN = {};
      function dN(e2, t2) {
        cN[t2] || (cN[t2] = true, e2());
      }
      function lN(e2) {
        const t2 = window.atob(e2), i2 = new Uint8Array(new ArrayBuffer(t2.length));
        for (let e3 = 0; e3 < t2.length; e3 += 1) i2[e3] = t2.charCodeAt(e3);
        return i2;
      }
      function uN(e2) {
        let t2 = "";
        for (let i2 = 0; i2 < e2.length; i2 += 1) t2 += String.fromCharCode(e2[i2]);
        return window.btoa(t2);
      }
      function hN(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16, i2 = new TextEncoder().encode(e2);
        if (i2.length > t2) i2 = i2.slice(0, t2);
        else if (i2.length < t2) {
          const e3 = new Uint8Array(t2);
          e3.set(i2), i2 = e3;
        }
        return i2;
      }
      function pN() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
        const n2 = nr(t2).call(t2, ((e3, t3) => e3 + t3.length), 0), r2 = new Uint8Array(new ArrayBuffer(n2));
        let o2 = 0;
        return t2.forEach(((e3) => {
          r2.set(e3, o2), o2 += e3.length;
        })), r2;
      }
      function _N(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function EN(e2) {
        let t2 = 0;
        return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e2.realFormData && (e2 = e2.realFormData), e2.forEach(((e3) => {
          t2 += "string" == typeof e3 ? _N(e3) : e3.size;
        })), t2 + 138;
      }
      function mN(e2) {
        const t2 = new pO(hO.TIMEOUT, "timeout");
        return new rp(((i2, n2) => {
          window.setTimeout((() => n2(t2)), e2);
        }));
      }
      function fN(e2) {
        return new rp(((t2) => {
          window.setTimeout(t2, e2);
        }));
      }
      function SN() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
        const i2 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return i2.length === e2 ? "".concat(t2).concat(i2) : "".concat(t2).concat(i2) + SN(e2 - i2.length, "");
      }
      function gN() {
        let e2, t2 = false;
        try {
          var i2;
          e2 = MT(i2 = iN()).call(i2, "-", "");
        } catch (e3) {
          t2 = true;
        }
        return !t2 && e2 && 32 === e2.length || (e2 = SN(32, "")), e2.toUpperCase();
      }
      const TN = () => {
      }, RN = new class {
        constructor() {
          dO(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t2, i2, n2) {
          for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++) o2[s2 - 4] = arguments[s2];
          if (this.fnMap.has(t2)) {
            const r3 = this.fnMap.get(t2);
            if (r3.threshold !== i2) {
              r3.fn(...r3.args), clearTimeout(r3.timer);
              const s3 = window.setTimeout((() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }), i2);
              this.fnMap.set(t2, { fn: e2, threshold: i2, timer: s3, args: o2, skipFn: n2 });
            } else r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, uO(uO({}, r3), {}, { fn: e2, args: o2, skipFn: n2 }));
          } else {
            const r3 = window.setTimeout((() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }), i2);
            this.fnMap.set(t2, { fn: e2, threshold: i2, timer: r3, args: o2, skipFn: n2 });
          }
        }
      }(), CN = RN.throttleByKey.bind(RN);
      function vN(e2) {
        return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
      }
      function yN(e2, t2) {
        if (!vN(e2) || !vN(t2)) return t2;
        if (Array.isArray(e2) && !Array.isArray(t2) || !Array.isArray(e2) && Array.isArray(t2)) return t2;
        if (Array.isArray(t2) && Array.isArray(e2)) {
          const i2 = [...e2];
          for (let n2 = 0; n2 < t2.length; n2++) i2[n2] = yN(e2[n2], t2[n2]);
          return i2;
        }
        {
          const i2 = uO({}, e2);
          for (const n2 in t2) Object.prototype.hasOwnProperty.call(t2, n2) && (Object.prototype.hasOwnProperty.call(e2, n2) ? i2[n2] = yN(e2[n2], t2[n2]) : i2[n2] = t2[n2]);
          return i2;
        }
      }
      function IN(e2, t2) {
        let i2 = [0];
        if (t2 && (i2 = new Array(t2).fill(0)), 0 === e2) return i2;
        let n2 = 0;
        for (; e2 > 0 && (i2[n2] = 255 & e2, e2 >>= 8, n2++, !t2 || n2 !== t2); ) ;
        return i2;
      }
      function AN(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function bN(e2, t2) {
        try {
          return "object" == typeof e2 && "object" == typeof t2 && JSON.stringify(e2) === JSON.stringify(t2);
        } catch (e3) {
          return false;
        }
      }
      function wN(e2) {
        return nr(e2).call(e2, ((e3, t2) => e3 + t2), 0);
      }
      function ON(e2) {
        const t2 = "0123456789abcdef";
        function i2(e3) {
          let i3, n3 = "";
          for (i3 = 0; i3 <= 3; i3++) n3 += t2.charAt(e3 >> 8 * i3 + 4 & 15) + t2.charAt(e3 >> 8 * i3 & 15);
          return n3;
        }
        function n2(e3, t3) {
          const i3 = (65535 & e3) + (65535 & t3);
          return (e3 >> 16) + (t3 >> 16) + (i3 >> 16) << 16 | 65535 & i3;
        }
        function r2(e3, t3, i3, r3, o3, s3) {
          return n2((function(e4, t4) {
            return e4 << t4 | e4 >>> 32 - t4;
          })(n2(n2(t3, e3), n2(r3, s3)), o3), i3);
        }
        function o2(e3, t3, i3, n3, o3, s3, a3) {
          return r2(t3 & i3 | ~t3 & n3, e3, t3, o3, s3, a3);
        }
        function s2(e3, t3, i3, n3, o3, s3, a3) {
          return r2(t3 & n3 | i3 & ~n3, e3, t3, o3, s3, a3);
        }
        function a2(e3, t3, i3, n3, o3, s3, a3) {
          return r2(t3 ^ i3 ^ n3, e3, t3, o3, s3, a3);
        }
        function c2(e3, t3, i3, n3, o3, s3, a3) {
          return r2(i3 ^ (t3 | ~n3), e3, t3, o3, s3, a3);
        }
        const d2 = (function(e3) {
          let t3;
          const i3 = 1 + (e3.length + 8 >> 6), n3 = new Array(16 * i3);
          for (t3 = 0; t3 < 16 * i3; t3++) n3[t3] = 0;
          for (t3 = 0; t3 < e3.length; t3++) n3[t3 >> 2] |= e3.charCodeAt(t3) << t3 % 4 * 8;
          return n3[t3 >> 2] |= 128 << t3 % 4 * 8, n3[16 * i3 - 2] = 8 * e3.length, n3;
        })(e2);
        let l2, u2, h2, p2, _2, E2 = 1732584193, m2 = -271733879, f2 = -1732584194, S2 = 271733878;
        for (l2 = 0; l2 < d2.length; l2 += 16) u2 = E2, h2 = m2, p2 = f2, _2 = S2, E2 = o2(E2, m2, f2, S2, d2[l2 + 0], 7, -680876936), S2 = o2(S2, E2, m2, f2, d2[l2 + 1], 12, -389564586), f2 = o2(f2, S2, E2, m2, d2[l2 + 2], 17, 606105819), m2 = o2(m2, f2, S2, E2, d2[l2 + 3], 22, -1044525330), E2 = o2(E2, m2, f2, S2, d2[l2 + 4], 7, -176418897), S2 = o2(S2, E2, m2, f2, d2[l2 + 5], 12, 1200080426), f2 = o2(f2, S2, E2, m2, d2[l2 + 6], 17, -1473231341), m2 = o2(m2, f2, S2, E2, d2[l2 + 7], 22, -45705983), E2 = o2(E2, m2, f2, S2, d2[l2 + 8], 7, 1770035416), S2 = o2(S2, E2, m2, f2, d2[l2 + 9], 12, -1958414417), f2 = o2(f2, S2, E2, m2, d2[l2 + 10], 17, -42063), m2 = o2(m2, f2, S2, E2, d2[l2 + 11], 22, -1990404162), E2 = o2(E2, m2, f2, S2, d2[l2 + 12], 7, 1804603682), S2 = o2(S2, E2, m2, f2, d2[l2 + 13], 12, -40341101), f2 = o2(f2, S2, E2, m2, d2[l2 + 14], 17, -1502002290), m2 = o2(m2, f2, S2, E2, d2[l2 + 15], 22, 1236535329), E2 = s2(E2, m2, f2, S2, d2[l2 + 1], 5, -165796510), S2 = s2(S2, E2, m2, f2, d2[l2 + 6], 9, -1069501632), f2 = s2(f2, S2, E2, m2, d2[l2 + 11], 14, 643717713), m2 = s2(m2, f2, S2, E2, d2[l2 + 0], 20, -373897302), E2 = s2(E2, m2, f2, S2, d2[l2 + 5], 5, -701558691), S2 = s2(S2, E2, m2, f2, d2[l2 + 10], 9, 38016083), f2 = s2(f2, S2, E2, m2, d2[l2 + 15], 14, -660478335), m2 = s2(m2, f2, S2, E2, d2[l2 + 4], 20, -405537848), E2 = s2(E2, m2, f2, S2, d2[l2 + 9], 5, 568446438), S2 = s2(S2, E2, m2, f2, d2[l2 + 14], 9, -1019803690), f2 = s2(f2, S2, E2, m2, d2[l2 + 3], 14, -187363961), m2 = s2(m2, f2, S2, E2, d2[l2 + 8], 20, 1163531501), E2 = s2(E2, m2, f2, S2, d2[l2 + 13], 5, -1444681467), S2 = s2(S2, E2, m2, f2, d2[l2 + 2], 9, -51403784), f2 = s2(f2, S2, E2, m2, d2[l2 + 7], 14, 1735328473), m2 = s2(m2, f2, S2, E2, d2[l2 + 12], 20, -1926607734), E2 = a2(E2, m2, f2, S2, d2[l2 + 5], 4, -378558), S2 = a2(S2, E2, m2, f2, d2[l2 + 8], 11, -2022574463), f2 = a2(f2, S2, E2, m2, d2[l2 + 11], 16, 1839030562), m2 = a2(m2, f2, S2, E2, d2[l2 + 14], 23, -35309556), E2 = a2(E2, m2, f2, S2, d2[l2 + 1], 4, -1530992060), S2 = a2(S2, E2, m2, f2, d2[l2 + 4], 11, 1272893353), f2 = a2(f2, S2, E2, m2, d2[l2 + 7], 16, -155497632), m2 = a2(m2, f2, S2, E2, d2[l2 + 10], 23, -1094730640), E2 = a2(E2, m2, f2, S2, d2[l2 + 13], 4, 681279174), S2 = a2(S2, E2, m2, f2, d2[l2 + 0], 11, -358537222), f2 = a2(f2, S2, E2, m2, d2[l2 + 3], 16, -722521979), m2 = a2(m2, f2, S2, E2, d2[l2 + 6], 23, 76029189), E2 = a2(E2, m2, f2, S2, d2[l2 + 9], 4, -640364487), S2 = a2(S2, E2, m2, f2, d2[l2 + 12], 11, -421815835), f2 = a2(f2, S2, E2, m2, d2[l2 + 15], 16, 530742520), m2 = a2(m2, f2, S2, E2, d2[l2 + 2], 23, -995338651), E2 = c2(E2, m2, f2, S2, d2[l2 + 0], 6, -198630844), S2 = c2(S2, E2, m2, f2, d2[l2 + 7], 10, 1126891415), f2 = c2(f2, S2, E2, m2, d2[l2 + 14], 15, -1416354905), m2 = c2(m2, f2, S2, E2, d2[l2 + 5], 21, -57434055), E2 = c2(E2, m2, f2, S2, d2[l2 + 12], 6, 1700485571), S2 = c2(S2, E2, m2, f2, d2[l2 + 3], 10, -1894986606), f2 = c2(f2, S2, E2, m2, d2[l2 + 10], 15, -1051523), m2 = c2(m2, f2, S2, E2, d2[l2 + 1], 21, -2054922799), E2 = c2(E2, m2, f2, S2, d2[l2 + 8], 6, 1873313359), S2 = c2(S2, E2, m2, f2, d2[l2 + 15], 10, -30611744), f2 = c2(f2, S2, E2, m2, d2[l2 + 6], 15, -1560198380), m2 = c2(m2, f2, S2, E2, d2[l2 + 13], 21, 1309151649), E2 = c2(E2, m2, f2, S2, d2[l2 + 4], 6, -145523070), S2 = c2(S2, E2, m2, f2, d2[l2 + 11], 10, -1120210379), f2 = c2(f2, S2, E2, m2, d2[l2 + 2], 15, 718787259), m2 = c2(m2, f2, S2, E2, d2[l2 + 9], 21, -343485551), E2 = n2(E2, u2), m2 = n2(m2, h2), f2 = n2(f2, p2), S2 = n2(S2, _2);
        return i2(E2) + i2(m2) + i2(f2) + i2(S2);
      }
      let NN = 1, DN = console, PN = class {
        static setLogger(e2) {
          DN = e2;
        }
        constructor(e2, t2) {
          dO(this, "id", void 0), dO(this, "lockingPromise", rp.resolve()), dO(this, "locks", 0), dO(this, "name", ""), dO(this, "lockId", void 0), this.lockId = NN++, e2 && (this.name = e2), t2 && (this.id = t2), this.logger("created");
        }
        logger(e2, t2) {
          const i2 = (this.id ? "[".concat(this.id, "]") : "") + "[lock-".concat(this.name, "-").concat(this.lockId, "]"), n2 = "created" === e2 ? "is ".concat(e2, ".") : "is ".concat(e2, ", current queue ").concat(this.locks, ". ").concat(null != t2 ? t2 : "");
          DN.debug("".concat(i2, " ").concat(n2));
        }
        setId(e2) {
          this.id = e2;
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t2;
          this.locks += 1, this.logger("locked", e2);
          const i2 = new rp(((i3) => {
            t2 = () => {
              this.locks -= 1, this.logger("unlocked", e2), i3();
            };
          })), n2 = this.lockingPromise.then((() => t2));
          return this.lockingPromise = this.lockingPromise.then((() => i2)), n2;
        }
      };
      function LN(e2, t2) {
        return function(i2, n2, r2) {
          const o2 = r2.value;
          if ("function" != typeof o2) throw new Error("Cannot use mutex on object property.");
          return r2.value = async function() {
            const i3 = this[t2];
            if (!i3) throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
            const r3 = await i3.lock("From ".concat(e2, ".").concat(n2));
            try {
              for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++) a2[c2] = arguments[c2];
              return await o2.apply(this, a2);
            } finally {
              r3();
            }
          }, r2;
        };
      }
      const kN = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function MN(e2, t2) {
        const i2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
        return Math.min(t2.maxRetryTimeout, i2);
      }
      function UN(e2, t2, i2, n2) {
        const r2 = Object.assign({}, kN, n2);
        let o2 = r2.timeout;
        const s2 = async () => {
          await (function(e3) {
            return new rp(((t3) => {
              window.setTimeout(t3, e3);
            }));
          })(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
        };
        let a2 = false;
        const c2 = new rp((async (n3, o3) => {
          t2 = t2 || (() => false), i2 = i2 || (() => true);
          for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
            if (a2) return o3(new pO(hO.OPERATION_ABORTED));
            try {
              const i3 = await e2();
              if (!t2(i3, c3)) return n3(i3);
              if (c3 + 1 === r2.maxRetryCount) return n3(i3);
              await s2();
            } catch (e3) {
              if (!i2(e3, c3)) return o3(e3);
              if (c3 + 1 === r2.maxRetryCount) return o3(e3);
              await s2();
            }
          }
        }));
        return c2.cancel = () => a2 = true, c2;
      }
      let VN, xN = class {
        constructor(e2) {
          dO(this, "input", []), dO(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return 0 === this.input.length ? 0 : nr(e2 = this.input).call(e2, ((e3, t2) => e3 + t2)) / this.input.length;
        }
      }, FN = 0, BN = 0;
      function jN(e2, t2, i2, n2) {
        return new rp(((r2, o2) => {
          t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), FN += _N(t2.data)) : i2 && (t2.data.size ? FN += t2.data.size : t2.data instanceof FormData ? FN += EN(t2.data) : FN += _N(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, Tw.request(t2).then(((e3) => {
            "string" == typeof e3.data ? BN += _N(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? BN += e3.data.byteLength : BN += _N(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          })).catch(((e3) => {
            Tw.isCancel(e3) ? o2(new pO(hO.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new pO(hO.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new pO(hO.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new pO(hO.NETWORK_ERROR, e3.message));
          }));
        }));
      }
      async function GN(e2, t2) {
        const i2 = new Blob([t2.data], { type: "buffer" });
        return await jN(e2, uO(uO({}, t2), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const WN = () => void 0 !== window.isSecureContext;
      function HN(e2) {
        if (Array.isArray(e2)) return e2.map(((e3) => e3));
        if (!KN(e2)) return e2;
        const t2 = {};
        for (const i2 in e2) {
          const n2 = e2[i2];
          KN(n2) || Array.isArray(n2) ? t2[i2] = HN(n2) : t2[i2] = n2;
        }
        return t2;
      }
      function KN(e2) {
        return !("object" != typeof e2 || Array.isArray(e2) || !e2);
      }
      let YN = class {
        constructor(e2) {
          dO(this, "input", []), dO(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        diffMean() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }
      };
      const zN = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, qN = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], transport: { bytesSent: 0, bytesReceived: 0, packetsSent: 0, packetsReceived: 0 }, selectedCandidatePair: { id: "unknown", localCandidate: zN, remoteCandidate: zN }, updateInterval: 0 }, XN = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0, framesDroppedCount: 0, outputFrameRate: 0, packetsDiscarded: 0, framesAssembledFromMultiplePackets: 0, totalProcessingDelay: 0, avgDecodeMs: 0, avgFramesAssembledFromMultiplePacketsMs: 0, avgProcessingDelayMs: 0, avgInterFrameDelayMs: 0, totalAssemblyTime: 0 }, JN = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 }, QN = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 }, ZN = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packetsDiscarded: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0, totalSamplesReceived: 0, silentConcealedSamples: 0, concealmentEvents: 0, freezeMs80: 0, freezeMs200: 0, freezeSamples80: 0, freezeSamples200: 0 };
      let $N = class {
        constructor(e2, t2) {
          dO(this, "onFirstVideoReceived", void 0), dO(this, "onFirstVideoDecoded", void 0), dO(this, "onFirstAudioReceived", void 0), dO(this, "onFirstVideoDecodedTimeout", void 0), dO(this, "onFirstAudioDecoded", void 0), dO(this, "onSelectedLocalCandidateChanged", void 0), dO(this, "onSelectedRemoteCandidateChanged", void 0), dO(this, "videoIsReady", false), dO(this, "videoIsReady2", {}), dO(this, "pc", void 0), dO(this, "options", void 0), dO(this, "intervalTimer", void 0), dO(this, "stats", HN(qN)), dO(this, "isFirstVideoReceived", {}), dO(this, "isFirstVideoDecoded", {}), dO(this, "isFirstAudioReceived", {}), dO(this, "isFirstAudioDecoded", {}), dO(this, "isFirstVideoDecodedTimeout", {}), dO(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval((async () => {
            this.updateStats();
          }), this.options.updateInterval);
        }
        getStats() {
          return this.stats;
        }
        getSelectedCandidatePair() {
          return new rp(((e2) => {
            e2({ local: uO({}, zN), remote: uO({}, zN) });
          }));
        }
        setVideoIsReady(e2) {
          this.videoIsReady = e2;
        }
        setVideoIsReady2(e2, t2) {
          this.videoIsReady2[e2] = t2;
        }
        getVideoIsReady(e2) {
          return this.videoIsReady2[e2] || false;
        }
        setIsFirstAudioDecoded(e2) {
        }
        destroy() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }
        calcLossRate(e2) {
          this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          const t2 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
          let n2 = 0, r2 = 0, o2 = 0, s2 = 0;
          for (const a2 of i2) e2[a2].forEach(((e3, i3) => {
            if (!this.lossRateWindowStats[t2 - 1][a2][i3] || !this.lossRateWindowStats[0][a2][i3]) return;
            const c2 = this.lossRateWindowStats[t2 - 1][a2][i3].packets - this.lossRateWindowStats[0][a2][i3].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i3].packetsLost - this.lossRateWindowStats[0][a2][i3].packetsLost;
            "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, o2 += d2) : (r2 += c2, s2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
          }));
          e2.sendPacketLossRate = n2 <= 0 || o2 <= 0 ? 0 : o2 / (n2 + o2), e2.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
        }
      }, eD = class extends $N {
        constructor() {
          super(...arguments), dO(this, "_stats", qN), dO(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
          this._stats = HN(qN);
          const i2 = t2.filter(((e3) => "ssrc" === e3.type));
          this.processSSRCStats(i2);
          const n2 = t2.find(((e3) => "VideoBwe" === e3.type));
          n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        processBandwidthStats(e2) {
          this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
        }
        processSSRCStats(e2) {
          e2.forEach(((e3) => {
            var t2;
            const i2 = Ln(t2 = e3.id).call(t2, "send");
            switch ("".concat(e3.mediaType, "_").concat(i2 ? "send" : "recv")) {
              case "video_send": {
                const t3 = HN(JN);
                t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
                break;
              }
              case "video_recv": {
                const t3 = HN(XN), i3 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i3) {
                  const n2 = i3.stats, r2 = Date.now() - i3.lts;
                  t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i3.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i3.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
                }
                this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: uO({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
                break;
              }
              case "audio_recv": {
                const t3 = HN(ZN);
                t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
                break;
              }
              case "audio_send": {
                const t3 = HN(QN);
                t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
                break;
              }
            }
          }));
        }
        _getStats() {
          return new rp(((e2, t2) => {
            this.pc.getStats(e2, t2);
          }));
        }
        statsResponsesToObjects(e2) {
          const t2 = [];
          return e2.result().forEach(((e3) => {
            const i2 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
            e3.names().forEach(((t3) => {
              i2[t3] = e3.stat(t3);
            })), t2.push(i2);
          })), t2;
        }
      }, tD = (function(e2) {
        return e2.BANDWIDTH = "bandwidth", e2.CPU = "cpu", e2.NONE = "none", e2.OTHER = "other", e2;
      })({}), iD = (function(e2) {
        return e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L1T3_KEY = "L1T3_KEY", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY", e2;
      })({}), nD = (function(e2) {
        return e2[e2.new = 0] = "new", e2[e2.connecting = 1] = "connecting", e2[e2.connected = 2] = "connected", e2[e2.disconnected = 3] = "disconnected", e2[e2.failed = 4] = "failed", e2[e2.closed = 5] = "closed", e2;
      })({}), rD = (function(e2) {
        return e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver", e2;
      })({});
      var oD = (function(e2) {
        return e2[e2.kNone = 1] = "kNone", e2[e2.kMillisecondsFromSeconds = 1e3] = "kMillisecondsFromSeconds", e2[e2.kBytesToBits = 8] = "kBytesToBits", e2;
      })(oD || {});
      function sD(e2, t2, i2, n2) {
        let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : oD.kNone;
        if (!t2) return;
        const o2 = Number(t2[i2]);
        if ("number" != typeof o2) return;
        const s2 = Number(t2[n2]);
        if ("number" != typeof s2) return;
        if (!e2) return s2 ? o2 / s2 * r2 : void 0;
        const a2 = Number(e2[i2]);
        if ("number" != typeof a2) return;
        const c2 = Number(e2[n2]);
        if ("number" != typeof c2) return;
        const d2 = s2 - c2;
        return d2 ? (o2 - a2) / d2 * r2 : void 0;
      }
      let aD = class extends $N {
        constructor() {
          super(...arguments), dO(this, "_stats", qN), dO(this, "report", void 0), dO(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), dO(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), dO(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), dO(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), dO(this, "lastVideoFramesOutput", /* @__PURE__ */ new Map()), dO(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), dO(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), dO(this, "mediaBytesSent", /* @__PURE__ */ new Map()), dO(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), dO(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), dO(this, "lastDecodeAudioReceiverStats", /* @__PURE__ */ new Map()), dO(this, "lastAudioConcealment", /* @__PURE__ */ new Map()), dO(this, "lastEncoderMs", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          this.report = await this.pc.getStats(), this._stats = HN(qN), this.report.forEach(((e2) => {
            switch (e2.type) {
              case rD.OUTBOUND:
              case rD.INBOUND: {
                const t2 = e2.mediaType || e2.kind, i2 = !t2 && "frameWidth" in e2, n2 = !t2 && !("frameWidth" in e2);
                e2.type === rD.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e2) : ("video" === t2 || i2) && this.processVideoOutboundStats(e2) : e2.type === rD.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e2) : ("video" === t2 || i2) && this.processVideoInboundStats(e2));
                break;
              }
              case rD.TRANSPORT: {
                this.processTransportStats(e2);
                const t2 = this.report.get(e2.selectedCandidatePairId);
                t2 && this.processCandidatePairStats(t2);
                break;
              }
              case rD.CANDIDATE_PAIR:
                e2.selected && this.processCandidatePairStats(e2);
            }
          })), this.updateSendBitrate(), this._stats.updateInterval = Date.now() - this.stats.timestamp, this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        async getSelectedCandidatePair() {
          const e2 = await this.pc.getStats(), t2 = { local: uO({}, zN), remote: uO({}, zN) };
          return e2.forEach(((i2) => {
            let n2;
            if (i2.type === rD.TRANSPORT && (n2 = e2.get(i2.selectedCandidatePairId)), i2.type === rD.CANDIDATE_PAIR && i2.selected && (n2 = i2), n2) {
              const i3 = (e3, t3) => {
                e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
              };
              if (n2.localCandidateId) {
                const r2 = e2.get(n2.localCandidateId);
                r2 && i3(t2.local, r2);
              }
              if (n2.remoteCandidateId) {
                const r2 = e2.get(n2.remoteCandidateId);
                r2 && i3(t2.remote, r2);
              }
            }
          })), t2;
        }
        processCandidatePairStats(e2) {
          if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach(((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          })), this._stats.audioSend.forEach(((t2) => {
            e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
          })), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
            const t2 = this.report.get(e2.localCandidateId);
            t2 && this.processCandidateStats(t2);
          }
          if (e2.remoteCandidateId) {
            const t2 = this.report.get(e2.remoteCandidateId);
            t2 && this.processCandidateStats(t2);
          }
        }
        processCandidateStats(e2) {
          let t2;
          e2.type === rD.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === rD.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === rD.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(uO({}, t2), uO({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === rD.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(uO({}, t2), uO({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }
        processAudioInboundStats(e2) {
          let t2 = this._stats.audioRecv.find(((t3) => t3.ssrc === e2.ssrc));
          t2 || (t2 = HN(ZN), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.packetsDiscarded = e2.packetsDiscarded, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, t2.retransmittedBytesReceived = e2.retransmittedBytesReceived, t2.retransmittedPacketsReceived = e2.retransmittedPacketsReceived, t2.totalProcessingDelay = e2.totalProcessingDelay, t2.jitterBufferEmittedCount = e2.jitterBufferEmittedCount, t2.estimatedPlayoutTimestamp = e2.estimatedPlayoutTimestamp;
          const i2 = this.lastDecodeAudioReceiverStats.get(t2.ssrc);
          t2.avgProcessingDelayMs = sD(i2, t2, "totalProcessingDelay", "jitterBufferEmittedCount", oD.kMillisecondsFromSeconds), this.processAudioTrackReceiverStats(e2, e2.trackId, t2), this.calculateAudioFreeze(t2, i2, e2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples), this.lastDecodeAudioReceiverStats.set(t2.ssrc, uO({}, t2));
        }
        calculateAudioFreeze(e2, t2, i2) {
          const n2 = this.lastAudioConcealment.get(e2.ssrc);
          if (null != t2 && null != n2) {
            const r2 = n2.lts, o2 = i2.timestamp, s2 = o2 - r2;
            if (s2 <= 0) return;
            const a2 = e2.concealedSamples - t2.concealedSamples - 0, c2 = n2.nonSilent + a2, d2 = e2.totalSamplesReceived - t2.totalSamplesReceived;
            if (d2 <= 0) return;
            const l2 = 80 * d2 / s2, u2 = 200 * d2 / s2, h2 = s2 / d2;
            let p2 = 0;
            e2.freezeSamples80 = t2.freezeSamples80, e2.freezeMs80 = t2.freezeMs80, c2 > l2 && (n2.plc80 > 0 ? (e2.freezeSamples80 += a2, e2.freezeMs80 += Math.round(a2 * h2)) : (e2.freezeSamples80 += c2, e2.freezeMs80 += Math.round(c2 * h2)), p2 = n2.plc80 + 1);
            let _2 = 0;
            e2.freezeSamples200 = t2.freezeSamples200, e2.freezeMs200 = t2.freezeMs200, c2 > u2 && (n2.plc200 > 0 ? (e2.freezeSamples200 += a2, e2.freezeMs200 += Math.round(a2 * h2)) : (e2.freezeSamples200 += c2, e2.freezeMs200 += Math.round(c2 * h2)), _2 = n2.plc200 + 1), this.lastAudioConcealment.set(e2.ssrc, { nonSilent: a2, lts: o2, plc80: p2, plc200: _2 });
          } else e2.freezeSamples80 = 0, e2.freezeSamples200 = 0, e2.freezeMs80 = 0, e2.freezeMs200 = 0, this.lastAudioConcealment.set(e2.ssrc, { nonSilent: 0, lts: i2.timestamp, plc80: 0, plc200: 0 });
        }
        processVideoInboundStats(e2) {
          let t2 = this._stats.videoRecv.find(((t3) => t3.ssrc === e2.ssrc));
          t2 || (t2 = HN(XN), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.framesDroppedCount = e2.framesDropped, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay, t2.totalFreezesDuration = e2.totalFreezesDuration, t2.totalProcessingDelay = e2.totalProcessingDelay, t2.packetsDiscarded = e2.packetsDiscarded, t2.framesAssembledFromMultiplePackets = e2.framesAssembledFromMultiplePackets, t2.totalAssemblyTime = e2.totalAssemblyTime, t2.keyFramesDecoded = e2.keyFramesDecoded, t2.retransmittedBytesReceived = e2.retransmittedBytesReceived, t2.retransmittedPacketsReceived = e2.retransmittedPacketsReceived, t2.estimatedPlayoutTimestamp = e2.estimatedPlayoutTimestamp;
          const i2 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = this.lastVideoFramesOutput.get(t2.ssrc), o2 = Date.now();
          if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
            const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i3 = t2.decodedFrame ? t2.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i3), this.isFirstVideoDecoded[t2.ssrc] = true;
          }
          if (i2) {
            const n3 = i2.stats, r3 = o2 - i2.lts;
            t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && r3 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i2.lts = Date.now(), t2.framesDecodeInterval = r3, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i2.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i2.qpSum) / (e2.framesDecoded - i2.stats.framesDecodeCount));
          }
          e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime, t2.avgDecodeMs = sD(null == i2 ? void 0 : i2.stats, t2, "decodeMs", "framesDecodeCount")), t2.avgProcessingDelayMs = sD(null == i2 ? void 0 : i2.stats, t2, "totalProcessingDelay", "framesDecodeCount", oD.kMillisecondsFromSeconds), t2.avgFramesAssembledFromMultiplePacketsMs = sD(null == i2 ? void 0 : i2.stats, t2, "totalAssemblyTime", "framesAssembledFromMultiplePackets", oD.kMillisecondsFromSeconds), t2.avgInterFrameDelayMs = sD(null == i2 ? void 0 : i2.stats, t2, "totalInterFrameDelay", "framesDecodeCount", oD.kMillisecondsFromSeconds), n2 && o2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((o2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: o2, rate: 0 }), t2.framesDroppedCount && e2.framesReceived && (r2 && o2 - r2.lts >= 800 ? (t2.outputFrameRate = Math.round((e2.framesReceived - t2.framesDroppedCount - r2.count) / ((o2 - r2.lts) / 1e3)), this.lastVideoFramesOutput.set(t2.ssrc, { count: e2.framesReceived - t2.framesDroppedCount, lts: o2, rate: Math.max(t2.outputFrameRate, 0) })) : r2 ? t2.outputFrameRate = r2.rate : this.lastVideoFramesOutput.set(t2.ssrc, { count: e2.framesReceived - t2.framesDroppedCount, lts: o2, rate: 0 })), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: uO({}, t2), lts: i2 ? i2.lts : Date.now(), qpSum: e2.qpSum });
        }
        processVideoOutboundStats(e2) {
          let t2 = this._stats.videoSend.find(((t3) => t3.ssrc === e2.ssrc));
          t2 || (t2 = HN(JN), this._stats.videoSend.push(t2));
          const i2 = this.mediaBytesSent.get(e2.ssrc);
          if (i2) i2.add(e2.bytesSent);
          else {
            const t3 = new YN(10);
            t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
          }
          if (void 0 !== e2.retransmittedBytesSent) {
            const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
            if (t3) t3.add(e2.retransmittedBytesSent);
            else {
              const t4 = new YN(10);
              t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
            }
          }
          if (e2.totalEncodedBytesTarget) {
            const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
            if (t3) t3.add(e2.totalEncodedBytesTarget);
            else {
              const t4 = new YN(10);
              t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
            }
          }
          if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, t2.retransmittedBytesSent = e2.retransmittedBytesSent, t2.retransmittedPacketsSent = e2.retransmittedPacketsSent, t2.hugeFramesSent = e2.hugeFramesSent, t2.keyFramesEncoded = e2.keyFramesEncoded, t2.targetBitrate = e2.targetBitrate, e2.totalEncodeTime && e2.framesEncoded) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            if (!i3 || i3.lastFrameCount > e2.framesEncoded) t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
            else {
              const n2 = e2.framesEncoded - i3.lastFrameCount, r2 = e2.totalEncodeTime - i3.lastEncoderTime;
              t2.avgEncodeMs = 1e3 * r2 / n2;
            }
          }
          if (e2.framesEncoded && e2.qpSum) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            !i3 || i3.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i3.lastQpSum) / (e2.framesEncoded - i3.lastFrameCount);
          }
          if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i3 = this.findRemoteStatsId(e2.ssrc, rD.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t2);
          }
        }
        processAudioOutboundStats(e2) {
          let t2 = this._stats.audioSend.find(((t3) => t3.ssrc === e2.ssrc));
          if (t2 || (t2 = HN(QN), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, t2.retransmittedBytesSent = e2.retransmittedBytesSent, t2.retransmittedPacketsSent = e2.retransmittedPacketsSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t2);
          else {
            const i2 = this.findRemoteStatsId(e2.ssrc, rD.REMOTE_INBOUND);
            i2 && this.processRemoteInboundStats(i2, t2);
          }
        }
        processTransportStats(e2) {
          this._stats.transport.bytesReceived = e2.bytesReceived || this._stats.transport.bytesReceived, this._stats.transport.bytesSent = e2.bytesSent || this._stats.transport.bytesSent, this._stats.transport.packetsReceived = e2.packetsReceived || this._stats.transport.packetsReceived, this._stats.transport.packetsSent = e2.packetsSent || this._stats.transport.packetsSent;
        }
        findRemoteStatsId(e2, t2) {
          var i2;
          const n2 = Array.from(pp(i2 = this.report).call(i2)).find(((i3) => i3.type === t2 && i3.ssrc === e2));
          return n2 ? n2.id : null;
        }
        processVideoMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && i2.width && i2.height && i2.framesPerSecond && (t2.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
        }
        processAudioMediaSource(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.inputLevel = i2.audioLevel);
        }
        processVideoTrackSenderStats(e2, t2, i2) {
          var n2, r2, o2, s2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null == a2 ? void 0 : a2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
          if ("number" != typeof c2) return;
          let d2 = null !== (r2 = null == a2 ? void 0 : a2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (o2 = null == a2 ? void 0 : a2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, u2 = null !== (s2 = null == a2 ? void 0 : a2.framesPerSecond) && void 0 !== s2 ? s2 : e2.framesPerSecond;
          if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == u2) {
            const e3 = Date.now(), t3 = this.lastVideoFramesSent.get(i2.ssrc);
            t3 && e3 - t3.lts >= 800 ? (u2 = Math.round((c2 - t3.count) / ((e3 - t3.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: u2 })) : t3 ? u2 = t3.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: 0 });
          }
          i2.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, u2) };
        }
        processVideoTrackReceiverStats(e2, t2, i2) {
          var n2, r2, o2, s2, a2;
          const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, l2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, u2 = null !== (o2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, h2 = null !== (s2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, p2 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
          if ("number" == typeof d2) {
            const e3 = this.lastVideoFramesRecv.get(i2.ssrc), t3 = Date.now();
            i2.framesReceivedCount = d2;
            let n3 = 0;
            e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: 0 }), i2.receivedFrame = { width: l2 || 0, height: u2 || 0, frameRate: n3 || 0 }, i2.decodedFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: l2 || 0, height: u2 || 0, frameRate: i2.outputFrameRate || i2.decodeFrameRate || 0 };
          }
          if (h2 && p2) {
            const e3 = this.lastVideoJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = p2 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (h2 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = t3, i2.currentDelayMs = Math.round(t3), this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: h2, jitterBufferEmittedCount: p2, jitterBufferMs: i2.currentDelayMs });
          }
        }
        processAudioTrackSenderStats(e2, t2, i2) {
          var n2, r2, o2, s2;
          const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (o2 = null !== (s2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
          i2.aecReturnLoss = c2, i2.aecReturnLossEnhancement = d2;
        }
        processAudioTrackReceiverStats(e2, t2, i2) {
          var n2, r2, o2, s2, a2, c2, d2, l2, u2;
          const h2 = t2 ? this.report.get(t2) : void 0, p2 = null !== (n2 = null == h2 ? void 0 : h2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, _2 = null !== (r2 = null == h2 ? void 0 : h2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, E2 = null !== (o2 = null == h2 ? void 0 : h2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, m2 = null !== (s2 = null == h2 ? void 0 : h2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e2.jitterBufferEmittedCount, f2 = null !== (a2 = null == h2 ? void 0 : h2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, S2 = null !== (c2 = null == h2 ? void 0 : h2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, g2 = null !== (d2 = null == h2 ? void 0 : h2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples, T2 = null !== (l2 = null == h2 ? void 0 : h2.silentConcealedSamples) && void 0 !== l2 ? l2 : e2.silentConcealedSamples, R2 = null !== (u2 = null == h2 ? void 0 : h2.concealmentEvents) && void 0 !== u2 ? u2 : e2.concealmentEvents;
          if ("number" == typeof _2 && (i2.totalSamplesReceived = _2), "number" == typeof T2 && (i2.silentConcealedSamples = T2), "number" == typeof R2 && (i2.concealmentEvents = R2), "number" == typeof g2 && (i2.concealedSamples = g2), p2 && _2 && (i2.accelerateRate = p2 / _2), E2 && m2) {
            const e3 = this.lastAudioJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t3 = e3.jitterBufferMs;
            const n3 = m2 - e3.jitterBufferEmittedCount;
            n3 > 0 && (t3 = 1e3 * (E2 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = Math.round(t3), this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: E2, jitterBufferEmittedCount: m2, jitterBufferMs: i2.jitterBufferMs });
          }
          i2.outputLevel = f2;
          let C2 = 1920;
          S2 && _2 && (C2 = _2 / S2 / 50, i2.receivedFrames = Math.round(_2 / C2)), g2 && (i2.droppedFrames = Math.round(g2 / C2));
        }
        processRemoteInboundStats(e2, t2) {
          const i2 = this.report.get(e2);
          i2 && (t2.packetsLost = i2.packetsLost, i2.roundTripTime && (t2.rttMs = 1e3 * i2.roundTripTime), i2.jitter && (t2.jitterMs = 1e3 * i2.jitter), i2.timestamp && (t2.timestamp = i2.timestamp));
        }
        getCodecFromCodecStats(e2) {
          const t2 = this.report.get(e2);
          if (!t2) return "";
          const i2 = t2.mimeType.match(/\/(.*)$/);
          return i2 && i2[1] ? i2[1] : "";
        }
        updateSendBitrate() {
          let e2 = 0, t2 = null, i2 = null;
          this.mediaBytesSent.forEach(((t3) => {
            e2 += t3.diffMean();
          })), this.mediaBytesRetransmit.forEach(((e3) => {
            t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
          })), this.mediaBytesTargetEncode.forEach(((e3) => {
            i2 = null === i2 ? e3.diffMean() : i2 + e3.diffMean();
          }));
          const n2 = null !== t2 ? e2 - t2 : e2;
          this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
        }
      }, cD = class extends $N {
        updateStats() {
          return rp.resolve();
        }
      };
      function dD(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
        const o2 = (function() {
          const e3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
          return e3 && e3[0] ? Number(e3[0].split("/")[1]) : null;
        })();
        return o2 ? o2 < 76 ? new eD(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new aD(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : (function(e3) {
          if (!window.RTCStatsReport) return false;
          const t3 = e3.getStats();
          return !!(t3 instanceof rp || (function(e4) {
            return !!e4 && ("object" == typeof e4 || "function" == typeof e4) && "function" == typeof e4.then;
          })(t3));
        })(e2) ? new aD(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new cD(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
      }
      const lD = "websdk_ng_install_id";
      function uD() {
        try {
          if (CD("INSTALL_ID")) return CD("INSTALL_ID");
          let e2 = window.localStorage.getItem(lD);
          return e2 || (e2 = gN(), window.localStorage.setItem(lD, e2)), RD("INSTALL_ID", e2), e2;
        } catch (e2) {
          return;
        }
      }
      const hD = (function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e2;
        const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-([0-9]+)/);
        if (t2 && t2[1] && t2[2]) {
          const e3 = t2[1], i2 = t2[2];
          return "".concat(e3, ".").concat(i2);
        }
        return "4.0.0.999";
      })("4.24.2"), pD = (function() {
        try {
          return true === JSON.parse("true");
        } catch (e2) {
          return true;
        }
      })();
      let _D = (function(e2) {
        return e2.Default = "default", e2.Auto = "auto", e2.Relay = "relay", e2.SdRtn = "sd-rtn", e2;
      })({});
      const ED = (function() {
        const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
        i2.splice(1, 0, "e");
        const n2 = i2.join(""), r2 = [];
        for (let e3 = 0; e3 < 6; e3++) r2.push("1");
        const o2 = r2.join(""), s2 = {};
        return s2[e2] = n2, s2[t2] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      })();
      window.DEFAULT_TURN_CONFIG = ED;
      const mD = { ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, ENABLE_USER_LICENSE_CHECK: true, DISABLE_FEC: void 0, ENABLE_NTP_REPORT: false, ENABLE_INSTANT_VIDEO: false, ENABLE_USER_AUTO_REBALANCE_CHECK: true, ENABLE_LOSSBASED_BWE: true, ENABLE_AUT_CC: true, FORCE_ENABLE_AUT_CC: false, ENABLE_CC_FALLBACK: void 0, SUBSCRIBE_TWCC: true, PUBLISH_TWCC: false, ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"], SVC: [], ENABLE_FULL_LINK_AV_SYNC: false, SVC_MODE: null, PRE_SUB_NUM: 1, ENABLE_AUT_FEEDBACK: true, SVC_EXTENDED: ["VP9"] }, fD = { MIN_FRAME_RATE: 1, MAX_FRAME_RATE: 30, MAX_THRESHOLD_FRAMERATE: 30, BITRATE_MIN_THRESHOLD: 100, BITRATE_MAX_THRESHOLD: 100, MAX_SCALE: 5, BWE_SCALE_UP_THRESHOLD: 0.6, BWE_SCALE_DOWN_THRESHOLD: 0.6, PERF_SCALE_UP_THRESHOLD: 0.7, PERF_SCALE_DOWN_THRESHOLD: 0.6, MOTION_RESOLUTION_FACTOR: 0.8, MOTION_BITRATE_FACTOR: 0.6, DETAIL_FRAMERATE_FACTOR: 0.8, DETAIL_BITRATE_FACTOR: 0.6, BALANCE_RESOLUTION_FACTOR: 0.9, BALANCE_FRAMERATE_FACTOR: 0.9, BALANCE_BITRATE_FACTOR: 0.6, OVERUSE_TIMES_THRESHOLD: 10, UNDERUSE_TIMES_THRESHOLD: 40 }, SD = "v4.24.2-0-g002485b1-dirty(12/12/2025, 5:26:54 PM)", gD = { ENABLE_EVENT_REPORT: true, UPLOAD_LOG: false, ENABLE_AG_ADAPTATION: true, FORCE_AG_HIGH_FRAMERATE: false, FORCE_SUPPORT_AG_ADAPTATION: false, ENCODER_CONFIG_LIMIT: {}, CAMERA_CAPTURE_CONFIG: void 0, ENABLE_PRELOAD: true, NEW_ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, RESTART_SEQUENCE: ["udp_tcp_relay", "relay"], FIRST_TCP_CANDIDATE: false, FIRST_TCP_CANDIDATE_INTERVAL: 1e3, TURN_DOMAIN: "edge.agora.io", TURN_DOMAINS: ["edge.agora.io"], USE_TURN_IP: true, NEW_TURN_MODE: 4, NEW_FORCE_TURN: false, USE_NEW_RENDER_FREEZE_TIME: false, FLS_FALLBACK_TIMEOUT: 3e4, RTE_DETAIL_REPORT_INTERVAL: 6e4, ENCODE_EXCEPTION_TIMES: 5, ENABLE_ENCODE_EXCEPTION: true, ENCODE_EXCEPTION_VALIDATE_CODEC: ["h264"], VIDEO_ENCODER_CONFIG_LIST: [{ width: 240, height: 180 }, { width: 320, height: 240 }, { width: 400, height: 300 }, { width: 480, height: 360 }, { width: 560, height: 420 }, { width: 640, height: 480 }], DELETE_NEQ_AFTER_USER_LEAVE: true, UPDATE_RTP_CAP_IN_HOST: false, IOS_BG_TAG: true, IOS_AUTO_RESTART_BG_TAG: true, IGNORE_UID_CHECK: false, ENABLE_UP_SPS_PPS: false, ENABLE_DOWN_SPS_PPS: false, NO_EDGES_RETRY: true, BUFFER_READY_FRAMES: 3, FLS_SYNC_AV_PLAY_LIMIT: 0, FLS_BUFFER_WAIT_TIME: 1500, VOS_CONFIGURE: void 0, ENABLE_QUALITY_FALLBACK: false, QUALITY_FALLBACK_REHEARSAL: true, ENABLE_FLS_AV1_FIRST: false, ENABLE_AP_MULTI_IP: true, FLS_ENABLE_AV1_DETECT: true, FLS_ENABLE_AV1_DECODE_DETECT: true }, TD = uO(uO(uO(uO({}, gD), {}, { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, NOT_REPORT_EVENT: [], PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, SHOW_REPORT_USER_INVOKER_LOG: true, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 250, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, FIRST_H264_PROFILE_LEVEL_ID: "42001f", FIRST_PACKETIZATION_MODE: "", X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_MANAGER_WSS: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, FINGERPRINT: null, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, ENABLE_AUDIO_TOPN: false, ENABLE_AUDIO_METADATA: false, ENABLE_AUDIO_PTS: false, TOPN_SMOOTH_LEVEL: void 0, TOPN_NEW_SPEAKER_DELAY: void 0, TOPN_SWITCH_HOLD_MS: void 0, TOPN_AUDIO_GAIN: void 0, TOPN_SILENCE_THRESHOLD: 250, AP_AREA: true, ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_WSS: "", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, DATASTREAM_MAX_RETRANSMITS: 10, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ENABLE_AUDIO_RED: false, OPUS_PTIME: void 0, AUDIO_DUPLICATE_NUM: void 0, ENABLE_ABSSENDTIME_AS_SENTTS: true, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, DC_JOIN_WITH_FAILBACK: 4e3, DC_CONNECTION_TIMEOUT: 2e3, DC_PINGPONG_INTERVAL: 2e3, DC_DEBUG_LOG: false, UNSUPPORTED_VIDEO_UPLINK_CODEC: [], UNSUPPORTED_VIDEO_DOWNLINK_CODEC: [], USE_NEW_NETWORK_CONFIG: false, AUTO_RESET_AUDIO_ROUTE: false, PLUGIN_INFO: [], OVERUSE_DETECTOR_PARAMS: fD, CUSTOM_ADAPTATION_DEFAULT_MODE: "", HIDE_NO_POSTER: false, AP_CACHE_NUM: 10, AP_UPDATE_INTERVAL: 12e4, AP_CACHE_LIFETIME: 12e4, MAX_PRELOAD_ASYNC_LENGTH: 3, DISABLE_SCREEN_SHARE_REMB: false }, mD), {}, { USE_CANDIDATE_FROM_AP_DETAIL: false, AP_REQUEST_DETAIL: void 0, ENABLE_ROLE_SELECT_EDGE: false, CLIENT_ROLE_OPTIONS: void 0, REMOTE_VIDEO_STREAM_TYPE: void 0, COMPATIBLE_SDP_EXTENSION: ["gdpr_forbidden"], LIMIT_BITRATE: void 0, EXPERIMENTS: {}, USE_PUB_RTX: true, USE_SUB_RTX: true, ENABLE_DATASTREAM_2: false, USE_XR: true, ENABLE_PREALLOC_PC: false, ENABLE_PRE_SUB: false, ENABLE_SVC: false, ENABLE_FORCE_HLS: false, MAX_WEBAUDIO_VOLUME: 300, ENABLE_VOS_FALLBACK: false, ENABLE_FALLBACK_TO_HLS: false, ENABLE_PRE_RENDER: false, FORCE_DISABLE_AUTO_SUB: false, ENABLE_PRE_SUB_WITH_PRE_PC: true, PRE_USE_LOCAL_CODECS: true }, { INSTALL_ID: "" }), {}, { K_MIN_RENDER_DELAY: 66, USE_STANDARD_BITRATE_DEFAULT: false, VIDEO_NEW_BITRATE_RATIO: void 0, VIDEO_STANDARD_BITRATE_VERSION: 2, BASELINE_MORE_H264_BITRATE_RATIO: 1.1, IGNORE_RTC_DEVICE_CHECK: false, FLS_AUTOPLAY_EMITS: false, ENABLE_DUAL_STREAM_FLAG: false, FORBID_MODIFY_LOCAL_OFFER_SDP: false, RESERVE_MID_1_MLINE: false });
      function RD(e2, t2, i2) {
        var n2, r2, o2;
        Ln(n2 = Object.keys(TD)).call(n2, e2) && (!i2 && Ln(r2 = Object.keys(yD)).call(r2, e2) || (TD[e2] = t2, "ENABLE_VIDEO_SEI" !== e2 && "ENABLE_AUDIO_TOPN" !== e2 && "ENABLE_AUDIO_METADATA" !== e2 && "ENABLE_AUDIO_PTS" !== e2 || true !== t2 || (TD.ENABLE_ENCODED_TRANSFORM = true), "USE_NEW_NETWORK_CONFIG" === e2 && t2 && (o2 = !!t2, TD.USE_NEW_NETWORK_CONFIG = o2, o2 && (TD.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"], TD.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"], TD.CDS_AP = ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], TD.ACCOUNT_REGISTER = ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], TD.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com", TD.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io", TD.GATEWAY_DOMAINS = ["edge.sd-rtn.com"])), "ENABLE_PRE_SUB" === e2 && t2 && (TD.ENABLE_INSTANT_VIDEO = true, TD.ENABLE_PREALLOC_PC = true), "ENABLE_SVC" === e2 && t2 && (TD.ENABLE_AUT_CC = true), "NEW_FORCE_TURN" === e2 && t2 && (TD.NEW_TURN_MODE || (TD.NEW_TURN_MODE = 4))));
      }
      function CD(e2) {
        if ("TURN_DOMAINS" === e2) {
          const e3 = TD.TURN_DOMAINS;
          return Ln(e3).call(e3, CD("TURN_DOMAIN")) ? e3 : [CD("TURN_DOMAIN")].concat(e3);
        }
        return TD[e2];
      }
      pD || (TD.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], TD.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], TD.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], TD.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], TD.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], TD.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], TD.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", TD.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", TD.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", TD.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", TD.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      let vD = (function(e2) {
        return e2[e2.REALTIME = 1] = "REALTIME", e2;
      })({});
      const yD = {};
      var ID = (function(e2) {
        return e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_RTE_URL = "SET_RTE_URL", e2.SET_RTE_SID = "SET_RTE_SID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_INT_UID = "SET_INT_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.KEY_METRIC_PRELOAD_START = "KEY_METRIC_PRELOAD_START", e2.KEY_METRIC_PRELOAD_END = "KEY_METRIC_PRELOAD_END", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_REQUEST_SUA_END = "KEY_METRIC_REQUEST_SUA_END", e2.KEY_METRIC_BEFORE_CONNECT = "KEY_METRIC_BEFORE_CONNECT", e2.KEY_METRIC_PEER_RECEIVER = "KEY_METRIC_PEER_RECEIVER", e2.KEY_METRIC_SIGNAL_CONNECTED = "KEY_METRIC_SIGNAL_CONNECTED", e2.KEY_METRIC_JOIN_REQ = "KEY_METRIC_JOIN_REQ", e2.KEY_METRIC_JOIN_REP = "KEY_METRIC_JOIN_REP", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED = "KEY_METRIC_FIRST_VIDEO_FRAME_DECODED", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.RESET_FIRST_VIDEO_FRAME_DECODED = "RESET_FIRST_VIDEO_FRAME_DECODED", e2.SET_USE_P2P = "SET_USE_P2P", e2.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE", e2;
      })(ID || {});
      let AD = (function(e2) {
        return e2.h264 = "h264", e2.h265 = "h265", e2.vp8 = "vp8", e2.vp9 = "vp9", e2.av1 = "av1", e2;
      })({});
      !(function(e2) {
        e2.opus = "opus", e2.pcma = "pcma", e2.pcmu = "pcmu", e2.g722 = "g722";
      })({});
      const bD = 128, wD = 96, OD = 1e3, ND = 10;
      let DD = 0;
      var PD = (() => {
        var e2 = { 8: (e3, t3, i3) => {
          i3.r(t3), i3.d(t3, { Parser: () => C2, Printer: () => b2, parse: () => D2, print: () => P2 });
          const n2 = "\n", r2 = "".concat("\r").concat(n2), o2 = " ";
          let s2;
          function a2(e4) {
            return e4 >= "0" && e4 <= "9";
          }
          function c2(e4) {
            return e4 >= "!" && e4 <= "~";
          }
          function d2(e4) {
            return c2(e4) || e4 >= "Â" && e4 <= "Ã¿";
          }
          function l2(e4) {
            return "!" === e4 || e4 >= "#" && e4 <= "'" || e4 >= "*" && e4 <= "+" || e4 >= "-" && e4 <= "." || e4 >= "0" && e4 <= "9" || e4 >= "A" && e4 <= "Z" || e4 >= "^" && e4 <= "~";
          }
          function u2(e4) {
            return e4 >= "1" && e4 <= "9";
          }
          function h2(e4) {
            return e4 >= "A" && e4 <= "Z" || e4 >= "a" && e4 <= "z";
          }
          function p2(e4) {
            return "d" === e4 || "h" === e4 || "m" === e4 || "s" === e4;
          }
          function _2(e4) {
            return e4 > "" && e4 < "	" || e4 > "\v" && e4 < "\f" || e4 > "" && e4 < "Ã¿";
          }
          function E2(e4) {
            return h2(e4) || a2(e4) || "+" === e4 || "/" === e4;
          }
          function m2(e4) {
            return a2(e4) || h2(e4) || "+" === e4 || "/" === e4 || "-" === e4 || "_" === e4;
          }
          function f2(e4) {
            return h2(e4) || a2(e4) || "+" === e4 || "/" === e4;
          }
          function S2(e4, t4) {
            var i4 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(e4);
              t4 && (n3 = n3.filter((function(t5) {
                return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
              }))), i4.push.apply(i4, n3);
            }
            return i4;
          }
          function g2(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i4 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? S2(Object(i4), true).forEach((function(t5) {
                T2(e4, t5, i4[t5]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : S2(Object(i4)).forEach((function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i4, t5));
              }));
            }
            return e4;
          }
          function T2(e4, t4, i4) {
            return t4 in e4 ? Object.defineProperty(e4, t4, { value: i4, enumerable: true, configurable: true, writable: true }) : e4[t4] = i4, e4;
          }
          !(function(e4) {
            e4.VERSION = "v", e4.ORIGIN = "o", e4.SESSION_NAME = "s", e4.INFORMATION = "i", e4.URI = "u", e4.EMAIL = "e", e4.PHONE = "p", e4.CONNECTION = "c", e4.BANDWIDTH = "b", e4.TIME = "t", e4.REPEAT = "r", e4.ZONE_ADJUSTMENTS = "z", e4.KEY = "k", e4.ATTRIBUTE = "a", e4.MEDIA = "m";
          })(s2 || (s2 = {}));
          class R2 {
            consumeText(e4, t4) {
              let i4 = t4;
              for (; i4 < e4.length; ) {
                const t5 = e4[i4];
                if ("\0" === t5 || "\r" === t5 || t5 === n2) break;
                i4 += 1;
              }
              if (i4 - t4 == 0) throw new Error("Invalid text, at ".concat(e4));
              return i4;
            }
            consumeUnicastAddress(e4, t4, i4) {
              return this.consumeTill(e4, t4, o2);
            }
            consumeOneOrMore(e4, t4, i4) {
              let n3 = t4;
              for (; i4(e4[n3]); ) n3++;
              if (n3 - t4 == 0) throw new Error("Invalid rule at ".concat(t4, "."));
              return n3;
            }
            consumeSpace(e4, t4) {
              if (e4[t4] === o2) return t4 + 1;
              throw new Error("Invalid space at ".concat(t4, "."));
            }
            consumeIP4Address(e4, t4) {
              let i4 = t4;
              for (let t5 = 0; t5 < 4; t5++) if (i4 = this.consumeDecimalUChar(e4, i4), 3 !== t5) {
                if ("." !== e4[i4]) throw new Error("Invalid IP4 address.");
                i4++;
              }
              return i4;
            }
            consumeDecimalUChar(e4, t4) {
              let i4 = t4;
              for (let t5 = 0; t5 < 3 && a2(e4[i4]); t5++, i4++) ;
              if (i4 - t4 == 0) throw new Error("Invalid decimal uchar.");
              const n3 = parseInt(e4.slice(t4, i4));
              if (n3 >= 0 && n3 <= 255) return i4;
              throw new Error("Invalid decimal uchar");
            }
            consumeIP6Address(e4, t4) {
              let i4 = this.consumeHexpart(e4, t4);
              return ":" === e4[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e4, i4), i4) : i4;
            }
            consumeHexpart(e4, t4) {
              let i4 = t4;
              if (":" === e4[i4] && ":" === e4[i4 + 1]) {
                i4 += 2;
                try {
                  i4 = this.consumeHexseq(e4, i4);
                } catch (e5) {
                }
                return i4;
              }
              if (i4 = this.consumeHexseq(e4, i4), ":" === e4[i4] && ":" === e4[i4 + 1]) {
                i4 += 2;
                try {
                  i4 = this.consumeHexseq(e4, i4);
                } catch (e5) {
                }
                return i4;
              }
              return i4;
            }
            consumeHexseq(e4, t4) {
              let i4 = t4;
              for (; i4 = this.consumeHex4(e4, i4), ":" === e4[i4] && ":" !== e4[i4 + 1]; ) i4 += 1;
              return i4;
            }
            consumeHex4(e4, t4) {
              let i4 = 0;
              for (; i4 < 4; i4++) if (!((n3 = e4[t4 + i4]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                if (0 === i4) throw new Error("Invalid hex 4");
                break;
              }
              var n3;
              return t4 + i4;
            }
            consumeFQDN(e4, t4) {
              let i4 = t4;
              for (; a2(e4[i4]) || h2(e4[i4]) || "-" === e4[i4] || "." === e4[i4]; ) i4 += 1;
              if (i4 - t4 < 4) throw new Error("Invalid FQDN");
              return i4;
            }
            consumeExtnAddr(e4, t4) {
              return this.consumeOneOrMore(e4, t4, d2);
            }
            consumeMulticastAddress(e4, t4, i4) {
              switch (i4) {
                case "IP4":
                case "ip4":
                  return this.consumeIP4MulticastAddress(e4, t4);
                case "IP6":
                case "ip6":
                  return this.consumeIP6MulticastAddress(e4, t4);
                default:
                  try {
                    return this.consumeFQDN(e4, t4);
                  } catch (i5) {
                    return this.consumeExtnAddr(e4, t4);
                  }
              }
            }
            consumeIP6MulticastAddress(e4, t4) {
              const i4 = this.consumeHexpart(e4, t4);
              return "/" === e4[i4] ? this.consumeInteger(e4, i4 + 1) : i4;
            }
            consumeIP4MulticastAddress(e4, t4) {
              let i4 = t4 + 3;
              const n3 = e4.slice(t4, i4), r3 = parseInt(n3);
              if (r3 < 224 || r3 > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
              for (let t5 = 0; t5 < 3; t5++) {
                if ("." !== e4[i4]) throw new Error("Invalid IP4 multicast address.");
                i4 += 1, i4 = this.consumeDecimalUChar(e4, i4);
              }
              return "/" === e4[i4] && (i4 += 1), i4 = this.consumeTTL(e4, i4), "/" === e4[i4] && (i4 = this.consumeInteger(e4, i4)), i4;
            }
            consumeInteger(e4, t4) {
              if (!u2(e4[t4])) throw new Error("Invalid integer.");
              for (t4 += 1; a2(e4[t4]); ) t4 += 1;
              return t4;
            }
            consumeTTL(e4, t4) {
              if ("0" === e4[t4]) return t4 + 1;
              if (!u2(e4[t4])) throw new Error("Invalid TTL.");
              t4 += 1;
              for (let i4 = 0; i4 < 2 && a2(e4[t4]); i4++) t4 += 1;
              return t4;
            }
            consumeToken(e4, t4) {
              return this.consumeOneOrMore(e4, t4, l2);
            }
            consumeTime(e4, t4) {
              let i4 = t4;
              if ("0" === e4[i4]) return i4 + 1;
              for (u2(e4[i4]) && (i4 += 1); a2(e4[i4]); ) i4++;
              if (i4 - t4 < 10) throw new Error("Invalid time");
              return i4;
            }
            consumeAddress(e4, t4) {
              return this.consumeTill(e4, t4, o2);
            }
            consumeTypedTime(e4, t4) {
              let i4 = t4;
              return i4 = this.consumeOneOrMore(e4, i4, a2), p2(e4[i4]) ? i4 + 1 : i4;
            }
            consumeRepeatInterval(e4, t4) {
              if (!u2(e4[t4])) throw new Error("Invalid repeat interval");
              for (t4 += 1; a2(e4[t4]); ) t4 += 1;
              return p2(e4[t4]) && (t4 += 1), t4;
            }
            consumePort(e4, t4) {
              return this.consumeOneOrMore(e4, t4, a2);
            }
            consume(e4, t4, i4) {
              for (let n3 = 0; n3 < i4.length; n3++) {
                if (t4 + n3 >= e4.length) throw new Error("consume exceeding value length");
                if (e4[t4 + n3] !== i4[n3]) throw new Error("consume ".concat(i4, " failed at ").concat(n3));
              }
              return t4 + i4.length;
            }
            consumeTill(e4, t4, i4) {
              let n3 = t4;
              for (; n3 < e4.length && ("string" != typeof i4 || e4[n3] !== i4) && ("function" != typeof i4 || !i4(e4[n3])); ) n3++;
              return n3;
            }
          }
          class C2 extends R2 {
            constructor() {
              super(), T2(this, "records", []), T2(this, "currentLine", 0);
            }
            parse(e4) {
              const t4 = this.probeEOL(e4);
              this.records = e4.split(t4).filter(((e5) => !!kg(e5).call(e5))).map(this.parseLine), this.currentLine = 0;
              const i4 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), u3 = this.parseTimeFields(), h3 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
              if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
              return { version: i4, origin: n3, sessionName: r3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: l3, timeFields: u3, key: h3, attributes: p3, mediaDescriptions: _3 };
            }
            getCurrentRecord() {
              const e4 = this.records[this.currentLine];
              if (!e4) throw new Error("Record doesn't exit.");
              return e4;
            }
            probeEOL(e4) {
              for (let t4 = 0; t4 < e4.length; t4++) if (e4[t4] === n2) return "\r" === e4[t4 - 1] ? r2 : n2;
              throw new Error("Invalid newline character.");
            }
            parseLine(e4, t4) {
              if (e4.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
              const i4 = e4[0];
              if ("=" !== e4[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
              return { type: i4, value: e4.slice(2), line: t4, cur: 0 };
            }
            parseSessionAttribute() {
              const e4 = new y2();
              for (; this.currentLine < this.records.length; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.ATTRIBUTE) break;
                const i4 = { attField: this.extractOneOrMore(t4, ((e5) => l2(e5) && ":" !== e5)), _cur: 0 };
                ":" === t4.value[t4.cur] && (t4.cur += 1, i4.attValue = this.extractOneOrMore(t4, _2)), e4.parse(i4), this.currentLine++;
              }
              return e4.digest();
            }
            parseMediaAttributes(e4) {
              const t4 = new I2(e4);
              for (; this.currentLine < this.records.length; ) {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.ATTRIBUTE) break;
                const i4 = { attField: this.extractOneOrMore(e5, ((e6) => l2(e6) && ":" !== e6)), _cur: 0 };
                ":" === e5.value[e5.cur] && (e5.cur += 1, i4.attValue = this.extractOneOrMore(e5, _2)), t4.parse(i4), this.currentLine++;
              }
              return t4.digest();
            }
            parseKey() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.KEY) {
                if ("prompt" === e4.value || "clear:" === e4.value || "base64:" === e4.value || "uri:" === e4.value) return e4.value;
                throw this.currentLine++, new Error("Invalid key.");
              }
            }
            parseZone() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.ZONE_ADJUSTMENTS) {
                const t4 = [];
                for (; ; ) try {
                  const i4 = this.extract(e4, this.consumeTime);
                  this.consumeSpaceForRecord(e4);
                  let n3 = false;
                  "-" === e4.value[e4.cur] && (n3 = true, e4.cur += 1);
                  const r3 = this.extract(e4, this.consumeTypedTime);
                  t4.push({ time: i4, typedTime: r3, back: n3 });
                } catch (e5) {
                  break;
                }
                if (0 === t4.length) throw new Error("Invalid zone adjustments");
                return this.currentLine++, t4;
              }
              return [];
            }
            parseRepeat() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.REPEAT) break;
                {
                  const i4 = this.extract(t4, this.consumeRepeatInterval), n3 = this.parseTypedTime(t4);
                  e4.push({ repeatInterval: i4, typedTimes: n3 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseTypedTime(e4) {
              const t4 = [];
              for (; ; ) try {
                this.consumeSpaceForRecord(e4), t4.push(this.extract(e4, this.consumeTypedTime));
              } catch (e5) {
                break;
              }
              if (0 === t4.length) throw new Error("Invalid typed time.");
              return t4;
            }
            parseTime() {
              const e4 = this.getCurrentRecord(), t4 = this.extract(e4, this.consumeTime);
              this.consumeSpaceForRecord(e4);
              const i4 = this.extract(e4, this.consumeTime);
              return this.currentLine++, { startTime: t4, stopTime: i4 };
            }
            parseBandWidth() {
              const e4 = [];
              for (; this.currentLine < this.records.length; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.BANDWIDTH) break;
                {
                  const i4 = this.extractOneOrMore(t4, l2);
                  if (":" !== t4.value[t4.cur]) throw new Error("Invalid bandwidth field.");
                  t4.cur++;
                  const n3 = this.extractOneOrMore(t4, a2);
                  e4.push({ bwtype: i4, bandwidth: n3 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseVersion() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.VERSION) throw new Error("first sdp record must be version");
              const t4 = e4.value.slice(0, this.consumeOneOrMore(e4.value, 0, a2));
              if (t4.length !== e4.value.length) throw new Error('invalid proto version, "v='.concat(e4.value, '"'));
              return this.currentLine++, t4;
            }
            parseOrigin() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.ORIGIN) throw new Error("second line of sdp must be origin");
              const t4 = this.extractOneOrMore(e4, d2);
              this.consumeSpaceForRecord(e4);
              const i4 = this.extractOneOrMore(e4, a2);
              this.consumeSpaceForRecord(e4);
              const n3 = this.extractOneOrMore(e4, a2);
              this.consumeSpaceForRecord(e4);
              const r3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const o3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const c3 = this.extract(e4, this.consumeUnicastAddress);
              return this.currentLine++, { username: t4, sessId: i4, sessVersion: n3, nettype: r3, addrtype: o3, unicastAddress: c3 };
            }
            parseSessionName() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.SESSION_NAME) {
                const t4 = this.extract(e4, this.consumeText);
                return this.currentLine++, t4;
              }
            }
            parseInformation() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.INFORMATION) return;
              const t4 = this.extract(e4, this.consumeText);
              return this.currentLine++, t4;
            }
            parseUri() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.URI) return this.currentLine++, e4.value;
            }
            parseEmail() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.EMAIL) break;
                e4.push(t4.value), this.currentLine++;
              }
              return e4;
            }
            parsePhone() {
              const e4 = [];
              for (; ; ) {
                const t4 = this.getCurrentRecord();
                if (t4.type !== s2.PHONE) break;
                e4.push(t4.value), this.currentLine++;
              }
              return e4;
            }
            parseConnection() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.CONNECTION) {
                const t4 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const i4 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const n3 = this.extract(e4, this.consumeAddress);
                return this.currentLine++, { nettype: t4, addrtype: i4, address: n3 };
              }
            }
            parseMedia() {
              const e4 = this.getCurrentRecord(), t4 = this.extract(e4, this.consumeToken);
              this.consumeSpaceForRecord(e4);
              let i4 = this.extract(e4, this.consumePort);
              "/" === e4.value[e4.cur] && (e4.cur += 1, i4 += this.extract(e4, this.consumeInteger)), this.consumeSpaceForRecord(e4);
              const n3 = [];
              for (n3.push(this.extract(e4, this.consumeToken)); "/" === e4.value[e4.cur]; ) e4.cur += 1, n3.push(this.extract(e4, this.consumeToken));
              if (0 === n3.length) throw new Error("Invalid proto");
              const r3 = this.parseFmt(e4);
              return this.currentLine++, { mediaType: t4, port: i4, protos: n3, fmts: r3 };
            }
            parseTimeFields() {
              const e4 = [];
              for (; this.getCurrentRecord().type === s2.TIME; ) {
                const t4 = this.parseTime(), i4 = this.parseRepeat(), n3 = this.parseZone();
                e4.push({ time: t4, repeats: i4, zones: n3 });
              }
              return e4;
            }
            parseMediaDescription() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                const t4 = this.parseMedia(), i4 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t4);
                e4.push({ media: t4, information: i4, connections: n3, bandwidths: r3, key: o3, attributes: s3 });
              }
              return e4;
            }
            parseConnections() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; ) e4.push(this.parseConnection());
              return e4;
            }
            parseFmt(e4) {
              const t4 = [];
              for (; ; ) try {
                this.consumeSpaceForRecord(e4), t4.push(this.extract(e4, this.consumeToken));
              } catch (e5) {
                break;
              }
              if (0 === t4.length) throw new Error("Invalid fmts");
              return t4;
            }
            extract(e4, t4) {
              for (var i4 = arguments.length, n3 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n3[r3 - 2] = arguments[r3];
              const o3 = t4.call(this, e4.value, e4.cur, ...n3), s3 = e4.value.slice(e4.cur, o3);
              return e4.cur = o3, s3;
            }
            extractOneOrMore(e4, t4) {
              const i4 = this.consumeOneOrMore(e4.value, e4.cur, t4), n3 = e4.value.slice(e4.cur, i4);
              return e4.cur = i4, n3;
            }
            consumeSpaceForRecord(e4) {
              if (e4.value[e4.cur] !== o2) throw new Error("Invalid space at ".concat(e4.cur, "."));
              e4.cur += 1;
            }
          }
          class v2 extends R2 {
            constructor() {
              super(...arguments), T2(this, "attributes", void 0), T2(this, "digested", false);
            }
            extractOneOrMore(e4, t4, i4) {
              const n3 = this.consumeOneOrMore(e4.attValue, e4._cur, t4), r3 = e4.attValue.slice(e4._cur, n3), [o3, s3] = i4 || [];
              if ("number" == typeof o3 && r3.length < o3) throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
              if ("number" == typeof s3 && r3.length > s3) throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
              return e4._cur = n3, r3;
            }
            consumeAttributeSpace(e4) {
              if (e4.attValue[e4._cur] !== o2) throw new Error("Invalid space at ".concat(e4._cur, "."));
              e4._cur += 1;
            }
            extract(e4, t4) {
              if (!e4.attValue) throw new Error("Nothing to extract from attValue.");
              for (var i4 = arguments.length, n3 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n3[r3 - 2] = arguments[r3];
              const o3 = t4.call(this, e4.attValue, e4._cur, ...n3), s3 = e4.attValue.slice(e4._cur, o3);
              return e4._cur = o3, s3;
            }
            atEnd(e4) {
              if (!e4.attValue) throw new Error();
              return e4._cur >= e4.attValue.length;
            }
            peekChar(e4) {
              if (!e4.attValue) throw new Error();
              return e4.attValue[e4._cur];
            }
            peek(e4, t4) {
              if (!e4.attValue) throw new Error();
              for (let i4 = 0; i4 < t4.length; i4++) if (t4[i4] !== e4.attValue[e4._cur + i4]) return false;
              return true;
            }
            parseIceUfrag(e4) {
              if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
              this.attributes.iceUfrag = this.extractOneOrMore(e4, E2, [4, 256]);
            }
            parseIcePwd(e4) {
              if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
              this.attributes.icePwd = this.extractOneOrMore(e4, E2, [22, 256]);
            }
            parseIceOptions(e4) {
              if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
              const t4 = [];
              for (; !this.atEnd(e4); ) {
                t4.push(this.extractOneOrMore(e4, E2));
                try {
                  this.consumeAttributeSpace(e4);
                } catch (t5) {
                  if (this.atEnd(e4)) break;
                  throw t5;
                }
              }
              this.attributes.iceOptions = t4;
            }
            parseFingerprint(e4) {
              const t4 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill);
              this.attributes.fingerprints.push({ hashFunction: t4, fingerprint: i4 });
            }
            parseExtmap(e4) {
              const t4 = this.extractOneOrMore(e4, a2);
              let i4;
              "/" === this.peekChar(e4) && (this.extract(e4, this.consume, "/"), i4 = this.extract(e4, this.consumeToken)), this.consumeAttributeSpace(e4);
              const n3 = this.extract(e4, this.consumeTill, o2), r3 = g2(g2({ entry: parseInt(t4, 10) }, i4 && { direction: i4 }), {}, { extensionName: n3 });
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), r3.extensionAttributes = this.extract(e4, this.consumeTill)), this.attributes.extmaps.push(r3);
            }
            parseSetup(e4) {
              if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
              const t4 = this.extract(e4, this.consumeTill);
              if ("active" !== t4 && "passive" !== t4 && "actpass" !== t4 && "holdconn" !== t4) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
              this.attributes.setup = t4;
            }
          }
          class y2 extends v2 {
            constructor() {
              super(...arguments), T2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
            }
            parse(e4) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "group":
                    this.parseGroup(e4);
                    break;
                  case "ice-lite":
                    this.parseIceLite();
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "tls-id":
                    this.parseTlsId(e4);
                    break;
                  case "identity":
                    this.parseIdentity(e4);
                    break;
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "msid-semantic":
                    this.parseMsidSemantic(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t4) {
                throw console.error("parsing session attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t4;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4)) throw new Error("attribute parsing error");
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseGroup(e4) {
              const t4 = this.extract(e4, this.consumeToken), i4 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; ) this.consumeAttributeSpace(e4), i4.push(this.extract(e4, this.consumeToken));
              this.attributes.groups.push({ semantic: t4, identificationTag: i4 });
            }
            parseIceLite() {
              if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
              this.attributes.iceLite = true;
            }
            parseTlsId(e4) {
              if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
              this.attributes.tlsId = this.extractOneOrMore(e4, m2);
            }
            parseIdentity(e4) {
              const t4 = this.extractOneOrMore(e4, f2), i4 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t5 = this.extract(e4, this.consumeToken);
                this.extract(e4, this.consume, "=");
                const n3 = this.extractOneOrMore(e4, ((e5) => e5 !== o2 && _2(e5)));
                i4.push({ name: t5, value: n3 });
              }
              this.attributes.identities.push({ assertionValue: t4, extensions: i4 });
            }
            parseMsidSemantic(e4) {
              this.peekChar(e4) === o2 && this.consumeAttributeSpace(e4);
              const t4 = { semantic: this.extract(e4, this.consumeToken), identifierList: [] };
              for (; ; ) {
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
                if ("*" === this.peekChar(e4)) {
                  this.extract(e4, this.consume, "*"), t4.applyForAll = true;
                  break;
                }
                {
                  const i4 = this.extract(e4, this.consumeTill, o2);
                  t4.identifierList.push(i4);
                }
              }
              this.attributes.msidSemantic = t4;
            }
          }
          class I2 extends v2 {
            constructor(e4) {
              super(), T2(this, "attributes", void 0), -1 !== e4.protos.indexOf("RTP") || e4.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
            }
            parse(e4) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "candidate":
                    this.parseCandidate(e4);
                    break;
                  case "remote-candidate":
                    this.parseRemoteCandidate(e4);
                    break;
                  case "end-of-candidates":
                    this.parseEndOfCandidates();
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "rtpmap":
                    this.parseRtpmap(e4);
                    break;
                  case "ptime":
                    this.parsePtime(e4);
                    break;
                  case "maxptime":
                    this.parseMaxPtime(e4);
                    break;
                  case "sendrecv":
                  case "recvonly":
                  case "sendonly":
                  case "inactive":
                    this.parseDirection(e4);
                    break;
                  case "ssrc":
                    this.parseSSRC(e4);
                    break;
                  case "fmtp":
                    this.parseFmtp(e4);
                    break;
                  case "rtcp-fb":
                    this.parseRtcpFb(e4);
                    break;
                  case "rtcp-mux":
                    this.parseRTCPMux();
                    break;
                  case "rtcp-mux-only":
                    this.parseRTCPMuxOnly();
                    break;
                  case "rtcp-rsize":
                    this.parseRTCPRsize();
                    break;
                  case "rtcp":
                    this.parseRTCP(e4);
                    break;
                  case "mid":
                    this.parseMid(e4);
                    break;
                  case "msid":
                    this.parseMsid(e4);
                    break;
                  case "imageattr":
                    this.parseImageAttr(e4);
                    break;
                  case "rid":
                    this.parseRid(e4);
                    break;
                  case "simulcast":
                    this.parseSimulcast(e4);
                    break;
                  case "sctp-port":
                    this.parseSctpPort(e4);
                    break;
                  case "max-message-size":
                    this.parseMaxMessageSize(e4);
                    break;
                  case "ssrc-group":
                    this.parseSSRCGroup(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t4) {
                throw console.error("parsing media attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t4;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4)) throw new Error("attribute parsing error");
            }
            parseCandidate(e4) {
              const t4 = this.extractOneOrMore(e4, E2, [1, 32]);
              this.consumeAttributeSpace(e4);
              const i4 = this.extractOneOrMore(e4, a2, [1, 5]);
              this.consumeAttributeSpace(e4);
              const n3 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const r3 = this.extractOneOrMore(e4, a2, [1, 10]);
              this.consumeAttributeSpace(e4);
              const s3 = this.extract(e4, this.consumeAddress);
              this.consumeAttributeSpace(e4);
              const d3 = this.extract(e4, this.consumePort);
              this.consumeAttributeSpace(e4), this.extract(e4, this.consume, "typ"), this.consumeAttributeSpace(e4);
              const l3 = { foundation: t4, componentId: i4, transport: n3, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e4, this.consumeToken), extension: {} };
              for (this.peek(e4, " raddr") && (this.extract(e4, this.consume, " raddr"), this.consumeAttributeSpace(e4), l3.relAddr = this.extract(e4, this.consumeAddress)), this.peek(e4, " rport") && (this.extract(e4, this.consume, " rport"), this.consumeAttributeSpace(e4), l3.relPort = this.extract(e4, this.consumePort)); this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t5 = this.extract(e4, this.consumeToken);
                this.consumeAttributeSpace(e4), l3.extension[t5] = this.extractOneOrMore(e4, c2);
              }
              this.attributes.candidates.push(l3);
            }
            parseRemoteCandidate(e4) {
              const t4 = [];
              for (; ; ) {
                const i4 = this.extractOneOrMore(e4, a2, [1, 5]);
                this.consumeAttributeSpace(e4);
                const n3 = this.extract(e4, this.consumeAddress);
                this.consumeAttributeSpace(e4);
                const r3 = this.extract(e4, this.consumePort);
                t4.push({ componentId: i4, connectionAddress: n3, port: r3 });
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
              }
              this.attributes.remoteCandidatesList.push(t4);
            }
            parseEndOfCandidates() {
              if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
              this.attributes.endOfCandidates = true;
            }
            parseRtpmap(e4) {
              const t4 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, "/");
              this.extract(e4, this.consume, "/");
              const n3 = { encodingName: i4, clockRate: this.extractOneOrMore(e4, a2) };
              this.atEnd(e4) || "/" !== this.peekChar(e4) || (this.extract(e4, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e4, this.consumeTill), 10));
              const r3 = this.attributes.payloads.find(((e5) => e5.payloadType === parseInt(t4, 10)));
              r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtpMap: n3, rtcpFeedbacks: [] });
            }
            parsePtime(e4) {
              if (this.attributes.ptime) throw new Error("must be only one line of ptime");
              this.attributes.ptime = this.extract(e4, this.consumeTill);
            }
            parseMaxPtime(e4) {
              if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
              this.attributes.maxPtime = this.extract(e4, this.consumeTill);
            }
            parseDirection(e4) {
              if (this.attributes.direction) throw new Error("must be only one line of direction info");
              this.attributes.direction = e4.attField;
            }
            parseSSRC(e4) {
              const t4 = this.extractOneOrMore(e4, a2);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, ":");
              let n3;
              ":" === this.peekChar(e4) && (this.extract(e4, this.consume, ":"), n3 = this.extract(e4, this.consumeTill));
              const r3 = this.attributes.ssrcs.find(((e5) => e5.ssrcId === parseInt(t4, 10)));
              r3 ? r3.attributes[i4] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t4, 10), attributes: { [i4]: n3 } });
            }
            parseFmtp(e4) {
              const t4 = this.extract(e4, this.consumeTill, o2);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill), n3 = {};
              i4.split(";").forEach(((e5) => {
                let [t5, i5] = e5.split("=");
                t5 = kg(t5).call(t5);
                const r4 = "string" == typeof i5 ? kg(i5).call(i5) : null;
                "string" == typeof t5 && t5.length > 0 && (n3[t5] = r4);
              }));
              const r3 = this.attributes.payloads.find(((e5) => e5.payloadType === parseInt(t4, 10)));
              r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
            }
            parseFmtParameters(e4) {
              const t4 = {}, i4 = this.extract(e4, this.consumeTill, "=");
              e4._cur++;
              const n3 = this.extract(e4, this.consumeTill, ";");
              for (t4[i4] = n3; ";" === e4.attValue[e4._cur]; ) {
                const i5 = this.extract(e4, this.consumeTill, "=");
                e4._cur++;
                const n4 = this.extract(e4, this.consumeTill, ";");
                t4[i5] = n4;
              }
              return t4;
            }
            parseRtcpFb(e4) {
              let t4 = "";
              t4 = "*" === this.peekChar(e4) ? this.extract(e4, this.consume, "*") : this.extract(e4, this.consumeTill, o2), this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, o2);
              let n3;
              if ("trr-int" === i4) n3 = { type: i4, interval: this.extract(e4, this.consumeTill) };
              else {
                const t5 = { type: i4 };
                this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t5.parameter = this.extract(e4, this.consumeToken), this.peekChar(e4) === o2 && (t5.additional = this.extract(e4, this.consumeTill))), n3 = t5;
              }
              if ("*" === t4) this.attributes.rtcpFeedbackWildcards.push(n3);
              else {
                const e5 = this.attributes.payloads.find(((e6) => e6.payloadType === parseInt(t4, 10)));
                e5 ? e5.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t4, 10), rtcpFeedbacks: [n3] });
              }
            }
            parseRTCPMux() {
              if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
              this.attributes.rtcpMux = true;
            }
            parseRTCPMuxOnly() {
              if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
              this.attributes.rtcpMuxOnly = true;
            }
            parseRTCPRsize() {
              if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
              this.attributes.rtcpRsize = true;
            }
            parseRTCP(e4) {
              if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
              const t4 = { port: this.extract(e4, this.consumePort) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t4.netType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t4.addressType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t4.address = this.extract(e4, this.consumeAddress)), this.attributes.rtcp = t4;
            }
            parseMsid(e4) {
              const t4 = { id: this.extractOneOrMore(e4, l2, [1, 64]) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t4.appdata = this.extractOneOrMore(e4, l2, [1, 64])), this.attributes.msids.push(t4);
            }
            parseImageAttr(e4) {
              this.attributes.imageattr.push(e4.attValue);
            }
            parseRid(e4) {
              const t4 = this.extractOneOrMore(e4, ((e5) => h2(e5) || a2(e5) || "_" === e5 || "-" === e5));
              this.consumeAttributeSpace(e4);
              const i4 = { id: t4, direction: this.extract(e4, this.consumeToken), params: [] };
              if (this.peekChar(e4) === o2) {
                if (this.consumeAttributeSpace(e4), this.peek(e4, "pt=")) {
                  this.extract(e4, this.consume, "pt=");
                  const t5 = [];
                  for (; ; ) {
                    const i5 = this.extract(e4, this.consumeToken);
                    t5.push(i5);
                    try {
                      this.extract(e4, this.consume, ",");
                    } catch (e5) {
                      break;
                    }
                  }
                  i4.payloads = t5, this.peekChar(e4) === o2 && this.extract(e4, this.consume, o2);
                }
                for (; ; ) {
                  const t5 = this.extract(e4, this.consumeToken);
                  switch (t5) {
                    case "depend": {
                      const n3 = { type: t5, rids: this.extract(e4, this.consume, "=").split(",") };
                      i4.params.push(n3);
                      break;
                    }
                    default: {
                      const n3 = { type: t5 };
                      "=" === this.peekChar(e4) && (this.extract(e4, this.consume, "="), n3.val = this.extract(e4, this.consumeTill, ";")), i4.params.push(n3);
                    }
                  }
                  try {
                    this.extract(e4, this.consume, ";");
                  } catch (e5) {
                    break;
                  }
                }
              }
              this.attributes.rids.push(i4);
            }
            parseSimulcast(e4) {
              if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
              this.attributes.simulcast = e4.attValue, this.extract(e4, this.consumeTill);
            }
            parseSctpPort(e4) {
              this.attributes.sctpPort = this.extractOneOrMore(e4, a2, [1, 5]);
            }
            parseMaxMessageSize(e4) {
              this.attributes.maxMessageSize = this.extractOneOrMore(e4, a2, [1, void 0]);
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseMid(e4) {
              this.attributes.mid = this.extract(e4, this.consumeToken);
            }
            parseSSRCGroup(e4) {
              const t4 = this.extract(e4, this.consumeToken), i4 = [];
              for (; ; ) try {
                this.consumeAttributeSpace(e4);
                const t5 = this.extract(e4, this.consumeInteger);
                i4.push(parseInt(t5, 10));
              } catch (e5) {
                break;
              }
              this.attributes.ssrcGroups.push({ semantic: t4, ssrcIds: i4 });
            }
          }
          function A2(e4, t4, i4) {
            return t4 in e4 ? Object.defineProperty(e4, t4, { value: i4, enumerable: true, configurable: true, writable: true }) : e4[t4] = i4, e4;
          }
          class b2 {
            constructor() {
              A2(this, "eol", r2);
            }
            print(e4, t4) {
              let i4 = "";
              return t4 && (this.eol = t4), i4 += this.printVersion(e4.version), i4 += this.printOrigin(e4.origin), i4 += this.printSessionName(e4.sessionName), i4 += this.printInformation(e4.information), i4 += this.printUri(e4.uri), i4 += this.printEmail(e4.emails), i4 += this.printPhone(e4.phones), i4 += this.printConnection(e4.connection), i4 += this.printBandwidth(e4.bandwidths), i4 += this.printTimeFields(e4.timeFields), i4 += this.printKey(e4.key), i4 += this.printSessionAttributes(e4.attributes), i4 += this.printMediaDescription(e4.mediaDescriptions), i4;
            }
            printVersion(e4) {
              return "v=".concat(e4).concat(this.eol);
            }
            printOrigin(e4) {
              return "o=".concat(e4.username, " ").concat(e4.sessId, " ").concat(e4.sessVersion, " ").concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.unicastAddress).concat(this.eol);
            }
            printSessionName(e4) {
              return e4 ? "s=".concat(e4).concat(this.eol) : "";
            }
            printInformation(e4) {
              return e4 ? "i=".concat(e4).concat(this.eol) : "";
            }
            printUri(e4) {
              return e4 ? "u=".concat(e4).concat(this.eol) : "";
            }
            printEmail(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += "e=".concat(i4).concat(this.eol);
              return t4;
            }
            printPhone(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += "e=".concat(i4).concat(this.eol);
              return t4;
            }
            printConnection(e4) {
              return e4 ? "c=".concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.address).concat(this.eol) : "";
            }
            printBandwidth(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
              return t4;
            }
            printTimeFields(e4) {
              let t4 = "";
              for (const i4 of e4) {
                t4 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
                for (const e5 of i4.repeats) t4 += "r=".concat(e5.repeatInterval, " ").concat(e5.typedTimes.join(" ")).concat(this.eol);
                i4.zoneAdjustments && (t4 += "z=", t4 += "z=".concat(i4.zoneAdjustments.map(((e5) => "".concat(e5.time, " ").concat(e5.back ? "-" : "", " ").concat(e5.typedTime))).join(" ")).concat(this.eol), t4 += this.eol);
              }
              return t4;
            }
            printKey(e4) {
              return e4 ? "k=".concat(e4).concat(this.eol) : "";
            }
            printAttributes(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
              return t4;
            }
            printMediaDescription(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += this.printMedia(i4.media), t4 += this.printInformation(i4.information), t4 += this.printConnections(i4.connections), t4 += this.printBandwidth(i4.bandwidths), t4 += this.printKey(i4.key), t4 += this.printMediaAttributes(i4);
              return t4;
            }
            printConnections(e4) {
              let t4 = "";
              for (const i4 of e4) t4 += this.printConnection(i4);
              return t4;
            }
            printMedia(e4) {
              return "m=".concat(e4.mediaType, " ").concat(e4.port, " ").concat(e4.protos.join("/"), " ").concat(e4.fmts.join(" ")).concat(this.eol);
            }
            printSessionAttributes(e4) {
              return new O2(this.eol).print(e4);
            }
            printMediaAttributes(e4) {
              return new N2(this.eol).print(e4);
            }
          }
          class w2 {
            constructor(e4) {
              A2(this, "eol", void 0), this.eol = e4;
            }
            printIceUfrag(e4) {
              return void 0 === e4 ? "" : "a=ice-ufrag:".concat(e4).concat(this.eol);
            }
            printIcePwd(e4) {
              return void 0 === e4 ? "" : "a=ice-pwd:".concat(e4).concat(this.eol);
            }
            printIceOptions(e4) {
              return void 0 === e4 ? "" : "a=ice-options:".concat(e4.join(o2)).concat(this.eol);
            }
            printFingerprints(e4) {
              return e4.length > 0 ? e4.map(((e5) => "a=fingerprint:".concat(e5.hashFunction).concat(o2).concat(e5.fingerprint))).join(this.eol) + this.eol : "";
            }
            printExtmap(e4) {
              return e4.map(((e5) => "a=extmap:".concat(e5.entry).concat(e5.direction ? "/".concat(e5.direction) : "").concat(o2).concat(e5.extensionName).concat(e5.extensionAttributes ? "".concat(o2).concat(e5.extensionAttributes) : "").concat(this.eol))).join("");
            }
            printSetup(e4) {
              return void 0 === e4 ? "" : "a=setup:".concat(e4).concat(this.eol);
            }
            printUnrecognized(e4) {
              return e4.map(((e5) => "a=".concat(e5.attField).concat(e5.attValue ? ":".concat(e5.attValue) : "").concat(this.eol))).join("");
            }
          }
          class O2 extends w2 {
            print(e4) {
              let t4 = "";
              return t4 += this.printGroups(e4.groups), t4 += this.printMsidSemantic(e4.msidSemantic), t4 += this.printIceLite(e4.iceLite), t4 += this.printIceUfrag(e4.iceUfrag), t4 += this.printIcePwd(e4.icePwd), t4 += this.printIceOptions(e4.iceOptions), t4 += this.printFingerprints(e4.fingerprints), t4 += this.printSetup(e4.setup), t4 += this.printTlsId(e4.tlsId), t4 += this.printIdentity(e4.identities), t4 += this.printExtmap(e4.extmaps), t4 += this.printUnrecognized(e4.unrecognized), t4;
            }
            printGroups(e4) {
              let t4 = "";
              return e4.length > 0 && (t4 += e4.map(((e5) => "a=group:".concat(e5.semantic).concat(e5.identificationTag.map(((e6) => "".concat(o2).concat(e6))).join("")).concat(this.eol))).join("")), t4;
            }
            printIceLite(e4) {
              return void 0 === e4 ? "" : "a=ice-lite" + this.eol;
            }
            printTlsId(e4) {
              return e4 ? "a=tls-id:".concat(e4).concat(this.eol) : "";
            }
            printIdentity(e4) {
              return 0 === e4.length ? "" : e4.map(((e5) => "a=identity:".concat(e5.assertionValue).concat(e5.extensions.map(((e6) => "".concat(o2).concat(e6.name).concat(e6.value ? "=".concat(e6.value) : "")))))).join(this.eol) + this.eol;
            }
            printMsidSemantic(e4) {
              if (!e4) return "";
              let t4 = "a=msid-semantic:".concat(e4.semantic);
              return e4.applyForAll ? t4 += "".concat(o2, "*") : e4.identifierList.length > 0 && (t4 += e4.identifierList.map(((e5) => "".concat(o2).concat(e5)))), t4 + this.eol;
            }
          }
          class N2 extends w2 {
            print(e4) {
              const t4 = e4.attributes;
              let i4 = "";
              return i4 += this.printRTCP(t4.rtcp), i4 += this.printIceUfrag(t4.iceUfrag), i4 += this.printIcePwd(t4.icePwd), i4 += this.printIceOptions(t4.iceOptions), i4 += this.printCandidates(t4.candidates), i4 += this.printRemoteCandidatesList(t4.remoteCandidatesList), i4 += this.printEndOfCandidates(t4.endOfCandidates), i4 += this.printFingerprints(t4.fingerprints), i4 += this.printSetup(t4.setup), i4 += this.printMid(t4.mid), i4 += this.printExtmap(t4.extmaps), i4 += this.printRTPRelated(t4), i4 += this.printPtime(t4.ptime), i4 += this.printMaxPtime(t4.maxPtime), i4 += this.printDirection(t4.direction), i4 += this.printSSRCGroups(t4.ssrcGroups), i4 += this.printSSRC(t4.ssrcs), i4 += this.printRTCPMux(t4.rtcpMux), i4 += this.printRTCPMuxOnly(t4.rtcpMuxOnly), i4 += this.printRTCPRsize(t4.rtcpRsize), i4 += this.printMSId(t4.msids), i4 += this.printImageattr(t4.imageattr), i4 += this.printRid(t4.rids), i4 += this.printSimulcast(t4.simulcast), i4 += this.printSCTPPort(t4.sctpPort), i4 += this.printMaxMessageSize(t4.maxMessageSize), i4 += this.printUnrecognized(t4.unrecognized), i4;
            }
            printCandidates(e4) {
              return e4.map(((e5) => "a=candidate:".concat(e5.foundation).concat(o2).concat(e5.componentId).concat(o2).concat(e5.transport).concat(o2).concat(e5.priority).concat(o2).concat(e5.connectionAddress).concat(o2).concat(e5.port).concat(o2, "typ").concat(o2).concat(e5.type).concat(e5.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e5.relAddr) : "").concat(e5.relPort ? "".concat(o2, "rport").concat(o2).concat(e5.relPort) : "").concat(Object.keys(e5.extension).map(((t4) => "".concat(o2).concat(t4).concat(o2).concat(e5.extension[t4]))).join("")).concat(this.eol))).join("");
            }
            printRemoteCandidatesList(e4) {
              return e4.map(((e5) => "a=remote-candidates:".concat(e5.join(o2)).concat(this.eol))).join("");
            }
            printEndOfCandidates(e4) {
              return void 0 === e4 ? "" : "a=end-of-candidates" + this.eol;
            }
            printRTPRelated(e4) {
              if (!e4.payloads) return "";
              const t4 = e4.payloads;
              let i4 = "";
              i4 += e4.rtcpFeedbackWildcards.map(((e5) => this.printRTCPFeedback("*", e5))).join("");
              for (const e5 of t4) i4 += this.printRtpMap(e5.payloadType, e5.rtpMap), i4 += this.printFmtp(e5.payloadType, e5.fmtp), i4 += e5.rtcpFeedbacks.map(((t5) => this.printRTCPFeedback(e5.payloadType, t5))).join("");
              return i4;
            }
            printFmtp(e4, t4) {
              if (!t4) return "";
              const i4 = Object.keys(t4.parameters);
              return 1 === i4.length && null === t4.parameters[i4[0]] ? "a=fmtp:".concat(e4).concat(o2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e4).concat(o2).concat(Object.keys(t4.parameters).map(((e5) => "".concat(e5, "=").concat(t4.parameters[e5]))).join(";")).concat(this.eol);
            }
            printRtpMap(e4, t4) {
              return t4 ? "a=rtpmap:".concat(e4).concat(o2).concat(t4.encodingName, "/").concat(t4.clockRate).concat(t4.encodingParameters ? "/".concat(t4.encodingParameters) : "").concat(this.eol) : "";
            }
            printRTCPFeedback(e4, t4) {
              let i4 = "a=rtcp-fb:".concat(e4).concat(o2), n3 = t4;
              return "trr-int" === n3.type ? i4 += "ttr-int".concat(o2).concat(n3.interval) : (i4 += "".concat(n3.type), n3.parameter && (i4 += "".concat(o2).concat(n3.parameter), n3.additional && (i4 += "".concat(o2).concat(n3.additional)))), i4 + this.eol;
            }
            printPtime(e4) {
              return void 0 === e4 ? "" : "a=ptime:".concat(e4).concat(this.eol);
            }
            printMaxPtime(e4) {
              return void 0 === e4 ? "" : "a=maxptime:".concat(e4).concat(this.eol);
            }
            printDirection(e4) {
              return void 0 === e4 ? "" : "a=".concat(e4).concat(this.eol);
            }
            printSSRC(e4) {
              return e4.map(((e5) => Object.keys(e5.attributes).map(((t4) => "a=ssrc:".concat(e5.ssrcId.toString(10)).concat(o2).concat(t4).concat(e5.attributes[t4] ? ":".concat(e5.attributes[t4]) : "").concat(this.eol))).join(""))).join("");
            }
            printRTCPMux(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux".concat(this.eol);
            }
            printRTCPMuxOnly(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux-only".concat(this.eol);
            }
            printRTCPRsize(e4) {
              return void 0 === e4 ? "" : "a=rtcp-rsize".concat(this.eol);
            }
            printRTCP(e4) {
              if (void 0 === e4) return "";
              let t4 = "a=rtcp:".concat(e4.port);
              return e4.netType && (t4 += "".concat(o2).concat(e4.netType)), e4.addressType && (t4 += "".concat(o2).concat(e4.addressType)), e4.address && (t4 += "".concat(o2).concat(e4.address)), t4 + this.eol;
            }
            printMSId(e4) {
              return e4.map(((e5) => "a=msid:".concat(e5.id).concat(e5.appdata ? "".concat(o2).concat(e5.appdata) : "").concat(this.eol))).join("");
            }
            printImageattr(e4) {
              return e4.map(((e5) => "a=imageattr:".concat(e5).concat(this.eol))).join("");
            }
            printRid(e4) {
              return e4.map(((e5) => {
                let t4 = "a=rid:".concat(e5.id).concat(o2).concat(e5.direction);
                return e5.payloads && (t4 += "".concat(o2, "pt=").concat(e5.payloads.join(","))), e5.params.length > 0 && (t4 += "".concat(o2).concat(e5.params.map(((e6) => "depend" === e6.type ? "depend=".concat(e6.rids.join(",")) : "".concat(e6.type, "=").concat(e6.val))).join(";"))), t4 + this.eol;
              })).join("");
            }
            printSimulcast(e4) {
              return void 0 === e4 ? "" : "a=simulcast:".concat(e4).concat(this.eol);
            }
            printSCTPPort(e4) {
              return void 0 === e4 ? "" : "a=sctp-port:".concat(e4).concat(this.eol);
            }
            printMaxMessageSize(e4) {
              return void 0 === e4 ? "" : "a=max-message-size:".concat(e4).concat(this.eol);
            }
            printMid(e4) {
              return void 0 === e4 ? "" : "a=mid:".concat(e4).concat(this.eol);
            }
            printSSRCGroups(e4) {
              return e4.map(((e5) => "a=ssrc-group:".concat(e5.semantic).concat(e5.ssrcIds.map(((e6) => "".concat(o2).concat(e6.toString(10)))).join("")).concat(this.eol))).join("");
            }
          }
          function D2(e4) {
            return new C2().parse(e4);
          }
          function P2(e4, t4) {
            return new b2().print(e4, t4);
          }
        } }, t2 = {};
        function i2(n2) {
          if (t2[n2]) return t2[n2].exports;
          var r2 = t2[n2] = { exports: {} };
          return e2[n2](r2, r2.exports, i2), r2.exports;
        }
        return i2.d = (e3, t3) => {
          for (var n2 in t3) i2.o(t3, n2) && !i2.o(e3, n2) && Object.defineProperty(e3, n2, { enumerable: true, get: t3[n2] });
        }, i2.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), i2.r = (e3) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, i2(8);
      })();
      function LD(e2) {
        return PD.parse(e2);
      }
      function kD(e2, t2) {
        return PD.print(e2, t2);
      }
      var MD = Zi("Array", "keys"), UD = En, VD = $e, xD = l, FD = MD, BD = Array.prototype, jD = { DOMTokenList: true, NodeList: true }, GD = function(e2) {
        var t2 = e2.keys;
        return e2 === BD || xD(BD, e2) && t2 === BD.keys || VD(jD, UD(e2)) ? FD : t2;
      }, WD = i(GD);
      function HD(e2, t2, i2) {
        return (t2 = (function(e3) {
          var t3 = (function(e4, t4) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n2 = i3.call(e4, "string");
              if ("object" != typeof n2) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        })(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      function KD(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function YD(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? KD(Object(i2), true).forEach((function(t3) {
            HD(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : KD(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      function zD(e2, t2) {
        return zD = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
          return e3.__proto__ = t3, e3;
        }, zD(e2, t2);
      }
      function qD() {
        qD = function(e3, t3) {
          return new i2(e3, void 0, t3);
        };
        var e2 = RegExp.prototype, t2 = /* @__PURE__ */ new WeakMap();
        function i2(e3, n3, r2) {
          var o2 = RegExp(e3, n3);
          return t2.set(o2, r2 || t2.get(e3)), zD(o2, i2.prototype);
        }
        function n2(e3, i3) {
          var n3, r2 = t2.get(i3);
          return nr(n3 = Object.keys(r2)).call(n3, (function(t3, i4) {
            var n4 = r2[i4];
            if ("number" == typeof n4) t3[i4] = e3[n4];
            else {
              for (var o2 = 0; void 0 === e3[n4[o2]] && o2 + 1 < n4.length; ) o2++;
              t3[i4] = e3[n4[o2]];
            }
            return t3;
          }), /* @__PURE__ */ Object.create(null));
        }
        return (function(e3, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && zD(e3, t3);
        })(i2, RegExp), i2.prototype.exec = function(t3) {
          var i3 = e2.exec.call(this, t3);
          if (i3) {
            i3.groups = n2(i3, this);
            var r2 = i3.indices;
            r2 && (r2.groups = n2(r2, this));
          }
          return i3;
        }, i2.prototype[Symbol.replace] = function(i3, r2) {
          if ("string" == typeof r2) {
            var o2 = t2.get(this);
            return e2[Symbol.replace].call(this, i3, r2.replace(/\$<([^>]+)(>|$)/g, (function(e3, t3, i4) {
              if ("" === i4) return e3;
              var n3 = o2[t3];
              return Array.isArray(n3) ? "$" + n3.join("$") : "number" == typeof n3 ? "$" + n3 : "";
            })));
          }
          if ("function" == typeof r2) {
            var s2 = this;
            return e2[Symbol.replace].call(this, i3, (function() {
              var e3 = arguments;
              return "object" != typeof e3[e3.length - 1] && (e3 = [].slice.call(e3)).push(n2(e3, s2)), r2.apply(this, e3);
            }));
          }
          return e2[Symbol.replace].call(this, i3, r2);
        }, qD.apply(this, arguments);
      }
      const XD = new class extends NO {
        constructor() {
          super(...arguments), HD(this, "currentUploadLogID", 0);
        }
        reportLogUploadError(e2) {
          const { errorRange: t2 } = e2;
          t2[t2.length - 1] && t2[t2.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t2[t2.length - 1], this.emit("REPORT_LOG_UPLOAD", e2));
        }
      }();
      class JD {
        constructor(e2) {
          HD(this, "logger", void 0), HD(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.debug(...this.prefixLists, ...t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.info(...this.prefixLists, ...t2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.warning(...this.prefixLists, ...t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          this.logger.error(...this.prefixLists, ...t2);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      function QD() {
        const e2 = /* @__PURE__ */ new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      function ZD() {
        const e2 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
        return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const $D = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, eP = Date.now(), tP = (e2) => {
        for (const t2 in $D) if (Object.prototype.hasOwnProperty.call($D, t2) && $D[t2] === e2) return t2;
        return "DEFAULT";
      };
      const iP = new class {
        constructor() {
          HD(this, "proxyServerURL", void 0), HD(this, "logLevel", $D.DEBUG), HD(this, "uploadState", "collecting"), HD(this, "uploadLogWaitingList", []), HD(this, "uploadLogUploadingList", []), HD(this, "uploadErrorCount", 0), HD(this, "currentLogID", 0), HD(this, "url", void 0), HD(this, "extLog", ((e2, t2) => {
            this.appendLogToWaitingList(e2, ...t2);
          }));
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [$D.DEBUG].concat(t2);
          this.log.apply(this, n2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [$D.INFO].concat(t2);
          this.log.apply(this, n2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [$D.WARNING].concat(t2);
          this.log.apply(this, n2);
        }
        warn() {
          this.warning(...arguments);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [$D.ERROR].concat(t2);
          this.log.apply(this, n2);
        }
        upload() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          const n2 = [$D.DEBUG].concat(t2);
          this.uploadLog.apply(this, n2);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          RD("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          RD("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new JD(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          if (Date.now() - eP < 100) return void setTimeout((() => {
            this.log(...t2);
          }), Date.now() - eP);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          if (t2[0] = QD() + " Agora-SDK [".concat(tP(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel) return;
          const r2 = QD() + " %cAgora-SDK [".concat(tP(n2), "]:");
          let o2 = [];
          if (!CD("USE_NEW_LOG")) switch (n2) {
            case $D.DEBUG:
              o2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
              break;
            case $D.INFO:
              o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
              break;
            case $D.WARNING:
              o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
              break;
            case $D.ERROR:
              o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
          }
        }
        uploadLog() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
          if (Date.now() - eP < 100) return void setTimeout((() => {
            this.uploadLog(...t2);
          }), Date.now() - eP);
          const n2 = Math.max(0, Math.min(4, t2[0]));
          t2[0] = QD() + " Agora-SDK [".concat(tP(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
        }
        appendLogToWaitingList(e2) {
          if (!CD("UPLOAD_LOG")) return;
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
          Array.isArray(i2[0]) ? i2[0][0] = ZD() + " Agora-SDK [".concat(tP(e2), "]:") : i2[0] = ZD() + " Agora-SDK [".concat(tP(e2), "]:");
          let r2 = "";
          i2.forEach(((e3) => {
            "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
          })), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t2 = { sdk_version: hD, process_id: CD("PROCESS_ID"), payload: JSON.stringify(e2) };
          return UN((async () => {
            const e3 = await Tw.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(CD("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(CD("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
            if ("OK" !== e3.data) {
              const t3 = new Error("unexpected upload log response");
              throw t3.response = e3, t3;
            }
          }), (() => (this.uploadLogUploadingList = [], false)), ((t3) => {
            const i2 = { status: -1, message: t3.message, errorRange: e2.map(((e3) => e3.log_item_id)) };
            return t3.response ? (i2.status = t3.response.status, i2.data = t3.response.data, i2.headers = t3.response.headers) : t3.request && (i2.status = t3.request.status), XD.reportLogUploadError(i2), true;
          }), { timeout: CD("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: CD("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, CD("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then((() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout((() => this.uploadLogInterval()), CD("UPLOAD_LOG_INTERVAL"));
          })).catch(((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout((() => this.uploadLogInterval()), CD("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout((() => this.uploadLogInterval()), CD("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          })));
        }
      }();
      var nP;
      function rP(e2) {
        return SO(e2.reportId, "params.reportId", 0, 100, false), SO(e2.category, "params.category", 0, 100, false), SO(e2.event, "params.event", 0, 100, false), SO(e2.label, "params.label", 0, 100, false), mO(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      (nP = {}).FREE = "free", nP.UPLOADING = "uploading", (function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      })({});
      const oP = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let sP = (function(e2) {
        return e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.RTE_DETAIL = "rte_detail_stats", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.XLA_PEER_FIRST_VIDEO_FRAME = "xla_peer_first_video_frame", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities", e2.AB_TEST = "ab_test", e2;
      })({}), aP = (function(e2) {
        return e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.RTE_DETAIL = "io.agora.pb.Wrtc.RteDetailStats", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.XLA_PEER_FIRST_VIDEO_FRAME = "io.agora.pb.Wrtc.XLAPeerFirstVideoFrame", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities", e2.AB_TEST = "io.agora.pb.Wrtc.ABTest", e2;
      })({});
      !(function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      })({});
      let cP = (function(e2) {
        return e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED", e2;
      })({});
      function dP() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(t2, i2, n2) {
          const r2 = n2.value;
          if ("function" == typeof r2) {
            const o2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
            n2.value = function() {
              for (var t3, n3 = arguments.length, s2 = new Array(n3), a2 = 0; a2 < n3; a2++) s2[a2] = arguments[a2];
              let c2 = s2;
              if (e2.argsMap) try {
                c2 = e2.argsMap(this, ...s2);
              } catch (e3) {
                iP.warning(e3), c2 = [];
              }
              try {
                JSON.stringify(c2);
              } catch (e3) {
                iP.warning("arguments for method ".concat(o2, ".").concat(String(i2), " not serializable for apiInvoke.")), c2 = [];
              }
              const d2 = (e2.report || lP).reportApiInvoke(this._sessionId || null, { id: this._clientId || (null === (t3 = this.store) || void 0 === t3 ? void 0 : t3.clientId) || this._ID, name: "".concat(o2, ".").concat(String(i2)), options: c2, tag: kO.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
              try {
                const t4 = r2.apply(this, s2);
                return t4 instanceof rp ? t4.then(((t5) => (d2.onSuccess(e2.reportResult && t5), t5))).catch(((e3) => {
                  throw d2.onError(e3), e3;
                })) : (d2.onSuccess(e2.reportResult && t4), t4);
              } catch (e3) {
                throw d2.onError(e3), e3;
              }
            };
          }
          return n2;
        };
      }
      const lP = new class {
        constructor() {
          HD(this, "baseInfoMap", /* @__PURE__ */ new Map()), HD(this, "proxyServer", void 0), HD(this, "eventUploadTimer", void 0), HD(this, "setSessionIdTimer", void 0), HD(this, "url", void 0), HD(this, "sids", /* @__PURE__ */ new Set()), HD(this, "backupUrl", void 0), HD(this, "_appId", void 0), HD(this, "_aid", 0), HD(this, "keyEventUploadPendingItems", []), HD(this, "normalEventUploadPendingItems", []), HD(this, "apiInvokeUploadPendingItems", []), HD(this, "apiInvokeCount", 0), HD(this, "apiInvokeLoggedCount", 0), HD(this, "ltsList", []), HD(this, "lastSendNormalEventTime", Date.now()), HD(this, "customReportCounterTimer", void 0), HD(this, "customReportCount", 0), HD(this, "extApiInvoke", (async (e2) => {
            for (const t2 of e2) {
              const e3 = YD(YD({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: kO.TRACER });
              this.sendApiInvoke(e3);
            }
          })), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), CD("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), CD("EVENT_REPORT_SEND_INTERVAL"));
        }
        getBaseInfoBySessionId(e2) {
          return this.baseInfoMap.get(e2);
        }
        setAppId(e2) {
          this._appId = e2, this._aid = parseInt(e2.replace(/[a-fA-F0-9]{8}/g, ((e3) => {
            let [t2, i2] = e3;
            return t2 + i2;
          })), 16) || 0;
        }
        reportApiInvoke(e2, t2, i2) {
          t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
          const n2 = Date.now();
          this.apiInvokeCount += 1;
          const r2 = this.apiInvokeCount, o2 = !!CD("SHOW_REPORT_INVOKER_LOG"), s2 = !!CD("SHOW_REPORT_USER_INVOKER_LOG"), a2 = o2 || s2 && t2.id;
          a2 && (this.apiInvokeLoggedCount += 1);
          const c2 = this.apiInvokeLoggedCount;
          function d2(e3, i3) {
            if (a2) {
              let n3 = "[apiInvoke-".concat(c2, "]");
              if (t2.id && (n3 += "[".concat(t2.id, "]")), t2.name && (n3 += "[".concat(t2.name, "]"), t2.name === LO.JOIN)) return iP.info("".concat(n3, " ").concat(e3));
              iP.info("".concat(n3, " ").concat(e3), "start" === e3 ? t2.options : i3 || "");
            }
          }
          const l2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null });
          d2("start");
          let u2 = false;
          fN(t2.timeout).then((() => {
            u2 || (this.sendApiInvoke(YD(YD({}, l2()), {}, { error: hO.API_INVOKE_TIMEOUT, success: false })), d2("timeout"));
          }));
          const h2 = new pO(hO.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const n3 = () => {
              if (u2) throw h2;
              return u2 = true, this.sendApiInvoke(YD(YD({}, l2()), {}, { success: true }, t2.reportResult && { result: e3 })), d2("onSuccess"), e3;
            };
            return i2 ? CN(n3, t2.name + "Success", i2, (() => u2 = true)) : n3();
          }, onError: (e3) => {
            const n3 = () => {
              if (u2) throw e3;
              u2 = true, this.sendApiInvoke(YD(YD({}, l2()), {}, { success: false, error: e3 })), d2("onFailure", e3.toString());
            };
            return i2 ? CN(n3, t2.name + "Error", i2, (() => u2 = true)) : n3();
          } };
        }
        _send(e2, t2, i2) {
          this.send({ type: e2, data: t2 }, i2);
        }
        _sendApiInvoke(e2) {
          return this.sendApiInvoke(e2);
        }
        sessionInit(e2, t2) {
          if (this.baseInfoMap.has(e2)) return;
          const i2 = Date.now(), n2 = this.createBaseInfo(e2, i2);
          n2.cname = t2.cname, n2.rteUrl = t2.rteUrl;
          const r2 = Object.assign({}, { willUploadConsoleLog: CD("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: pD ? "global" : "oversea", areas: CD("AREAS") && CD("AREAS").join(",") }, t2.extend), { stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientRole: l2 } = t2, u2 = Date.now(), h2 = YD(YD({}, n2), {}, { eventType: sP.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, buildFormat: t2.buildFormat, build: SD, lts: u2, elapse: u2 - i2, extend: JSON.stringify(r2), mode: t2.mode, process: CD("PROCESS_ID"), appType: CD("APP_TYPE"), success: true, version: hD, stringUid: o2, channelProfile: s2, channelMode: a2, isABTestSuccess: c2, lsid: d2, clientType: Ln(p2 = window.navigator.userAgent).call(p2, "AgoraWebView") ? 42 : 20, clientRole: l2, serviceId: CD("PROCESS_ID"), extensionID: CD("PLUGIN_INFO").join(",") || "", rteUrl: t2.rteUrl, rteSid: t2.rteSid });
          var p2;
          this.send({ type: aP.SESSION, data: h2 }, true);
        }
        reportRteDetail(e2) {
          const t2 = this.baseInfoMap.get(e2);
          if (!t2) return;
          const i2 = t2.info, n2 = Date.now(), r2 = YD(YD({}, i2), {}, { eventType: sP.RTE_DETAIL, lts: n2, success: true, elapse: n2 - t2.startTime, vid: void 0 === i2.vid ? 0 : Number(i2.vid), ua: navigator.userAgent });
          this.send({ type: aP.RTE_DETAIL, data: r2 }, true);
        }
        joinChooseServer(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info;
          t2.vid && (n2.vid = t2.vid);
          const r2 = Date.now(), o2 = YD(YD({}, n2), {}, { role: t2.role, eventType: sP.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: t2.elapse || r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3, corssRegionTagReq: t2.corssRegionTagReq || void 0, corssRegionTagRes: t2.corssRegionTagRes || void 0, ua: navigator.userAgent, resourceTimingInfo: t2.resourceTimingInfo || void 0 });
          this.send({ type: aP.JOIN_CHOOSE_SERVER, data: o2 }, true);
        }
        reqUserAccount(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { eventType: sP.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: t2.elapse || r2 - i2.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
          this.send({ type: aP.REQ_USER_ACCOUNT, data: o2 }, true);
        }
        joinGateway(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info;
          t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
          const r2 = Date.now(), { firstSuccess: o2, addr: s2, isProxy: a2 } = t2, c2 = r2 - i2.startTime, d2 = YD(YD({}, n2), {}, { eventType: sP.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, errorMsg: t2.errorMsg || "", elapse: c2, eventElapse: r2 - t2.lts, firstSuccess: o2, signalChannel: t2.signalChannel, preload: t2.preload ? 1 : 0, installId: uD(), isABTestSuccess: t2.isABTestSuccess ? 1 : 0, gatewayIp: null, gatewayPort: null, isProxy: a2 ? 1 : 0 }), l2 = d2.success ? 1 : 0;
          if (t2.succ && (i2.lastJoinSuccessTime = r2), s2) if ("1" === d2.signalChannel) {
            const e3 = qD(/(\d+\.\d+\.\d+\.\d+):(\d+)/, { ip: 1, port: 2 }), t3 = s2.match(e3);
            d2.gatewayIp = t3 && t3.groups ? t3.groups.ip : "", d2.gatewayPort = t3 && t3.groups ? t3.groups.port : "";
          } else if (a2) {
            const e3 = s2.match(/h=(\d{1,3}-){3}\d{1,3}/g), t3 = s2.match(/p=[0-9]{1,6}/g);
            d2.gatewayIp = e3 && e3.length ? e3[0].split("=")[1].replace(/-/g, ".") : "", d2.gatewayPort = t3 && t3.length ? t3[0].split("=")[1] : "";
          } else {
            const e3 = s2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), t3 = s2.match(/(:|p=)[0-9]{1,6}/g);
            d2.gatewayIp = e3 && e3.length ? e3[0].split("//")[1].replace(/-/g, ".") : "", d2.gatewayPort = t3 && t3.length ? t3[0].split(/:|p=/g)[1] : "";
          }
          if (o2) this.send({ type: aP.JOIN_GATEWAY, data: d2 }, true);
          else {
            let e3 = { isSuccess: l2, port: d2.gatewayPort };
            delete d2.success, delete d2.eventType, delete d2.firstSuccess, delete d2.gatewayPort, d2.vid = Number(d2.vid);
            const t3 = Object.assign({}, d2, e3, { eventType: sP.REJOIN_GATEWAY });
            this.send({ type: aP.RE_JOIN_GATEWAY, data: t3 }, true);
          }
        }
        joinChannelTimeout(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = Date.now(), r2 = YD(YD({}, i2.info), {}, { lts: n2, timeout: t2, elapse: n2 - i2.startTime });
          this.send({ type: aP.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
        }
        publish(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { eventType: sP.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
          this.send({ type: aP.PUBLISH, data: o2 }, true);
        }
        subscribe(e2, t2, i2) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2) return;
          const r2 = n2.info, o2 = Date.now(), s2 = YD(YD({}, r2), {}, { eventType: sP.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid, preSsrc: t2.preSsrc ? 1 : 0 }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t2.peerid ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: aP.SUBSCRIBE, data: s2 }, true);
        }
        wsCompressorInit(e2) {
          var t2;
          const i2 = [...WD(t2 = this.baseInfoMap).call(t2)], n2 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a2 = YD(YD({}, o2), {}, { eventType: sP.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - r2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: aP.WS_COMPRESSOR_INIT, data: a2 }, true);
        }
        firstXLAPeerFirstVideoFrame(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = t2.peerPubStatusMs - (i2.lastJoinSuccessTime || r2), s2 = YD(YD({}, n2), {}, { elapse: r2 - i2.startTime, eventType: sP.XLA_PEER_FIRST_VIDEO_FRAME, lts: r2, peer: t2.peer, width: t2.width, height: t2.height, ssrc: t2.ssrc, p2pid: t2.p2pid, peerPublishDuration: t2.peerPublishDuration, joinChannelSuccessElapse: o2, peerPubStatusMs: t2.peerPubStatusMs - t2.joinChannelStart, availablePublish: t2.peerPublishDuration > o2 ? 1 : 0, preloadStart: Math.max(t2.preloadStart - t2.joinChannelStart, 0), preloadEnd: Math.max(t2.preloadEnd - t2.joinChannelStart, 0), encrypt: Math.max(t2.apStart - t2.joinChannelStart, 0), ap: Math.max(t2.apEnd - t2.joinChannelStart, 0), sua: Math.max(t2.suaEnd - t2.joinChannelStart, 0), beforeConnect: Math.max(t2.beforeConnect - t2.joinChannelStart, 0), peerRecevier: Math.max(t2.peerReceiver - t2.joinChannelStart, 0), ice: Math.max(t2.ice - t2.joinChannelStart, 0), pc: Math.max(t2.pc - t2.joinChannelStart, 0), signalConnected: Math.max(t2.signalConnected - t2.joinChannelStart, 0), joinReq: Math.max(t2.joinReq - t2.joinChannelStart, 0), joinRes: Math.max(t2.joinRes - t2.joinChannelStart, 0), userJoinNotify: Math.max(t2.userJoinNotify - t2.joinChannelStart, 0), videoSsrcNotify: Math.max(t2.videoAddNotify - t2.joinChannelStart, 0), subscribeDelayMs: Math.max(t2.subscribeStart - t2.videoAddNotify, 0), subscribeStart: Math.max(t2.subscribeStart - t2.joinChannelStart, 0), subscribeEnd: Math.max(t2.subscribeEnd - t2.joinChannelStart, 0), firstReceived: Math.max(t2.firstReceived - t2.joinChannelStart, 0), firstDecoded: Math.max(t2.firstDecoded - t2.joinChannelStart, 0), firstPreRender: Math.max(t2.firstPreRender - t2.joinChannelStart, 0), firstRender: Math.max(t2.firstRender - t2.joinChannelStart, 0), playDelayMs: Math.max(t2.playStart - t2.subscribeEnd, 0), playStart: Math.max(t2.playStart - t2.joinChannelStart, 0), playEnd: Math.max(t2.playEnd - t2.joinChannelStart, 0), isPreSub: t2.isPreSub ? 1 : 0, isPrePc: t2.isPrePc ? 1 : 0, isPreInstantVideo: t2.isPreInstantVideo ? 1 : 0, firstReceivedEncodedFrame: t2.firstReceivedEncodedFrame ? Math.max(t2.firstReceivedEncodedFrame - t2.joinChannelStart, 0) : void 0, frameType: t2.frameType || "", rtpTimestamp: t2.rtpTimestamp || 0, framePayloadType: t2.framePayloadType || 0, frameDataLength: t2.frameDataLength || 0, mimeType: t2.mimeType || "" });
          this.send({ type: aP.XLA_PEER_FIRST_VIDEO_FRAME, data: s2 }, true);
        }
        firstRemoteVideoDecode(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a2 = YD(YD(YD({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2, firstDecodeFrame: Math.max((n2.firstFrame || s2) - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
          this.send({ type: i2, data: a2 }, true);
        }
        firstRemoteFrame(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a2 = YD(YD(YD({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2 });
          this.send({ type: i2, data: a2 }, true);
        }
        abTest(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: sP.AB_TEST, lts: r2 });
          this.send({ type: aP.AB_TEST, data: o2 }, true);
        }
        pcStats(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: sP.PC_STATS, lts: r2, preallocation: t2.preallocation ? 1 : 0 });
          this.send({ type: aP.PC_STATS, data: o2 }, true);
        }
        updateRemoteRTPCapabilities(e2, t2) {
          if (e2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2) return;
            const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), eventType: sP.UPDATE_REMOTE_RTPCAPABILITIES, lts: r2 });
            this.send({ type: aP.UPDATE_REMOTE_RTPCAPABILITIES, data: o2 }, true);
          }
        }
        onGatewayStream(e2, t2, i2, n2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a2 = YD(YD(YD({}, o2), n2), {}, { eventType: t2, lts: s2 });
          this.send({ type: i2, data: a2 }, true);
        }
        streamSwitch(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { eventType: sP.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i2.startTime, success: t2.succ });
          this.send({ type: aP.STREAM_SWITCH, data: o2 }, true);
        }
        requestProxyAppCenter(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { eventType: sP.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: aP.REQUEST_PROXY_APPCENTER, data: o2 }, true);
        }
        requestProxyWorkerManager(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { eventType: sP.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: aP.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? iP.debug("reportProxyServerurl: ".concat(e2)) : iP.debug("disable reportProxyServerurl: ".concat(e2));
        }
        peerPublishStatus(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
          this.send({ type: aP.PEER_PUBLISH_STATUS, data: o2 }, true);
        }
        workerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now();
          (function(e3, t3, i3) {
            const n3 = e3[t3];
            if (!n3 || "string" != typeof n3) return [e3];
            e3[t3] = "";
            const r3 = _N(JSON.stringify(e3));
            let o2 = 0;
            const s2 = [];
            let a2 = 0;
            for (let c2 = 0; c2 < n3.length; c2++) a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i3 - r3 || (s2[s2.length] = uO(uO({}, e3), {}, { [t3]: n3.substring(o2, c2) }), o2 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
            return o2 !== n3.length - 1 && (s2[s2.length] = uO(uO({}, e3), {}, { [t3]: n3.substring(o2) })), s2;
          })(YD(YD(YD({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach(((e3) => this.send({ type: aP.WORKER_EVENT, data: e3 }, true)));
        }
        apworkerEvent(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: aP.AP_WORKER_EVENT, data: o2 }, true);
        }
        joinWebProxyAP(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t2.extend || void 0 });
          this.send({ type: aP.JOIN_WEB_PROXY_AP, data: o2 }, true);
        }
        WebSocketQuit(e2, t2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n2 = i2.info, r2 = Date.now(), o2 = YD(YD(YD({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: aP.WEBSOCKET_QUIT, data: o2 }, true);
        }
        async sendCustomReportMessage(e2, t2) {
          if (this.customReportCount += t2.length, this.customReportCount > CD("CUSTOM_REPORT_LIMIT")) throw new pO(hO.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval((() => {
            this.customReportCount = 0;
          }), 5e3));
          const i2 = Date.now(), n2 = t2.map(((t3) => ({ type: aP.USER_ANALYTICS, data: YD(YD({ sid: e2 }, t3), {}, { lts: i2 }) })));
          try {
            CD("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
          } catch (e3) {
            throw iP.error("send custom report message failed", e3.toString()), new pO(hO.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        sendApiInvoke(e2) {
          const t2 = CD("NOT_REPORT_EVENT");
          if (e2.tag && Ln(t2) && Ln(t2).call(t2, e2.tag)) return false;
          if (null === e2.sid) return this.apiInvokeUploadPendingItems.push(e2), false;
          const i2 = this.baseInfoMap.get(e2.sid);
          if (!i2) return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: n2, uid: r2, cid: o2 } = i2.info;
          let s2;
          if (e2.lts = e2.lts || Date.now(), e2.error) if (e2.error instanceof pO) {
            const { code: t3, message: i3 } = e2.error;
            s2 = t3 || i3 || e2.error.toString();
          } else s2 = e2.error.toString();
          const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: o2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? s2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: aP.API_INVOKE, data: a2 }, false), true;
        }
        addSid(e2) {
          this.sids.add(e2);
        }
        removeSid(e2) {
          this.sids.delete(e2);
        }
        appendSessionId() {
          const e2 = this.apiInvokeUploadPendingItems;
          if (0 === e2.length) return;
          const t2 = Array.from(this.sids).find(((e3) => null !== e3));
          t2 && e2.forEach(((e3) => {
            e3 && (e3.sid = t2, this.sendApiInvoke(Object.assign({}, e3)));
          })), e2.length = 0;
        }
        send(e2, t2) {
          if (t2) return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > CD("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t2) {
          const i2 = [], n2 = [];
          for (; e2.length; ) {
            const t3 = e2.shift();
            i2.length < 20 ? i2.push(t3) : n2.push(t3);
          }
          e2.push(...n2);
          for (const e3 of [...i2]) {
            var r2;
            -1 !== this.ltsList.indexOf(e3.data.lts) ? (e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts)) : (this.ltsList.push(e3.data.lts), Qp(r2 = this.ltsList).call(r2, ((e4, t3) => e4 - t3)));
          }
          return t2 || (this.lastSendNormalEventTime = Date.now()), CD("ENABLE_EVENT_REPORT") ? (i2.length && (CD("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(/* @__PURE__ */ ((e3) => (i3) => {
            CD("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > CD("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - CD("NORMAL_EVENT_QUEUE_CAPACITY")), iP.warning("report: drop normal events"))));
          })(i2)), e2) : e2;
        }
        async postDataToStatsCollector2(e2) {
          QO.networkState === KO.OFFLINE && await rp.race([QO.onlineWaiter, fN(2 * kN.maxRetryTimeout)]);
          const t2 = (e3) => {
            let t3 = new Uint8Array();
            return e3.forEach(((e4) => {
              const i3 = bO(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
                let t4 = 0;
                return Object.entries(aP).forEach(((i4) => {
                  let [n4, r3] = i4;
                  r3 === e5.type && (t4 = cP[n4]);
                })), t4;
              })(e4), o2 = new DataView(n3);
              o2.setUint16(0, i3.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t3 = wO(t3, new Uint8Array(n3)), t3 = wO(t3, i3);
            })), t3;
          }, i2 = "event";
          let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(CD("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(CD("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
          for (let r2 = 0; r2 < 2; r2 += 1) {
            1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(CD("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(CD("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
            try {
              await jN(n2, { timeout: 1e4, data: t2(e2), headers: YD(YD({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e3) {
              if (1 === r2) throw e3;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i2 = ((e3) => {
            const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t3 && t3.info.vid && +t3.info.vid || 0;
          })(e2[0]), n2 = i2 ? void 0 : this._aid, r2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map(((e3) => JSON.stringify(e3))), vid: i2, aid: n2 };
          QO.networkState === KO.OFFLINE && await rp.race([QO.onlineWaiter, fN(2 * kN.maxRetryTimeout)]);
          const o2 = t2 ? "/events/proto-raws" : "/events/messages";
          let s2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(CD("EVENT_REPORT_DOMAIN"), "&p=").concat(CD("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(CD("EVENT_REPORT_DOMAIN"), ":").concat(CD("STATS_COLLECTOR_PORT")).concat(o2));
          for (let e3 = 0; e3 < 2; e3 += 1) {
            1 === e3 && (s2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(CD("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(CD("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(CD("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(CD("STATS_COLLECTOR_PORT")).concat(o2)));
            try {
              t2 ? await GN(s2, { timeout: 1e4, data: r2 }) : await jN(s2, { timeout: 1e4, data: r2 });
            } catch (t3) {
              if (1 === e3) throw t3;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t2) {
          const i2 = Object.assign({}, oP);
          return i2.sid = e2, this.baseInfoMap.set(e2, { info: i2, startTime: t2 }), i2;
        }
        reportResourceTiming(e2, t2) {
          const i2 = performance.getEntriesByName(e2), n2 = i2[i2.length - 1];
          n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: kO.TRACER }).onSuccess();
        }
      }();
      XD.on("REPORT_LOG_UPLOAD", ((e2) => {
        e2.networkState = QO.networkState, lP.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: kO.TRACER }).onSuccess("logUploadError");
      }));
      let uP = class extends pO {
        constructor(e2) {
          super(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), HD(this, "name", "AgoraRTCException");
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return super.print(e2, iP);
        }
        throw() {
          super.throw(iP);
        }
      };
      const hP = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false, supportRequestVideoFrameCallback: false, supportWebCrypto: false, supportSuppressLocalAudioPlayback: false, supportRestrictOwnAudio: false };
      function pP() {
        return hP;
      }
      function _P() {
        return "setSinkId" in HTMLAudioElement.prototype && (!CD("RESTRICTION_SET_PLAYBACK_DEVICE") || (Uw() || Fw()) && !oO());
      }
      function EP() {
        return !hP.supportUnifiedPlan || CD("CHROME_FORCE_PLAN_B") && sO();
      }
      function mP(e2) {
        return !(Bw() || Ww(87) || EP() || !CD("ENABLE_PRE_SUB") && (null == e2 || !e2.autoSubscribe || CD("FORCE_DISABLE_AUTO_SUB")));
      }
      function fP(e2) {
        return CD("ENABLE_INSTANT_VIDEO") ? CD("ENABLE_INSTANT_VIDEO") : !(null == e2 || !e2.autoSubscribe || CD("FORCE_DISABLE_AUTO_SUB"));
      }
      function SP() {
        return navigator.mediaDevices && "getSupportedConstraints" in navigator.mediaDevices;
      }
      function gP() {
        if (SP()) {
          const e2 = navigator.mediaDevices.getSupportedConstraints();
          return !(!("suppressLocalAudioPlayback" in e2) || !e2.suppressLocalAudioPlayback);
        }
        return Gw(141) || Kw(141) || Qw(141);
      }
      function TP() {
        if (SP()) {
          const e2 = navigator.mediaDevices.getSupportedConstraints();
          return !(!("restrictOwnAudio" in e2) || !e2.restrictOwnAudio);
        }
        return Gw(141) || Kw(141) || Qw(125);
      }
      let RP = (function(e2) {
        return e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change", e2;
      })({});
      function CP(e2, t2, i2) {
        return { sampleRate: e2, stereo: t2, bitrate: i2 };
      }
      function vP(e2, t2, i2, n2, r2) {
        return { width: e2, height: t2, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function yP(e2, t2, i2, n2, r2) {
        return { width: { max: e2 }, height: { max: t2 }, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
      }
      function IP(e2, t2) {
        return { numSpatialLayers: e2, numTemporalLayers: t2 };
      }
      const AP = { "90p": vP(160, 90), "90p_1": vP(160, 90), "120p": vP(160, 120, 15, 30, 65), "120p_1": vP(160, 120, 15, 30, 65), "120p_3": vP(120, 120, 15, 30, 50), "120p_4": vP(212, 120), "180p": vP(320, 180, 15, 30, 140), "180p_1": vP(320, 180, 15, 30, 140), "180p_3": vP(180, 180, 15, 30, 100), "180p_4": vP(240, 180, 15, 30, 120), "240p": vP(320, 240, 15, 40, 200), "240p_1": vP(320, 240, 15, 40, 200), "240p_3": vP(240, 240, 15, 40, 140), "240p_4": vP(424, 240, 15, 40, 220), "360p": vP(640, 360, 15, 80, 400), "360p_1": vP(640, 360, 15, 80, 400), "360p_3": vP(360, 360, 15, 80, 260), "360p_4": vP(640, 360, 30, 80, 600), "360p_6": vP(360, 360, 30, 80, 400), "360p_7": vP(480, 360, 15, 80, 320), "360p_8": vP(480, 360, 30, 80, 490), "360p_9": vP(640, 360, 15, 80, 800), "360p_10": vP(640, 360, 24, 80, 800), "360p_11": vP(640, 360, 24, 80, 1e3), "480p": vP(640, 480, 15, 100, 500), "480p_1": vP(640, 480, 15, 100, 500), "480p_2": vP(640, 480, 30, 100, 1e3), "480p_3": vP(480, 480, 15, 100, 400), "480p_4": vP(640, 480, 30, 100, 750), "480p_6": vP(480, 480, 30, 100, 600), "480p_8": vP(848, 480, 15, 100, 610), "480p_9": vP(848, 480, 30, 100, 930), "480p_10": vP(640, 480, 10, 100, 400), "720p": vP(1280, 720, 15, 120, 1130), "720p_auto": vP(1280, 720, 30, 900, 3e3), "720p_1": vP(1280, 720, 15, 120, 1130), "720p_2": vP(1280, 720, 30, 120, 2e3), "720p_3": vP(1280, 720, 30, 120, 1710), "720p_5": vP(960, 720, 15, 120, 910), "720p_6": vP(960, 720, 30, 120, 1380), "1080p": vP(1920, 1080, 15, 120, 2080), "1080p_1": vP(1920, 1080, 15, 120, 2080), "1080p_2": vP(1920, 1080, 30, 120, 3e3), "1080p_3": vP(1920, 1080, 30, 120, 3150), "1080p_5": vP(1920, 1080, 60, 120, 4780), "1440p": vP(2560, 1440, 30, 120, 4850), "1440p_1": vP(2560, 1440, 30, 120, 4850), "1440p_2": vP(2560, 1440, 60, 120, 7350), "4k": vP(3840, 2160, 30, 120, 8910), "4k_1": vP(3840, 2160, 30, 120, 8910), "4k_3": vP(3840, 2160, 60, 120, 13500) }, bP = { "480p": yP(640, 480, 5), "480p_1": yP(640, 480, 5), "480p_2": yP(640, 480, 30), "480p_3": yP(640, 480, 15), "720p": yP(1280, 720, 5), "720p_auto": vP(1280, 720, 30, 900, 3e3), "720p_1": yP(1280, 720, 5), "720p_2": yP(1280, 720, 30), "720p_3": yP(1280, 720, 15), "1080p": yP(1920, 1080, 5), "1080p_1": yP(1920, 1080, 5), "1080p_2": yP(1920, 1080, 30), "1080p_3": yP(1920, 1080, 15) }, wP = { "1SL1TL": IP(1, 1), "3SL3TL": IP(3, 3), "2SL3TL": IP(2, 3) };
      function OP(e2) {
        return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, AP[e2]) : e2;
      }
      function NP(e2) {
        return "string" == typeof e2 ? Object.assign({}, bP[e2]) : e2;
      }
      function DP(e2) {
        return "string" == typeof e2 ? Object.assign({}, wP[e2]) : e2;
      }
      const PP = { speech_low_quality: CP(16e3, false), speech_standard: CP(32e3, false, 18), music_standard: CP(48e3, false), standard_stereo: CP(48e3, true, 56), high_quality: CP(48e3, false, 128), high_quality_stereo: CP(48e3, true, 192) };
      function LP(e2) {
        return "string" == typeof e2 ? Object.assign({}, PP[e2]) : e2;
      }
      const kP = [];
      function MP(e2) {
        return EO(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      let UP = (function(e2) {
        return e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_RTC_STATS = "@get_rtc_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_UPDATE_VIDEO_SEND_PARAMETERS = "@need_update_video_send_parameters", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track", e2;
      })({}), VP = (function(e2) {
        return e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream", e2.SCREEN_LOW_TRACK = "screen_low_track", e2;
      })({});
      let xP = (function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2;
      })({}), FP = (function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.HIGH_STREAM_LAYER1 = 4] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 5] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 6] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 7] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 8] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 9] = "HIGH_STREAM_LAYER6", e2;
      })({}), BP = (function(e2) {
        return e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY", e2[e2.HIGH_STREAM_LAYER1 = 3] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 4] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 5] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 6] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 7] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 8] = "HIGH_STREAM_LAYER6", e2;
      })({}), jP = (function(e2) {
        return e2.TRANSCEIVER_UPDATED = "transceiver-updated", e2.SEI_TO_SEND = "sei-to-send", e2.SEI_RECEIVED = "sei-received", e2.TRACK_UPDATED = "track-updated", e2;
      })({}), GP = (function(e2) {
        return e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed", e2;
      })({}), WP = (function(e2) {
        return e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.VIDEO_STATE_CHANGED = "video-state-changed", e2.PLAY_START = "play-start", e2.PLAY_END = "play-end", e2.FIRST_FRAME_RENDER = "first-frame-render", e2;
      })({}), HP = (function(e2) {
        return e2.AUDIO = "audio", e2.VIDEO = "video", e2.DATA = "data", e2;
      })({}), KP = (function(e2) {
        return e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source", e2;
      })({});
      !(function(e2) {
        e2.UPDATE_TRACK_SOURCE = "update-track-source";
      })({});
      const YP = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 }, zP = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, qP = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receivePacketsDiscarded: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, XP = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, JP = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let QP = (function(e2) {
        return e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node", e2;
      })({}), ZP = (function(e2) {
        return e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints", e2;
      })({}), $P = (function(e2) {
        return e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND", e2;
      })({}), eL = (function(e2) {
        return e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged", e2;
      })({}), tL = (function(e2) {
        return e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata", e2;
      })({}), iL = (function(e2) {
        return e2[e2.VideoStateStopped = 0] = "VideoStateStopped", e2[e2.VideoStateStarting = 1] = "VideoStateStarting", e2[e2.VideoStateDecoding = 2] = "VideoStateDecoding", e2[e2.VideoStateFrozen = 3] = "VideoStateFrozen", e2;
      })({});
      const nL = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      let rL = (function(e2) {
        return e2.OPEN = "open", e2.MESSAGE = "message", e2.CLOSE = "close", e2.CLOSING = "closing", e2.ERROR = "error", e2;
      })({});
      function oL(e2, t2, i2, n2, r2) {
        var o2, s2, a2 = {};
        return Object.keys(n2).forEach((function(e3) {
          a2[e3] = n2[e3];
        })), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = nr(o2 = mr(s2 = i2.slice()).call(s2)).call(o2, (function(i3, n3) {
          return n3(e2, t2, i3) || i3;
        }), a2), r2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(r2) : void 0, a2.initializer = void 0), void 0 === a2.initializer ? (Object.defineProperty(e2, t2, a2), null) : a2;
      }
      function sL(e2, t2, i2) {
        return (t2 = (function(e3) {
          var t3 = (function(e4, t4) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n2 = i3.call(e4, "string");
              if ("object" != typeof n2) return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          })(e3);
          return "symbol" == typeof t3 ? t3 : t3 + "";
        })(t2)) in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
      }
      function aL(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function cL(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? aL(Object(i2), true).forEach((function(t3) {
            sL(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : aL(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class dL extends NO {
        set _mediaStreamTrack(e2) {
          e2 !== this.mediaStreamTrack && (this.safeEmit(jP.TRACK_UPDATED, e2), this.mediaStreamTrack = e2);
        }
        get _mediaStreamTrack() {
          return this.mediaStreamTrack;
        }
        constructor(e2, t2) {
          super(), sL(this, "trackMediaType", void 0), sL(this, "_ID", void 0), sL(this, "_rtpTransceiver", void 0), sL(this, "_lowRtpTransceiver", void 0), sL(this, "_hints", []), sL(this, "_isClosed", false), sL(this, "_originMediaStreamTrack", void 0), sL(this, "mediaStreamTrack", void 0), sL(this, "_external", {}), this._ID = t2 || SN(8, "track-"), this._originMediaStreamTrack = e2, this.mediaStreamTrack = e2, (function(e3) {
            Ln(kP).call(kP, e3) || kP.push(e3);
          })(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          return e2 || dN((() => {
            var e3;
            lP.reportApiInvoke(null, { name: LO.GET_MEDIA_STREAM_TRACK, options: [], tag: kO.TRACER }).onSuccess((null === (e3 = this._mediaStreamTrack) || void 0 === e3 ? void 0 : e3.label) || "");
          }), this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;
        }
        getRTCRtpTransceiver(e2) {
          return e2 === xP.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, (function(e2) {
            const t2 = kP.indexOf(e2);
            -1 !== t2 && kP.splice(t2, 1);
          })(this), this.emit(GP.CLOSED), this.removeAllListeners(jP.SEI_RECEIVED);
        }
        _updateRtpTransceiver(e2, t2) {
          if (t2 === xP.LOW_STREAM) {
            if (this._lowRtpTransceiver === e2) return;
            this._lowRtpTransceiver = e2;
          } else {
            if (this._rtpTransceiver === e2) return;
            this._rtpTransceiver = e2;
          }
          this.emit(jP.TRANSCEIVER_UPDATED, e2, t2);
        }
      }
      class lL extends dL {
        get isExternalTrack() {
          return this._isExternalTrack;
        }
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        get processorContext() {
          return this._processorContext;
        }
        constructor(e2, t2) {
          super(e2, t2), sL(this, "_enabled", true), sL(this, "_muted", false), sL(this, "_isExternalTrack", false), sL(this, "_isClosed", false), sL(this, "_enabledMutex", void 0), sL(this, "processor", void 0), sL(this, "_processorContext", void 0), sL(this, "_handleTrackEnded", (() => {
            this.onTrackEnded();
          })), this._enabledMutex = new PN("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, iP.debug("[".concat(this.getTrackId(), "] close")), this.emit(UP.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          this._isExternalTrack = i2, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          iP.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(GP.TRACK_ENDED);
        }
        stateCheck(e2, t2) {
          if (iP.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), _O(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2) throw new pO(hO.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", iP);
          if (!this._enabled && !this._muted && "muted" === e2 && true === t2) throw new pO(hO.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", iP);
        }
        getProcessorStats() {
          return this._processorContext && this._processorContext.gatherStats() || [];
        }
        getProcessorUsage() {
          return this._processorContext ? this._processorContext.gatherUsage() : rp.resolve([]);
        }
      }
      const uL = window.AudioContext || window.webkitAudioContext;
      let hL, pL = null;
      const _L = new class extends NO {
        constructor() {
          super(...arguments), sL(this, "prevState", void 0), sL(this, "curState", void 0), sL(this, "currentTime", void 0), sL(this, "currentTimeStuckAt", void 0), sL(this, "interruptDetectorTrack", void 0), sL(this, "onLocalAudioTrackMute", (() => {
            iP.info("ios15-interruption-start"), this.emit(RP.IOS_15_16_INTERRUPTION_START);
          })), sL(this, "onLocalAudioTrackUnmute", (async () => {
            iP.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? iP.info("ios15-interruption-end-canceled") : (pL && await pL.suspend(), this.emit(RP.IOS_15_16_INTERRUPTION_END));
          }));
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e2) {
          iP.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          iP.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function EL() {
        if (!pL) {
          if ((function() {
            if (!uL) return void iP.error("your browser is not support web audio");
            iP.info("create audio context");
            const e2 = cL({}, CD("WEBAUDIO_INIT_OPTIONS"));
            iP.debug("audio context init option:", JSON.stringify(e2)), pL = new uL(e2), _L.curState = pL.state, pL.onstatechange = () => {
              _L.prevState = _L.curState, _L.curState = pL ? pL.state : void 0;
              const { prevState: e3, curState: t2 } = _L, i2 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, o2 = "suspended" === e3, s2 = "interrupted" === e3, a2 = Dw().osVersion;
              (jw() || iO()) && r2 && n2 && (iP.info("ios".concat(a2, "-interruption-start")), _L.emit(RP.IOS_INTERRUPTION_START)), (jw() || iO()) && (o2 || s2) && i2 && (iP.info("ios".concat(a2, "-interruption-end")), _L.emit(RP.IOS_INTERRUPTION_END)), e3 !== t2 && _L.emit(RP.STATE_CHANGE, t2, e3);
            }, setInterval((() => {
              var e3;
              const t2 = null === (e3 = pL) || void 0 === e3 ? void 0 : e3.currentTime;
              _L.currentTime !== t2 ? (_L.currentTimeStuckAt && (iP.debug("AudioContext current time resume at ".concat(t2)), _L.currentTimeStuckAt = void 0), _L.currentTime = t2) : (t2 !== _L.currentTimeStuckAt && (lP.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: kO.TRACER }).onSuccess(), iP.warning("AudioContext current time stuck at ".concat(t2))), _L.currentTimeStuckAt = t2);
            }), 5e3), (async function(e3) {
              const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
              let i2, n2, r2 = false, o2 = false, s2 = false;
              function a2(t3) {
                "running" === e3.state ? c2(false) : jw() || iO() ? "suspended" === e3.state && (c2(true), t3 && e3.resume().then(d2, d2)) : "closed" !== e3.state && (c2(true), t3 && e3.resume().then(d2, d2));
              }
              function c2(e4) {
                if (r2 !== e4) {
                  r2 = e4;
                  for (let i3 = 0, n3 = t2; i3 < n3.length; i3 += 1) {
                    const t3 = n3[i3];
                    e4 ? window.addEventListener(t3, l2, { capture: true, passive: true }) : window.removeEventListener(t3, l2, { capture: true, passive: true });
                  }
                }
              }
              function d2() {
                a2(false);
              }
              function l2() {
                a2(true);
              }
              function u2() {
                let e4;
                try {
                  e4 = i2.play(), e4 ? e4.then(_2, _2) : (i2.addEventListener("playing", _2), i2.addEventListener("abort", _2), i2.addEventListener("error", _2));
                } catch (e5) {
                  _2();
                }
              }
              function h2(e4) {
                s2 || (i2.paused ? e4 ? (p2(false), s2 = true, u2()) : p2(true) : p2(false));
              }
              function p2(e4) {
                if (o2 !== e4) {
                  o2 = e4;
                  for (let i3 = 0, n3 = t2; i3 < n3.length; i3++) {
                    const t3 = n3[i3];
                    e4 ? window.addEventListener(t3, E2, { capture: true, passive: true }) : window.removeEventListener(t3, E2, { capture: true, passive: true });
                  }
                }
              }
              function _2() {
                i2.removeEventListener("playing", _2), i2.removeEventListener("abort", _2), i2.removeEventListener("error", _2), s2 = false, h2(false);
              }
              function E2() {
                h2(true);
              }
              if (jw() && CD("IOS_BG_TAG")) {
                const t3 = e3.createMediaStreamDestination(), r3 = document.createElement("div");
                r3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = r3.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t3.stream, n2 = () => {
                  if (CD("IOS_AUTO_RESTART_BG_TAG") && i2 && i2.srcObject && !s2 && (!i2.paused || true !== o2)) {
                    i2.paused || i2.pause();
                    try {
                      s2 = true, u2();
                    } catch (e4) {
                      s2 = false;
                    }
                    return true;
                  }
                }, h2(true);
              }
              return _L.on(RP.STATE_CHANGE, (function() {
                a2(true);
              })), a2(false), n2;
            })(pL).then(((e3) => {
              hL = e3;
            }));
          })(), !pL) throw new pO(hO.NOT_SUPPORTED, "can not create audio context");
          return pL;
        }
        return pL;
      }
      function mL(e2) {
        if ((function() {
          if (null !== fL) return fL;
          const e3 = EL(), t3 = e3.createBufferSource(), i3 = e3.createGain(), n2 = e3.createGain();
          t3.connect(i3), t3.connect(n2), t3.disconnect(i3);
          let r2 = false;
          try {
            t3.disconnect(i3);
          } catch (e4) {
            r2 = true;
          }
          return t3.disconnect(), fL = r2, r2;
        })()) return;
        const t2 = e2.connect, i2 = e2.disconnect;
        e2.connect = (i3, n2, r2) => {
          var o2;
          return e2._inputNodes || (e2._inputNodes = []), Ln(o2 = e2._inputNodes).call(o2, i3) || (i3 instanceof AudioNode ? (e2._inputNodes.push(i3), t2.call(e2, i3, n2, r2)) : t2.call(e2, i3, n2)), e2;
        }, e2.disconnect = (n2, r2, o2) => {
          i2.call(e2), n2 ? nN(e2._inputNodes, n2) : e2._inputNodes = [];
          for (const i3 of e2._inputNodes) t2.call(e2, i3);
        };
      }
      let fL = null;
      function SL(e2, t2) {
        let i2 = false;
        const n2 = 1 / t2;
        if (CD("DISABLE_WEBAUDIO")) {
          const t3 = window.setInterval((() => {
            i2 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
          }), 1e3 * n2);
        } else {
          const t3 = EL();
          let r2 = t3.createGain();
          r2.gain.value = 0, r2.connect(t3.destination);
          const o2 = () => {
            if (i2) return void (r2 = null);
            const s2 = t3.createOscillator();
            s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t3.currentTime + n2), e2(t3.currentTime);
          };
          o2();
        }
        return () => {
          i2 = true;
        };
      }
      class gL {
        constructor() {
          sL(this, "context", void 0), sL(this, "analyserNode", void 0), sL(this, "sourceNode", void 0), this.context = EL(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e2) {
          if (e2 !== this.sourceNode) {
            if (this.sourceNode) try {
              this.sourceNode.disconnect(this.analyserNode);
            } catch (e3) {
            }
            this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode) return 0;
          if (!this.context || jw() || iO() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;
          const e2 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e2);
          else {
            const t3 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t3);
            for (let i2 = 0; i2 < e2.length; ++i2) e2[i2] = t3[i2] / 128 - 1;
          }
          const t2 = nr(e2).call(e2, ((e3, t3) => e3 + t3 * t3), 0) / e2.length;
          return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e2, t2;
            null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
          } catch (e3) {
            iP.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class TL extends NO {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t2;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var i2;
              null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
            } catch (e3) {
            }
            null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), sL(this, "outputNode", void 0), sL(this, "outputTrack", void 0), sL(this, "isPlayed", false), sL(this, "sourceNode", void 0), sL(this, "context", void 0), sL(this, "audioBufferNode", void 0), sL(this, "destNode", void 0), sL(this, "audioOutputLevel", 0), sL(this, "volumeLevelAnalyser", void 0), sL(this, "_processedNode", void 0), sL(this, "playNode", void 0), sL(this, "isDestroyed", false), sL(this, "onNoAudioInput", void 0), sL(this, "isNoAudioInput", false), sL(this, "_noAudioInputCount", 0), this.context = EL(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), mL(this.outputNode), this.volumeLevelAnalyser = new gL();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(KP.ON_AUDIO_BUFFER, (function(e4) {
              for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                const i2 = e4.outputBuffer.getChannelData(t2);
                for (let e5 = 0; e5 < i2.length; e5 += 1) i2[e5] = 0;
              }
              return e4.inputBuffer;
            })(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!pP().webAudioMediaStreamDest) throw new pO(hO.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          "running" !== this.context.state && oN((() => {
            _L.emit("autoplay-failed");
          })), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed) try {
            this.outputNode.disconnect(this.playNode);
          } catch (e2) {
          }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e2 > 5) return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          jw() || iO() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t2 = this.volumeLevelAnalyser.getAnalyserNode();
          let i2;
          t2.getFloatTimeDomainData ? (i2 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i2));
          let n2 = false;
          for (let e3 = 0; e3 < i2.length; e3++) 0 !== i2[e3] && (n2 = true);
          return n2 ? (this.isNoAudioInput = false, true) : (await fN(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        disconnect() {
          var e2, t2;
          null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class RL extends TL {
        get isFreeze() {
          return false;
        }
        constructor(e2, t2, i2) {
          var n2;
          if (super(), sL(this, "sourceNode", void 0), sL(this, "track", void 0), sL(this, "clonedTrack", void 0), sL(this, "audioElement", void 0), sL(this, "isCurrentTrackCloned", false), sL(this, "isRemoteTrack", false), sL(this, "originVolumeLevelAnalyser", void 0), sL(this, "rebuildWebAudio", (async () => {
            if (iP.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, true), void iP.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then((() => iP.info("resume success"))), iP.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t3 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t3), mL(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i3 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), mL(this.outputNode), this.emit(KP.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          })), "audio" !== e2.kind) throw new pO(hO.UNEXPECTED_ERROR);
          this.track = e2;
          const r2 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), mL(this.sourceNode), i2) {
            const e3 = i2.clone();
            e3.enabled = true, this.clonedTrack = e3, iP.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i2.id, " to get the volume"));
            const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
            mL(t3), this.originVolumeLevelAnalyser = new gL(), this.originVolumeLevelAnalyser.updateSource(t3);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
          const o2 = Dw();
          t2 && o2.os === Aw.IOS && Number(null === (n2 = o2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (_L.on(RP.STATE_CHANGE, (() => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          })), this.checkHasAudioInput().then(((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          })));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t2 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t2), mL(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(KP.UPDATE_SOURCE), this.audioElement.srcObject = t2;
        }
        destroy() {
          var e2;
          this.audioElement.srcObject = null, this.audioElement.remove(), _L.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e2) {
          return this.context.createMediaStreamSource(new MediaStream([e2]));
        }
        updateOriginTrack(e2) {
          const t2 = e2.clone();
          t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), iP.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
          const i2 = this.context.createMediaStreamSource(new MediaStream([t2]));
          mL(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function CL(e2, t2, i2) {
        const n2 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, r2 = { audio: !!i2 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: n2(t2.height, 1080), maxWidth: n2(t2.width, 1920) } } };
        return t2.frameRate && "number" != typeof t2.frameRate ? (r2.video.mandatory.maxFrameRate = t2.frameRate.max, r2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (r2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(r2);
      }
      async function vL(e2, t2) {
        const i2 = await yL(e2.mediaSource), { sourceId: n2, audio: r2 } = await (function(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return new rp(((i3, n3) => {
            const r3 = document.createElement("div");
            r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const o2 = document.createElement("div");
            o2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const s2 = document.createElement("div");
            s2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", s2.setAttribute("style", "height: 12%;");
            const a2 = document.createElement("div");
            a2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const c2 = document.createElement("div");
            c2.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
            const d2 = document.createElement("button");
            d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
              document.body.removeChild(h2);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", n3(e4);
            };
            let l2 = t3;
            const u2 = document.createElement("div");
            if (t3) {
              const e4 = document.createElement("input");
              e4.setAttribute("type", "checkbox");
              const t4 = document.createElement("span");
              e4.setAttribute("style", "margin-right: 6px;"), t4.innerText = "Share audio", e4.checked = l2, e4.onchange = () => {
                l2 = e4.checked;
              }, u2.appendChild(e4), u2.appendChild(t4);
            }
            c2.appendChild(u2), c2.appendChild(d2), o2.appendChild(s2), o2.appendChild(a2), o2.appendChild(c2);
            const h2 = document.createElement("div");
            h2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), h2.appendChild(r3), h2.appendChild(o2), document.body.appendChild(h2), e3.map(((e4) => {
              if (e4.id) {
                const t4 = document.createElement("div");
                t4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let n4 = e4.thumbnail;
                try {
                  const { width: e5 } = n4.getSize();
                  e5 > 1920 && (n4 = n4.resize({ width: 1920 }));
                } catch (e5) {
                  throw e5 && e5.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e5;
                }
                t4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e4.name.replace(/[\u00A0-\u9999<>\&]/g, (function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                })) + "</span>", t4.onclick = () => {
                  document.body.removeChild(h2), i3({ sourceId: e4.id, audio: l2 });
                }, a2.appendChild(t4);
              }
            }));
          }));
        })(i2, t2);
        return await CL(n2, e2, r2);
      }
      async function yL(e2) {
        let t2 = ["window", "screen"];
        "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
        const i2 = PO();
        if (!i2) throw console.error("failed to fetch electron, please mount it to window"), new pO(hO.ELECTRON_IS_NULL);
        let n2 = null;
        try {
          var r2;
          n2 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
        } catch (e3) {
          n2 = null;
        }
        n2 && n2.then || (n2 = new rp(((e3, n3) => {
          i2.desktopCapturer.getSources({ types: t2 }, ((t3, i3) => {
            t3 ? n3(t3) : e3(i3);
          }));
        })));
        try {
          return await n2;
        } catch (e3) {
          throw new pO(hO.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      const IL = new PN("safari");
      let AL = false, bL = false;
      async function wL(e2, t2) {
        let i2 = 0, n2 = null;
        for (; i2 < 2; ) try {
          n2 = await OL(e2, t2, i2 > 0);
          break;
        } catch (e3) {
          if (e3 instanceof pO) throw iP.error("[".concat(t2, "] ").concat(e3.toString())), e3;
          const n3 = NL(e3.name || e3.code || e3, e3.message);
          if (n3.code === hO.MEDIA_OPTION_INVALID) {
            iP.debug("[".concat(t2, "] detect media option invalid, retry")), i2 += 1, await fN(500);
            continue;
          }
          throw iP.error("[".concat(t2, "] ").concat(n3.toString())), n3;
        }
        if (!n2) throw new pO(hO.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return n2;
      }
      async function OL(e2, t2, i2) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new pO(hO.NOT_SUPPORTED, "can not find getUserMedia");
        i2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const n2 = pP(), r2 = new MediaStream();
        if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen) return iP.debug("Using Video Source/ Audio Source"), r2;
        if (e2.screen) if (PO()) e2.screen.sourceId ? DL(r2, await CL(e2.screen.sourceId, e2.screen, !!e2.screenAudio)) : DL(r2, await vL(e2.screen, !!e2.screenAudio));
        else if (Uw() && e2.screen.extensionId && e2.screen.mandatory) {
          if (!n2.getStreamFromExtension) throw new pO(hO.NOT_SUPPORTED, "This browser does not support screen sharing");
          iP.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
          const i3 = await (s2 = e2.screen.extensionId, a2 = t2, new rp(((e3, t3) => {
            try {
              chrome.runtime.sendMessage(s2, { getStream: true }, ((i4) => {
                if (!i4 || !i4.streamId) return iP.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t3(new pO(hO.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                e3(i4.streamId);
              }));
            } catch (e4) {
              iP.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e4.toString()), t3(new pO(hO.CHROME_PLUGIN_NOT_INSTALL));
            }
          })));
          e2.screen.mandatory.chromeMediaSourceId = i3, DL(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
        } else if (n2.getDisplayMedia) {
          var o2;
          e2.screen.mediaSource && MP(e2.screen.mediaSource);
          const i3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (o2 = e2.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3, preferCurrentTab: c3, windowAudio: d3, monitorTypeSurfaces: l3 } = e2.screen, u3 = { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3, preferCurrentTab: c3, windowAudio: d3, monitorTypeSurfaces: l3 };
          !n3 && delete u3.selfBrowserSurface, !s3 && delete u3.surfaceSwitching, !a3 && delete u3.systemAudio, !c3 && delete u3.preferCurrentTab, !d3 && delete u3.windowAudio, !l3 && delete u3.monitorTypeSurfaces, iP.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: e2.screenAudio, controls: u3 })), DL(r2, await navigator.mediaDevices.getDisplayMedia(cL({ video: i3, audio: e2.screenAudio }, u3)));
        } else {
          if (!Bw()) throw iP.error("[".concat(t2, "] This browser does not support screenSharing")), new pO(hO.NOT_SUPPORTED, "This browser does not support screen sharing");
          {
            e2.screen.mediaSource && MP(e2.screen.mediaSource);
            const i3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
            iP.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i3))), DL(r2, await navigator.mediaDevices.getUserMedia(i3));
          }
        }
        var s2, a2;
        if (!e2.video && !e2.audio) return r2;
        let c2 = { video: e2.video, audio: e2.audio }, d2 = CD("MEDIA_DEVICE_CONSTRAINTS");
        if (d2) try {
          "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = yN(c2, d2);
        } catch (e3) {
        }
        iP.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), Dw();
        let l2, u2 = null;
        (Vw() || jw() || Mw()) && (u2 = await IL.lock());
        try {
          l2 = await navigator.mediaDevices.getUserMedia(c2);
        } catch (e3) {
          throw u2 && u2(), e3;
        }
        return c2.audio && (AL = true), c2.video && (bL = true), DL(r2, l2), u2 && u2(), r2;
      }
      function NL(e2, t2) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new pO(hO.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new pO(hO.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
          case "NotSupportedError":
            return new pO(hO.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
          case "NotReadableError":
            return new pO(hO.NOT_READABLE, "".concat(e2, ": ").concat(t2));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new pO(hO.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
          case "ConstraintNotSatisfiedError":
            return new pO(hO.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
          default:
            return iP.error("getUserMedia unexpected error", e2), new pO(hO.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
        }
      }
      function DL(e2, t2) {
        const i2 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
        o2 && (n2 && e2.removeTrack(n2), e2.addTrack(o2)), r2 && (i2 && e2.removeTrack(i2), e2.addTrack(r2));
      }
      const PL = new class extends NO {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(eL.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), sL(this, "_state", $P.IDLE), sL(this, "isAccessMicrophonePermission", false), sL(this, "isAccessCameraPermission", false), sL(this, "lastAccessMicrophonePermission", false), sL(this, "lastAccessCameraPermission", false), sL(this, "checkdeviceMatched", false), sL(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then((() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval((() => {
              (CD("ENUMERATE_DEVICES_INTERVAL") || (aO() || Lw() === Aw.HARMONY_OS) && sO()) && this.updateDevicesInfo();
            }), CD("ENUMERATE_DEVICES_INTERVAL_TIME"));
          })).catch(((e2) => iP.error(e2.toString())));
        }
        async enumerateDevices(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) throw new pO(hO.NOT_SUPPORTED, "enumerateDevices() not supported.");
          const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
          let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t2;
          r2.audio && (o2 = false), r2.video && (s2 = false);
          let a2 = null, c2 = null, d2 = null;
          if (!i2 && (o2 || s2)) {
            if (IL.isLocked && (iP.debug("[device manager] wait GUM lock"), (await IL.lock())(), iP.debug("[device manager] GUM unlock")), AL && (o2 = false, this.isAccessMicrophonePermission = true), bL && (s2 = false, this.isAccessCameraPermission = true), iP.debug("[device manager] check media device permissions", e2, t2, o2, s2), o2 && s2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t3 = NL(e3.name || e3.code || e3, e3.message);
                if (t3.code === hO.PERMISSION_DENIED) throw t3;
                iP.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t3 = NL(e3.name || e3.code || e3, e3.message);
                if (t3.code === hO.PERMISSION_DENIED) throw t3;
                iP.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
              } catch (e3) {
                const t3 = NL(e3.name || e3.code || e3, e3.message);
                if (t3.code === hO.PERMISSION_DENIED) throw t3;
                iP.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true;
            }
            iP.debug("[device manager] mic permission", e2, "cam permission", t2);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a2 && a2.getTracks().forEach(((e4) => e4.stop())), c2 && c2.getTracks().forEach(((e4) => e4.stop())), d2 && d2.getTracks().forEach(((e4) => e4.stop())), a2 = null, c2 = null, d2 = null, e3;
          } catch (e3) {
            return a2 && a2.getTracks().forEach(((e4) => e4.stop())), c2 && c2.getTracks().forEach(((e4) => e4.stop())), d2 && d2.getTracks().forEach(((e4) => e4.stop())), a2 = null, c2 = null, d2 = null, new pO(hO.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter(((e3) => "audioinput" === e3.kind));
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter(((e3) => "videoinput" === e3.kind));
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter(((e3) => "audiooutput" === e3.kind));
        }
        searchDeviceIdByName(e2) {
          let t2 = null;
          return this.deviceInfoMap.forEach(((i2) => {
            i2.device.label === e2 && (t2 = i2.device.deviceId);
          })), t2;
        }
        async getDeviceById(e2) {
          const t2 = (await this.enumerateDevices(true, true, true)).find(((t3) => t3.deviceId === e2));
          if (!t2) throw new pO(hO.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t2;
        }
        async init() {
          this.state = $P.INITING;
          try {
            await this.updateDevicesInfo(), this.state = $P.INITEND;
          } catch (e2) {
            if (this.state = $P.IDLE, !("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname)) throw new pO(hO.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.");
            throw iP.warning("Device Detection functionality cannot start properly.", e2.toString()), e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i2 = [];
          if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t3 = e2.find(((e3) => "audioinput" === e3.kind && "default" === e3.deviceId)), i3 = e2.find(((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId));
            t3 && i3 ? i3.groupId === t3.groupId ? iP.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is the same group")) : iP.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is not the same group")) : iP.debug("[device-check] default input or output not found");
          }
          const n2 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach(((e3) => {
            if (!e3.deviceId) return;
            const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
              const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i2.push(n4);
            }
            n3 && (n3.updateAt = t2);
          })), this.deviceInfoMap.forEach(((e3, n3) => {
            "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i2.push(e3));
          })), this.state !== $P.INITEND) return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i2.forEach(((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(eL.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(eL.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(eL.PLAYOUT_DEVICE_CHANGED, e3);
            }
          })), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t2 = e2.filter(((e3) => "audioinput" === e3.kind)), i2 = e2.filter(((e3) => "videoinput" === e3.kind)), n2 = { audio: false, video: false };
          for (const e3 of t2) if (e3.label && e3.deviceId) {
            n2.audio = true;
            break;
          }
          for (const e3 of i2) if (e3.label && e3.deviceId) {
            n2.video = true;
            break;
          }
          return n2;
        }
      }();
      let LL = false;
      const kL = new class extends NO {
        constructor() {
          super(...arguments), sL(this, "onAutoplayFailed", void 0), sL(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function ML() {
        if (LL) return CD("FLS_AUTOPLAY_EMITS") ? (kL.onAutoplayFailed && kL.onAutoplayFailed(), kL.emit("autoplay-failed")) : void 0;
        {
          const e2 = (t2) => {
            t2.preventDefault(), LL = false, cO() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          LL = true, cO() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), iP.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), kL.onAutoplayFailed ? kL.onAutoplayFailed() : kL.onAudioAutoplayFailed ? iP.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : iP.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), kL.emit("autoplay-failed");
        }
      }
      function UL(e2, t2, i2, n2) {
        if (!e2) return;
        const r2 = lP.getBaseInfoBySessionId(e2);
        if (!r2) return;
        const o2 = r2.info, s2 = Date.now(), a2 = cL(cL({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: kL.onAutoplayFailed || kL.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t2, trackId: n2, extend: void 0 });
        lP.send({ type: aP.AUTOPLAY_FAILED, data: a2 }, true);
      }
      const VL = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], xL = new class {
        constructor() {
          sL(this, "onAutoplayFailed", void 0), sL(this, "elementMap", /* @__PURE__ */ new Map()), sL(this, "elementStateMap", /* @__PURE__ */ new Map()), sL(this, "elementsNeedToResume", []), sL(this, "sinkIdMap", /* @__PURE__ */ new Map()), sL(this, "autoResumeAfterInterruption", ((e2) => rp.all(Array.from(this.elementMap.entries()).map((async (t2) => {
            let [i2, n2] = t2;
            const r2 = this.elementStateMap.get(i2), o2 = n2.srcObject.getAudioTracks()[0], s2 = o2 && o2.readyState;
            if (iP.debug("resume after interrupted, ele: ".concat(r2, " audio: ").concat(s2, " ").concat(e2)), "live" === s2) {
              if (e2) return n2.pause(), n2.play();
              if ("running" === _L.curState) return $w() ? (n2.pause(), n2.play()) : r2 && "paused" === r2 ? n2.play() : void 0;
            }
          }))))), sL(this, "autoResumeAfterInterruptionOnIOS15_16", (() => {
            Array.from(this.elementMap.entries()).forEach(((e2) => {
              let [t2, i2] = e2;
              const n2 = i2.srcObject.getAudioTracks()[0];
              n2 && "live" === n2.readyState && (iP.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
            }));
          })), this.autoResumeAudioElement(), _L.on(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), _L.on(RP.STATE_CHANGE, (() => {
            jw() && "suspended" === _L.prevState && "running" === _L.curState && this.autoResumeAfterInterruption();
          }));
        }
        async setSinkID(e2, t2) {
          const i2 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t2), i2) try {
            await i2.setSinkId(t2);
          } catch (e3) {
            throw new pO(hO.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
          }
        }
        play(e2, t2, i2, n2) {
          if (this.elementMap.has(t2)) return;
          const r2 = document.createElement("audio");
          r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, tL.INIT), this.setVolume(t2, i2);
          const o2 = this.sinkIdMap.get(t2);
          if (o2) try {
            r2.setSinkId(o2).catch(((e3) => {
              iP.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            }));
          } catch (e3) {
            iP.warning("[".concat(t2, "] set sink id failed"), e3.toString());
          }
          const s2 = r2.play();
          s2 && s2.then && s2.catch(((e3) => {
            n2 && UL(n2, "audio", e3.message, t2), iP.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (iP.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), oN((() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), ML();
            })));
          }));
        }
        updateTrack(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (i2.srcObject = new MediaStream([t2]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
        }
        setVolume(e2, t2) {
          const i2 = this.elementMap.get(e2);
          i2 && (t2 = Math.max(0, Math.min(100, t2)), i2.volume = t2 / 100);
        }
        getVolume(e2) {
          const t2 = this.elementMap.get(e2);
          return t2 ? t2.volume : 0;
        }
        stop(e2) {
          const t2 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t2) return;
          const i2 = this.elementsNeedToResume.indexOf(t2);
          this.elementsNeedToResume.splice(i2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t2) {
          VL.forEach(((i2) => {
            t2.addEventListener(i2, ((i3) => {
              const n2 = this.elementStateMap.get(e2), r2 = "pause" === i3.type ? "paused" : i3.type;
              if (iP.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i3.type) {
                const i4 = null == t2 ? void 0 : t2.error;
                i4 && iP.error("[".concat(e2, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
              }
              this.elementStateMap.set(e2, r2);
            }));
          }));
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach(((e3) => {
              e3.play().then(((e4) => {
                iP.debug("Auto resume audio element success");
              })).catch(((e4) => {
                iP.warning("Auto resume audio element failed!", e4);
              }));
            })), this.elementsNeedToResume = [];
          };
          new rp(((e3) => {
            document.body ? e3() : window.addEventListener("load", (() => e3()));
          })).then((() => {
            cO() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
          }));
        }
      }();
      function FL() {
        return function(e2, t2, i2) {
          const n2 = i2.value;
          return "function" == typeof n2 && (i2.value = function() {
            this._isClosed && new pO(hO.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", iP);
            for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++) t3[i3] = arguments[i3];
            const r2 = n2.apply(this, t3);
            return r2 instanceof rp ? new rp(((e4, t4) => {
              r2.then(e4).catch(t4);
            })) : r2;
          }), i2;
        };
      }
      class BL extends NO {
        constructor(e2) {
          super(), sL(this, "name", "VideoProcessorDestination"), sL(this, "ID", "0"), sL(this, "_source", void 0), sL(this, "videoContext", void 0), sL(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new pO(hO.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new pO(hO.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(QP.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(QP.ON_TRACK, void 0);
        }
      }
      class jL extends NO {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2) {
          super(), sL(this, "constraintsMap", /* @__PURE__ */ new Map()), sL(this, "statsRegistry", []), sL(this, "usageRegistry", []), sL(this, "trackId", void 0), sL(this, "direction", void 0), sL(this, "_chained", false), this.trackId = e2, this.direction = t2;
        }
        async getConstraints() {
          return await zO(this, ZP.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return iP.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2)) return iP.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find(((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2)) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex(((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2));
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
            const o2 = r2();
            e2.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
          } catch (e3) {
            iP.error(new pO(hO.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find(((t3) => t3.processorID === e2.ID && t3.processorName === e2.name)) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex(((t3) => t3.processorID === e2.ID && t3.processorName === e2.name));
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t2 } of this.usageRegistry) try {
            let i2 = t2();
            i2 instanceof rp && (i2 = await i2), e2.push(cL(cL({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            iP.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class GL extends NO {
        constructor(e2) {
          super(), sL(this, "name", "AudioProcessorDestination"), sL(this, "ID", "0"), sL(this, "inputTrack", void 0), sL(this, "inputNode", void 0), sL(this, "audioProcessorContext", void 0), sL(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new pO(hO.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new pO(hO.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(QP.ON_TRACK, void 0), this.emit(QP.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(QP.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(QP.ON_NODE, this.inputNode));
        }
      }
      class WL extends NO {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t2, i2) {
          super(), sL(this, "constraintsMap", /* @__PURE__ */ new Map()), sL(this, "statsRegistry", []), sL(this, "audioContext", void 0), sL(this, "trackId", void 0), sL(this, "direction", void 0), sL(this, "usageRegistry", []), sL(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i2;
        }
        async getConstraints() {
          return zO(this, ZP.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t2) {
          var i2;
          return iP.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2)) return this.constraintsMap.delete(e2), qO(this, ZP.REQUEST_UPDATE_CONSTRAINTS, Array.from(pp(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, i2) {
          this.statsRegistry.find(((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2)) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
        }
        unregisterStats(e2, t2) {
          const i2 = this.statsRegistry.findIndex(((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2));
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry) try {
            const o2 = r2();
            e2.push({ processorID: t2, processorName: i2, type: n2, stats: o2 });
          } catch (e3) {
            iP.error(new pO(hO.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t2) {
          this.usageRegistry.find(((t3) => t3.processorID === e2.ID && t3.processorName === e2.name)) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
        }
        unregisterUsage(e2) {
          const t2 = this.usageRegistry.findIndex(((t3) => t3.processorID === e2.ID && t3.processorName === e2.name));
          -1 !== t2 && this.usageRegistry.splice(t2, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t2 } of this.usageRegistry) try {
            let i2 = t2();
            i2 instanceof rp && (i2 = await i2), e2.push(cL(cL({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            iP.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class HL extends NO {
        get isPlayed() {
          return true;
        }
        get isFreeze() {
          return false;
        }
        constructor() {
          super(), sL(this, "context", void 0), sL(this, "processSourceNode", void 0), sL(this, "outputTrack", void 0), sL(this, "processedNode", void 0), sL(this, "clonedTrack", void 0), sL(this, "outputNode", void 0), this.outputNode = new KL();
        }
        setVolume() {
        }
        createOutputTrack() {
          throw new pO(hO.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
        }
        getOriginVolumeLevel() {
          return 0;
        }
        getAccurateVolumeLevel() {
          return 0;
        }
        stopGetAudioBuffer() {
        }
        startGetAudioBuffer() {
        }
        play() {
        }
        stop() {
        }
        destroy() {
        }
        updateTrack() {
        }
        updateOriginTrack() {
        }
        createMediaStreamSourceNode() {
        }
      }
      class KL {
        disconnect() {
        }
        connect() {
        }
      }
      function YL(e2) {
        return new rp(((t2, i2) => {
          let n2 = false;
          const r2 = document.createElement("video");
          r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
          const o2 = jw() ? "canplay" : "playing";
          r2.addEventListener(o2, (() => {
            const e3 = r2.videoWidth, i3 = r2.videoHeight;
            !e3 && Bw() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i3]));
          })), r2.srcObject = new MediaStream([e2]), r2.play().catch(TN), setTimeout((() => {
            n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
          }), 4e3);
        }));
      }
      function zL(e2) {
        const t2 = {};
        e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
        const i2 = OP(e2.encoderConfig);
        return null != i2.width && (t2.width = i2.width), null != i2.height && (t2.height = i2.height), !rO() && i2.frameRate && (t2.frameRate = i2.frameRate), Fw() && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Bw() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
      }
      function qL(e2) {
        const t2 = {};
        return rO() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Uw() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), t2;
      }
      function XL(e2) {
        const t2 = qL(e2);
        if (e2.encoderConfig) {
          const i2 = LP(e2.encoderConfig);
          t2.channelCount = i2.stereo ? 2 : 1, t2.sampleRate = i2.sampleRate, t2.sampleSize = i2.sampleSize;
        }
        return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), aO() && (t2.sampleRate = void 0), t2;
      }
      const JL = (e2) => {
        const t2 = e2._encoderConfig;
        if (!t2) return;
        const { frameRate: i2, width: n2, height: r2 } = e2.getMediaStreamTrackSettings();
        let { frameRate: o2 = i2, width: s2 = n2, height: a2 = r2 } = t2;
        if (!o2 || !s2 || !a2) return;
        s2 = AN(s2), a2 = AN(a2), o2 = AN(o2);
        const { max: c2, min: d2 } = (function(e3, t3, i3) {
          const n3 = 200 * Math.pow(i3 / 15, 0.6) * Math.pow(e3 * t3 / 640 / 360, 0.75);
          return { min: Math.floor(n3), max: Math.floor(4 * n3) };
        })(s2, a2, o2), { bitrateMax: l2, bitrateMin: u2 } = t2 || {};
        l2 || iP.debug("calculate bitrate: [w: ".concat(s2, ", h: ").concat(a2, ", fps: ").concat(o2, "] => [brMax: ").concat(l2, ", brMin: ").concat(u2, "]"));
        const { maxFramerate: h2 } = CD("ENCODER_CONFIG_LIMIT");
        return h2 && "number" == typeof h2 && (o2 = Math.min(o2, h2)), { frameRate: o2, bitrateMax: l2 || c2, bitrateMin: u2 || d2, scaleResolutionDownBy: 1, scale: 0 };
      }, QL = async (e2, t2, i2) => await (async (e3, t3, i3) => {
        const n2 = (function(e4) {
          const t4 = [];
          for (let i4 = 0; i4 < e4.length; i4 += 2) t4.push(parseInt(e4.slice(i4, i4 + 2), 16));
          return Uint8Array.from(t4);
        })(ON("" + t3 + i3)).slice(0, 16), r2 = n2.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e3));
      })(e2.buffer, t2, i2), ZL = (e2) => {
        const t2 = document.createElement("canvas");
        return t2.width = 2, t2.height = 2, new rp(((i2, n2) => {
          t2.toBlob((async (e3) => {
            if (t2.remove(), e3) {
              const n3 = await $L(e3);
              i2({ buffer: n3, width: t2.width, height: t2.height });
            } else n2(new pO(hO.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }), e2, 1);
        }));
      }, $L = async (e2) => {
        const t2 = await e2.arrayBuffer();
        return new Uint8Array(t2);
      };
      var ek, tk, ik, nk, rk, ok, sk, ak, ck, dk, lk, uk, hk, pk, _k, Ek, mk, fk, Sk, gk, Tk, Rk, Ck, vk, yk, Ik, Ak, bk, wk, Ok, Nk, Dk, Pk, Lk, kk, Mk, Uk, Vk, xk, Fk;
      let Bk = (ek = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), tk = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ik = FL(), nk = LN("LocalAudioTrack", "_enabledMutex"), rk = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ok = FL(), sk = LN("LocalAudioTrack", "_enabledMutex"), ak = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), ck = FL(), dk = FL(), lk = FL(), uk = dP({ argsMap: (e2) => [e2.getTrackId()] }), hk = FL(), pk = dP({ argsMap: (e2) => [e2.getTrackId()] }), _k = FL(), Ek = dP({ argsMap: (e2) => [e2.getTrackId()] }), mk = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), fk = dP({ argsMap: (e2) => [e2.getTrackId()] }), oL((Sk = class extends lL {
        get _source() {
          return this.initWebAudio();
        }
        set _source(e2) {
          this._trackSource = e2;
        }
        get processorContext() {
          return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
        }
        get processorDestination() {
          return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
        }
        get isPlaying() {
          return this._useAudioElement ? xL.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "LocalAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, i2), sL(this, "trackMediaType", HP.AUDIO), sL(this, "_encoderConfig", void 0), sL(this, "_trackSource", void 0), sL(this, "metadata", []), sL(this, "_enabled", true), sL(this, "_volume", 100), sL(this, "_useAudioElement", true), sL(this, "_bypassWebAudio", false), sL(this, "processor", void 0), sL(this, "_processorContext", void 0), sL(this, "_processorDestination", void 0), sL(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2, this._trackSource = new HL(), CD("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), CD("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), Vw() && !pL ? setTimeout((() => this.initWebAudio())) : this.initWebAudio();
        }
        setVolume(e2) {
          mO(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && xL.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio) return void iP.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, qO(this, UP.NEED_REPLACE_TRACK, this).then((() => {
              iP.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
            })).catch(((e4) => {
              iP.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
            })));
          } catch (e3) {
          }
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !_P()) throw new pO(hO.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await xL.setSinkID(this.getTrackId(), e2);
        }
        async setEnabled(e2, t2, i2) {
          return this._setEnabled(e2, t2, i2);
        }
        async _setEnabled(e2, t2, i2) {
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (iP.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i2 || (this._enabled = true), await qO(this, UP.NEED_ENABLE_TRACK, this), iP.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
            } catch (e3) {
              throw i2 || (this._enabled = false), iP.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
            try {
              await qO(this, UP.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw i2 || (this._enabled = true), iP.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, iP.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await qO(this, UP.NEED_MUTE_TRACK, this) : await qO(this, UP.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          dN((() => {
            iP.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }), "localAudioTrackGetStatsWarning");
          return XO(this, UP.GET_STATS) || cL({}, YP);
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), this._source.on(KP.ON_AUDIO_BUFFER, ((t3) => e2(t3)));
        }
        play() {
          iP.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (iP.debug("[".concat(this.getTrackId(), "] start audio playback in element")), xL.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
        }
        stop() {
          iP.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? xL.stop(this.getTrackId()) : this._source.stop();
        }
        close() {
          super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          iP.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xL.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: e2, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
        }
        renewMediaStreamTrack(e2) {
          return rp.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new pO(hO.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2) return e2;
          if (e2._source) throw new pO(hO.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor) return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents(e2) {
          e2.on(QP.ON_TRACK, (async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this));
          })), e2.on(QP.ON_NODE, ((e3) => {
            this._source.processedNode = e3;
          }));
        }
        unbindProcessorDestinationEvents(e2) {
          e2.removeAllListeners(QP.ON_TRACK), e2.removeAllListeners(QP.ON_NODE);
        }
        bindProcessorContextEvents(e2) {
          e2.on(ZP.REQUEST_CONSTRAINTS, (async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          }));
        }
        unbindProcessorContextEvents(e2) {
          e2.removeAllListeners(ZP.REQUEST_CONSTRAINTS);
        }
        initWebAudio() {
          return this._trackSource instanceof HL && (this._trackSource = new RL(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
        }
        initProcessor() {
          const e2 = new WL(this._source.context, this.getTrackId(), "local"), t2 = new GL(e2);
          return this._processorContext = e2, this._processorDestination = t2, this.bindProcessorContextEvents(e2), this.bindProcessorDestinationEvents(t2), this._source.on(KP.UPDATE_SOURCE, (() => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: e2 });
          })), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (xL.stop(this.getTrackId()), this._source.play()), qO(this, UP.NEED_REPLACE_MIXING_TRACK, this).then((() => {
            iP.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
          })).catch(((e3) => {
            iP.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), e3);
          }))), { processorContext: e2, processorDestination: t2 };
        }
      }).prototype, "setVolume", [ek], Object.getOwnPropertyDescriptor(Sk.prototype, "setVolume"), Sk.prototype), oL(Sk.prototype, "setPlaybackDevice", [tk, ik], Object.getOwnPropertyDescriptor(Sk.prototype, "setPlaybackDevice"), Sk.prototype), oL(Sk.prototype, "setEnabled", [nk, rk, ok], Object.getOwnPropertyDescriptor(Sk.prototype, "setEnabled"), Sk.prototype), oL(Sk.prototype, "setMuted", [sk, ak, ck], Object.getOwnPropertyDescriptor(Sk.prototype, "setMuted"), Sk.prototype), oL(Sk.prototype, "getStats", [dk], Object.getOwnPropertyDescriptor(Sk.prototype, "getStats"), Sk.prototype), oL(Sk.prototype, "setAudioFrameCallback", [lk], Object.getOwnPropertyDescriptor(Sk.prototype, "setAudioFrameCallback"), Sk.prototype), oL(Sk.prototype, "play", [uk, hk], Object.getOwnPropertyDescriptor(Sk.prototype, "play"), Sk.prototype), oL(Sk.prototype, "stop", [pk, _k], Object.getOwnPropertyDescriptor(Sk.prototype, "stop"), Sk.prototype), oL(Sk.prototype, "close", [Ek], Object.getOwnPropertyDescriptor(Sk.prototype, "close"), Sk.prototype), oL(Sk.prototype, "pipe", [mk], Object.getOwnPropertyDescriptor(Sk.prototype, "pipe"), Sk.prototype), oL(Sk.prototype, "unpipe", [fk], Object.getOwnPropertyDescriptor(Sk.prototype, "unpipe"), Sk.prototype), Sk), jk = (gk = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Tk = FL(), Rk = LN("MicrophoneAudioTrack", "_enabledMutex"), Ck = dP({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), vk = FL(), yk = dP({ argsMap: (e2) => [e2.getTrackId()] }), oL((Ik = class extends Bk {
        get __className__() {
          return "MicrophoneAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2.encoderConfig ? LP(t2.encoderConfig) : {}, n2, CD("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), sL(this, "_config", void 0), sL(this, "_deviceName", "default"), sL(this, "_constraints", void 0), sL(this, "_originalConstraints", void 0), sL(this, "_enabled", true), this._config = t2, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), ($w() || eO()) && _L.bindInterruptDetectorTrack(this);
        }
        async setDevice(e2) {
          if (iP.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled) try {
            const t2 = await PL.getDeviceById(e2), i2 = {};
            i2.audio = cL({}, this._constraints), i2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await wL(i2, this.getTrackId());
            } catch (e3) {
              throw iP.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await wL({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw iP.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          else try {
            const t2 = await PL.getDeviceById(e2);
            this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw iP.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          iP.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
        }
        async setEnabled(e2, t2, i2) {
          if (t2) return iP.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (iP.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), CD("AUTO_RESET_AUDIO_ROUTE") && (jw() || iO())) {
            const t3 = navigator.audioSession;
            t3 && (e2 || (t3.type = "playback"), t3.type = "auto");
          }
          if (!e2) {
            var n2;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i2 || (this._enabled = false);
            try {
              await qO(this, UP.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw iP.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
            }
            return;
          }
          const r2 = cL({}, this._constraints), o2 = PL.searchDeviceIdByName(this._deviceName);
          o2 && !r2.deviceId && (r2.deviceId = o2);
          try {
            i2 || (this._enabled = true);
            const e3 = await wL({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await qO(this, UP.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw i2 || (this._enabled = false), iP.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
          }
          iP.info("[".concat(this.getTrackId(), "] setEnabled success"));
        }
        close() {
          super.close(), ($w() || eO()) && _L.unbindInterruptDetectorTrack(this), kP.some(((e2) => (function(e3) {
            return "__className__" in e3 && "MicrophoneAudioTrack" === e3.__className__;
          })(e2))) || hL && hL() && (lP.reportApiInvoke(null, { name: "BG_AUDIO_TAG_RESTART", options: {}, tag: kO.TRACER }).onSuccess(), iP.debug("restart background audio tag success"));
        }
        onTrackEnded() {
          if ((jw() || iO()) && this._enabled && !this._isClosed && _L.duringInterruption) {
            const e2 = async () => {
              _L.off(RP.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (iP.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _L.on(RP.IOS_INTERRUPTION_END, e2);
          } else iP.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(GP.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, i2 = PL.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = i2), this._constraints = t2, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e3 = await wL({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents(e2) {
          super.bindProcessorContextEvents(e2), e2.on(ZP.REQUEST_UPDATE_CONSTRAINTS, (async (e3, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e4) {
              i2(e4);
            }
          }));
        }
        unbindProcessorContextEvents(e2) {
          super.unbindProcessorContextEvents(e2), e2.removeAllListeners(ZP.REQUEST_UPDATE_CONSTRAINTS);
        }
      }).prototype, "setDevice", [gk, Tk], Object.getOwnPropertyDescriptor(Ik.prototype, "setDevice"), Ik.prototype), oL(Ik.prototype, "setEnabled", [Rk, Ck, vk], Object.getOwnPropertyDescriptor(Ik.prototype, "setEnabled"), Ik.prototype), oL(Ik.prototype, "close", [yk], Object.getOwnPropertyDescriptor(Ik.prototype, "close"), Ik.prototype), Ik), Gk = (Ak = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), bk = FL(), wk = dP({ argsMap: (e2) => [e2.getTrackId()] }), Ok = FL(), Nk = dP({ argsMap: (e2) => [e2.getTrackId()] }), Dk = FL(), Pk = dP({ argsMap: (e2) => [e2.getTrackId()] }), Lk = FL(), kk = dP({ argsMap: (e2) => [e2.getTrackId()] }), Mk = FL(), Uk = dP({ argsMap: (e2) => [e2.getTrackId()] }), Vk = dP({ argsMap: (e2) => [e2.getTrackId()] }), xk = FL(), oL((Fk = class extends Bk {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(t2.createOutputTrack(), i2, n2), sL(this, "source", void 0), sL(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = e2, this._bufferSource = t2, this._bufferSource.on(KP.AUDIO_SOURCE_STATE_CHANGE, ((e3) => {
            this.safeEmit(GP.SOURCE_STATE_CHANGE, e3);
          }));
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e2) {
          this._bufferSource.seekAudioBuffer(e2);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        close() {
          this.source = null, this._bufferSource.destroy(), super.close();
        }
        setAudioBufferPlaybackSpeed(e2) {
          mO(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
        }
      }).prototype, "startProcessAudioBuffer", [Ak, bk], Object.getOwnPropertyDescriptor(Fk.prototype, "startProcessAudioBuffer"), Fk.prototype), oL(Fk.prototype, "pauseProcessAudioBuffer", [wk, Ok], Object.getOwnPropertyDescriptor(Fk.prototype, "pauseProcessAudioBuffer"), Fk.prototype), oL(Fk.prototype, "seekAudioBuffer", [Nk, Dk], Object.getOwnPropertyDescriptor(Fk.prototype, "seekAudioBuffer"), Fk.prototype), oL(Fk.prototype, "resumeProcessAudioBuffer", [Pk, Lk], Object.getOwnPropertyDescriptor(Fk.prototype, "resumeProcessAudioBuffer"), Fk.prototype), oL(Fk.prototype, "stopProcessAudioBuffer", [kk, Mk], Object.getOwnPropertyDescriptor(Fk.prototype, "stopProcessAudioBuffer"), Fk.prototype), oL(Fk.prototype, "close", [Uk], Object.getOwnPropertyDescriptor(Fk.prototype, "close"), Fk.prototype), oL(Fk.prototype, "setAudioBufferPlaybackSpeed", [Vk, xk], Object.getOwnPropertyDescriptor(Fk.prototype, "setAudioBufferPlaybackSpeed"), Fk.prototype), Fk);
      class Wk extends Bk {
        get __className__() {
          return "MixingAudioTrack";
        }
        get isActive() {
          for (const e2 of this.trackList) if (e2._enabled && !e2._isClosed && !e2.muted) return true;
          return false;
        }
        constructor() {
          const e2 = EL().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, SN(8, "track-mix-")), sL(this, "trackList", void 0), sL(this, "destNode", void 0), this._useAudioElement = false;
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return -1 !== this.trackList.indexOf(e2);
        }
        addAudioTrack(e2) {
          -1 === this.trackList.indexOf(e2) ? (iP.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : iP.debug("track ".concat(e2.getTrackId(), " is already added"));
        }
        removeAudioTrack(e2) {
          if (-1 !== this.trackList.indexOf(e2)) {
            iP.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            nN(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach(((t2) => {
            t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
          })), this._encoderConfig = e2;
        }
        _updateRtpTransceiver(e2) {
          this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach(((t2) => {
            t2 instanceof Wk ? t2.emit(jP.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
          })));
        }
      }
      class Hk extends TL {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.safeEmit(KP.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), sL(this, "audioBuffer", void 0), sL(this, "sourceNode", void 0), sL(this, "startPlayTime", 0), sL(this, "startPlayOffset", 0), sL(this, "pausePlayTime", 0), sL(this, "options", void 0), sL(this, "currentLoopCount", 0), sL(this, "currentPlaybackSpeed", 100), sL(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer ? this.audioBuffer.duration : 0;
        }
        get playbackSpeed() {
          return this.currentPlaybackSpeed;
        }
        get currentTime() {
          return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
        }
        updateOptions(e2) {
          "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : iP.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        destroy() {
          this.audioBuffer = null, super.destroy();
        }
        setAudioBufferPlaybackSpeed(e2) {
          this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const Kk = /* @__PURE__ */ new Map();
      function Yk(e2, t2) {
        if (0 === e2.length || 0 === t2.length) return 1 / 0;
        const i2 = wN(e2), n2 = wN(t2);
        return Math.floor(n2 / i2);
      }
      class zk {
        get rendFrameRate() {
          const e2 = Math.max(1, Yk(this._render_interframe_delays_sizes, this._render_interframe_delays));
          return Math.floor(1e3 / e2);
        }
        get videoElementStatus() {
          return this._isInPage ? this._videoElementStatus : tL.DESTROYED;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (iP.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        get videoState() {
          return this._videoState;
        }
        set videoState(e2) {
          var t2;
          e2 !== this._videoState && (this._videoState = e2, null === (t2 = this.onVideoStateChanged) || void 0 === t2 || t2.call(this, this.videoState));
        }
        constructor(e2) {
          sL(this, "trackId", void 0), sL(this, "config", void 0), sL(this, "onFirstVideoFrameDecoded", void 0), sL(this, "onFirstVideoFrameRender", void 0), sL(this, "onVideoBufferReady", void 0), sL(this, "onVideoStateChanged", void 0), sL(this, "freezeTimeCounterList", []), sL(this, "renderFreezeAccTime", 0), sL(this, "renderFreezeAccTime2", 0), sL(this, "isKeepLastFrame", false), sL(this, "isDestroyed", false), sL(this, "timeUpdatedCount", 0), sL(this, "freezeTime", 0), sL(this, "playbackTime", 0), sL(this, "lastTimeUpdatedTime", 0), sL(this, "autoplayFailed", false), sL(this, "videoTrack", void 0), sL(this, "videoElement", void 0), sL(this, "cacheVideoElement", void 0), sL(this, "cancelRVFId", void 0), sL(this, "internal", false), sL(this, "_render_interframe_delays", []), sL(this, "_render_interframe_delays_sizes", []), sL(this, "_videoState", iL.VideoStateStopped), sL(this, "videoElementCheckInterval", void 0), sL(this, "videoElementFreezeTimeout", void 0), sL(this, "_videoElementStatus", tL.NONE), sL(this, "_isInPage", true), sL(this, "isGettingVideoDimensions", false), sL(this, "startGetVideoDimensions", (() => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return iP.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          })), sL(this, "autoResumeAfterInterruption", (() => {
            this.videoTrack && "live" === this.videoTrack.readyState && "running" === _L.curState && (iP.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(kw())), tO() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          })), sL(this, "handleVideoEvents", ((e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                "play" === e3.type && iP.debug("[".concat(this.trackId, "] video element status: play")), this.startGetVideoDimensions(), this.videoElementStatus = tL.PLAYING;
                break;
              case "loadeddata":
                if (this.videoState = iL.VideoStateStarting, this.onFirstVideoFrameRender && this.onFirstVideoFrameRender(), this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                  try {
                    this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                  } catch (e4) {
                  }
                  this.cacheVideoElement = void 0;
                }
                break;
              case "canplay":
                this.videoElementStatus = tL.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = tL.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = tL.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = tL.PAUSED, jw() || iO() || Vw() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (iP.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = tL.WAITING;
                break;
              case "abort":
                this.videoElementStatus = tL.ABORT;
                break;
              case "ended":
                this.videoElementStatus = tL.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = tL.EMPTIED;
                break;
              case "error": {
                const e4 = this.videoElement.error;
                e4 && (this.videoElementStatus = tL.ERROR, iP.error("[".concat(this.trackId, "] media error: ").concat(e4.message, " (").concat(e4.code, ")")));
                break;
              }
              case "timeupdate": {
                const e4 = performance.now();
                if (this.timeUpdatedCount += 1, this.onVideoBufferReady && this.timeUpdatedCount > CD("BUFFER_READY_FRAMES") && this.onVideoBufferReady(), this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e4);
                const t2 = e4 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
                if (this.lastTimeUpdatedTime = e4, eU.lastVisibleTime < eU.lastHiddenTime || i2 < eU.lastHiddenTime || i2 < eU.lastVisibleTime) return;
                if (this.isSkipCalcRenderFreezeTime()) return;
                for (t2 > CD("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                  this.playbackTime -= 6e3;
                  const e5 = Math.min(6e3, this.freezeTime);
                  this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                }
                break;
              }
            }
          })), sL(this, "autoResumeAfterInterruptionOnIOS15_16", (() => {
            this.videoTrack && "live" === this.videoTrack.readyState && (iP.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(kw())), tO() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          })), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), _L.on(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          var e2;
          return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
        }
        play(e2) {
          const t2 = this.videoElement.play();
          t2 && t2.catch && t2.catch(((t3) => {
            e2 && UL(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (iP.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : iP.warning("[".concat(this.trackId, "] play warning: "), t3);
          }));
          const i2 = Dw();
          if (("Safari" === i2.name && 15 === Number(i2.version) || $w()) && t2 && t2.then) {
            const e3 = () => {
              this.config.mirror && !this.config.noStyle && (this.videoElement.style.transform = "rotateY(180deg)");
            };
            t2.then(e3).catch(e3);
          }
        }
        getCurrentFrame() {
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t2 = e2.getContext("2d");
          if (!t2) return iP.error("create canvas context failed!"), new ImageData(2, 2);
          t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const i2 = t2.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), i2;
        }
        async getCurrentFrameToUint8Array(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          const i2 = document.createElement("canvas");
          i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
          const n2 = i2.getContext("2d");
          return n2 ? (n2.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new rp(((n3, r2) => {
            i2.toBlob((async (e3) => {
              if (i2.remove(), e3) {
                const t3 = await $L(e3);
                n3({ buffer: t3, width: i2.width, height: i2.height });
              } else r2(new pO(hO.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }), e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
          }))) : await ZL(e2);
        }
        destroy() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          this.isDestroyed = true, _L.off(RP.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _L.off(RP.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), e2 ? this.videoElement.pause() : this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = iL.VideoStateStopped;
        }
        initVideoElement() {
          if (this.videoElementStatus = tL.INIT, !this.videoElementCheckInterval && (qk.forEach(((e3) => {
            this.videoElement.addEventListener(e3, this.handleVideoEvents);
          })), this.videoElementCheckInterval = window.setInterval((() => {
            this._isInPage = (function(e3) {
              return e3 !== document.body && document.body.contains(e3);
            })(this.videoElement);
          }), 1e3), CD("ENABLE_VIDEO_FRAME_CALLBACK"))) {
            var e2, t2;
            let i3;
            const n3 = () => {
              "visible" === document.visibilityState && (document.removeEventListener("visibilitychange", n3), this.videoElementFreezeTimeout = window.setTimeout(r2, CD("VIDEO_FREEZE_DURATION")));
            }, r2 = () => {
              this.videoElementFreezeTimeout = void 0, this.videoState === iL.VideoStateDecoding && ("visible" === document.visibilityState ? this.videoState = iL.VideoStateFrozen : document.addEventListener("visibilitychange", n3));
            }, o2 = (e3, t3) => {
              if (this.videoElementStatus === tL.PLAYING) {
                if (i3) {
                  const e4 = t3.presentationTime - i3.presentationTime, n5 = t3.presentedFrames - i3.presentedFrames;
                  this._render_interframe_delays_sizes.push(n5), this._render_interframe_delays.push(e4);
                  const o3 = wN(this._render_interframe_delays_sizes), s3 = o3 - this._render_interframe_delays_sizes[0];
                  if (o3 > 30 && s3 > 5 && (this._render_interframe_delays_sizes.shift(), this._render_interframe_delays.shift()), this.videoState === iL.VideoStateStarting && (this.videoState = iL.VideoStateDecoding), this.videoState === iL.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r2, CD("VIDEO_FREEZE_DURATION"))), e4 < CD("VIDEO_FREEZE_DURATION") && this.videoState === iL.VideoStateFrozen && (this.videoState = iL.VideoStateDecoding), e4 > CD("VIDEO_FREEZE_DURATION") && eU.lastVisibleTime >= eU.lastHiddenTime && i3.timestamp > eU.lastVisibleTime && i3.timestamp > eU.lastHiddenTime) {
                    const t4 = Math.min(66, Yk(this._render_interframe_delays_sizes, this._render_interframe_delays)), i4 = Math.max(0, e4 - (n5 - 1) * t4);
                    this.renderFreezeAccTime2 += i4 > t4 ? i4 : 0, this.renderFreezeAccTime += e4;
                  }
                }
                i3 = cL(cL({}, t3), {}, { timestamp: e3 });
              } else this.isSkipCalcRenderFreezeTime() && (i3 = cL(cL({}, t3), {}, { timestamp: e3 }));
              var n4, s2;
              CD("ENABLE_VIDEO_FRAME_CALLBACK") && (this.cancelRVFId = null === (n4 = (s2 = this.videoElement).requestVideoFrameCallback) || void 0 === n4 ? void 0 : n4.call(s2, o2));
            };
            this.cancelRVFId = null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 ? void 0 : e2.call(t2, o2);
          }
          this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), aO() && !CD("HIDE_NO_POSTER") && (this.videoElement.poster = "noposter");
          const i2 = Dw();
          this.config.noStyle || ("Safari" === i2.name && 15 === Number(i2.version) || $w() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover"), this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Bw() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Bw() && this.videoElement.load());
          const n2 = this.videoElement.play();
          void 0 !== n2 && n2.catch(((e3) => {
            iP.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
          }));
        }
        resetVideoElement() {
          var e2, t2;
          qk.forEach(((e3) => {
            this.videoElement && this.videoElement.removeEventListener(e3, this.handleVideoEvents);
          })), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.cancelRVFId && this.videoElement && (null === (e2 = (t2 = this.videoElement).cancelVideoFrameCallback) || void 0 === e2 || e2.call(t2, this.cancelRVFId), this.cancelRVFId = void 0), this.videoElementStatus = tL.NONE;
        }
        isSkipCalcRenderFreezeTime() {
          return this.videoElementStatus === tL.DESTROYED || this.internal;
        }
        handleAutoPlayFailed() {
          const e2 = (t2) => {
            t2.preventDefault(), this.videoElement.play().then((() => {
              iP.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
            })).catch(((e3) => {
              iP.error(e3);
            })), this.autoplayFailed = false, cO() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          cO() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), ML();
        }
      }
      const qk = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
      class Xk extends zk {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          super(e2), sL(this, "container", void 0), sL(this, "slot", void 0), this.slot = e2.element, this.internal = t2, this.updateConfig(e2);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t2 = e2.element;
          var i2;
          !this.internal || this.slot ? (t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements()) : (this.slot = t2, t2 && this.container ? (this.internal = false, this.container.id = "agora-video-player-".concat(this.trackId), this.videoElement.id = "video_".concat(this.trackId), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", null === (i2 = this.slot) || void 0 === i2 || i2.appendChild(this.container)) : this.createElements());
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          var t2;
          null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
        }
        getCurrentFrame() {
          var e2;
          return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameToUint8Array(e2) {
          var t2;
          let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i2) : await ZL(e2);
        }
        destroy() {
          if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
            try {
              var e2;
              this.container.remove(), null === (e2 = this.slot) || void 0 === e2 || e2.removeChild(this.container);
            } catch (e3) {
            }
            this.container = void 0;
          }
        }
        createElements() {
          var e2;
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", CD("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), null === (e2 = this.slot) || void 0 === e2 || e2.appendChild(this.container);
        }
        mountedVideoElement() {
          var e2;
          !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
        }
        unmountedVideoElement() {
          var e2;
          if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
            super.resetVideoElement();
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = document.createElement("video");
          }
        }
        resetVideoElement() {
          var e2;
          null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
        }
        getContainerElement() {
          return this.container;
        }
      }
      var Jk, Qk, Zk, $k, eM, tM, iM, nM, rM, oM, sM, aM, cM, dM, lM, uM, hM, pM, _M, EM, mM, fM, SM, gM, TM, RM, CM, vM, yM, IM, AM, bM, wM, OM, NM, DM, PM, LM;
      let kM = (Jk = dP({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), Qk = FL(), Zk = dP({ argsMap: (e2) => [e2.getTrackId()] }), $k = LN("LocalVideoTrack", "_enabledMutex"), eM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), tM = FL(), iM = LN("LocalVideoTrack", "_enabledMutex"), nM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), rM = FL(), oM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2._saveEncodeBitrateRatio] }), sM = FL(), aM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), cM = FL(), dM = FL(), lM = dP({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), uM = FL(), hM = FL(), pM = FL(), _M = dP({ argsMap: (e2) => [e2.getTrackId()] }), EM = FL(), mM = FL(), fM = FL(), SM = FL(), gM = FL(), TM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), RM = dP({ argsMap: (e2) => [e2.getTrackId()] }), CM = dP({ argsMap: (e2) => [e2.getTrackId()] }), vM = dP({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2.label, i2] }), yM = class e2 extends lL {
        get videoHeight() {
          if (Vw()) {
            const { height: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoHeight = e3, this._videoHeight;
          }
          return this._videoHeight;
        }
        get videoWidth() {
          if (Vw()) {
            const { width: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoWidth = e3, this._videoWidth;
          }
          return this._videoWidth;
        }
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== tL.PLAYING);
        }
        get processorDestination() {
          return this._processorDestination;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e3) {
          this._processorContext = e3;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e3, t2, i2, n2, r2, o2) {
          if (super(e3, r2), sL(this, "trackMediaType", HP.VIDEO), sL(this, "_player", void 0), sL(this, "isUseScaleResolutionDownBy", false), sL(this, "_videoVisibleTimer", null), sL(this, "_previousVideoVisibleStatus", void 0), sL(this, "_clearPreviousVideoVisibleStatus", (() => this._previousVideoVisibleStatus = void 0)), sL(this, "_encoderConfig", void 0), sL(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), sL(this, "_optimizationMode", void 0), sL(this, "_saveEncodeBitrateRatio", 1), sL(this, "_videoHeight", void 0), sL(this, "_videoWidth", void 0), sL(this, "_forceBitrateLimit", void 0), sL(this, "_enabled", true), sL(this, "_processorDestination", void 0), sL(this, "_processorContext", void 0), Vw()) {
            const { width: t3, height: i3 } = e3.getSettings();
            this._videoWidth = t3, this._videoHeight = i3;
          } else this.updateMediaStreamTrackResolution();
          if (this._scalabilityMode = i2, this._optimizationMode = n2, this._hints = o2 || [], t2 && -1 !== this._hints.indexOf(VP.CUSTOM_TRACK) ? this._encoderConfig = sN(t2) : this._encoderConfig = t2, -1 === this._hints.indexOf(VP.SCREEN_TRACK)) this.updateBitrateFromProfile();
          else if (Hw(bw.CHROME, 115) && -1 !== Lw().indexOf("Windows")) {
            const t3 = (function(e4, t4) {
              if ("VideoFrame" in window && "TransformStream" in window && pP().supportWebRTCInsertableStream) {
                const i3 = new MediaStreamTrackProcessor(e4), n3 = new MediaStreamTrackGenerator({ kind: "video" });
                let r3, o3, s2 = Date.now();
                const a2 = () => {
                  c2 && (clearInterval(c2), c2 = void 0), r3 && (r3.close(), r3 = void 0), e4.stop(), o3 = void 0, n3.removeEventListener("ended", a2);
                };
                let c2 = window.setInterval((() => {
                  if (o3 && r3 && Date.now() - s2 > (null != t4 ? t4 : 1e3)) try {
                    "live" === n3.readyState ? o3.enqueue(r3.clone()) : a2();
                  } catch (e5) {
                    a2();
                  }
                }), null != t4 ? t4 : 1e3);
                const d2 = new TransformStream({ transform: (e5, t5) => {
                  "live" === n3.readyState ? (o3 = t5, s2 = Date.now(), void 0 === r3 ? (r3 = e5, t5.enqueue(e5.clone())) : (t5.enqueue(r3), r3 = e5)) : e5.close();
                } });
                return n3.addEventListener("ended", a2), i3.readable.pipeThrough(d2).pipeTo(n3.writable), n3;
              }
            })(e3);
            t3 && (iP.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t3);
          }
          t2 && -1 !== this._hints.indexOf(VP.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this._processorContext = new jL(this.getTrackId(), "local"), this._processorDestination = new BL(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e3) {
            const t3 = document.getElementById(e3);
            t3 ? e3 = t3 : (iP.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), e3 = document.body);
          }
          iP.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = cL(cL(cL({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(i2) : (e3 instanceof HTMLVideoElement ? this._player = new zk(i2) : this._player = new Xk(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval((() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.safeEmit(GP.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }), CD("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, iP.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled) return;
            this.stateCheck("enabled", e3);
          }
          if (iP.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), !e3) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await qO(this, UP.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw iP.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            return t2 || (this._enabled = false), void iP.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await qO(this, UP.NEED_ENABLE_TRACK, this);
          } catch (e4) {
            throw iP.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e4.toString()), e4;
          }
          iP.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, iP.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), e3 ? await qO(this, UP.NEED_MUTE_TRACK, this) : await qO(this, UP.NEED_UNMUTE_TRACK, this));
        }
        async setSaveEncodeBitrateRatio() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._saveEncodeBitrateRatio;
          if (1 !== this._saveEncodeBitrateRatio && this._encoderConfig && this._encoderConfig.bitrateMax && this._encoderConfig.bitrateMin) {
            this._encoderConfig.bitrateMin = Math.floor(this._encoderConfig.bitrateMin * e3), this._encoderConfig.bitrateMax = Math.floor(this._encoderConfig.bitrateMax * e3), iP.debug("[".concat(this.getTrackId(), "] set save encode bitrate ratio, ").concat(e3)), this._saveEncodeBitrateRatio = 1;
            try {
              await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e4) {
              return e4.throw(iP);
            }
          }
        }
        async setEncoderConfiguration(e3, t2) {
          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          if (e3 = OP(e3), CD("USE_STANDARD_BITRATE_DEFAULT") && (delete e3.bitrateMax, delete e3.bitrateMin), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), e3.width || e3.height || e3.frameRate) {
            const t3 = zL({ encoderConfig: e3 });
            (Vw() || jw() || iO()) && (t3.deviceId = void 0), iP.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(t3));
            try {
              await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
            } catch (e4) {
              const t4 = new pO(hO.UNEXPECTED_ERROR, e4.toString());
              throw iP.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
            }
          }
          this._encoderConfig = e3, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(iP);
          }
        }
        getStats() {
          dN((() => {
            iP.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }), "localVideoTrackGetStatsWarning");
          return XO(this, UP.GET_STATS) || cL({}, zP);
        }
        async setBeautyEffect(e3) {
          iP.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e3) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e3, t2) : await ZL(e3);
        }
        async findClosestProfile() {
          const { width: e3, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings(), { width: n2, height: r2, frameRate: o2 } = this._encoderConfig || {}, s2 = AN(this._videoWidth || e3 || n2 || 0), a2 = AN(this._videoHeight || t2 || r2 || 0), c2 = (function(e4, t3, i3) {
            if (!Array.isArray(CD("VIDEO_ENCODER_CONFIG_LIST"))) return false;
            if (0 === CD("VIDEO_ENCODER_CONFIG_LIST").length) return false;
            const n3 = Math.min(e4, t3);
            return !(n3 >= 480) && cL(cL({}, CD("VIDEO_ENCODER_CONFIG_LIST").find(((e5) => e5.height > n3))), {}, { frameRate: i3 });
          })(s2, a2, AN(i2 || o2 || 15));
          if (c2) return iP.debug("[".concat(this.getTrackId(), "] find closest profile, ").concat(s2, "x").concat(a2, " => ").concat(JSON.stringify(c2))), this.setEncoderConfiguration(c2);
        }
        async setBitrateLimit(e3) {
          iP.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), e3 && (this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate));
        }
        async setOptimizationMode(e3) {
          if ("motion" !== e3 && "detail" !== e3 && "balanced" !== e3) return void iP.error(hO.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
          const t2 = this._optimizationMode;
          try {
            this._optimizationMode = e3, await qO(this, UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
          } catch (e4) {
            throw this._optimizationMode = t2, iP.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e4.toString()), e4;
          }
          iP.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")"));
        }
        setScalabiltyMode(e3) {
          if (1 === e3.numSpatialLayers && 1 !== e3.numTemporalLayers) return iP.error(hO.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabilityMode = e3, iP.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")"));
        }
        updateMediaStreamTrackResolution() {
          YL(this._originMediaStreamTrack).then(((e3) => {
            let [t2, i2] = e3;
            this._videoHeight = i2, this._videoWidth = t2;
          })).catch(TN);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        async setSenderConfiguration(e3) {
          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          iP.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e3)), e3 = OP(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), this._encoderConfig = e3, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(iP);
          }
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig) return;
          const { width: e3, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings();
          if (!e3 || !t2 || !i2) return;
          const { bitrateMax: n2, bitrateMin: r2 } = this._encoderConfig;
          if (null == r2 || null == n2) {
            const { max: o2, min: s2 } = (function(e4, t3, i3, n3, r3) {
              const o3 = CD("BITRATE_ADAPTER_TYPE");
              if ("DEFAULT_BITRATE" === o3) return { min: n3, max: r3 };
              if (void 0 === r3) {
                const s3 = Math.floor(200 * Math.pow(i3 / 15, 0.6) * Math.pow(e4 * t3 / 640 / 360, 0.75));
                r3 = "STANDARD_BITRATE" === o3 ? 4 * s3 : 2 * s3, n3 = null != n3 ? n3 : s3;
              } else n3 = null != n3 ? n3 : Math.floor(r3 / 10);
              return { min: n3, max: r3 };
            })(e3, t2, i2, r2, n2);
            if (this._encoderConfig.bitrateMin = s2, this._encoderConfig.bitrateMax = o2, CD("VIDEO_STANDARD_BITRATE_VERSION") && null == r2 && null == n2) {
              const [n3, r3] = (function(e4, t3, i3) {
                const n4 = 4 * Math.floor(2e5 * Math.pow(i3 / 15, 0.6) * Math.pow(e4 * t3 / 230400, 0.75)), r4 = e4 * t3, o3 = /* @__PURE__ */ new Map([[19200, 0.9], [230400, 0.85], [518400, 0.75], [921600, 0.7], [2073600, 0.6], [3686400, 0.5]]), s3 = /* @__PURE__ */ new Map([[230400, 0.95], [518400, 0.9], [921600, 0.85], [2073600, 0.8]]);
                let a2 = pp(o3).call(o3).next().value, c2 = 1;
                if (o3.has(r4)) a2 = o3.get(r4);
                else {
                  var d2;
                  const e5 = Qp(d2 = Array.from(o3.entries())).call(d2, ((e6, t5) => {
                    let [i4] = e6, [n5] = t5;
                    return i4 - n5;
                  })), t4 = e5.find(((e6) => {
                    let [t5] = e6;
                    return t5 > r4;
                  }));
                  if (t4) {
                    const i4 = e5.indexOf(t4);
                    if (i4 > 0) {
                      const n5 = e5[i4 - 1], o4 = (r4 - n5[0]) / (t4[0] - n5[0]);
                      a2 = n5[1] + o4 * (t4[1] - n5[1]);
                    } else a2 = t4[1];
                  } else a2 = e5[e5.length - 1][1];
                }
                if (s3.has(r4)) c2 = s3.get(r4);
                else {
                  var l2;
                  const e5 = Qp(l2 = Array.from(s3.entries())).call(l2, ((e6, t5) => {
                    let [i4] = e6, [n5] = t5;
                    return i4 - n5;
                  })), t4 = e5.find(((e6) => {
                    let [t5] = e6;
                    return t5 > r4;
                  }));
                  if (t4) {
                    const i4 = e5.indexOf(t4);
                    if (i4 > 0) {
                      const n5 = e5[i4 - 1], o4 = (r4 - n5[0]) / (t4[0] - n5[0]);
                      c2 = n5[1] + o4 * (t4[1] - n5[1]);
                    } else c2 = t4[1];
                  } else c2 = e5[e5.length - 1][1];
                }
                const u2 = CD("VIDEO_NEW_BITRATE_RATIO");
                u2 && u2 > 0 && (a2 = u2 / 100);
                const h2 = Math.floor(n4 * a2), p2 = Math.floor(65e4 * Math.pow(e4 * t3 / 230400, 0.5) * Math.pow(i3 / 15, 0.69));
                let _2 = h2;
                const E2 = CD("VIDEO_STANDARD_BITRATE_VERSION");
                return E2 && E2 > 0 && (1 === E2 ? _2 = n4 : 2 === E2 ? _2 = h2 : 3 === E2 && (_2 = p2)), [Math.floor(_2 / 1e3), c2];
              })(e3, t2, i2);
              this._encoderConfig.bitrateMax = n3, this._encoderConfig.bitrateMin = s2 ? Math.min(s2, n3) : n3, this._saveEncodeBitrateRatio = r3, iP.debug("[".concat(this.getTrackId(), "] update new bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(this._encoderConfig.bitrateMax, ", brMin: ").concat(this._encoderConfig.bitrateMin, ", save_bitrate_ratio: ").concat(this._saveEncodeBitrateRatio, "]"));
            } else iP.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(o2, ", brMin: ").concat(s2, "]")), this._saveEncodeBitrateRatio = 1;
          }
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t2;
            const i2 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e4 = AO.checkOneElementVisible(r2), t3 = Object.assign({}, e4);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e5 = lP.reportApiInvoke(null, { tag: kO.TRACER, name: LO.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e4) {
            throw new pO(hO.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        async renewMediaStreamTrack(e3) {
        }
        pipe(e3) {
          if (this.processor === e3) return e3;
          if (e3._source) throw new pO(hO.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor) return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        clone(t2) {
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
          t2 && (n2 = cL(cL({}, n2), OP(t2))), n2 = aN(n2);
          const r2 = SN(8, "track-video-cloned-"), o2 = new e2(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n2, aN(this._scalabilityMode), this._optimizationMode, r2, aN(this._hints));
          return t2 && n2 && o2.setEncoderConfiguration(n2), iP.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
        }
        async replaceTrack(e3, t2) {
          if (!(e3 instanceof MediaStreamTrack)) throw new pO(hO.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
          if ("video" !== e3.kind) throw new pO(hO.INVALID_PARAMS, "track should be a video MediaStreamTrack");
          await this._updateOriginMediaStreamTrack(e3, t2, true), this.updateMediaStreamTrackResolution();
        }
        sendSeiData(e3) {
          if (dN((() => {
            lP.reportApiInvoke(null, { name: LO.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: kO.TRACER }).onSuccess("");
          }), this._mediaStreamTrack.id || this.getTrackId()), !CD("ENABLE_VIDEO_SEI") || !CD("ENABLE_ENCODED_TRANSFORM")) return void iP.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
          if (e3 instanceof Uint8Array == 0) return new pO(hO.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
          const t2 = this.getRTCRtpTransceiver();
          if (!t2) return void iP.warning("Video track is not published, SEI can not be send");
          const i2 = t2.sender.getParameters();
          if (0 === i2.codecs.length) return;
          const n2 = i2.codecs[0].mimeType.toLocaleLowerCase();
          "video/h264" === n2 || "video/h265" === n2 ? this.safeEmit("sei-to-send", e3) : iP.warning("SEI is not supported by ".concat(n2));
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QP.ON_TRACK, (async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await qO(this, UP.NEED_REPLACE_TRACK, this));
          }));
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QP.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(ZP.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(ZP.REQUEST_CONSTRAINTS);
        }
      }, oL(yM.prototype, "play", [Jk, Qk], Object.getOwnPropertyDescriptor(yM.prototype, "play"), yM.prototype), oL(yM.prototype, "stop", [Zk], Object.getOwnPropertyDescriptor(yM.prototype, "stop"), yM.prototype), oL(yM.prototype, "setEnabled", [$k, eM, tM], Object.getOwnPropertyDescriptor(yM.prototype, "setEnabled"), yM.prototype), oL(yM.prototype, "setMuted", [iM, nM, rM], Object.getOwnPropertyDescriptor(yM.prototype, "setMuted"), yM.prototype), oL(yM.prototype, "setSaveEncodeBitrateRatio", [oM, sM], Object.getOwnPropertyDescriptor(yM.prototype, "setSaveEncodeBitrateRatio"), yM.prototype), oL(yM.prototype, "setEncoderConfiguration", [aM, cM], Object.getOwnPropertyDescriptor(yM.prototype, "setEncoderConfiguration"), yM.prototype), oL(yM.prototype, "getStats", [dM], Object.getOwnPropertyDescriptor(yM.prototype, "getStats"), yM.prototype), oL(yM.prototype, "setBeautyEffect", [lM, uM], Object.getOwnPropertyDescriptor(yM.prototype, "setBeautyEffect"), yM.prototype), oL(yM.prototype, "getCurrentFrameData", [hM], Object.getOwnPropertyDescriptor(yM.prototype, "getCurrentFrameData"), yM.prototype), oL(yM.prototype, "getCurrentFrameImage", [pM], Object.getOwnPropertyDescriptor(yM.prototype, "getCurrentFrameImage"), yM.prototype), oL(yM.prototype, "findClosestProfile", [_M, EM], Object.getOwnPropertyDescriptor(yM.prototype, "findClosestProfile"), yM.prototype), oL(yM.prototype, "setBitrateLimit", [mM], Object.getOwnPropertyDescriptor(yM.prototype, "setBitrateLimit"), yM.prototype), oL(yM.prototype, "setOptimizationMode", [fM], Object.getOwnPropertyDescriptor(yM.prototype, "setOptimizationMode"), yM.prototype), oL(yM.prototype, "setScalabiltyMode", [SM], Object.getOwnPropertyDescriptor(yM.prototype, "setScalabiltyMode"), yM.prototype), oL(yM.prototype, "updateMediaStreamTrackResolution", [gM], Object.getOwnPropertyDescriptor(yM.prototype, "updateMediaStreamTrackResolution"), yM.prototype), oL(yM.prototype, "pipe", [TM], Object.getOwnPropertyDescriptor(yM.prototype, "pipe"), yM.prototype), oL(yM.prototype, "unpipe", [RM], Object.getOwnPropertyDescriptor(yM.prototype, "unpipe"), yM.prototype), oL(yM.prototype, "close", [CM], Object.getOwnPropertyDescriptor(yM.prototype, "close"), yM.prototype), oL(yM.prototype, "replaceTrack", [vM], Object.getOwnPropertyDescriptor(yM.prototype, "replaceTrack"), yM.prototype), yM), MM = (IM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), AM = FL(), bM = LN("CameraVideoTrack", "_enabledMutex"), wM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), OM = FL(), NM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), DM = FL(), PM = dP({ argsMap: (e2) => [e2.getTrackId()] }), LM = class e2 extends kM {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e3, t2, i2, n2, r2, o2) {
          super(e3, OP(t2.encoderConfig), n2, r2, o2), sL(this, "_config", void 0), sL(this, "_originalConstraints", void 0), sL(this, "_constraints", void 0), sL(this, "_enabled", true), sL(this, "_deviceName", "default"), sL(this, "tryResumeVideoForIOS15_16WeChat", (async () => {
            ($w() || eO()) && !(function() {
              const e4 = Dw();
              if (e4.os !== Aw.IOS || !e4.osVersion) return false;
              const t3 = e4.osVersion.split(".");
              return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
            })() && nO() && this._enabled && !this._isClosed && (iP.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          })), this._config = t2, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e3.label, this._encoderConfig = OP(this._config.encoderConfig), _L.on(RP.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _L.on(RP.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e3) {
          return "string" == typeof e3 ? this._setDeviceById(e3) : e3.deviceId ? this._setDeviceById(e3.deviceId) : e3.facingMode ? this._setDeviceByFacingModel(e3.facingMode) : void 0;
        }
        async _setDeviceById(e3) {
          if (iP.info("[".concat(this.getTrackId(), "] set device to ").concat(e3)), this._enabled) try {
            const t2 = await PL.getDeviceById(e3), i2 = {};
            i2.video = cL({}, this._constraints), i2.video.deviceId = { exact: e3 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await wL(i2, this.getTrackId());
            } catch (e4) {
              throw iP.error("[".concat(this.getTrackId(), "] setDevice failed"), e4.toString()), n2 = await wL({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e4;
            }
            await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
          } catch (e4) {
            throw iP.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
          }
          else try {
            const t2 = await PL.getDeviceById(e3);
            this._deviceName = t2.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
          } catch (e4) {
            throw iP.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
          }
          iP.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async _setDeviceByFacingModel(e3) {
          iP.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e3));
          const t2 = { video: cL(cL({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e3 } }) };
          if (this._enabled) {
            this._originMediaStreamTrack.stop();
            let e4 = null;
            try {
              e4 = await wL(t2, this.getTrackId());
            } catch (t3) {
              throw iP.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t3.toString()), e4 = await wL({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), t3;
            }
            await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
          }
          this._deviceName = "", this._config.facingMode = e3, this._config.cameraId = void 0, this._constraints = cL({}, t2.video), iP.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled) return;
            this.stateCheck("enabled", e3);
          }
          if (iP.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), e3) {
            try {
              if (this.isExternalTrack) this._originMediaStreamTrack.enabled = true;
              else {
                const e4 = await wL({ video: this._constraints }, this.getTrackId());
                await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false);
              }
              await qO(this, UP.NEED_ENABLE_TRACK, this);
            } catch (e4) {
              throw iP.error("[".concat(this.getTrackId(), "] setEnabled true error"), e4.toString()), e4;
            }
            this.updateMediaStreamTrackResolution(), iP.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
          } else {
            this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
            try {
              await qO(this, UP.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw iP.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            iP.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
        }
        async setEncoderConfiguration(e3, t2) {
          if (!this._enabled) throw new pO(hO.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          e3 = OP(e3), CD("USE_STANDARD_BITRATE_DEFAULT") && (delete e3.bitrateMax, delete e3.bitrateMin), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate || e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate || e3.bitrateMin);
          const i2 = sN(this._config);
          i2.encoderConfig = e3;
          const n2 = zL(i2);
          (Vw() || jw() || iO()) && (n2.deviceId = void 0), iP.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(n2));
          try {
            await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
          } catch (e4) {
            const t3 = new pO(hO.UNEXPECTED_ERROR, e4.toString());
            throw iP.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
          }
          this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e3, -1 === this._hints.indexOf(VP.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await qO(this, UP.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(iP);
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((jw() || iO()) && this._enabled && !this._isClosed && _L.duringInterruption) {
            const e3 = async () => {
              _L.off(RP.IOS_INTERRUPTION_END, e3), this._enabled && !this._isClosed && (iP.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _L.on(RP.IOS_INTERRUPTION_END, e3);
          } else iP.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(GP.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e3) {
          const t2 = e3 || this._constraints, i2 = PL.searchDeviceIdByName(this._deviceName);
          if (i2 && !t2.deviceId && (t2.deviceId = { exact: i2 }), this._enabled) {
            const e4 = await wL({ video: t2 }, this.getTrackId());
            this._constraints = t2, await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), _L.off(RP.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _L.off(RP.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
        }
        clone(t2) {
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n2 = this._encoderConfig;
          t2 && (n2 = cL(cL({}, n2), OP(t2))), n2 = aN(n2);
          const r2 = SN(8, "track-cam-cloned-"), o2 = new e2(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, aN(cL(cL({}, this._config), {}, { encoderConfig: n2 })), aN(this._constraints), aN(this._scalabilityMode), this._optimizationMode, r2);
          return t2 && n2 && o2.setEncoderConfiguration(n2), iP.debug("clone track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
        }
        bindProcessorContextEvents() {
          this.processorContext.on(ZP.REQUEST_UPDATE_CONSTRAINTS, (async (e3, t2, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i3), t2();
            } catch (e4) {
              i2(e4);
            }
          })), this.processorContext.on(ZP.REQUEST_CONSTRAINTS, (async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          }));
        }
      }, oL(LM.prototype, "setDevice", [IM, AM], Object.getOwnPropertyDescriptor(LM.prototype, "setDevice"), LM.prototype), oL(LM.prototype, "setEnabled", [bM, wM, OM], Object.getOwnPropertyDescriptor(LM.prototype, "setEnabled"), LM.prototype), oL(LM.prototype, "setEncoderConfiguration", [NM, DM], Object.getOwnPropertyDescriptor(LM.prototype, "setEncoderConfiguration"), LM.prototype), oL(LM.prototype, "close", [PM], Object.getOwnPropertyDescriptor(LM.prototype, "close"), LM.prototype), LM);
      function UM(e2) {
        const t2 = SN(8, "track-cus-"), i2 = lP.reportApiInvoke(null, { id: t2, tag: kO.TRACER, name: LO.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), n2 = new Bk(e2.mediaStreamTrack, e2.encoderConfig ? LP(e2.encoderConfig) : {}, t2, false);
        return iP.info("create custom audio track success with config", e2, "trackId", n2.getTrackId()), i2.onSuccess(n2.getTrackId()), n2;
      }
      function VM(e2, t2, i2, n2) {
        i2.optimizationMode && (n2 && n2.width && n2.height ? (i2.encoderConfig = cL(cL({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t2.contentHint = i2.optimizationMode, t2.contentHint === i2.optimizationMode ? iP.debug("[".concat(e2, "] set content hint to"), i2.optimizationMode) : iP.debug("[".concat(e2, "] set content hint failed")))) : iP.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
      }
      var xM, FM, BM, jM, GM, WM, HM, KM, YM, zM, qM, XM, JM;
      class QM extends dL {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t2, i2, n2) {
          super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(SN(5, ""))), sL(this, "_userId", void 0), sL(this, "_uintId", void 0), sL(this, "_isDestroyed", false), sL(this, "store", void 0), sL(this, "processor", void 0), sL(this, "processorContext", void 0), this._userId = t2, this._uintId = i2, this.store = n2;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, iP.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let ZM = (xM = dP({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), FM = dP({ argsMap: (e2) => [e2.getTrackId()] }), BM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), jM = dP({ argsMap: (e2) => [e2.getTrackId()] }), oL((GM = class extends QM {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== tL.PLAYING);
        }
        get __className__() {
          return "RemoteVideoTrack";
        }
        constructor(e2, t2, i2, n2, r2) {
          super(e2, t2, i2, n2), sL(this, "_videoVisibleTimer", null), sL(this, "_previousVideoVisibleStatus", void 0), sL(this, "_clearPreviousVideoVisibleStatus", (() => this._previousVideoVisibleStatus = void 0)), sL(this, "trackMediaType", HP.VIDEO), sL(this, "_videoWidth", void 0), sL(this, "_videoHeight", void 0), sL(this, "_player", void 0), sL(this, "_prePlayer", void 0), sL(this, "processorDestination", void 0), sL(this, "processorContext", void 0), this._prePlayer = r2, this.updateMediaStreamTrackResolution(), this.processorContext = new jL(this.getTrackId(), "remote"), this.processorDestination = new BL(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          return dN((() => {
            iP.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }), "remoteVideoTrackGetStatsWarning"), XO(this, UP.GET_STATS) || cL({}, JP);
        }
        play(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (this.safeEmit(WP.PLAY_START), "string" == typeof e2) {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (iP.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          iP.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
          const i2 = cL(cL({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
          if (this._player) this._player.updateConfig(i2);
          else {
            let t3 = false, n2 = false;
            e2 instanceof HTMLVideoElement ? (this._player = new zk(i2), this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0, n2 = true)) : this._prePlayer && !this._prePlayer.isDestroyed ? (this._player = this._prePlayer, this._prePlayer = void 0, t3 = this._player.videoState > 0, this._player.updateConfig(i2)) : this._player = new Xk(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
              this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(WP.FIRST_FRAME_DECODED), n2 && this.safeEmit(WP.FIRST_FRAME_RENDER);
            }, this._player.onVideoStateChanged = (e3) => {
              this.safeEmit(WP.VIDEO_STATE_CHANGED, e3);
            }, t3 && (this._player.onFirstVideoFrameDecoded(), this._player.onVideoStateChanged(this._player.videoState));
          }
          this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval((() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(WP.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }), CD("CHECK_VIDEO_VISIBLE_INTERVAL")), this.safeEmit(WP.PLAY_END);
        }
        stop() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(e2), this._player = void 0, iP.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          YL(this._originMediaStreamTrack).then(((e2) => {
            let [t2, i2] = e2;
            this._videoHeight = i2, this._videoWidth = t2;
          })).catch(TN);
        }
        _updatePlayerSource() {
          iP.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n2;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e3 = AO.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = lP.reportApiInvoke(null, { tag: kO.TRACER, name: LO.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new pO(hO.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        pipe(e2) {
          if (this.processor === e2) return e2;
          if (e2._source) throw new pO(hO.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor) return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QP.ON_TRACK, (async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }));
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QP.ON_TRACK);
        }
        _destroy() {
          this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0), super._destroy(), this.unbindProcessorDestinationEvents();
        }
        _onSei(e2) {
          this.emit(jP.SEI_RECEIVED, e2);
        }
      }).prototype, "play", [xM], Object.getOwnPropertyDescriptor(GM.prototype, "play"), GM.prototype), oL(GM.prototype, "stop", [FM], Object.getOwnPropertyDescriptor(GM.prototype, "stop"), GM.prototype), oL(GM.prototype, "pipe", [BM], Object.getOwnPropertyDescriptor(GM.prototype, "pipe"), GM.prototype), oL(GM.prototype, "unpipe", [jM], Object.getOwnPropertyDescriptor(GM.prototype, "unpipe"), GM.prototype), GM), $M = (WM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), HM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), KM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), YM = dP({ argsMap: (e2) => [e2.getTrackId()] }), zM = dP({ argsMap: (e2) => [e2.getTrackId()] }), qM = dP({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), XM = dP({ argsMap: (e2) => [e2.getTrackId()] }), oL((JM = class extends QM {
        get isPlaying() {
          return this._useAudioElement ? xL.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "RemoteAudioTrack";
        }
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), sL(this, "trackMediaType", HP.AUDIO), sL(this, "_source", void 0), sL(this, "_useAudioElement", true), sL(this, "_volume", 100), sL(this, "processorContext", void 0), sL(this, "processorDestination", void 0), sL(this, "_played", false), sL(this, "_bypassWebAudio", false), CD("DISABLE_WEBAUDIO") ? (this._source = new HL(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new RL(e2, true), CD("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(KP.RECEIVE_TRACK_BUFFER, (() => {
            this.safeEmit(WP.FIRST_FRAME_DECODED);
          })), this.processorContext = new WL(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new GL(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(KP.UPDATE_SOURCE, (() => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          }));
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(KP.ON_AUDIO_BUFFER), this._source.on(KP.ON_AUDIO_BUFFER, ((t3) => e2(t3)));
        }
        setVolume(e2) {
          this._volume = e2, this._useAudioElement ? xL.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
        }
        setAmplifiedVolume(e2) {
          this._useAudioElement && this._played && (xL.stop(this.getTrackId()), this._source.play()), this._useAudioElement = false, e2 = Math.min(e2, CD("MAX_WEBAUDIO_VOLUME")), this._volume = e2, this._source.setVolume(e2 / 100);
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !_P()) throw new pO(hO.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await xL.setSinkID(this.getTrackId(), e2);
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getVolume() {
          return this._useAudioElement ? xL.getVolume(this.getTrackId()) : this._source instanceof RL ? this._source.getAudioVolume() : 0;
        }
        getStats() {
          return dN((() => {
            iP.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }), "remoteAudioTrackGetStatsWarning"), XO(this, UP.GET_STATS) || cL({}, qP);
        }
        play() {
          iP.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (iP.debug("[".concat(this.getTrackId(), "] use audio element to play")), xL.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : (iP.debug("[".concat(this.getTrackId(), "] use audio context to play")), this._source.play());
        }
        stop() {
          iP.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? xL.stop(this.getTrackId()) : this._source.stop();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          iP.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xL.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
          if (this.processor === e2) return e2;
          if (e2._source) throw new pO(hO.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (this._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
          if (!this.processor) return;
          const t2 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QP.ON_TRACK, (async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          })), this.processorDestination.on(QP.ON_NODE, ((e2) => {
            this._source.processedNode = e2;
            const t2 = !e2;
            this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
          }));
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QP.ON_TRACK), this.processorDestination.removeAllListeners(QP.ON_NODE);
        }
      }).prototype, "setVolume", [WM], Object.getOwnPropertyDescriptor(JM.prototype, "setVolume"), JM.prototype), oL(JM.prototype, "setAmplifiedVolume", [HM], Object.getOwnPropertyDescriptor(JM.prototype, "setAmplifiedVolume"), JM.prototype), oL(JM.prototype, "setPlaybackDevice", [KM], Object.getOwnPropertyDescriptor(JM.prototype, "setPlaybackDevice"), JM.prototype), oL(JM.prototype, "play", [YM], Object.getOwnPropertyDescriptor(JM.prototype, "play"), JM.prototype), oL(JM.prototype, "stop", [zM], Object.getOwnPropertyDescriptor(JM.prototype, "stop"), JM.prototype), oL(JM.prototype, "pipe", [qM], Object.getOwnPropertyDescriptor(JM.prototype, "pipe"), JM.prototype), oL(JM.prototype, "unpipe", [XM], Object.getOwnPropertyDescriptor(JM.prototype, "unpipe"), JM.prototype), JM);
      const eU = new class extends NO {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), sL(this, "_lastHiddenTime", 0), sL(this, "_lastVisibleTime", 0), sL(this, "needUploadStats", []), sL(this, "isCollectingStats", false), document.addEventListener("visibilitychange", (() => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), this.isCollectingStats && this.needUploadStats.push("visible" === document.visibilityState ? 1 : 0), iP.debug("current web page is ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          }));
        }
        startCollectStats() {
          this.isCollectingStats = true, this.needUploadStats.push("visible" === this.visibility ? 1 : 0);
        }
        stopCollectStats() {
          this.isCollectingStats = false, this.needUploadStats.length = 0;
        }
      }();
      class tU extends NO {
        constructor(e2, t2) {
          super(), sL(this, "trackMediaType", HP.DATA), sL(this, "_version", 1), sL(this, "_type", 3), sL(this, "_config", void 0), sL(this, "_originDataChannel", void 0), sL(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), sL(this, "_dataStreamPacketHandler", { serialize: (e3) => e3, deserialize: (e3) => e3 }), sL(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e2, t2 && (this._originDataChannel = t2, this._bandDataChannelEvents(t2)), this._initPacketHeader();
        }
        useDataStream(e2) {
          this._dataStreamPacketHandler = e2;
        }
        get id() {
          return this._config.id;
        }
        get ordered() {
          return this._config.ordered;
        }
        get maxRetransmits() {
          return CD("DATASTREAM_MAX_RETRANSMITS");
        }
        get metadata() {
          return this._config.metadata;
        }
        get readyState() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.readyState) && void 0 !== e2 ? e2 : "connecting";
        }
        get _originDataChannelId() {
          var e2, t2;
          return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.id) && void 0 !== e2 ? e2 : null;
        }
        getChannelId() {
          return this.id;
        }
        getConfig() {
          return this._config;
        }
        _close() {
          this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
        }
        async _waitTillOpen() {
          return new rp(((e2, t2) => {
            if (this._originDataChannel) {
              "open" === this._originDataChannel.readyState && e2();
              const i2 = setTimeout((() => {
                var e3;
                t2(new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e3 = this._originDataChannel) || void 0 === e3 ? void 0 : e3.id)));
              }), 1e4);
              this._originDataChannel.onopen = () => {
                clearTimeout(i2), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e2();
              }, this._originDataChannel.onerror = () => {
                throw clearTimeout(i2), new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT);
              };
            } else t2(new pO(hO.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
          }));
        }
        _updateOriginDataChannel(e2) {
          this._originDataChannel = e2, this._bandDataChannelEvents(e2);
        }
        _initPacketHeader() {
          const e2 = new DataView(this._dataStreamPacketHeader);
          e2.setUint16(0, this._version), e2.setUint8(2, this._type), e2.setUint8(3, this._config.id);
        }
        _bandDataChannelEvents(e2) {
          this._unbindDataChannelEvents(e2), [rL.OPEN, rL.CLOSE, rL.ERROR].forEach(((t2) => {
            const i2 = () => {
              this.emit(t2);
            };
            this._datachannelEventMap.set(t2, i2), e2.addEventListener(t2, i2);
          }));
        }
        _unbindDataChannelEvents(e2) {
          Array.from(this._datachannelEventMap.entries()).forEach(((t2) => {
            let [i2, n2] = t2;
            e2.removeEventListener(i2, n2);
          })), this._datachannelEventMap.clear();
        }
      }
      class iU extends tU {
        constructor(e2) {
          super(e2), sL(this, "_messageListener", void 0), this._messageListener = (e3) => {
            if (e3.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
            const t2 = e3.data.slice(0, this._dataStreamPacketHeader.byteLength), i2 = new DataView(t2).getUint8(3);
            if (i2 !== this.id) return void (CD("SHOW_DATASTREAM2_LOG") && iP.debug("invalid datachannel id: ".concat(i2, " !== ").concat(this.id)));
            let n2 = e3.data.slice(this._dataStreamPacketHeader.byteLength);
            n2 = this._dataStreamPacketHandler.deserialize(n2), this.emit(rL.MESSAGE, n2);
          };
        }
        _updateOriginDataChannel(e2) {
          super._updateOriginDataChannel(e2), this._bandRemoteDataChannelEvents();
        }
        _close() {
          this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
        }
        _bandRemoteDataChannelEvents() {
          this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
        }
      }
      class nU extends tU {
        send(e2) {
          if (this._originDataChannel) {
            let t2 = e2;
            t2 = this._dataStreamPacketHandler.serialize(e2);
            const i2 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t2.byteLength);
            i2.set(new Uint8Array(this._dataStreamPacketHeader), 0), i2.set(new Uint8Array(t2), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i2.buffer);
          }
        }
      }
      function rU() {
        const e2 = new Blob([atob("Y29uc3QgdD0idmlkZW8vaDI2NCIsZT0idmlkZW8vaDI2NSI7ZnVuY3Rpb24gbih0LGUsbil7bGV0IGE9bmV3IFVpbnQ4QXJyYXkodCxlLG4pLHI9W10sbz0wO2Zvcig7ci5sZW5ndGg8bjspbyszPG4mJjA9PT1hW29dJiYwPT09YVtvKzFdJiYzPT09YVtvKzJdJiYoMD09PWFbbyszXXx8MT09PWFbbyszXXx8Mj09PWFbbyszXXx8Mz09PWFbbyszXSk/KHIucHVzaChhW29dLGFbbysxXSxhW28rM10pLG8rPTQpOihyLnB1c2goYVtvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocil9ZnVuY3Rpb24gYShhLHIpe3N3aXRjaChyKXtjYXNlIHQ6cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IERhdGFWaWV3KHQuZGF0YSk7bGV0IGE9MDtmb3IoO2ErNDx0LmRhdGEuYnl0ZUxlbmd0aDspe2lmKDA9PT1lLmdldFVpbnQ4KGErMCkmJjA9PT1lLmdldFVpbnQ4KGErMSkmJjA9PT1lLmdldFVpbnQ4KGErMikmJjE9PT1lLmdldFVpbnQ4KGErMykmJjY9PT1lLmdldFVpbnQ4KGErNCkpe2xldCByPWErNixvPTAsaT0wO2Zvcig7MjU1PT09KGk9ZS5nZXRVaW50OChyKyspKTspbys9MjU1O28rPWk7Y29uc3Qgcz1uKHQuZGF0YSxyLG8pO3JldHVybiBuZXcgVWludDhBcnJheShzKX1hKyt9cmV0dXJuIG51bGx9KGEpO2Nhc2UgZTpyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgRGF0YVZpZXcodC5kYXRhKTtsZXQgYT0wO2Zvcig7YSs1PHQuZGF0YS5ieXRlTGVuZ3RoOyl7aWYoMD09PWUuZ2V0VWludDgoYSswKSYmMD09PWUuZ2V0VWludDgoYSsxKSYmMD09PWUuZ2V0VWludDgoYSsyKSYmMT09PWUuZ2V0VWludDgoYSszKSYmNzg9PT1lLmdldFVpbnQ4KGErNCkmJjE9PT1lLmdldFVpbnQ4KGErNSkmJjEwMT09PWUuZ2V0VWludDgoYSs2KSl7bGV0IHI9YSs3LG89MCxpPTA7Zm9yKDsyNTU9PT0oaT1lLmdldFVpbnQ4KHIrKykpOylvKz0yNTU7bys9aTtjb25zdCBzPW4odC5kYXRhLHIsbyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHMpfWErK31yZXR1cm4gbnVsbH0oYSk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcih0KXtjb25zdCBlPXQubGVuZ3RoO2xldCBuPVtdLGE9MDtmb3IoO2E8ZTspYSsyPGUmJjA9PT10W2FdJiYwPT09dFthKzFdJiYoMD09PXRbYSsyXXx8MT09PXRbYSsyXXx8Mj09PXRbYSsyXXx8Mz09PXRbYSsyXSk/KG4ucHVzaCh0W2FdLHRbYSsxXSwzLHRbYSsyXSksYSs9Myk6KG4ucHVzaCh0W2FdKSxhKyspO3JldHVybiBuZXcgVWludDhBcnJheShuKX1mdW5jdGlvbiBvKG4sYSxvKXtzd2l0Y2gobyl7Y2FzZSB0OnJldHVybiBmdW5jdGlvbih0LGUpe2NvbnN0IG49cihlKSxhPW4ubGVuZ3RoLG89TWF0aC5mbG9vcihhLzI1NSksaT1hJTI1NSxzPW5ldyBVaW50OEFycmF5KDYrbysxK2ErdC5ieXRlTGVuZ3RoKTtzWzBdPTAsc1sxXT0wLHNbMl09MCxzWzNdPTEsc1s0XT02LHNbNV09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNitmXT0yNTUsZisrO3JldHVybiBzWzYrZl09aSxmKysscy5zZXQobiw2K2YpLHMuc2V0KG5ldyBVaW50OEFycmF5KHQpLDYrZithKSxzLmJ1ZmZlcn0obixhKTtjYXNlIGU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1yKGUpLGE9bi5sZW5ndGgsbz1NYXRoLmZsb29yKGEvMjU1KSxpPWElMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNytvKzErYSsxK3QuYnl0ZUxlbmd0aCk7c1swXT0wLHNbMV09MCxzWzJdPTAsc1szXT0xLHNbNF09Nzgsc1s1XT0xLHNbNl09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNytmXT0yNTUsZisrO3JldHVybiBzWzcrZl09aSxmKysscy5zZXQobiw3K2YpLGYrPWEsc1s3K2ZdPTEyOCxmKysscy5zZXQobmV3IFVpbnQ4QXJyYXkodCksNytmKSxzLmJ1ZmZlcn0obixhKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBpKG4pe2lmKG4ubGVuZ3RoPDUpcmV0dXJuIiI7bGV0IGE9LTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aC0zO3QrKyl7aWYoMD09PW5bdF0mJjA9PT1uW3QrMV0mJjE9PT1uW3QrMl0pe2E9dDticmVha31pZih0PG4ubGVuZ3RoLTQmJjA9PT1uW3RdJiYwPT09blt0KzFdJiYwPT09blt0KzJdJiYxPT09blt0KzNdKXthPXQ7YnJlYWt9fWlmKC0xPT09YSlyZXR1cm4iIjtjb25zdCByPWErKDA9PT1uW2ErMl0/NDozKTtpZihyPj1uLmxlbmd0aClyZXR1cm4iIjtjb25zdCBvPW5bcl07aWYoMTI4Jm8pcmV0dXJuIiI7aWYoKG8+PjEmNjMpPj0zMilyZXR1cm4gZTtpZihyKzE8bi5sZW5ndGgpe2lmKDA9PSgyNDgmbltyKzFdKSlyZXR1cm4gZX1yZXR1cm4oMzEmbyk8PTMxP3Q6IiJ9Y29uc3Qgcz03MSxmPTEsbD0yLHU9MSxnPTI7dmFyIGM7ZnVuY3Rpb24gZCh0LGU9ITEpe2NvbnN0IG49dC5nZXRVaW50OCgwKTtpZihuIT09cylyZXR1cm47Y29uc3QgYT10LmdldFVpbnQxNigxKSxyPWYrbCthLG89bmV3IFVpbnQ4QXJyYXkodC5ieXRlTGVuZ3RoLXIpO28uc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHIsdC5ieXRlTGVuZ3RoLXIpKTtjb25zdCBpPXttOm4sdGx2TGVuOmEsdGx2OltdLGZyYW1lOm99O2xldCBkPWYrbDtmb3IoO2Q8cjspe2NvbnN0IG49dC5nZXRVaW50OChkKSxhPXQuZ2V0VWludDE2KGQrdSkscj11K2c7aWYobj09PWMuQVVESU9fTEVWRUwpe2xldCBvPXQuZ2V0VWludDgoZCtyKTtmb3IobGV0IGU9MTtlPGE7ZSsrKW89bzw8OHx0LmdldFVpbnQ4KGQrcitlKTtpLnRsdi5wdXNoKHt0YWc6bixsZW5ndGg6YSx2YWx1ZTplPzEyN15vPj4xOjEyNyZvfSl9ZWxzZSBpZihuPT09Yy5NRVRBREFUQXx8bj09PWMuQVVESU9fNjRfQklUX1BUUyl7Y29uc3QgZT1uZXcgVWludDhBcnJheShhKTtmb3IobGV0IG49MDtuPGE7bisrKWVbbl09dC5nZXRVaW50OChkK3Irbik7aS50bHYucHVzaCh7dGFnOm4sbGVuZ3RoOmEsdmFsdWU6ZX0pfWQrPXIrYX1yZXR1cm4gaX0hZnVuY3Rpb24odCl7dFt0LkFVRElPX0xFVkVMPTFdPSJBVURJT19MRVZFTCIsdFt0Lk1FVEFEQVRBPTJdPSJNRVRBREFUQSIsdFt0LkFVRElPXzY0X0JJVF9QVFM9M109IkFVRElPXzY0X0JJVF9QVFMifShjfHwoYz17fSkpLHNlbGYub25ydGN0cmFuc2Zvcm09dD0+e2NvbnN0IGU9dC50cmFuc2Zvcm1lcixuPVtdLHI9W107bGV0IGg9bnVsbDtlLm9wdGlvbnMucG9ydC5vbm1lc3NhZ2U9dD0+e3QuZGF0YS5zZWkmJm4ucHVzaCh0LmRhdGEuc2VpKSx0LmRhdGEubWV0YWRhdGEmJnIucHVzaCh0LmRhdGEubWV0YWRhdGEpfSxzZWxmLnBvc3RNZXNzYWdlKCJzdGFydGVkIik7Y29uc3QgcD1lLnJlYWRhYmxlLmdldFJlYWRlcigpLFU9ZS53cml0YWJsZS5nZXRXcml0ZXIoKTsic2VpLXJ4Ij09PWUub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1pKG5ldyBVaW50OEFycmF5KG4udmFsdWUuZGF0YSkpLHI9YShuLnZhbHVlLHQpO2lmKHImJmUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHtzZWk6cn0pLCFoKXtjb25zdCB0PW4udmFsdWUuZ2V0TWV0YWRhdGEoKXx8e307aD17dHlwZTpuLnZhbHVlLnR5cGUscnRwVGltZXN0YW1wOm4udmFsdWUudGltZXN0YW1wLHBheWxvYWRUeXBlOnQucGF5bG9hZFR5cGV8fDAsc3NyYzp0LnN5bmNocm9uaXphdGlvblNvdXJjZXx8MCxsZW5ndGg6bi52YWx1ZS5kYXRhLmJ5dGVMZW5ndGgsLi4uIm1pbWVUeXBlImluIHQ/e21pbWVUeXBlOnQubWltZVR5cGV9Ont9fSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7Zmlyc3RGcmFtZUluZm86aH0pfX1VLndyaXRlKG4udmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToic2VpLXR4Ij09PWUub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigoYT0+e2lmKCFhLmRvbmUpe2lmKGEudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1pKG5ldyBVaW50OEFycmF5KGEudmFsdWUuZGF0YSkpLGU9bi5zaGlmdCgpO2lmKGUpe2NvbnN0IG49byhhLnZhbHVlLmRhdGEsZSx0KTtuJiYoYS52YWx1ZS5kYXRhPW4pfX1VLndyaXRlKGEudmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToiYXVkaW8tbWV0YWRhdGEtcngiPT09ZS5vcHRpb25zLm5hbWU/ZnVuY3Rpb24gdChlKXtwLnJlYWQoKS50aGVuKChuPT57aWYoIW4uZG9uZSl7aWYobi52YWx1ZSBpbnN0YW5jZW9mIFJUQ0VuY29kZWRBdWRpb0ZyYW1lKXtjb25zdCB0PW5ldyBEYXRhVmlldyhuLnZhbHVlLmRhdGEpLGE9dC5nZXRVaW50OCgwKTtsZXQgcjtpZigwIT0oMTI4JmEpJiY3MSE9PWEpe2NvbnN0IGU9ZnVuY3Rpb24odCl7aWYodC5ieXRlTGVuZ3RoPD0wKXJldHVybltdO2NvbnN0IGU9W107bGV0IG49MDtmb3IoO248dC5ieXRlTGVuZ3RoOyl7Y29uc3QgYT0oMTI4JnQuZ2V0VWludDgobikpPj43LHI9MTI3JnQuZ2V0VWludDgobik7aWYoIShhJiZuKzQ8PXQuYnl0ZUxlbmd0aCkpe24rKzticmVha317Y29uc3QgYT10LmdldFVpbnQzMihuLCExKSxvPSgxNjc3NjE5MiZhKT4+MTAsaT0xMDIzJmE7ZS5wdXNoKHtwdDpyLHRzX29mZnNldDpvLGxlbmd0aDppLGRhdGE6bmV3IFVpbnQ4QXJyYXl9KSxuKz00fX1sZXQgYT10LmJ5dGVMZW5ndGgtbjtmb3IoY29uc3QgciBvZiBlKXtpZihyLmxlbmd0aD5hKXJldHVybiBjb25zb2xlLndhcm4oIkJyb2tlbiByZWQgcGF5bG9hZCIpLFtdO3IubGVuZ3RoPjAmJihyLmRhdGE9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sci5sZW5ndGgpLG4rPXIubGVuZ3RoLGEtPXIubGVuZ3RoKX1pZihhPjApe2NvbnN0IHI9e3B0OmUubGVuZ3RoPjA/ZVtlLmxlbmd0aC0xXS5wdDowLHRzX29mZnNldDowLGxlbmd0aDphLGRhdGE6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sYSl9O2UucHVzaChyKX1yZXR1cm4gZX0odCk7aWYoZS5sZW5ndGg+MCl7Y29uc3QgdD1mdW5jdGlvbih0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWUrPW48dC5sZW5ndGgtMT80OjEsZSs9dFtuXS5sZW5ndGg7Y29uc3Qgbj1uZXcgVWludDhBcnJheShlKTtsZXQgYT0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKGU8dC5sZW5ndGgtMSl7Y29uc3Qgcj0oMjE0NzQ4MzY0OHwoMTI3JnRbZV0ucHQpPDwyNHwoMjYyMTQzJnRbZV0udHNfb2Zmc2V0KTw8MTB8MTAyMyZ0W2VdLmxlbmd0aCk+Pj4wO25bYSsrXT1yPj4yNCYyNTUsblthKytdPXI+PjE2JjI1NSxuW2ErK109cj4+OCYyNTUsblthKytdPTI1NSZyfWVsc2UgblthKytdPTEyNyZ0W2VdLnB0O2Zvcihjb25zdCBlIG9mIHQpbi5zZXQoZS5kYXRhLGEpLGErPWUubGVuZ3RoO3JldHVybiBufShlLm1hcCgodD0+e2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO2Uuc2V0KHQuZGF0YSk7Y29uc3Qgbj1kKG5ldyBEYXRhVmlldyhlLmJ1ZmZlcikpO3JldHVybiBuPy5mcmFtZSYmKHQuZGF0YT1uPy5mcmFtZSkscj1uLHR9KSkpO24udmFsdWUuZGF0YT10LmJ1ZmZlcn19ZWxzZSByPWQodCksciYmKG4udmFsdWUuZGF0YT1yLmZyYW1lLmJ1ZmZlcik7aWYocil7bGV0IHQ9ci50bHYuZmluZCgodD0+dC50YWc9PT1jLk1FVEFEQVRBKSk7aWYodCYmdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHttZXRhZGF0YTp0LnZhbHVlfSksdD1yLnRsdi5maW5kKCh0PT50LnRhZz09PWMuQVVESU9fNjRfQklUX1BUUykpLHQmJnQudmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5JiY4PT10LnZhbHVlLmxlbmd0aCl7Y29uc3Qgbj1uZXcgRGF0YVZpZXcodC52YWx1ZS5idWZmZXIpLmdldEJpZ1VpbnQ2NCgwLCEwKTt0JiZ0LnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSYmZS5vcHRpb25zLnBvcnQucG9zdE1lc3NhZ2Uoe3B0czpufSl9fX1VLndyaXRlKG4udmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToiYXVkaW8tbWV0YWRhdGEtdHgiPT09ZS5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIHQoZSl7cC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHtnZXRNZXRhZGF0YTohMH0pLG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkQXVkaW9GcmFtZSl7Y29uc3QgdD1yLnNoaWZ0KCk7dCYmKG4udmFsdWUuZGF0YT1mdW5jdGlvbih0LGUsbil7Y29uc3QgYT1uLmJ5dGVMZW5ndGgscj1hK3UrZyxvPWYrbCtyLGk9bmV3IEFycmF5QnVmZmVyKHQuYnl0ZUxlbmd0aCtvKSxjPW5ldyBEYXRhVmlldyhpKTtjLnNldFVpbnQ4KDAscyksYy5zZXRVaW50MTYoMSxyKSxjLnNldFVpbnQ4KDMsZSksYy5zZXRVaW50MTYoNCxhKTtmb3IobGV0IHQ9MDt0PGE7dCsrKWMuc2V0VWludDgoNit0LG5bdF0pO2NvbnN0IGQ9bmV3IFVpbnQ4QXJyYXkoYy5idWZmZXIpO3JldHVybiBkLnNldChuZXcgVWludDhBcnJheSh0KSxvKSxkLmJ1ZmZlcn0obi52YWx1ZS5kYXRhLGMuQVVESU9fNjRfQklUX1BUUyx0KSl9VS53cml0ZShuLnZhbHVlKSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSx0KGUpfX0pKX0oZSl9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKTsK")], { type: "text/javascript" });
        return setTimeout((() => vS.revokeObjectURL(e2)), 0), new Worker(vS.createObjectURL(e2));
      }
      const oU = 71, sU = 1, aU = 2, cU = 1, dU = 2;
      var lU = (function(e2) {
        return e2[e2.AUDIO_LEVEL = 1] = "AUDIO_LEVEL", e2[e2.METADATA = 2] = "METADATA", e2[e2.AUDIO_64_BIT_PTS = 3] = "AUDIO_64_BIT_PTS", e2;
      })(lU || {});
      function uU(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = e2.getUint8(0);
        if (i2 !== oU) return;
        const n2 = e2.getUint16(1), r2 = sU + aU + n2, o2 = new Uint8Array(e2.byteLength - r2);
        o2.set(new Uint8Array(e2.buffer, r2, e2.byteLength - r2));
        const s2 = { m: i2, tlvLen: n2, tlv: [], frame: o2 };
        let a2 = sU + aU;
        for (; a2 < r2; ) {
          const i3 = e2.getUint8(a2), n3 = e2.getUint16(a2 + cU), r3 = cU + dU;
          if (i3 === lU.AUDIO_LEVEL) {
            let o3 = e2.getUint8(a2 + r3);
            for (let t3 = 1; t3 < n3; t3++) o3 = o3 << 8 | e2.getUint8(a2 + r3 + t3);
            s2.tlv.push({ tag: i3, length: n3, value: t2 ? 127 ^ o3 >> 1 : 127 & o3 });
          } else if (i3 === lU.METADATA || i3 === lU.AUDIO_64_BIT_PTS) {
            const t3 = new Uint8Array(n3);
            for (let i4 = 0; i4 < n3; i4++) t3[i4] = e2.getUint8(a2 + r3 + i4);
            s2.tlv.push({ tag: i3, length: n3, value: t3 });
          }
          a2 += r3 + n3;
        }
        return s2;
      }
      const hU = /* @__PURE__ */ new Map();
      const pU = 127, _U = 1e-10, EU = 139 / 13, mU = /* @__PURE__ */ new Map();
      function fU(e2, t2, i2) {
        const n2 = "".concat(e2, "-").concat(t2, "-").concat(i2);
        let r2 = 0;
        if (mU.has(n2)) r2 = mU.get(n2);
        else {
          const o2 = 0.5;
          r2 = Math.log((function(e3, t3) {
            const i3 = e3 - t3;
            t3 < i3 && (t3 = i3);
            let n3 = 1;
            for (let i4 = e3, r3 = 1; i4 > t3; i4--, r3++) n3 = n3 * i4 / r3;
            return n3;
          })(t2, e2)) + e2 * Math.log(o2) + (t2 - e2) * Math.log(1 - o2) - Math.log(i2) + i2 * e2, mU.set(n2, r2);
        }
        return r2 < _U && (r2 = _U), r2;
      }
      function SU(e2, t2, i2) {
        const n2 = t2.length, r2 = e2.length / n2;
        let o2 = false;
        for (let s2 = 0, a2 = 0; s2 < n2; s2++) {
          let n3 = 0;
          for (let t3 = a2 + r2; a2 < t3; a2++) e2[a2] > i2 && n3++;
          t2[s2] !== n3 && (t2[s2] = n3, o2 = true);
        }
        return o2;
      }
      window.cache = mU;
      let gU = 0;
      class TU {
        constructor(e2) {
          sL(this, "id", void 0), sL(this, "immediates", []), sL(this, "lastNonSilence", -1), sL(this, "immediateSpeechActivityScore", _U), sL(this, "lastLevelChangedTime", Date.now()), sL(this, "levels", []), sL(this, "longs", []), sL(this, "longSpeechActivityScore", _U), sL(this, "mediums", []), sL(this, "mediumSpeechActivityScore", _U), sL(this, "minLevel", 0), sL(this, "nextMinLevel", 0), sL(this, "nextMinLevelWindowLength", 0), sL(this, "energyScore", 0), this.id = e2 || "".concat(gU++), this.immediates.length = 50, this.mediums.length = 10, this.longs.length = 1, this.levels.length = this.immediates.length;
        }
        computeImmediates() {
          const e2 = this.immediates, t2 = this.levels, i2 = this.minLevel + EU;
          let n2 = false;
          for (let r2 = 0; r2 < e2.length; ++r2) {
            let o2 = t2[r2];
            o2 < i2 && (o2 = 0);
            const s2 = Math.floor(o2 / EU);
            e2[r2] !== s2 && (e2[r2] = s2, n2 = true);
          }
          return n2;
        }
        computeLongs() {
          return SU(this.mediums, this.longs, 4);
        }
        computeMediums() {
          return SU(this.immediates, this.mediums, 7);
        }
        evaluateImmediateSpeechActivityScore() {
          this.immediateSpeechActivityScore = fU(this.immediates[0], 13, 0.78);
        }
        evaluateLongSpeechActivityScore(e2) {
          this.longSpeechActivityScore = fU(this.longs[0], 10, 47), this.longSpeechActivityScore > _U && (this.lastNonSilence = e2);
        }
        evaluateMediumSpeechActivityScore() {
          this.mediumSpeechActivityScore = fU(this.mediums[0], 5, 24);
        }
        evaluateSpeechActivityScores(e2) {
          this.computeImmediates() && (this.evaluateImmediateSpeechActivityScore(), this.computeMediums() && (this.evaluateMediumSpeechActivityScore(), this.computeLongs() && this.evaluateLongSpeechActivityScore(e2)));
        }
        getLastLevelChangedTime() {
          return this.lastLevelChangedTime;
        }
        getLevels() {
          var e2;
          return "[".concat(mr(e2 = [...this.levels]).call(e2).join(), "]");
        }
        getSpeechActivityScore(e2) {
          switch (e2) {
            case 0:
              return this.immediateSpeechActivityScore;
            case 1:
              return this.mediumSpeechActivityScore;
            case 2:
              return this.longSpeechActivityScore;
            default:
              throw new Error("interval " + e2);
          }
        }
        levelChanged(e2, t2) {
          if (this.lastLevelChangedTime <= t2) {
            this.lastLevelChangedTime = t2;
            let i2 = e2;
            return e2 < 0 && (i2 = 0), e2 > pU && (i2 = pU), this.levels.unshift(i2), this.levels.length > this.immediates.length && this.levels.pop(), this.updateMinLevel(i2), i2 >= this.minLevel + EU ? i2 : i2 / 2;
          }
          return -1;
        }
        levelTimedOut() {
          this.levelChanged(0, this.lastLevelChangedTime);
        }
        updateMinLevel(e2) {
          if (0 !== e2) {
            if (0 === this.minLevel || this.minLevel > e2) return this.minLevel = e2, this.nextMinLevel = 0, void (this.nextMinLevelWindowLength = 0);
            if (0 === this.nextMinLevel) return this.nextMinLevel = e2, void (this.nextMinLevelWindowLength = 1);
            if (this.nextMinLevel > e2 && (this.nextMinLevel = e2), this.nextMinLevelWindowLength++, this.nextMinLevelWindowLength >= 750) {
              let e3 = Math.sqrt(this.minLevel * this.nextMinLevel);
              e3 < 0 ? e3 = 0 : e3 > pU && (e3 = pU), this.minLevel = e3, this.nextMinLevel = 0, this.nextMinLevelWindowLength = 0;
            }
          }
        }
      }
      class RU {
        constructor(e2) {
          sL(this, "algorithm", void 0), this.algorithm = e2;
        }
        execute() {
          let e2 = !this.algorithm;
          if (!e2) try {
            const t2 = this.algorithm.runInDecisionMaker(this);
            t2 <= 0 ? e2 = true : setTimeout(this.execute.bind(this), t2);
          } catch (t2) {
            e2 = true;
          }
          e2 && this.algorithm && this.algorithm.decisionMakerExited(this);
        }
      }
      class CU {
        constructor(e2, t2, i2) {
          sL(this, "isDominant", void 0), sL(this, "energyRanking", void 0), sL(this, "energyScore", void 0), this.isDominant = e2, this.energyRanking = t2, this.energyScore = i2;
        }
      }
      class vU extends NO {
        constructor(e2) {
          super(), sL(this, "dominantId", null), sL(this, "lastDecisionTime", 0), sL(this, "lastLevelChangedTime", 0), sL(this, "lastLevelIdleTime", 0), sL(this, "relativeSpeechActivities", []), sL(this, "speakers", /* @__PURE__ */ new Map()), sL(this, "enableSilence", false), sL(this, "timeoutToSilenceInterval", 0), sL(this, "decisionMaker", null), sL(this, "loudest", []), sL(this, "numLoudestToTrack", 3), sL(this, "energyExpireTimeMs", 250), sL(this, "energyAlphaPct", 50), this.timeoutToSilenceInterval = e2, this.enableSilence = e2 > 0, this.relativeSpeechActivities.length = 3;
        }
        setLoudestConfig() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3, t2 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
          this.numLoudestToTrack = e2, null != t2 && (this.energyExpireTimeMs = t2), null != i2 && (this.energyAlphaPct = i2), this.loudest.length > e2 && this.loudest.splice(e2);
        }
        getDominantSpeaker() {
          return this.dominantId;
        }
        isAmongLoudest(e2) {
          return this.loudest.some(((t2) => t2.id === e2));
        }
        levelChanged(e2, t2) {
          const i2 = Date.now(), n2 = this.getOrCreateSpeaker(e2);
          this.lastLevelChangedTime < i2 && (this.lastLevelChangedTime = i2, this.maybeStartDecisionMaker());
          const r2 = n2.levelChanged(t2, i2);
          return this.updateLoudestList(n2, r2, i2);
        }
        runInDecisionMaker(e2) {
          return this.decisionMaker !== e2 || this.lastDecisionTime > 0 && this.lastDecisionTime - this.lastLevelChangedTime >= 15e3 ? -1 : this._runInDecisionMaker();
        }
        decisionMakerExited(e2) {
          this.decisionMaker === e2 && (this.decisionMaker = null);
        }
        destroy() {
          this.decisionMaker = null, this.loudest.length = 0, this.speakers.clear(), this.removeAllListeners();
        }
        addSpeakers(e2) {
          e2.forEach(((e3) => {
            this.speakers.has(e3.id) || this.speakers.set(e3.id, e3);
          }));
        }
        removeSpeakers(e2) {
          e2.forEach(((e3) => {
            this.speakers.delete(e3.id);
          }));
        }
        getOrCreateSpeaker(e2) {
          let t2 = this.speakers.get(e2);
          return t2 || (t2 = new TU(e2), this.speakers.set(e2, t2), this.maybeStartDecisionMaker()), t2;
        }
        updateLoudestList(e2, t2, i2) {
          const n2 = e2.id === this.dominantId;
          if (t2 < 0) {
            let t3 = 0;
            for (; t3 < this.loudest.length && this.loudest[t3] !== e2; ) ++t3;
            return new CU(n2, t3, e2.energyScore);
          }
          if (e2.energyScore = Math.floor((this.energyAlphaPct * t2 + (100 - this.energyAlphaPct) * e2.energyScore + 50) / 100), 0 === this.numLoudestToTrack) return new CU(n2, 0, e2.energyScore);
          const r2 = i2 - this.energyExpireTimeMs;
          let o2 = 0;
          for (; o2 < this.loudest.length; ) {
            const t3 = this.loudest[o2];
            if (t3.getLastLevelChangedTime() < r2 && this.loudest.length >= this.numLoudestToTrack) this.loudest.splice(o2, 1);
            else if (t3.id !== e2.id) ++o2;
            else if (this.loudest.splice(o2, 1), this.loudest.length < this.numLoudestToTrack) break;
          }
          let s2 = 0;
          for (; s2 < this.loudest.length && !(this.loudest[s2].energyScore < e2.energyScore); ) ++s2;
          return s2 < this.numLoudestToTrack && (this.loudest.splice(s2, 0, e2), this.loudest.length > this.numLoudestToTrack && this.loudest.splice(this.numLoudestToTrack, 1)), new CU(n2, s2, e2.energyScore);
        }
        maybeStartDecisionMaker() {
          !this.decisionMaker && this.speakers.size > 0 && (this.decisionMaker = new RU(this), this.decisionMaker.execute());
        }
        makeDecision(e2) {
          let t2 = null, i2 = null;
          const n2 = this.speakers.size;
          let r2 = null;
          if (0 === n2) r2 = null;
          else if (1 === n2) {
            var o2;
            const t3 = pp(o2 = this.speakers).call(o2).next().value;
            this.enableSilence && t3 && (r2 = t3.id, t3.evaluateSpeechActivityScores(e2), e2 - t3.lastNonSilence > this.timeoutToSilenceInterval && (r2 = null));
          } else {
            let t3 = null == this.dominantId ? null : this.speakers.get(this.dominantId);
            if (null == t3) {
              const e3 = this.speakers.entries().next();
              e3.value && (r2 = e3.value[0], t3 = e3.value[1]);
            } else r2 = t3.id;
            null != t3 && t3.evaluateSpeechActivityScores(e2);
            const i3 = this.relativeSpeechActivities;
            let n3 = 2;
            for (const o3 of this.speakers.entries()) {
              const [s2, a2] = o3;
              if (a2 === t3) continue;
              a2.evaluateSpeechActivityScores(e2);
              for (let e3 = 0; e3 < i3.length; ++e3) {
                const n4 = null == t3 ? _U : t3.getSpeechActivityScore(e3);
                i3[e3] = Math.log(a2.getSpeechActivityScore(e3) / n4);
              }
              const c2 = i3[0], d2 = i3[1], l2 = i3[2];
              c2 > 3 && d2 > 2 && l2 > 0 && d2 > n3 && (n3 = d2, r2 = s2);
            }
            this.enableSilence && null != t3 && r2 === t3.id && e2 - t3.lastNonSilence > this.timeoutToSilenceInterval && (r2 = null);
          }
          null == r2 && !this.enableSilence || r2 === this.dominantId || (t2 = this.dominantId, this.dominantId = r2, i2 = this.dominantId), null == i2 && !this.enableSilence || i2 === t2 || this.emit("ActiveSpeakerChanged", i2);
        }
        _runInDecisionMaker() {
          const e2 = Date.now(), t2 = 300 - (e2 - this.lastLevelIdleTime);
          let i2 = 0;
          t2 <= 0 ? (0 !== this.lastLevelIdleTime && this.timeoutIdleLevels(e2), this.lastLevelIdleTime = e2) : i2 = t2;
          let n2 = 300 - (e2 - this.lastDecisionTime);
          return n2 <= 0 && (this.lastDecisionTime = e2, this.makeDecision(e2), n2 = 300 - (Date.now() - e2)), n2 > 0 && i2 > n2 && (i2 = n2), i2;
        }
        timeoutIdleLevels(e2) {
          const t2 = [];
          for (const n2 of pp(i2 = this.speakers).call(i2)) {
            var i2;
            const r2 = e2 - n2.getLastLevelChangedTime();
            36e5 < r2 && (null == this.dominantId || n2.id !== this.dominantId) ? t2.push(n2.id) : 300 < r2 && n2.levelTimedOut();
          }
          t2.forEach(((e3) => this.speakers.delete(e3)));
        }
      }
      const yU = /* @__PURE__ */ new Map();
      let IU = null, AU = null;
      const bU = 3;
      let wU = [];
      const OU = /* @__PURE__ */ new Map(), NU = /* @__PURE__ */ new Map();
      class DU {
        get samples() {
          return this.actives + this.inactives;
        }
        get activeRate() {
          return this.actives / this.samples;
        }
        constructor(e2, t2) {
          sL(this, "id", void 0), sL(this, "track", void 0), sL(this, "score", 0), sL(this, "active", true), sL(this, "muted", false), sL(this, "timer", 0), sL(this, "actives", 0), sL(this, "inactives", 0), this.id = e2, this.track = t2, this.setActive(OU.size < 3);
        }
        autoCheckActive() {
          this.autoSetActive(), this.autoAdjustActive(), this.resetTimer(), this.actives = 0, this.inactives = 0;
        }
        autoSetActive() {
          const e2 = this.active;
          this.active = this.activeRate >= 0.8;
          const { actives: t2, inactives: i2 } = (function() {
            const e3 = [], t3 = [];
            return Array.from(pp(OU).call(OU)).forEach(((i3) => {
              i3.active ? e3.push(i3) : t3.push(i3);
            })), { actives: e3, inactives: t3 };
          })();
          if (t2.length > 3) {
            let e3;
            t2.forEach(((t3) => {
              (!e3 || e3.score > t3.score) && (e3 = t3);
            })), e3 && e3.setActive(false);
          }
          if (t2.length < 3 && i2.length > 0) {
            let t3;
            i2.forEach(((e3) => {
              (!t3 || t3.score < e3.score) && e3.id !== this.id && (t3 = e3);
            })), t3 && e2 && !this.active && (t3.samples > 40 && t3.activeRate - this.activeRate > 0.4 ? t3.setActive(true) : this.active = true);
          }
          this.setMuted(!this.active);
        }
        setActive(e2) {
          this.active = e2, this.resetTimer(), this.setMuted(!e2);
        }
        autoAdjustActive() {
          this.active ? this.autoSwitchToInactive() : this.autoSwitchToActive();
        }
        autoSwitchToActive() {
          const e2 = (function(e3) {
            let t2;
            return Array.from(pp(OU).call(OU)).forEach(((i2) => {
              !i2.active || i2.id === e3 || i2.samples < 40 || (!t2 || i2.score < t2.score) && (t2 = i2);
            })), t2;
          })(this.id);
          e2 && this.activeRate - e2.activeRate > 0.4 && (e2.setActive(false), this.setActive(true));
        }
        autoSwitchToInactive() {
          const e2 = (function(e3) {
            let t2;
            return Array.from(pp(OU).call(OU)).forEach(((i2) => {
              i2.active || i2.id === e3 || i2.samples < 40 || (!t2 || i2.score > t2.score) && (t2 = i2);
            })), t2;
          })(this.id);
          e2 && e2.activeRate - this.activeRate > 0.4 && (e2.setActive(true), this.setActive(false));
        }
        addSample(e2) {
          e2 ? this.actives += 1 : this.inactives += 1, this.samples > 66.66666666666667 && this.autoCheckActive();
        }
        setMuted(e2) {
          this.track && (this.track.enabled = !e2, this.muted = e2);
        }
        resetTimer() {
          this.clearTimer(), this.timer = window.setTimeout((() => {
            if (0 !== this.samples) return this.samples < 50 ? this.resetTimer() : void this.autoCheckActive();
          }), 1e3);
        }
        clearTimer() {
          this.timer && (clearTimeout(this.timer), this.timer = 0);
        }
      }
      let PU;
      function LU(e2) {
        const t2 = OU.get(e2);
        t2 && (OU.delete(e2), t2.clearTimer());
      }
      const kU = /* @__PURE__ */ new Map(), MU = /* @__PURE__ */ new Map();
      const UU = "video/h264", VU = "video/h265";
      function xU(e2, t2, i2) {
        let n2 = new Uint8Array(e2, t2, i2), r2 = [], o2 = 0;
        for (; r2.length < i2; ) o2 + 3 < i2 && 0 === n2[o2] && 0 === n2[o2 + 1] && 3 === n2[o2 + 2] && (0 === n2[o2 + 3] || 1 === n2[o2 + 3] || 2 === n2[o2 + 3] || 3 === n2[o2 + 3]) ? (r2.push(n2[o2], n2[o2 + 1], n2[o2 + 3]), o2 += 4) : (r2.push(n2[o2]), o2++);
        return new Uint8Array(r2);
      }
      function FU(e2) {
        const t2 = e2.length;
        let i2 = [], n2 = 0;
        for (; n2 < t2; ) n2 + 2 < t2 && 0 === e2[n2] && 0 === e2[n2 + 1] && (0 === e2[n2 + 2] || 1 === e2[n2 + 2] || 2 === e2[n2 + 2] || 3 === e2[n2 + 2]) ? (i2.push(e2[n2], e2[n2 + 1], 3, e2[n2 + 2]), n2 += 3) : (i2.push(e2[n2]), n2++);
        return new Uint8Array(i2);
      }
      function BU(e2) {
        if (e2.length < 5) return "";
        let t2 = -1;
        for (let i3 = 0; i3 < e2.length - 3; i3++) {
          if (0 === e2[i3] && 0 === e2[i3 + 1] && 1 === e2[i3 + 2]) {
            t2 = i3;
            break;
          }
          if (i3 < e2.length - 4 && 0 === e2[i3] && 0 === e2[i3 + 1] && 0 === e2[i3 + 2] && 1 === e2[i3 + 3]) {
            t2 = i3;
            break;
          }
        }
        if (-1 === t2) return "";
        const i2 = t2 + (0 === e2[t2 + 2] ? 4 : 3);
        if (i2 >= e2.length) return "";
        const n2 = e2[i2];
        return 128 & n2 ? "" : (n2 >> 1 & 63) >= 32 || i2 + 1 < e2.length && 0 == (248 & e2[i2 + 1]) ? VU : (31 & n2) <= 31 ? UU : "";
      }
      const jU = /* @__PURE__ */ new Map();
      const GU = /* @__PURE__ */ new Map();
      !(function() {
        const e2 = Dw();
        hP.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), hP.getStreamFromExtension = e2.name === bw.CHROME && Number(e2.version) > 34, hP.supportUnifiedPlan = (function() {
          if (!window.RTCRtpTransceiver) return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype)) return false;
          const e3 = new RTCPeerConnection();
          let t2 = false;
          try {
            e3.addTransceiver("audio"), t2 = true;
          } catch (e4) {
          }
          return e3.close(), t2;
        })(), hP.supportMinBitrate = e2.name === bw.CHROME || e2.name === bw.EDGE, hP.supportSetRtpSenderParameters = (function() {
          const e3 = Dw();
          return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!sO() || !(!Vw() && !Mw()) || e3.name === bw.FIREFOX && Number(e3.version) >= 64);
        })(), e2.name === bw.SAFARI && (Number(e2.version) >= 14 ? hP.supportDualStream = true : hP.supportDualStream = false), hP.webAudioMediaStreamDest = (function() {
          const e3 = Dw();
          return !(e3.name === bw.SAFARI && Number(e3.version) < 12);
        })(), hP.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, hP.supportWebGL = "undefined" != typeof WebGLRenderingContext, hP.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, sO() || (hP.webAudioWithAEC = true), hP.supportShareAudio = (function() {
          const e3 = Dw();
          return (e3.os === Aw.WIN_10 || e3.os === Aw.WIN_81 || e3.os === Aw.WIN_7 || e3.os === Aw.LINUX || e3.os === Aw.MAC_OS || e3.os === Aw.CHROMIUM_OS) && e3.name === bw.CHROME && Number(e3.version) >= 74;
        })(), hP.supportDataChannel = !!(Gw(76) || Yw(68) || zw(14)), hP.supportPCSetConfiguration = (function() {
          const e3 = window.RTCPeerConnection;
          return !Bw() && !!e3 && e3.prototype.setConfiguration instanceof Function;
        })(), hP.supportWebRTCEncodedTransform = Gw(87) || xw() || Yw(117), hP.supportWebRTCInsertableStream = (function() {
          const e3 = Dw();
          return (e3.name === bw.CHROME || e3.name === bw.EDGE) && Number(e3.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
        })(), hP.supportRequestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, hP.supportWebCrypto = "undefined" != typeof window && void 0 !== window.crypto && void 0 !== window.crypto.subtle, hP.supportSuppressLocalAudioPlayback = gP(), hP.supportRestrictOwnAudio = TP(), oN((() => {
          hP.supportDualStreamEncoding = (function() {
            const e3 = Dw();
            return !!CD("DISABLE_WEBAUDIO") || ("Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && CD("CHROME_DUAL_STREAM_USE_ENCODING")));
          })(), iP.debug("browser ua: ", navigator.userAgent), iP.info("browser info: ", e2), iP.info("browser compatibility: ", hP);
        }));
      })();
      const WU = ["CHINA", "GLOBAL"];
      const HU = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], KU = [], YU = [];
      function zU(e2, t2) {
        return !!t2 && KU.some(((i2) => i2.uid === e2 && i2.channelName === t2));
      }
      function qU() {
        return YU.length > 0;
      }
      var XU = Sv.forEach, JU = Wn("forEach") ? [].forEach : function(e2) {
        return XU(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      };
      Oi({ target: "Array", proto: true, forced: [].forEach !== JU }, { forEach: JU });
      var QU = Zi("Array", "forEach"), ZU = En, $U = $e, eV = l, tV = QU, iV = Array.prototype, nV = { DOMTokenList: true, NodeList: true }, rV = function(e2) {
        var t2 = e2.forEach;
        return e2 === iV || eV(iV, e2) && t2 === iV.forEach || $U(nV, ZU(e2)) ? tV : t2;
      }, oV = i(rV), sV = Je, aV = ho;
      Oi({ target: "Object", stat: true, forced: n((function() {
        aV(1);
      })) }, { keys: function(e2) {
        return aV(sV(e2));
      } });
      var cV = i($.Object.keys), dV = i(ir), lV = i(Er), uV = Oi, hV = or, pV = Qc, _V = Z, EV = xi, mV = Wi, fV = J, SV = qE, gV = pt, TV = sd, RV = PC("slice"), CV = gV("species"), vV = Array, yV = Math.max;
      uV({ target: "Array", proto: true, forced: !RV }, { slice: function(e2, t2) {
        var i2, n2, r2, o2 = fV(this), s2 = mV(o2), a2 = EV(e2, s2), c2 = EV(void 0 === t2 ? s2 : t2, s2);
        if (hV(o2) && (i2 = o2.constructor, (pV(i2) && (i2 === vV || hV(i2.prototype)) || _V(i2) && null === (i2 = i2[CV])) && (i2 = void 0), i2 === vV || void 0 === i2)) return TV(o2, a2, c2);
        for (n2 = new (void 0 === i2 ? vV : i2)(yV(c2 - a2, 0)), r2 = 0; a2 < c2; a2++, r2++) a2 in o2 && SV(n2, r2, o2[a2]);
        return n2.length = r2, n2;
      } });
      var IV = Zi("Array", "slice"), AV = l, bV = IV, wV = Array.prototype, OV = function(e2) {
        var t2 = e2.slice;
        return e2 === wV || AV(wV, e2) && t2 === wV.slice ? bV : t2;
      }, NV = i(OV);
      function DV(e2, t2, i2, n2, r2) {
        var o2, s2, a2, c2 = {};
        return oV(o2 = cV(n2)).call(o2, (function(e3) {
          c2[e3] = n2[e3];
        })), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = dV(s2 = lV(a2 = NV(i2).call(i2)).call(a2)).call(s2, (function(i3, n3) {
          return n3(e2, t2, i3) || i3;
        }), c2), r2 && void 0 !== c2.initializer && (c2.value = c2.initializer ? c2.initializer.call(r2) : void 0, c2.initializer = void 0), void 0 === c2.initializer ? (TC(e2, t2, c2), null) : c2;
      }
      let PV = (function(e2) {
        return e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR", e2;
      })({}), LV = (function(e2) {
        return e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR", e2;
      })({}), kV = (function(e2) {
        return e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND", e2[e2.REQ_DOWNGRADE_FALLBACK = 27] = "REQ_DOWNGRADE_FALLBACK", e2;
      })({}), MV = (function(e2) {
        return e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV", e2;
      })({}), UV = (function(e2) {
        return e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.DATASTREAM2_NOT_AVAILABLE = 27] = "DATASTREAM2_NOT_AVAILABLE", e2[e2.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e2[e2.K_VOS_FALLBACK = 30] = "K_VOS_FALLBACK", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY", e2;
      })({}), VV = (function(e2) {
        return e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed", e2;
      })({}), xV = (function(e2) {
        return e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.PRE_CONNECT_PC = "pre_connect_pc", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_CONNECTING = "datachannel_connecting", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.P2P_CONNECTION = "p2p_connection", e2.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e2.P2P_SUBSCRIBE = "p2p_subscribe", e2.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e2.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e2.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e2.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream", e2.RECOVER_NOTIFICATION = "recover_notification", e2.VOS_FALLBACK = "vos_fallback", e2.VOS_FALLBACK_PROMISE = "vos_fallback_promise", e2;
      })({}), FV = (function(e2) {
        return e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.PUBLISH_DATASTREAM = "publish_datastream", e2.UNPUBLISH = "unpublish", e2.UNPUBLISH_DATASTREAM = "unpublish_datastream", e2.SUBSCRIBE = "subscribe", e2.PRE_SUBSCRIBE = "pre_subscribe", e2.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SET_DUAL_STREAM_MODE = "set_dual_stream_mode", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.CONFIGURE = "configure", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter", e2.SET_RTM2_FLAG = "set_rtm2_flag", e2.DOWNGRADE_CODEC = "downgrade_codec", e2;
      })({}), BV = (function(e2) {
        return e2.WRTC_STATS = "wrtc_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats", e2;
      })({}), jV = (function(e2) {
        return e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e2.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e2.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list", e2.ENABLE_MULTI_STREAM = "enable_multi_stream", e2;
      })({}), GV = (function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      })({}), WV = (function(e2) {
        return e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire", e2.ON_FALLBACK = "websocket:on_fallback", e2;
      })({});
      function HV(e2) {
        if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2)) throw iP.error("Invalid Channel Name ".concat(e2)), new uP(hO.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function KV(e2) {
        if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || RO(e2, 1, 255))) throw new uP(hO.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t2;
        "string" == typeof e2 && iP.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      let YV = (function(e2) {
        return e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2;
      })({});
      const zV = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, qV = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function XV(e2, t2) {
        SO(e2.url, "".concat(t2, ".url"), 1, 1e3, false), TO(e2.x) || mO(e2.x, "".concat(t2, ".x"), 0, 1e4), TO(e2.y) || mO(e2.y, "".concat(t2, ".y"), 0, 1e4), TO(e2.width) || mO(e2.width, "".concat(t2, ".width"), 0, 1e4), TO(e2.height) || mO(e2.height, "".concat(t2, ".height"), 0, 1e4), TO(e2.zOrder) || mO(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), TO(e2.alpha) || mO(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
      }
      const JV = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" };
      let QV = (function(e2) {
        return e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address", e2;
      })({}), ZV = (function(e2) {
        return e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager", e2;
      })({}), $V = (function(e2) {
        return e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN", e2;
      })({});
      function ex(e2) {
        if (!e2.channelName) throw new uP(hO.INVALID_PARAMS, "invalid channelName in info");
        if ("number" != typeof e2.uid) throw new uP(hO.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && SO(e2.token, "info.token", 1, 2047), KV(e2.uid), HV(e2.channelName), true;
      }
      let tx = (function(e2) {
        return e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile", e2;
      })({}), ix = (function(e2) {
        return e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", e2;
      })({}), nx = (function(e2) {
        return e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE", e2;
      })({}), rx = (function(e2) {
        return e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED", e2;
      })({}), ox = (function(e2) {
        return e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low", e2;
      })({}), sx = (function(e2) {
        return e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.PRE_CONNECT_PC = "pre-connect_pc", e2.UPDATE_GATEWAY_CONFIG = "update-gateway-config", e2.VOS_FALLBACK = "vos-fallback", e2.VOS_FALLBACK_PROMISE = "vos-fallback-promise", e2.RESET_SIGNAL = "reset-signal", e2.DATACHANNEL_FAILBACK = "datachannel-failback", e2;
      })({}), ax = (function(e2) {
        return e2.P2P_DISCONNECTED = "P2P_DISCONNECTED", e2.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e2.TIMEOUT = "TIMEOUT", e2.UNKNOWN_REASON = "UNKNOWN_REASON", e2;
      })({}), cx = (function(e2) {
        return e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data", e2[e2.DataStream0 = 256] = "DataStream0", e2[e2.DataStream1 = 512] = "DataStream1", e2[e2.DataStream2 = 1024] = "DataStream2", e2[e2.DataStream3 = 2048] = "DataStream3", e2[e2.DataStream4 = 4096] = "DataStream4", e2[e2.DataStream5 = 8192] = "DataStream5", e2[e2.DataStream6 = 16384] = "DataStream6", e2[e2.DataStream7 = 32768] = "DataStream7", e2;
      })({}), dx = (function(e2) {
        return e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS", e2;
      })({});
      const lx = [dx.AFRICA, dx.ASIA, dx.CHINA, dx.EUROPE, dx.GLOBAL, dx.INDIA, dx.JAPAN, dx.NORTH_AMERICA, dx.OCEANIA, dx.OVERSEA, dx.SOUTH_AMERICA];
      let ux = (function(e2) {
        return e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL", e2;
      })({});
      const hx = { CHINA: {}, ASIA: { CODE: ux.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: ux.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: ux.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: ux.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: ux.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: ux.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: ux.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: ux.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: ux.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: ux.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: ux.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: ux.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: ux.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
      pD && (hx.CHINA = { CODE: ux.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] });
      let px = (function(e2) {
        return e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit", e2.UPDATE_CLIENT_ROLE_OPTIONS = "update_client_role_options", e2.UPDATE_REMOTE_VIDEO_STREAM_TYPE = "update_remote_video_stream_type", e2.FALLBACK_TO_HLS = "fallback_to_hls", e2.UPDATE_VOS_CONFIGURE = "update_vos_configure", e2;
      })({});
      function _x(e2) {
        return !!e2 && (!(!e2.uplink || !e2.id) && (void 0 !== e2.uplink.max_bitrate && void 0 !== e2.uplink.min_bitrate));
      }
      class Ex extends NO {
        constructor(e2, t2) {
          super(), iA(this, "onICEConnectionStateChange", void 0), iA(this, "onConnectionStateChange", void 0), iA(this, "onDTLSTransportStateChange", void 0), iA(this, "onDTLSTransportError", void 0), iA(this, "onICETransportStateChange", void 0), iA(this, "onFirstAudioReceived", void 0), iA(this, "onFirstVideoReceived", void 0), iA(this, "onFirstAudioDecoded", void 0), iA(this, "onFirstVideoDecoded", void 0), iA(this, "onFirstVideoRender", void 0), iA(this, "onFirstVideoBufferReady", void 0), iA(this, "onFirstVideoDecodedTimeout", void 0), iA(this, "onSelectedLocalCandidateChanged", void 0), iA(this, "onSelectedRemoteCandidateChanged", void 0), iA(this, "onICECandidateError", void 0), iA(this, "getLocalVideoStats", void 0);
        }
      }
      class mx extends Ex {
        constructor(e2, t2) {
          super(e2, t2), iA(this, "establishPromise", void 0);
        }
      }
      let fx = (function(e2) {
        return e2.VIDEO = "video", e2.AUDIO = "audio", e2;
      })({}), Sx = (function(e2) {
        return e2.UDP_RELAY = "udp_relay", e2.UDP_TCP_RELAY = "udp_tcp_relay", e2.TCP_RELAY = "tcp_relay", e2.RELAY = "relay", e2;
      })({}), gx = (function(e2) {
        return e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.UDP_TCP_RESTART = 1] = "UDP_TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.TCP_RESTART = 3] = "TCP_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED", e2;
      })({});
      const Tx = ["disconnected", "failed"];
      let Rx = (function(e2) {
        return e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack", e2;
      })({}), Cx = (function(e2) {
        return e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected", e2;
      })({}), vx = (function(e2) {
        return e2.AudioMetadata = "audioMetadata", e2.AudioPts = "audioPts", e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestRePublishDataChannel = "requestRePublishDataChannel", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.RequestUpload = "requestUpload", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState", e2.LocalCandidate = "LocalCandidate", e2.RequestP2PMuteLocal = "requestP2PMuteLocal", e2.RequestP2PUnPublish = "RequestP2PUnPublish", e2.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e2.RequestP2PMuteRemote = "RequestP2PMuteRemote", e2.RequestP2PRestartICE = "RequestP2PRestartICE", e2.FirstVideoPreRender = "FirstVideoPreRender", e2.FirstVideoBufferReady = "FirstVideoBufferReady", e2;
      })({}), yx = (function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      })({}), Ix = (function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      })({}), Ax = (function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      })({}), bx = (function(e2) {
        return e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK", e2;
      })({}), wx = (function(e2) {
        return e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback", e2.PRE_CONNECT_PC = "transmitter:pre_connect_pc", e2;
      })({}), Ox = (function(e2) {
        return e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation", e2;
      })({}), Nx = (function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      })({}), Dx = (function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      })({}), Px = (function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      })({}), Lx = (function(e2) {
        return e2.CALL = "call", e2.CANDIDATE = "candidate", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.CONTROL = "control", e2.RESTART_ICE = "restart_ice", e2.ACK = "ack", e2.RESPONSE = "response", e2.JOIN = "join", e2.CHECK = "check", e2;
      })({}), kx = (function(e2) {
        return e2.ABORT = "abort", e2;
      })({}), Mx = (function(e2) {
        return e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e2;
      })({}), Ux = (function(e2) {
        return e2.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", e2.P2P_TOKEN_CHANGED = "p2p_token_changed", e2;
      })({});
      const Vx = { [PV.ACCESS_POINT]: { [MV.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [MV.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [MV.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [MV.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [MV.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [MV.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [MV.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [PV.UNILBS]: { [kV.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [kV.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [kV.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [kV.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [kV.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [kV.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [kV.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [kV.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [kV.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [kV.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [kV.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [kV.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false }, [kV.REQ_DOWNGRADE_FALLBACK]: { desc: "request downgrade fallback", retry: false } }, [PV.STRING_UID_ALLOCATOR]: { [LV.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [LV.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [LV.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function xx(e2) {
        const t2 = Vx[Math.floor(e2 / 1e4)];
        if (!t2) return { desc: "unknown error", retry: false };
        const i2 = t2[e2 % 1e4];
        if (!i2) {
          if (Math.floor(e2 / 1e4) === PV.ACCESS_POINT) {
            const t3 = e2 % 1e4;
            if ("1" === t3.toString()[0]) return { desc: e2.toString(), retry: false };
            if ("2" === t3.toString()[0]) return { desc: e2.toString(), retry: true };
          }
          return { desc: "unknown error", retry: false };
        }
        return i2;
      }
      const Fx = { [UV.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [UV.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [UV.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [UV.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [UV.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [UV.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [UV.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [UV.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [UV.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [UV.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [UV.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [UV.DATASTREAM2_NOT_AVAILABLE]: { desc: "DATASTREAM2_NOT_AVAILABLE", action: "quit" }, [UV.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [UV.K_VOS_FALLBACK]: { desc: "K_VOS_FALLBACK", action: "tryNext" }, [UV.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [UV.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [UV.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [UV.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [UV.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [UV.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [UV.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [UV.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [UV.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [UV.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [UV.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [UV.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [UV.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [UV.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [UV.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [UV.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [UV.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [UV.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [UV.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [UV.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [UV.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [UV.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [UV.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [UV.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [UV.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [UV.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [UV.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [UV.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [UV.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [UV.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [UV.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [UV.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [UV.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [UV.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [UV.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [UV.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [UV.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [UV.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [UV.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [UV.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [UV.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [UV.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [UV.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [UV.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [UV.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [UV.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [UV.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [UV.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [UV.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [UV.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [UV.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function Bx(e2) {
        const t2 = Fx[e2];
        return t2 || { desc: "UNKNOWN_ERROR_".concat(e2), action: "failed" };
      }
      function jx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Gx(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? jx(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : jx(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      function Wx(e2, t2) {
        if ("string" == typeof e2) return e2;
        const { proxy: i2, host: n2, port: r2 } = e2;
        if (t2) {
          const e3 = CD("JOIN_GATEWAY_FALLBACK_PORT") || 443;
          return 443 === e3 ? "wss://".concat(n2, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n2, ":").concat(e3, "/ws/?p=").concat(Number(r2) + 150);
        }
        return i2 ? "wss://".concat(i2, "/ws/?h=").concat(n2, "&p=").concat(r2) : "wss://".concat(n2, ":").concat(r2);
      }
      const Hx = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/, Kx = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/, Yx = /wss:\/\/(.+):([0-9]+)\/?/, zx = /wss:\/\/(.[^\/]+)\/?/;
      let qx = 0;
      class Xx {
        constructor(e2, t2) {
          iA(this, "id", 0), iA(this, "store", void 0), iA(this, "recordIndex", void 0), iA(this, "websockets", []), iA(this, "try443PortDuration", 2e3), iA(this, "forceCloseWSDuration", 5e3), iA(this, "try443PortTimeout", null), iA(this, "forceCloseTimeout", null), iA(this, "isTry443PortFailed", false), iA(this, "isNormalPortFailed", false), iA(this, "useDoubleDomain", false), iA(this, "useProxy", false), iA(this, "startTime", Date.now()), this.id = ++qx, this.try443PortDuration = CD("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e2 || 5e3, this.store = t2;
        }
        closeAllWebsockets() {
          this.websockets.forEach(((e2) => {
            e2.onopen = null, e2.onclose = null, e2.onmessage = null, e2.close();
          })), this.websockets.length = 0;
        }
        clearTimeout() {
          this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout), this.forceCloseTimeout = null, this.try443PortTimeout = null;
        }
        logger() {
          var e2;
          const t2 = Date.now() - this.startTime;
          for (var i2 = arguments.length, n2 = new Array(i2), r2 = 0; r2 < i2; r2++) n2[r2] = arguments[r2];
          iP.debug("[choose-best-ws ".concat(null === (e2 = this.store) || void 0 === e2 ? void 0 : e2.clientId, " ").concat(this.id, "] ").concat(t2, "ms:"), ...n2);
        }
        createWebSocket(e2, t2, i2) {
          this.logger("createWebSocket:", e2, { isTry443Port: t2, hasTimeoutDetection: i2 });
          const n2 = CD("GATEWAY_DOMAINS"), r2 = Date.now(), o2 = [], s2 = n2.find(((t3) => {
            var i3;
            return Ln(i3 = e2.host).call(i3, t3);
          }));
          s2 || (this.useDoubleDomain = false);
          const a2 = [];
          if (this.useDoubleDomain) n2.forEach(((i3) => {
            a2.push(Wx(Gx(Gx({}, e2), {}, { host: e2.host.replace(s2, i3) }), t2));
          }));
          else {
            const i3 = Gx({}, e2);
            if (t2 && s2) {
              const e3 = n2.find(((e4) => e4 !== s2));
              e3 && (i3.host = i3.host.replace(s2, e3));
            }
            a2.push(Wx(i3, t2));
          }
          try {
            a2.forEach(((e3) => {
              const t3 = new WebSocket(e3);
              t3.binaryType = "arraybuffer", o2.push(t3), this.logger("ws is connecting:", t3.url);
            }));
          } catch (n3) {
            if (this.logger("ws create failed"), o2.forEach(((e3) => e3.close())), o2.length = 0, this.useDoubleDomain) return this.useDoubleDomain = false, this.createWebSocket(e2, t2, i2);
            if (!t2 && 443 !== Number(e2.port)) return this.createWebSocket(e2, true, i2);
            throw new uP(hO.WS_ERR, "init websocket failed! Error: ".concat(n3.toString()));
          }
          const c2 = Cw();
          this.store && this.store.recordJoinChannelService({ urls: o2.map(((e3) => e3.url)), service: "gateway" }, this.recordIndex), o2.forEach(((e3) => {
            e3.onopen = () => {
              this.logger("onopen: ws ".concat(e3.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach(((t3) => {
                t3 !== e3 && (t3.onopen = null, t3.onclose = null, t3.onmessage = null, t3.close(), this.logger("close backup websocket: ".concat(t3.url)));
              })), this.websockets.length = 0, c2.resolve(e3);
            }, e3.onclose = (i3) => {
              this.logger("onclose: ws ".concat(e3.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e3.readyState));
              const n3 = o2.every(((e4) => e4.readyState === WebSocket.CLOSED || e4.readyState === WebSocket.CLOSING));
              this.logger("".concat(t2 ? "443" : "47xx", " websocket closed, all failed: ").concat(n3)), n3 && (t2 || this.isTry443PortFailed || this.useProxy) ? (this.logger("onclose: all websocket is closed, ".concat(i3.reason)), c2.reject({ code: i3.code, reason: ax.A_ROUND_WS_FAILED })) : !t2 && n3 && !this.isNormalPortFailed && this.try443PortTimeout && (this.logger("all 47xx websocket is closed, try 443 port"), this.clearTimeout(), l2()), t2 ? this.isTry443PortFailed = n3 : this.isNormalPortFailed = n3;
            }, e3.onmessage = (t3) => this.logger("".concat(e3.url, " onmessage: ").concat(t3.data));
          })), this.websockets.push(...o2);
          const d2 = () => {
            this.websockets.forEach(((e3) => e3.readyState !== WebSocket.OPEN && e3.close()));
          }, l2 = () => {
            if (c2.isResolved) return d2();
            Dw().os === Aw.MAC_OS && Bw() && d2(), this.createWebSocket(e2, true, true).then(((e3) => {
              c2.resolve(e3);
            })).catch(((e3) => {
              this.isNormalPortFailed && c2.reject(e3), this.logger("try 443 port to create ws failed");
            })), this.forceCloseTimeout = window.setTimeout((() => {
              this.logger("5s timeout close un-opens, isWebsocket created: ", c2.isResolved), this.forceCloseTimeout = null, d2();
            }), this.forceCloseWSDuration);
          };
          return i2 || (() => {
            if (t2 || this.useProxy) return this.logger("add 5s timeout at ".concat(t2 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout((() => {
              this.forceCloseTimeout = null, d2();
            }), this.forceCloseWSDuration);
            this.try443PortTimeout = window.setTimeout((() => {
              this.logger("2s timeout, isWebsocket created: ", c2.isResolved), this.try443PortTimeout = null, l2();
            }), this.try443PortDuration);
          })(), c2.promise;
        }
        chooseBestWebsocket(e2, t2, i2, n2) {
          return this.useDoubleDomain = !!t2, "string" == typeof e2 && (e2 = (function(e3) {
            let t3, i3, n3;
            return [, t3, i3, n3] = e3.match(Hx) || [], t3 || ([, i3, n3] = e3.match(Kx) || []), i3 && n3 || ([, i3, n3] = e3.match(Yx) || []), i3 && n3 || ([, i3] = e3.match(zx) || []), i3 || iP.warning("un-destructible url: ", e3), { proxy: t3, host: i3, port: n3 || "443" };
          })(e2)), this.recordIndex = n2, this.useProxy = !!e2.proxy, i2 && this.useProxy && (iP.warn("cannot use 443 only when use proxy"), i2 = false), this.createWebSocket(e2, !!i2, false).finally((() => this.clearTimeout()));
        }
      }
      function Jx(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class Qx extends NO {
        get url() {
          return this.websocket && this.websocket.url || this._websocketUrl;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t2;
          Ln(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(WV.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(WV.CONNECTED) : "closed" === this._state ? this.emit(WV.CLOSED) : "failed" === this._state && this.emit(WV.FAILED));
        }
        resetReconnectCount(e2) {
          iP.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = arguments.length > 5 ? arguments[5] : void 0;
          super(), iA(this, "_websocketUrl", null), iA(this, "connectionID", 0), iA(this, "currentURLIndex", 0), iA(this, "urls", []), iA(this, "_reconnectMode", "tryNext"), iA(this, "reconnectReason", void 0), iA(this, "_initMutex", void 0), iA(this, "name", void 0), iA(this, "_state", "closed"), iA(this, "reconnectInterrupter", void 0), iA(this, "websocket", void 0), iA(this, "retryConfig", void 0), iA(this, "reconnectCount", 0), iA(this, "forceCloseTimeout", 5e3), iA(this, "onlineReconnectListener", void 0), iA(this, "useCompress", void 0), iA(this, "tryDoubleDomain", false), iA(this, "use443PortOnly", false), iA(this, "wsInflateLength", 0), iA(this, "wsDeflateLength", 0), iA(this, "closeEstablishingWs", (() => {
          })), iA(this, "store", void 0), iA(this, "joinGatewayRecordIndex", void 0), this.store = o2, this.name = e2, this.retryConfig = (function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? Jx(Object(i3), true).forEach((function(t4) {
                iA(e3, t4, i3[t4]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : Jx(Object(i3)).forEach((function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              }));
            }
            return e3;
          })({}, t2), this.useCompress = i2, this.tryDoubleDomain = n2, this.use443PortOnly = r2, this._initMutex = new PN("websocket", o2 ? o2.clientId : void 0);
          const { timeout: s2, timeoutFactor: a2 } = t2, c2 = Math.max(300, Math.floor(3 * s2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a2) / 10);
          KO.ONLINE && (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2), QO.on(YO.NETWORK_STATE_CHANGE, ((e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === KO.ONLINE ? (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = s2, this.retryConfig.timeoutFactor = a2));
          }));
        }
        getConnection() {
          return this.websocket || void 0;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i2 = await this._initMutex.lock();
          this._reconnectMode = "tryNext", this.forceCloseTimeout = t2, this.urls = e2, this.state = "connecting";
          try {
            var n2;
            const e3 = Cw(), t3 = this.urls[this.currentURLIndex];
            null === (n2 = this.store) || void 0 === n2 || n2.beforeConnect(), (function(e4) {
              return !(EP() || CD("USE_NEW_TOKEN") || !CD("ENABLE_PREALLOC_PC") && (null == e4 || !e4.autoSubscribe || CD("FORCE_DISABLE_AUTO_SUB")));
            })(this.store) && this.emit(wx.PRE_CONNECT_PC), this.createWebSocketConnection(t3).then(e3.resolve).catch(e3.reject), this.once(WV.CLOSED, (() => {
              e3.reject(new pO(hO.WS_DISCONNECT));
            })), this.once(WV.CONNECTED, e3.resolve), await e3.promise;
          } catch (e3) {
          } finally {
            i2();
          }
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t2 ? setTimeout((() => e3.close()), 500) : e3.close(), this.websocket = void 0, this._websocketUrl = null;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t2) {
          if (!this.websocket) return void iP.warning("[".concat(this.name, "] can not reconnect, no websocket"));
          void 0 !== e2 && (this.reconnectMode = e2), iP.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinGatewayRecordIndex);
          const i2 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t2 });
        }
        sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new pO(hO.WS_ABORT, "websocket is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
          } catch (e3) {
            throw new pO(hO.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2) {
          var t2;
          const i2 = Cw();
          this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
          const n2 = (e3) => {
            var t3;
            null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), iP.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2.resolve();
          }, r2 = async (e3) => {
            var t3;
            if (iP.debug("[".concat(this.name, "] websocket close ").concat(null === (t3 = this.websocket) || void 0 === t3 ? void 0 : t3.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i2.reject(new pO(hO.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            else {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const t4 = XO(this, WV.WILL_RECONNECT, this.reconnectMode, e3.reason) || this.reconnectMode, n3 = await this.reconnectWithAction(t4);
              if ("closed" === this.state) return void iP.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
              if (!n3) return i2.reject(new pO(hO.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), this.close(true);
              i2.resolve();
            }
          }, o2 = (e3) => {
            this.emit(WV.ON_MESSAGE, e3);
          }, s2 = (e3) => {
            iP.warn("[".concat(this.connectionID, "] ws open error ").concat(e3));
          };
          this.websocket && (this.websocket.onclose = null, this.websocket.close()), CD("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = CD("GATEWAY_WSS_ADDRESS")), iP.debug("[".concat(this.name, "] start connect, url:"), e2);
          const a2 = null === (t2 = this.store) || void 0 === t2 ? void 0 : t2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
          try {
            var c2;
            this._websocketUrl = Wx(e2);
            const t3 = await this.chooseBestWebsocketConnection(e2);
            this.websocket = t3, n2 && n2(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = o2, this.websocket.onerror = s2, null === (c2 = this.store) || void 0 === c2 || c2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this.joinGatewayRecordIndex = a2;
          } catch (e3) {
            const t3 = "closed" === this.state, n3 = e3 instanceof pO, o3 = n3 && e3.code === hO.WS_ABORT, s3 = n3 && e3.code === hO.WS_ERR, c3 = n3 ? e3.message : e3 && (e3.reason || e3.toString());
            iP.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c3)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: o3 ? "aborted" : "error", errors: [e3] }, a2), t3 || s3 ? (i2.reject(t3 ? new pO(hO.WS_DISCONNECT, "websocket is closed: ".concat(c3)) : new pO(hO.WS_ERR, "init websocket failed: ".concat(c3))), s3 && iP.error("[".concat(this.name, "] init websocket failed: ").concat(c3))) : r2 && r2(e3);
          }
          return i2.promise;
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount) return false;
          if (0 === this.urls.length) return false;
          if ("closed" === this.state) return false;
          iP.warning("[choose-best-ws] action: =>", e2), this.onlineReconnectListener || QO.isOnline || !QO.onlineWaiter || (this.onlineReconnectListener = QO.onlineWaiter.then((() => {
            this.onlineReconnectListener = void 0;
          })));
          let i2 = true;
          if (this.reconnectInterrupter = () => i2 = false, t2) {
            const t3 = MN(this.reconnectCount, this.retryConfig);
            iP.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await rp.race([fN(t3), this.onlineReconnectListener || new rp((() => {
            }))]);
          }
          if ("closed" === this._state || !i2) return false;
          this.reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(WV.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
          };
          try {
            if ("retry" === e2) await n2(this.urls[this.currentURLIndex], e2);
            else if ("tryNext" === e2) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction("recover", false);
              iP.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), await n2(this.urls[this.currentURLIndex], e2);
            } else "recover" === e2 && (iP.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.urls = await zO(this, WV.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n2(this.urls[this.currentURLIndex], e2));
          } catch (i3) {
            var r2;
            iP.error("[".concat(this.name, "] reconnect failed ").concat(i3 && i3.toString()));
            const n3 = null == i3 || null === (r2 = i3.data) || void 0 === r2 ? void 0 : r2.desc;
            if (Array.isArray(n3)) {
              if (Ln(n3).call(n3, "dynamic key expired")) return this.emit(WV.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false;
              if (Ln(n3).call(n3, "request downgrade fallback")) return this.emit(WV.ON_FALLBACK), false;
            }
            return this.reconnectWithAction(e2, t2);
          }
          return true;
        }
      }
      class Zx extends Qx {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          const i2 = Cw(), n2 = (function(e3, t3) {
            return new Xx(e3, t3);
          })(this.forceCloseTimeout, this.store);
          this.closeEstablishingWs = () => {
            iP.debug("[choose-best-ws] close establishing websockets"), n2.closeAllWebsockets(), i2.reject(new pO(hO.WS_ABORT, "choose best websocket aborted"));
          };
          const r2 = CD("GATEWAY_DOMAINS");
          return iP.debug("[choose-best-ws] currentDomain: ", e2, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n2.chooseBestWebsocket(e2, this.tryDoubleDomain, this.use443PortOnly, t2).then(i2.resolve).catch(i2.reject), i2.promise.finally((() => {
            this.closeEstablishingWs = void 0;
          }));
        }
      }
      class $x extends Qx {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t2) {
          return new rp(((i2, n2) => {
            let r2 = false;
            const o2 = [];
            this.closeEstablishingWs = () => {
              iP.debug("[choose-best-ws] close establishing websockets"), o2.forEach(((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              })), n2(new pO(hO.WS_ABORT, "choose best websocket aborted"));
            };
            const s2 = CD("GATEWAY_DOMAINS");
            let a2;
            const c2 = e2.indexOf("?h="), d2 = s2.find(((t3) => -1 !== c2 ? Ln(e2).call(e2, t3, c2) : Ln(e2).call(e2, t3)));
            iP.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", s2);
            let l2 = !this.tryDoubleDomain || !d2;
            if (!l2 && d2) {
              var u2;
              const h3 = Date.now();
              try {
                s2.forEach(((t3) => {
                  const i3 = -1 === c2 ? e2.replace(d2, t3) : e2.substr(0, c2) + e2.substr(c2).replace(d2, t3), n3 = new WebSocket(i3);
                  n3.binaryType = "arraybuffer", o2.push(n3), iP.debug("[choose-best-ws] ws is connecting:", n3.url);
                }));
              } catch (e3) {
                for (iP.debug("[choose-best-ws] ws create failed, fallback to single url"), o2.forEach(((e4) => e4.close())); o2.length; ) o2.pop();
                l2 = true;
              }
              null === (u2 = this.store) || void 0 === u2 || u2.recordJoinChannelService({ urls: o2.map(((e3) => e3.url)), service: "gateway" }, t2), o2.forEach(((e3) => {
                e3.onopen = () => {
                  if (r2) return;
                  const t3 = Date.now() - h3;
                  iP.debug("[choose-best-ws] ws open cost ".concat(t3, "ms")), o2.filter(((t4) => t4 !== e3)).forEach(((e4) => {
                    iP.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                  })), r2 = true, i2(e3);
                }, e3.onclose = (e4) => {
                  if (a2 = e4, r2) return;
                  o2.find(((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING))) || (iP.debug("[choose-best-ws] all websocket is closed"), r2 = true, n2(a2));
                }, e3.onmessage = (t3) => {
                  iP.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t3.data));
                };
              })), fN(this.forceCloseTimeout).then((() => {
                o2.forEach(((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                }));
              }));
            }
            if (l2) {
              var h2;
              let r3;
              iP.debug("[choose-best-ws] use single url: ", e2), null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: [e2], service: "gateway" }, t2);
              try {
                r3 = new WebSocket(e2), o2.push(r3), r3.binaryType = "arraybuffer";
              } catch (e3) {
                const t3 = new pO(hO.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return iP.error("[".concat(this.name, "]").concat(t3)), void n2(t3);
              }
              r3.onopen = () => {
                i2(r3);
              }, r3.onclose = (e3) => {
                n2(e3);
              }, r3.onmessage = (e3) => {
                iP.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e3.data));
              }, fN(this.forceCloseTimeout).then((() => {
                r3 && r3.readyState !== WebSocket.OPEN && r3.close();
              }));
            }
          })).then(((e3) => (this.closeEstablishingWs = void 0, e3))).catch(((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          }));
        }
      }
      class eF extends NO {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === VV.CONNECTED ? this.emit(xV.WS_CONNECTED) : e2 === VV.RECONNECTING ? this.emit(xV.WS_RECONNECTING, this._websocketReconnectReason) : e2 === VV.CLOSED && this.emit(xV.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), iA(this, "__name__", "AgoraRTCSignal"), iA(this, "_disconnectedReason", void 0), iA(this, "_websocketReconnectReason", void 0), iA(this, "_connectionState", VV.CLOSED), iA(this, "reconnectToken", void 0), iA(this, "websocket", void 0), iA(this, "openConnectionTime", void 0), iA(this, "clientId", void 0), iA(this, "lastMsgTime", Date.now()), iA(this, "uploadCache", []), iA(this, "uploadCacheInterval", void 0), iA(this, "rttRolling", new xN(5)), iA(this, "pingpongTimer", void 0), iA(this, "wsInflateDataTimer", void 0), iA(this, "pingpongTimeoutCount", 0), iA(this, "ortc", void 0), iA(this, "joinResponse", void 0), iA(this, "multiIpOption", void 0), iA(this, "initError", void 0), iA(this, "spec", void 0), iA(this, "store", void 0), iA(this, "onWebsocketMessage", ((e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(xV.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              if (this.emit(t3._type, t3._message), t3._type === jV.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === jV.ON_USER_BANNED) switch (t3._message.error_code) {
                case 14:
                  this.close(VO.UID_BANNED);
                  break;
                case 15:
                  this.close(VO.IP_BANNED);
                  break;
                case 16:
                  this.close(VO.CHANNEL_BANNED);
              }
              if (t3._type === jV.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
                case UV.ERR_LICENSE_MISSING:
                  this.close(VO.LICENSE_MISSING);
                  break;
                case UV.ERR_LICENSE_EXPIRED:
                  this.close(VO.LICENSE_EXPIRED);
                  break;
                case UV.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(VO.LICENSE_MINUTES_EXCEEDED);
                  break;
                case UV.ERR_LICENSE_PERIOD_INVALID:
                  this.close(VO.LICENSE_PERIOD_INVALID);
                  break;
                case UV.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(VO.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case UV.ERR_LICENSE_ILLEGAL:
                  this.close(VO.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          })), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new Zx("gateway-".concat(this.clientId), this.spec.retryConfig, true, CD("JOIN_GATEWAY_USE_DUAL_DOMAIN"), CD("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", (() => {
            this.connectionState === VV.CONNECTED && this.reconnect("retry", HO.OFFLINE);
          }));
        }
        async request(e2, t2, i2, n2) {
          const r2 = SN(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new rp(((t3, i3) => {
            if (this.connectionState === VV.CONNECTED) return t3();
            const n3 = () => {
              this.off(xV.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(xV.WS_CONNECTED, n3), i3(new uP(hO.WS_ABORT));
            };
            this.once(xV.WS_CONNECTED, n3), this.once(xV.WS_CLOSED, r3), e2 !== FV.PUBLISH && e2 !== FV.PUBLISH_DATASTREAM && e2 !== FV.SUBSCRIBE && e2 !== FV.SUBSCRIBE_DATASTREAM && e2 !== FV.UNSUBSCRIBE && e2 !== FV.UNSUBSCRIBE_DATASTREAM && e2 !== FV.UNPUBLISH && e2 !== FV.UNPUBLISH_DATASTREAM && e2 !== FV.CONTROL && e2 !== FV.RESTART_ICE || this.once(xV.DISCONNECT_P2P, (() => {
              i3(new uP(hO.DISCONNECT_P2P));
            })), e2 !== FV.PUBLISH && e2 !== FV.RESTART_ICE || this.once(xV.ABORT_P2P_EXECUTION, (() => {
              i3(new uP(hO.DISCONNECT_P2P));
            }));
          }));
          if (this.connectionState !== VV.CONNECTING && this.connectionState !== VV.RECONNECTING || e2 === FV.JOIN || e2 === FV.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2) return;
          const c2 = new rp(((i3, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.emit(xV.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new uP(hO.WS_ABORT, "type: ".concat(e2))), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(xV.WS_CLOSED, c3), this.once(xV.WS_RECONNECTING, c3), fN(CD("SIGNAL_REQUEST_TIMEOUT")).then((() => {
              this.websocket.connectionID !== s2 || o3 || (iP.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(xV.REQUEST_TIMEOUT, e2, t2));
            }));
          }));
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === VV.CLOSED || e2 === FV.LEAVE) throw new uP(hO.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === FV.JOIN || e2 === FV.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = Bx(l2), h2 = new uP(hO.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
          return "success" === u2.action ? d2.message : (iP.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === UV.ERR_TOO_MANY_BROADCASTERS ? e2 === FV.JOIN || e2 === FV.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === UV.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, iP.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", HO.MULTI_IP)) : this.reconnect(u2.action, HO.SERVER_ERROR), e2 === FV.JOIN || e2 === FV.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new rp(((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          }));
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void iP.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(BV.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = CD("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval((() => {
              if (this.connectionState !== VV.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }), CD("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new rp(((t2, i2) => {
            this.once(xV.WS_CONNECTED, (() => t2(this.joinResponse))), this.once(xV.WS_CLOSED, ((e3) => i2(this.initError || new uP(hO.WS_ABORT, e3)))), this.connectionState = VV.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval((() => {
              this.handleWsInflateData();
            }), 2e4);
          }));
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || VO.LEAVE, this.connectionState = VV.CLOSED, iP.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close();
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(xV.ABORT_P2P_EXECUTION), this.store.signalConnected();
            const e2 = await zO(this, xV.REQUEST_JOIN_INFO);
            this.store.joinReq();
            const t2 = await this.request(FV.JOIN, e2);
            if (this.ortc = null == e2 ? void 0 : e2.ortc, this.store.joinRep(), !t2) return this.emit(xV.REPORT_JOIN_GATEWAY, ax.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(xV.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken) throw new uP(hO.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = JO(this, xV.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(FV.REJOIN, e2);
          return !!t2 && (this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach(((e3) => {
            this.emit(jV.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(jV.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(jV.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(jV.MUTE_AUDIO, { uid: e3.uid }) : this.emit(jV.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(jV.MUTE_VIDEO, { uid: e3.uid }) : this.emit(jV.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(jV.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(jV.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(jV.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(jV.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(jV.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          })), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        async downgradeCodec(e2) {
          if (!this.ortc) return false;
          const t2 = { downgrade_codec: e2, ortc: this.ortc };
          return !!await this.request(FV.DOWNGRADE_CODEC, t2);
        }
        handleNotification(e2) {
          iP.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = Bx(e2.code);
          if (28 === e2.code && "detail" in e2 && (iP.info("[".concat(this.clientId, "] receive recover notification: "), e2.detail), this.emit(xV.RECOVER_NOTIFICATION, e2.detail)), "success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? e2.code === UV.ERR_REPEAT_JOIN_CHANNEL && CD("IGNORE_UID_CHECK") ? void this.close(VO.UID_CONFLICT) : ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(VO.UID_BANNED), void this.close()) : e2.code === UV.K_VOS_FALLBACK && "detail" in e2 ? (iP.info("[".concat(this.clientId, "] receive vos fallback notification: "), e2.detail), "FALLBACKCN" === e2.detail && CD("ENABLE_QUALITY_FALLBACK") ? void zO(this, xV.VOS_FALLBACK_PROMISE, e2.detail).then((() => {
              this.reconnect("recover", t2.desc);
            })).catch(((e3) => {
              iP.debug("[".concat(this.clientId, "] cancel vos fallback cn, error: "), e3);
            })) : "fallback_hls" === e2.detail && CD("ENABLE_FALLBACK_TO_HLS") ? (this.emit(xV.VOS_FALLBACK, e2.detail), void this.close(VO.FALLBACK_TO_HLS)) : this.reconnect(t2.action, t2.desc)) : void this.reconnect(t2.action, HO.SERVER_ERROR);
            iP.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = CD("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (iP.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > CD("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", HO.TIMEOUT) : this.request(FV.PING, void 0, true).then((() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), CD("REPORT_STATS") && this.send(FV.PING_BACK, { pingpongElapse: e3 });
          })).catch(((e3) => {
          }));
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
          0 !== e2 && 0 !== t2 && this.upload(BV.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(WV.RECONNECT_CREATE_CONNECTION, ((e2) => {
            this.emit(xV.WS_RECONNECT_CREATE_CONNECTION, e2);
          })), this.websocket.on(WV.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(WV.CLOSED, (() => {
            this.connectionState = VV.CLOSED;
          })), this.websocket.on(WV.FAILED, (() => {
            this._disconnectedReason = VO.NETWORK_ERROR, this.connectionState = VV.CLOSED;
          })), this.websocket.on(WV.RECONNECTING, ((e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === VV.CONNECTED ? this.connectionState = VV.RECONNECTING : this.connectionState = VV.CONNECTING;
          })), this.websocket.on(WV.WILL_RECONNECT, ((e2, t2, i2) => {
            const n2 = JO(this, xV.IS_P2P_DISCONNECTED), r2 = n2 || "retry" !== e2;
            n2 && "retry" === e2 && (iP.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e2 = "tryNext", t2 = ax.P2P_DISCONNECTED), r2 && (iP.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e2)), this.emit(xV.REPORT_JOIN_GATEWAY, t2 || ax.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(xV.DISCONNECT_P2P)), i2(e2);
          })), this.websocket.on(WV.CONNECTED, (() => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(((e2) => {
              iP.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", HO.SERVER_ERROR);
            })) : this.join().catch(((e2) => {
              if (this.emit(xV.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof uP) {
                if (e2.code === hO.UNEXPECTED_RESPONSE && e2.data.code === UV.ERR_NO_AUTHORIZED) return this.initError = new uP(hO.TOKEN_EXPIRE, "dynamic key expired"), void this.close(VO.TOKEN_EXPIRE);
                iP.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", HO.SERVER_ERROR) : (this.initError = e2, this.close());
              }
            }));
          })), this.websocket.on(WV.REQUEST_NEW_URLS, ((e2, t2) => {
            zO(this, xV.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          })), this.websocket.on(WV.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => {
            this.emit(jV.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          })), this.websocket.on(wx.PRE_CONNECT_PC, (() => {
            this.emit(xV.PRE_CONNECT_PC);
          })), this.websocket.on(WV.ON_FALLBACK, (() => {
            CD("ENABLE_FALLBACK_TO_HLS") && this.emit(xV.VOS_FALLBACK, "fallback_hls");
          }));
        }
      }
      let tF = (function(e2) {
        return e2.NATIVE_RTC = "native_rtc", e2.NATIVE_RTM = "native_rtm", e2.WEB_RTC = "web_rtc", e2.WEB_RTM = "web_rtm", e2;
      })({}), iF = (function(e2) {
        return e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK", e2;
      })({});
      function nF(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function rF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? nF(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : nF(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let oF = 0;
      function sF(e2) {
        const t2 = CD("TURN_DOMAINS");
        oF = (oF + 1) % t2.length;
        const i2 = t2[oF] || "edge.agora.io";
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(i2) : (iP.debug("Cannot recognized as ip address: ".concat(e2, ", use as host2")), e2);
      }
      function aF(e2) {
        try {
          const t2 = CD("TURN_DOMAINS"), i2 = CD("GATEWAY_DOMAINS").concat(t2).find(((t3) => Ln(e2).call(e2, t3)));
          if (i2) {
            return e2.split(".".concat(i2))[0].replace(/-/g, ".");
          }
          return e2;
        } catch (t2) {
          return iP.debug("serverUrlToIp error, fallback to url", e2), e2;
        }
      }
      function cF(e2, t2) {
        e2.addresses || (e2.addresses = []);
        const i2 = (function(e3, t3) {
          if (CD("CONNECT_GATEWAY_WITHOUT_DOMAIN")) return e3.map(((e4) => {
            let { ip: t4, port: i4 } = e4;
            return { address: "".concat(t4, ":").concat(i4) };
          }));
          const i3 = CD("GATEWAY_DOMAINS");
          let n3 = i3[1] && Ln(t3).call(t3, i3[1]) ? 1 : 0;
          return e3.map(((e4) => {
            let { domain_prefix: t4, port: r3, ip: o3 } = e4;
            if (t4) return { address: "".concat(t4, ".").concat(i3[n3++ % i3.length], ":").concat(r3) };
            const s3 = /^[\.\:\d]+$/.test(o3), a2 = s3 ? "".concat(o3.replace(/[^\d]/g, "-"), ".").concat(i3[n3++ % i3.length], ":").concat(r3) : "".concat(o3, ":").concat(r3);
            return s3 || iP.debug("Cannot recognized as ip address: ".concat(o3, ", use as host3")), { ip: o3, port: r3, address: a2 };
          }));
        })(e2.addresses, t2), n2 = Array.isArray(e2.detail) && e2.detail[18];
        if (n2 && "string" == typeof n2) {
          const e3 = n2.split(";");
          for (let t3 = 0; t3 < e3.length; t3++) {
            var r2;
            const n3 = kg(r2 = e3[t3]).call(r2);
            i2[t3] && n3 && (i2[t3].ip6 = n3);
          }
        }
        const o2 = e2.detail && e2.detail.candidate;
        let s2;
        if (o2) {
          const [e3, t3] = o2.split(":");
          e3 && t3 && (s2 = { port: Number(t3), ip: e3, address: "".concat(e3, ":").concat(t3) });
        }
        return { gatewayAddrs: i2, apGatewayAddress: s2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function dF(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function lF(e2) {
        const t2 = e2._encoderConfig;
        if (!t2) return {};
        const i2 = { resolution: t2.width && t2.height ? "".concat(dF(t2.width), "x").concat(dF(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
        return "number" == typeof t2.frameRate ? (i2.maxFrameRate = t2.frameRate, i2.minFrameRate = t2.frameRate) : t2.frameRate && (i2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i2;
      }
      function uF(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function hF(e2, t2) {
        let i2, n2, r2;
        switch (t2) {
          case iF.CHOOSE_SERVER:
            n2 = 4096, r2 = "choose server";
            break;
          case iF.CLOUD_PROXY:
            n2 = 1048576, r2 = "proxy";
            break;
          case iF.CLOUD_PROXY_5:
            n2 = 4194304, r2 = "proxy5";
            break;
          case iF.CLOUD_PROXY_FALLBACK:
            n2 = 4194310, r2 = "proxy fallback";
            break;
          default:
            throw new uP(hO.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach(((t3) => {
          t3.buffer && t3.buffer.flag === n2 && (i2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map(((e3) => rF(rF({}, e3), {}, { ticket: t3.buffer.cert }))), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: rF(rF({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
        })), !i2) throw new uP(hO.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return i2;
      }
      async function pF(e2, t2) {
        return await rp.all(e2.addresses.map((async (e3) => ({ address: sF(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && CD("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : ED.username, password: t2 && CD("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await OO(t2.toString()) : ED.password }))));
      }
      function _F(e2, t2) {
        const i2 = t2.getMediaStreamTrack(true).getSettings(), n2 = t2.videoHeight || i2.height, r2 = t2.videoWidth || i2.width;
        return n2 && r2 ? Math.max(Math.min(n2, r2) / Math.min(dF(e2.height), dF(e2.width)), 1) : (iP.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
      }
      function EF(e2) {
        let { candidateType: t2, relayProtocol: i2, type: n2, address: r2, port: o2, protocol: s2 } = e2;
        const a2 = { candidateType: t2, relayProtocol: i2, protocol: s2 };
        if ("local-candidate" !== n2) {
          const e3 = r2.split(".");
          e3.length >= 4 && (e3[1] = "*", e3[2] = "*"), a2.address = e3.join("."), a2.port = o2;
        }
        return a2;
      }
      function mF(e2) {
        const t2 = e2.split(":"), i2 = e2.split(/[-.]/), n2 = Ln(e2).call(e2, "-") ? "-" : ".";
        let r2 = e2;
        return t2.length > 1 ? i2.length > 1 ? (i2[1] = "**", r2 = i2[0] + n2 + "**:" + t2[t2.length - 1]) : r2 = t2.length > 2 ? t2[0] + n2 + "**:" + t2[t2.length - 1] : "**:" + t2[t2.length - 1] : i2.length > 1 && (r2 = i2[0] + n2 + "**"), r2;
      }
      function fF(e2, t2) {
        return e2.getTransceivers().find(((e3) => e3.sender.track === t2 || e3.receiver.track === t2));
      }
      function SF() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : CD("SVC_MODE");
        if (CD("ENABLE_SVC")) return (function(e3) {
          return e3 in iD;
        })(e2) ? e2 : iD.L1T3;
      }
      const gF = { [fx.VIDEO]: [{ key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }, { key: "video-orientation", extensionName: "urn:3gpp:video-orientation" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "playout-delay", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay" }, { key: "video-content-type", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type" }, { key: "color-space", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/color-space" }, { key: "video-timing", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing" }], [fx.AUDIO]: [{ key: "ssrc-audio-level", extensionName: "urn:ietf:params:rtp-hdrext:ssrc-audio-level" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }] };
      function TF(e2) {
        e2.send && (vF(fx.VIDEO, e2.send.videoExtensions), vF(fx.AUDIO, e2.send.audioExtensions)), e2.recv && (vF(fx.VIDEO, e2.recv.videoExtensions), vF(fx.AUDIO, e2.recv.audioExtensions)), e2.sendrecv && (vF(fx.VIDEO, e2.sendrecv.videoExtensions), vF(fx.AUDIO, e2.sendrecv.audioExtensions));
      }
      function RF(e2, t2) {
        e2.send && (CF(fx.VIDEO, e2.send.videoExtensions, t2.send.videoExtensions), CF(fx.AUDIO, e2.send.audioExtensions, t2.send.audioExtensions)), e2.recv && (CF(fx.VIDEO, e2.recv.videoExtensions, t2.recv.videoExtensions), CF(fx.AUDIO, e2.recv.audioExtensions, t2.recv.audioExtensions));
      }
      function CF(e2, t2, i2) {
        t2.forEach(((t3) => {
          var n2;
          const r2 = gF[e2].find(((e3) => {
            var i3;
            let { key: n3 } = e3;
            return Ln(i3 = t3.extensionName).call(i3, n3);
          }));
          if (!r2) return;
          const o2 = i2.find(((e3) => {
            let { extensionName: t4 } = e3;
            return Ln(t4).call(t4, r2.key);
          }));
          o2 && Ln(n2 = o2.extensionName).call(n2, "gdpr_forbidden") && (t3.extensionName = o2.extensionName);
        }));
      }
      function vF(e2, t2) {
        t2.forEach(((t3) => {
          var i2;
          const n2 = gF[e2].find(((e3) => {
            var i3;
            let { key: n3 } = e3;
            return Ln(i3 = t3.extensionName).call(i3, n3);
          }));
          Ln(i2 = t3.extensionName).call(i2, "gdpr_forbidden") && n2 && (t3.extensionName = n2.extensionName);
        }));
      }
      function yF(e2) {
        return "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e2 || Ln(e2).call(e2, "abs-send-time");
      }
      function IF(e2) {
        return "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e2 || Ln(e2).call(e2, "draft-holmer-rmcat-transport-wide-cc-extensions-01");
      }
      function AF(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function bF(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? AF(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : AF(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      function wF(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = arguments.length > 3 ? arguments[3] : void 0;
        const { filterRTX: r2, filterVideoFec: o2, filterAudioFec: s2, filterAudioCodec: a2, filterVideoCodec: c2, unsupportedVideoUplinkCodec: d2, unsupportedVideoDownlinkCodec: l2 } = t2, { useXR: u2 } = i2;
        let h2 = [], p2 = [], _2 = [], E2 = [], m2 = false, f2 = false;
        if (LD(e2).mediaDescriptions.forEach(((e3) => {
          n2 && n2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || m2 || (p2 = e3.attributes.payloads, E2 = e3.attributes.extmaps, m2 = true), "audio" !== e3.media.mediaType || f2 || (h2 = e3.attributes.payloads, _2 = e3.attributes.extmaps, f2 = true));
        })), !E2 || 0 === p2.length) throw new Error("Cannot get video capabilities from SDP.");
        if (!_2 || 0 === h2.length) throw new Error("Cannot get audio capabilities from SDP.");
        if (p2.forEach(((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), u2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        })), h2.forEach(((e3) => {
          var t3;
          null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), u2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        })), r2 && (h2 = h2.filter(((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        })), p2 = p2.filter(((e3) => {
          var t3;
          return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }))), o2) {
          const e3 = p2.filter(((e4) => {
            var t4;
            return /(red)|(ulpfec)|(flexfec)/i.test((null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName) || "");
          })), t3 = zF(e3, p2).map(((e4) => e4.payloadType)), i3 = [...e3.map(((e4) => e4.payloadType)), ...t3];
          p2 = p2.filter(((e4) => !Ln(i3).call(i3, e4.payloadType)));
        }
        if (s2 && (h2 = h2.filter(((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
        }))), a2 && (null == a2 ? void 0 : a2.length) > 0 && (h2 = h2.filter(((e3) => {
          var t3;
          return Ln(a2).call(a2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
        }))), c2 && (null == c2 ? void 0 : c2.length) > 0) {
          const e3 = p2.filter(((e4) => {
            var t3;
            return Ln(c2).call(c2, (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
          }));
          p2 = e3.concat(r2 ? [] : zF(e3, p2));
        }
        const S2 = CD("UNSUPPORTED_VIDEO_CODEC");
        if (S2 && S2.length > 0) {
          const e3 = p2.filter(((e4) => e4.rtpMap && Ln(S2).call(S2, e4.rtpMap.encodingName.toLowerCase()))), t3 = zF(e3, p2), i3 = e3.concat(t3).map(((e4) => e4.payloadType));
          p2 = p2.filter(((e4) => !Ln(i3).call(i3, e4.payloadType))), iP.debug("unsupportedVideoCodec: ".concat(S2, ", toBeRemoved: ").concat(i3));
        }
        if (d2 && d2.length > 0 && "sendonly" === n2) {
          const e3 = p2.filter(((e4) => e4.rtpMap && Ln(d2).call(d2, e4.rtpMap.encodingName.toLowerCase()))), t3 = zF(e3, p2), i3 = e3.concat(t3).map(((e4) => e4.payloadType));
          p2 = p2.filter(((e4) => !Ln(i3).call(i3, e4.payloadType))), iP.debug("unsupportedVideoUplinkCodec: ".concat(d2, ", toBeRemoved: ").concat(i3));
        }
        if (l2 && l2.length > 0 && "recvonly" === n2) {
          const e3 = p2.filter(((e4) => e4.rtpMap && Ln(l2).call(l2, e4.rtpMap.encodingName.toLowerCase()))), t3 = zF(e3, p2), i3 = e3.concat(t3).map(((e4) => e4.payloadType));
          p2 = p2.filter(((e4) => !Ln(i3).call(i3, e4.payloadType))), iP.debug("unsupportedVideoDownlinkCodec: ".concat(l2, ", toBeRemoved: ").concat(i3));
        }
        return { audioCodecs: h2, videoCodecs: p2, audioExtensions: _2, videoExtensions: E2 };
      }
      function OF(e2) {
        const t2 = LD(e2);
        let i2, n2;
        for (const e3 of t2.mediaDescriptions) {
          if (!i2) {
            const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
            if (!t3 || !n3) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i2 = { iceUfrag: t3, icePwd: n3 };
          }
          if (!n2) {
            const t3 = e3.attributes.fingerprints;
            t3.length > 0 && (n2 = { fingerprints: t3 });
          }
        }
        if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i2) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i2, dtlsParameters: n2 };
      }
      function NF(e2, t2) {
        const i2 = [], n2 = e2.attributes.ssrcGroups.filter(((e3) => "FID" === e3.semantic)), r2 = e2.attributes.ssrcGroups.find(((e3) => "SIM" === e3.semantic)), o2 = e2.attributes.ssrcs;
        if (r2) r2.ssrcIds.forEach(((e3) => {
          var r3;
          const o3 = null === (r3 = n2.find(((t3) => t3.ssrcIds[0] === e3))) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t2 ? o3 : void 0 });
        }));
        else if (n2.length > 0) {
          const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
        } else {
          if (0 === o2.length) throw new Error("No ssrcs found on local media description.");
          i2.push({ ssrcId: o2[0].ssrcId });
        }
        return i2;
      }
      function DF(e2, t2, i2) {
        const { cname: n2 } = e2;
        let r2 = [];
        t2 && (r2 = PF(t2)), 0 === r2.length && (r2 = e2.iceParameters.candidates.map(((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }))), iP.debug("Using candidates from gateway."));
        const o2 = { fingerprints: e2.dtlsParameters.fingerprints.map(((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint }))) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let a2;
        switch (e2.dtlsParameters.role) {
          case "server":
            a2 = "passive";
            break;
          case "client":
            a2 = "active";
            break;
          case "auto":
            a2 = "actpass";
        }
        const c2 = HF(e2.rtpCapabilities), d2 = [];
        return Array.isArray(i2) && i2.length > 0 && i2.forEach(((e3) => {
          d2.push({ kind: fx.VIDEO, ssrcMsg: [{ ssrcId: e3.v, rtx: e3.v_rtx }], mslabel: "".concat(e3.v, "_").concat(e3.a) }, { kind: fx.AUDIO, ssrcMsg: [{ ssrcId: e3.a }], mslabel: "".concat(e3.v, "_").concat(e3.a) });
        })), { dtlsParameters: o2, iceParameters: s2, candidates: r2, rtpCapabilities: c2, setup: a2, cname: n2, preSSRCs: d2 };
      }
      function PF(e2) {
        let t2 = [];
        return e2.ip && "number" == typeof e2.port && (t2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip, port: e2.port.toString(), type: "host", extension: {} }], iP.debug("Using remote candidate from AP ".concat(mF(e2.ip), ":").concat(e2.port)), e2.ip6 && (t2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip6, port: e2.port.toString(), type: "host", extension: {} }), iP.debug("Using IPV6 remote candidate from AP ".concat(mF(e2.ip6), ":").concat(e2.port)))), t2;
      }
      function LF(e2, t2, i2) {
        const n2 = [], r2 = [];
        return e2.forEach(((e3) => {
          let { ssrcId: o2, rtx: s2 } = e3;
          const a2 = SN(8, "track-"), c2 = { ssrcId: o2, attributes: bF({ label: a2, mslabel: i2 = i2 || SN(10, ""), msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
          if (n2.push(c2), void 0 !== s2) {
            const e4 = { ssrcId: s2, attributes: bF({ label: a2, mslabel: i2, msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
            n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
          }
        })), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map(((e3) => {
          let { ssrcId: t3 } = e3;
          return t3;
        })) }), { ssrcs: n2, ssrcGroups: r2 };
      }
      function kF(e2, t2) {
        t2 instanceof Bk && e2.attributes.payloads.forEach(((e3) => {
          var i2;
          const n2 = null === (i2 = e3.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
          if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2)) return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), "opus" === n2 && "number" == typeof CD("OPUS_PTIME") ? e3.fmtp.parameters.ptime = CD("OPUS_PTIME") : e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const r2 = t2._encoderConfig;
          r2 && ("pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Bw() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1")), t2 instanceof jk && "opus" === n2 && t2._config.DTX && (e3.fmtp.parameters.usedtx = "1"));
        }));
      }
      function MF(e2) {
        const t2 = e2.attributes.unrecognized.findIndex(((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue));
        -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
      }
      function UF(e2, t2) {
        var i2;
        if (e2.attributes.payloads.forEach(((e3) => {
          var t3;
          "h264" === (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) && e3.fmtp && e3.fmtp.parameters && CD("ENABLE_UP_SPS_PPS") && (e3.fmtp.parameters["sps-pps-idr-in-keyframe"] = "1");
        })), !(t2 instanceof kM && t2._encoderConfig && -1 === t2._hints.indexOf(VP.SCREEN_TRACK))) return;
        const n2 = t2._encoderConfig;
        pP().supportMinBitrate && n2.bitrateMin && e2.attributes.payloads.forEach(((e3) => {
          var t3, i3;
          Ln(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(n2.bitrateMin));
        })), pP().supportMinBitrate && !Ln(i2 = t2._hints).call(i2, VP.LOW_STREAM) && n2.bitrateMax && e2.attributes.payloads.forEach(((e3) => {
          var t3, i3;
          Ln(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(CD("X_GOOGLE_START_BITRATE") || Math.floor(n2.bitrateMax)));
        }));
      }
      function VF(e2) {
        if ("video" !== e2.media.mediaType) return;
        const t2 = Dw();
        if (t2.name !== bw.SAFARI && t2.os !== Aw.IOS) return;
        const i2 = e2.attributes.extmaps.findIndex(((e3) => /video-orientation/g.test(e3.extensionName)));
        -1 !== i2 && e2.attributes.extmaps.splice(i2, 1);
      }
      function xF(e2, t2, i2) {
        if (!t2) return;
        let n2, r2;
        if ("video" === e2.media.mediaType ? (n2 = i2.videoExtensions, r2 = i2.videoCodecs) : (n2 = i2.audioExtensions, r2 = i2.audioCodecs), true === t2.twcc) {
          const t3 = n2.find(((e3) => IF(e3.extensionName)));
          if (t3) {
            const i3 = t3.extensionName;
            e2.attributes.extmaps.find(((e3) => IF(e3.extensionName))) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: i3 });
            const n3 = (function(e3, t4) {
              return t4.filter(((t5) => !!e3.find(((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find(((e5) => "transport-cc" === e5.type))))));
            })(r2, e2.attributes.payloads);
            n3.forEach(((e3) => {
              e3.rtcpFeedbacks.find(((e4) => "transport-cc" === e4.type)) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            }));
          }
        } else if (false === t2.twcc) {
          const t3 = e2.attributes.extmaps.findIndex(((e3) => IF(e3.extensionName)));
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach(((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex(((e4) => "transport-cc" === e4.type));
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          }));
        }
        if (true === t2.remb) {
          const t3 = n2.find(((e3) => yF(e3.extensionName)));
          if (t3) {
            const i3 = t3.extensionName;
            e2.attributes.extmaps.find(((e3) => e3.extensionName === i3)) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: i3 });
            const n3 = (function(e3, t4) {
              return t4.filter(((t5) => !!e3.find(((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find(((e5) => "goog-remb" === e5.type))))));
            })(r2, e2.attributes.payloads);
            n3.forEach(((e3) => {
              e3.rtcpFeedbacks.find(((e4) => "goog-remb" === e4.type)) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            }));
          }
        } else if (false === t2.remb) {
          const t3 = e2.attributes.extmaps.findIndex(((e3) => yF(e3.extensionName)));
          -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach(((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex(((e4) => "goog-remb" === e4.type));
            -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
          }));
        }
      }
      function FF(e2, t2, i2) {
        if (Bw()) return;
        if ("video" !== e2.media.mediaType) return;
        if (!(t2 instanceof kM)) return;
        if ("vp9" !== i2 && "vp8" !== i2) return;
        if ("vp8" === i2 && !CD("SIMULCAST")) return;
        if ("vp9" === i2 && CD("ENABLE_SVC")) return;
        if (void 0 === t2._scalabilityMode || t2._scalabilityMode.numSpatialLayers <= 1) return;
        const n2 = "vp8" === i2 ? 2 : t2._scalabilityMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], o2 = e2.attributes.ssrcGroups.find(((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId)), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
        for (let t3 = 1; t3 < n2; t3++) e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: sN(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t3), o2 && (e2.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t3, attributes: sN(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, o2.ssrcIds[1] + t3] }));
        e2.attributes.ssrcGroups.unshift(s2);
      }
      async function BF() {
        try {
          const e2 = new RTCPeerConnection();
          e2.addTransceiver("video", { direction: "sendonly", sendEncodings: [{ scalabilityMode: iD.L1T3 }] });
          const t2 = await e2.createOffer();
          if (!t2.sdp) return void e2.close();
          const i2 = LD(t2.sdp).mediaDescriptions[0];
          if (!i2) return;
          const n2 = i2.attributes.extmaps.find(((e3) => "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension" === e3.extensionName));
          return e2.close(), n2;
        } catch (e2) {
          return;
        }
      }
      async function jF() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = new RTCPeerConnection();
        i2.addTransceiver("video", { direction: "sendonly" }), i2.addTransceiver("audio", { direction: "sendonly" }), i2.addTransceiver("video", { direction: "recvonly" }), i2.addTransceiver("audio", { direction: "recvonly" });
        const n2 = (await i2.createOffer()).sdp, { send: r2, recv: o2, sendrecv: s2 } = (function() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = arguments.length > 2 ? arguments[2] : void 0;
          const n3 = wF(i3, e3, t3, "sendonly"), r3 = wF(i3, e3, t3, "recvonly"), o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, a2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (WF(n3, r3, "videoExtensions", o3, s3, a2), WF(n3, r3, "videoCodecs", o3, s3, a2), WF(n3, r3, "audioExtensions", o3, s3, a2), WF(n3, r3, "audioCodecs", o3, s3, a2), CD("RAISE_H264_BASELINE_PRIORITY")) {
            const e4 = [], t4 = [];
            if (a2.videoCodecs.forEach(((i4, n4) => {
              var r4;
              if ("h264" === (null === (r4 = i4.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                var o4, s4;
                const r5 = a2.videoCodecs[n4 + 1], c2 = r5 && $F(i4, r5), d2 = null === (o4 = i4.fmtp) || void 0 === o4 ? void 0 : o4.parameters["profile-level-id"], l2 = null === (s4 = i4.fmtp) || void 0 === s4 ? void 0 : s4.parameters["packetization-mode"];
                !d2 || d2 !== CD("FIRST_H264_PROFILE_LEVEL_ID") || CD("FIRST_PACKETIZATION_MODE") && l2 !== CD("FIRST_PACKETIZATION_MODE") ? c2 ? t4.push([i4, r5]) : t4.push([i4]) : c2 ? e4.push([i4, r5]) : e4.push([i4]);
              }
            })), e4.length > 0 && t4.length > 0) {
              iP.debug("raising H264 baseline profile priority"), a2.videoCodecs.forEach(((i5, n4) => {
                var r4;
                if ("h264" === (null === (r4 = i5.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                  const r5 = $F(i5, a2.videoCodecs[n4 + 1]), o4 = e4.shift() || t4.shift() || [];
                  o4.length > 0 && (r5 ? a2.videoCodecs.splice(n4, 2, ...o4) : a2.videoCodecs.splice(n4, 1, ...o4));
                }
              }));
              const i4 = s3.videoCodecs.filter(((e5) => {
                var t5, i5;
                return "h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== CD("FIRST_H264_PROFILE_LEVEL_ID");
              }));
              if (i4.length > 0) {
                const e5 = zF(i4, s3.videoCodecs).map(((e6) => e6.payloadType)), t5 = [...i4.map(((e6) => e6.payloadType)), ...e5];
                s3.videoCodecs = s3.videoCodecs.filter(((e6) => !Ln(t5).call(t5, e6.payloadType)));
              }
              CD("FILTER_SEND_H264_BASELINE") && (o3.videoCodecs = o3.videoCodecs.filter(((e5) => {
                var t5, i5;
                return !("h264" === (null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== CD("FIRST_H264_PROFILE_LEVEL_ID"));
              })));
            }
            return { send: o3, recv: s3, sendrecv: a2 };
          }
          return { send: o3, recv: s3, sendrecv: a2 };
        })(e2, t2, n2);
        try {
          i2.close();
        } catch (e3) {
        }
        return { send: r2, recv: o2, sendrecv: s2 };
      }
      function GF() {
        const e2 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t2 = wF(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "recvonly"), i2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (WF(e2, t2, "videoExtensions", i2, n2, r2), WF(e2, t2, "videoCodecs", i2, n2, r2), WF(e2, t2, "audioExtensions", i2, n2, r2), WF(e2, t2, "audioCodecs", i2, n2, r2), CD("RAISE_H264_BASELINE_PRIORITY")) {
          const e3 = r2.videoCodecs.findIndex(((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" === e4.fmtp.parameters["profile-level-id"]));
          if (-1 !== e3) {
            const t3 = r2.videoCodecs.findIndex(((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase()));
            if (t3 < e3) {
              iP.debug("raising H264 baseline profile priority");
              const i3 = r2.videoCodecs[e3];
              r2.videoCodecs.splice(e3, 1), r2.videoCodecs.splice(t3, 0, i3);
            }
            -1 !== t3 && (n2.videoCodecs = n2.videoCodecs.filter(((e4) => !(e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" !== e4.fmtp.parameters["profile-level-id"]))));
          }
        }
        return { send: i2, recv: n2, sendrecv: r2 };
      }
      function WF(e2, t2, i2, n2, r2, o2) {
        if ("videoExtensions" === i2 || "audioExtensions" === i2) {
          const s2 = [];
          return e2[i2].forEach(((e3) => {
            t2[i2].some(((t3, i3) => {
              if (e3.entry === t3.entry && e3.extensionName === t3.extensionName) return s2.push(i3), true;
            })) ? o2[i2].push(e3) : n2[i2].push(e3);
          })), void t2[i2].forEach(((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i2].push(e3);
          }));
        }
        if ("videoCodecs" === i2 || "audioCodecs" === i2) {
          const s2 = [];
          return e2[i2].forEach(((e3) => {
            t2[i2].some(((t3, i3) => {
              if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3)) return s2.push(i3), true;
            })) ? o2[i2].push(e3) : n2[i2].push(e3);
          })), void t2[i2].forEach(((e3, t3) => {
            -1 === s2.indexOf(t3) && r2[i2].push(e3);
          }));
        }
      }
      function HF(e2) {
        const { send: t2, recv: i2, sendrecv: n2 } = e2;
        if (!n2) {
          if (!t2 || !i2) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t2, recv: i2 };
        }
        let r2, o2;
        return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = sN(n2), i2 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i2.audioCodecs, ...n2.audioCodecs], o2.videoCodecs = [...i2.videoCodecs, ...n2.videoCodecs], o2.audioExtensions = [...i2.audioExtensions, ...n2.audioExtensions], o2.videoExtensions = [...i2.videoExtensions, ...n2.videoExtensions]) : o2 = sN(n2), { send: r2, recv: o2 };
      }
      function KF(e2) {
        if ("audio" !== e2.media.mediaType) return;
        e2.attributes.payloads.filter(((e3) => {
          var t2;
          return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
        })).forEach(((e3) => {
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
        }));
      }
      function YF(e2, t2, i2, n2) {
        let r2 = [];
        if (e2 === fx.VIDEO) {
          if (CD("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (r2 = t2.videoCodecs.filter(((e3) => {
            var t3;
            return Ln(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2) && e3 && e3.fmtp && e3.fmtp.parameters["profile-level-id"] === CD("H264_PROFILE_LEVEL_ID");
          }))), !Array.isArray(r2) || 0 === r2.length) {
            let e3 = [];
            const o2 = [], s2 = [], a2 = [];
            if (i2.videoCodecs.forEach(((t3) => {
              const i3 = t3.rtpMap && t3.rtpMap.encodingName.toLowerCase() || "";
              Ln(i3).call(i3, n2) ? e3.push(t3) : Ln(i3).call(i3, "vp9") ? o2.push(t3) : Ln(i3).call(i3, "vp8") ? s2.push(t3) : Ln(i3).call(i3, "h264") && a2.push(t3);
            })), 0 === e3.length) {
              let t3 = "";
              0 !== o2.length ? (e3 = o2, t3 = "vp9") : 0 !== s2.length ? (e3 = s2, t3 = "vp8") : 0 !== a2.length && (e3 = a2, t3 = "h264"), iP.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t3));
            }
            0 !== e3.length && (r2 = t2.videoCodecs.filter(((t3) => e3.some(((e4) => e4.payloadType === t3.payloadType)))));
          }
          if (0 === r2.length && (iP.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t2.videoCodecs[0].rtpMap && t2.videoCodecs[0].rtpMap.encodingName)), r2 = t2.videoCodecs), CD("USE_PUB_RTX") || CD("USE_SUB_RTX")) {
            const e3 = zF(r2, t2.videoCodecs);
            r2 = [...r2, ...e3];
          }
        } else {
          r2 = t2.audioCodecs.filter(((e4) => {
            var t3;
            return Ln(t3 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
          }));
          const e3 = t2.audioCodecs.filter(((e4) => {
            var t3;
            return Ln(t3 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t3, "red");
          }));
          0 === r2.length && (iP.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), r2 = t2.audioCodecs.filter(((e4) => {
            var t3;
            return Ln(t3 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t3, "opus");
          }))), CD("ENABLE_AUDIO_RED") && 0 !== e3.length && (r2 = [...e3, ...r2]);
        }
        return r2;
      }
      function zF(e2, t2) {
        const i2 = e2.map(((e3) => e3.payloadType.toString()));
        return t2.filter(((e3) => e3.rtpMap && "rtx" === e3.rtpMap.encodingName && e3.fmtp && e3.fmtp.parameters.apt && Ln(i2).call(i2, e3.fmtp && e3.fmtp.parameters.apt)));
      }
      async function qF(e2, t2, i2) {
        const n2 = t2.toString(), r2 = JF(n2, "offer", "remote", "exchangeSDP");
        await e2.setRemoteDescription({ type: "offer", sdp: n2 });
        const o2 = await e2.createAnswer();
        if (!o2.sdp) throw new Error("cannot get answer sdp");
        let s2 = o2.sdp;
        s2 = XF(s2, i2 || {}), null == r2 || r2(s2 || ""), await e2.setLocalDescription({ type: "answer", sdp: s2 });
      }
      function XF(e2, t2, i2) {
        if (CD("FORBID_MODIFY_LOCAL_OFFER_SDP")) return e2;
        const n2 = LD(e2), { useXR: r2 } = t2;
        return n2.mediaDescriptions.forEach(((e3) => {
          var t3;
          e3.attributes.mid && (Array.isArray(i2) && !Ln(i2).call(i2, e3.attributes.mid) || ("audio" === e3.media.mediaType && KF(e3), "video" === e3.media.mediaType && (function(e4) {
            if ("video" !== e4.media.mediaType) return;
            if (!CD("ENABLE_DOWN_SPS_PPS")) return;
            e4.attributes.payloads.filter(((e5) => {
              var t4;
              return "h264" === (null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase());
            })).forEach(((e5) => {
              e5.fmtp || (e5.fmtp = { parameters: {} }), e5.fmtp.parameters["sps-pps-idr-in-keyframe"] = "1";
            }));
          })(e3), r2 && Ln(t3 = ["audio", "video"]).call(t3, e3.media.mediaType) && e3.attributes.payloads.forEach(((e4) => {
            -1 === e4.rtcpFeedbacks.findIndex(((e5) => "rrtr" === e5.type)) && e4.rtcpFeedbacks.push({ type: "rrtr" });
          }))));
        })), kD(n2);
      }
      function JF(e2, t2, i2, n2) {
        if (CD("SDP_LOGGING")) return iP.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
          JF(e3, "answer", "local" === i2 ? "remote" : "local", n2);
        } : void 0;
      }
      async function QF(e2, t2, i2) {
        try {
          var n2;
          if (!pP().supportSetRtpSenderParameters) return;
          if (!/* @__PURE__ */ (function(e3) {
            return "vp9" === e3 || "av1" === e3;
          })(e2) || !CD("ENABLE_SVC")) return;
          const r2 = {}, o2 = {}, s2 = t2.getParameters(), a2 = null === (n2 = s2.encodings) || void 0 === n2 ? void 0 : n2[0];
          o2.scalabilityMode = SF(i2), a2 && Object.assign(a2, o2), Object.assign(s2, r2), await t2.setParameters(s2), iP.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(JSON.stringify(s2.encodings)));
        } catch (e3) {
          iP.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed", e3);
        }
      }
      function ZF(e2) {
        const t2 = CD("COMPATIBLE_SDP_EXTENSION");
        return !!(Array.isArray(t2) && t2.length > 0) && t2.some(((t3) => Ln(e2).call(e2, t3)));
      }
      function $F(e2, t2) {
        try {
          var i2;
          return (null === (i2 = e2.fmtp) || void 0 === i2 ? void 0 : i2.parameters.apt) === t2.payloadType.toString();
        } catch (e3) {
          return false;
        }
      }
      function eB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function tB(e2, t2) {
        return typeof CD(e2) === t2 ? CD(e2) : void 0;
      }
      function iB() {
        try {
          const e2 = CD("EXPERIMENTS") || {};
          return "string" == typeof e2 || Array.isArray(e2) ? {} : (function(e3) {
            for (var t2 = 1; t2 < arguments.length; t2++) {
              var i2 = null != arguments[t2] ? arguments[t2] : {};
              t2 % 2 ? eB(Object(i2), true).forEach((function(t3) {
                iA(e3, t3, i2[t3]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : eB(Object(i2)).forEach((function(t3) {
                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i2, t3));
              }));
            }
            return e3;
          })({}, e2);
        } catch (e2) {
          return iP.debug("handle gateway attributes failed: ", e2), {};
        }
      }
      const nB = {};
      function rB(e2) {
        (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && iP.debug("install service ".concat(e2.name)), nB[e2.name] = e2;
      }
      function oB(e2) {
        const t2 = nB[e2];
        if (!t2) throw new pO(hO.INVALID_OPERATION, "".concat(e2, " not found, please use AgoraRTC.use(").concat(e2, "Service) to load it first"));
        return t2;
      }
      function sB(e2, t2) {
        return oB("DataStream").create(e2, t2);
      }
      function aB() {
        return oB("InterceptFrame").create();
      }
      function cB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function dB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? cB(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : cB(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const lB = /* @__PURE__ */ new Map();
      class uB extends NO {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state) return;
          const t2 = this._state;
          this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(sx.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(sx.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          iP.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t2) {
          var i2, n2, r2;
          super(), iA(this, "store", void 0), iA(this, "joinInfo", void 0), iA(this, "key", void 0), iA(this, "ntpOffset", 0), iA(this, "usingProxy", false), iA(this, "signal", void 0), iA(this, "role", void 0), iA(this, "isPreallocation", void 0), iA(this, "isPreSub", void 0), iA(this, "inChannelInfo", { joinAt: null, duration: 0 }), iA(this, "spec", void 0), iA(this, "_state", "DISCONNECTED"), iA(this, "_statsCollector", void 0), iA(this, "_disconnectedReason", void 0), iA(this, "isSignalRecover", false), iA(this, "hasChangeBGPAddress", false), iA(this, "trafficStatsInterval", void 0), iA(this, "networkQualityInterval", void 0), iA(this, "_joinGatewayStartTime", 0), iA(this, "_signalTimeout", false), iA(this, "_clientRoleOptions", void 0), iA(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useP2P ? (i2 = { spec: dB(dB({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), store: e2 }, null === (n2 = (r2 = oB("P2PChannel")).createSubmodule) || void 0 === n2 ? void 0 : n2.call(r2, i2)) : this.store.useDcSignal ? (function(e3) {
            return oB("DataChannelSignal").create(e3);
          })({ spec: dB(dB({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), store: e2 }) : new eF(dB(dB({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
        }
        setUsingProxy(e2) {
          this.usingProxy = e2;
        }
        async join(e2, t2, i2) {
          if (this.store.useDcSignal) {
            let t3 = false;
            "disabled" !== e2.cloudProxyServer ? (iP.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e2.cloudProxyServer, ")")), t3 = true) : "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length > 255 || "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length < 22 ? (iP.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t3 = true) : e2.apResponse.addresses.some(((e3) => e3.fingerprint)) || CD("FINGERPRINT") || (iP.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t3 = true), t3 && this.resetSignal();
          }
          this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const n2 = Date.now();
          let r2 = lB.get(e2.cname);
          if (r2 || (r2 = /* @__PURE__ */ new Map(), lB.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
            const t3 = new uP(hO.UID_CONFLICT);
            throw lP.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.code, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, isProxy: !!e2.proxyServer || this.usingProxy, signalChannel: this.store.useDcSignal ? "1" : "0", preload: e2.preload }), t3;
          }
          r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
          let o2 = 0;
          this.joinGatewayStartTime = n2;
          const s2 = e2.proxyServer, a2 = this.store.useDcSignal ? "datachannel" : "websocket";
          try {
            iP.debug("[".concat(this.store.clientId, "] use ").concat(a2, " join uid ").concat(o2));
            const t3 = e2.gatewayAddrs.map(((t4) => {
              let { address: i4 } = t4;
              const [n3, r3] = i4.split(":"), o3 = { host: n3, port: r3 };
              return e2.proxyServer && (o3.proxy = e2.proxyServer), o3;
            }));
            let i3;
            i3 = this.store.useDcSignal ? await this.signal.init(e2.apResponse.addresses) : await this.signal.init(t3), o2 = i3.uid, iP.debug("[".concat(this.store.clientId, "] ").concat(a2, " join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t3) {
            var c2;
            if (t3.code === hO.INIT_DATACHANNEL_TIMEOUT && "AgoraRTCSignal" === this.signal.__name__) ;
            else lP.joinGateway(e2.sid, { lts: n2, succ: false, ec: (null === (c2 = t3.data) || void 0 === c2 ? void 0 : c2.desc) || t3.code, errorMsg: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, isProxy: !!s2 || this.usingProxy, signalChannel: "DataChannelSignal" === this.signal.__name__ ? "1" : "0", preload: e2.preload });
            if (t3 && t3.code === hO.INIT_DATACHANNEL_TIMEOUT) throw iP.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t3.toString()), this.resetSignal(), t3;
            throw iP.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), r2.delete(e2.uid), this.signal.close(), t3;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), iP.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval((() => {
            this.updateTrafficStats().catch(((e3) => {
              iP.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
            }));
          }), 3e3), this.networkQualityInterval = window.setInterval((() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(sx.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(sx.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(sx.NETWORK_QUALITY, { uplinkNetworkQuality: uF(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: uF(this._statsCollector.trafficStats.B_dnq) }) : this.emit(sx.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }), 2e3), this.store.joinGatewayEnd(), o2;
        }
        async leave() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t2 !== VO.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== VV.CONNECTED || await (function(e3, t3) {
                return t3 === 1 / 0 ? e3 : rp.race([e3, mN(t3)]);
              })(this.signal.request(FV.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              iP.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
            }
            this.signal.close(t2), t2 !== VO.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: CD("PUB_EXTEND"), twcc: !!CD("PUBLISH_TWCC"), rtx: !!CD("USE_PUB_RTX") };
          try {
            return (await this.signal.request(FV.PUBLISH, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === UV.ERR_PUBLISH_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
            throw n3;
          }
        }
        async publishDataChannel(e2, t2, i2) {
          var n2;
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const r2 = { stream_id: t2.streamId, ordered: t2.ordered ? 1 : 0, max_retrans_times: null !== (n2 = t2.maxRetransmits) && void 0 !== n2 ? n2 : 10, channel_id: t2.channelId, metadata: t2.metadata };
          try {
            await this.signal.request(FV.PUBLISH_DATASTREAM, r2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === UV.ERR_PUBLISH_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n3.toString()), await this.tryUnpubDataChannelBeforeRepub(e2, t2), this.publishDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async unpublish(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(FV.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
          } catch (e3) {
            iP.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
          }
        }
        async unpublishDataChannel(e2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await rp.all(e2.map(((e3) => this.signal.request(FV.UNPUBLISH_DATASTREAM, { channel_id: e3 }, true))));
          } catch (e3) {
            iP.warning("unpublish datachannels warning: ", e3);
          }
        }
        async presubscribe(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!CD("SUBSCRIBE_TWCC"), rtx: !!CD("USE_SUB_RTX") || void 0, extend: CD("SUB_EXTEND"), svc: Array.isArray(CD("SVC")) && 0 !== CD("SVC").length ? CD("SVC") : void 0 };
          try {
            return await this.signal.request(FV.PRE_SUBSCRIBE, n2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), n3.toString()), this.presubscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribe(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!CD("SUBSCRIBE_TWCC"), rtx: !!CD("USE_SUB_RTX"), extend: CD("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(CD("SVC")) && 0 !== CD("SVC").length ? CD("SVC") : void 0 };
          try {
            return (await this.signal.request(FV.SUBSCRIBE, n2, true))._message;
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
            throw n3;
          }
        }
        async subscribeDataChannel(e2, t2, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
          const n2 = { uid: e2, stream_id: t2.id, channel_id: t2.datachannelId };
          try {
            return void await this.signal.request(FV.SUBSCRIBE_DATASTREAM, n2, true);
          } catch (n3) {
            if (i2 && n3.data && n3.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n3.toString()), await this.tryUnsubDataChannelBeforeResub(e2, t2), await this.subscribeDataChannel(e2, t2, false);
            throw n3;
          }
        }
        async subscribeAll(e2, t2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i2 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!CD("USE_SUB_RTX"), twcc: !!CD("SUBSCRIBE_TWCC"), svc: Array.isArray(CD("SVC")) && 0 !== CD("SVC").length ? CD("SVC") : void 0 };
          try {
            return await this.signal.request(FV.SUBSCRIBE_STREAMS, i2, true);
          } catch (i3) {
            if (t2 && i3.data && i3.data.code === UV.ERR_SUBSCRIBE_REQUEST_INVALID) return iP.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw i3;
          }
        }
        async setVideoProfile(e2) {
          const t2 = (function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width)) return;
            let t3 = e3.frameRate, i2 = e3.width, n2 = e3.height, r2 = true;
            return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          })(e2);
          if (t2) return this.signal.request(FV.SET_VIDEO_PROFILE, t2);
          iP.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t2) {
          try {
            await this.signal.request(FV.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
          } catch (e3) {
            iP.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
          }
        }
        async unsubscribeDataChannel(e2, t2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new uP(hO.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await rp.all(e2.map(((e3) => this.signal.request(FV.UNSUBSCRIBE_DATASTREAM, { stream_id: e3, uid: t2 }, true))));
          } catch (e3) {
            iP.warning("unsubscribeDataChannel warning: ", e3);
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(FV.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            iP.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = e2;
          return { gatewayEstablishParams: await this.signal.request(FV.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(FV.GATEWAY_INFO);
        }
        async renewToken(e2) {
          await this.signal.request(FV.RENEW_TOKEN, e2), this.key = e2.token;
        }
        updateClientRole(e2, t2) {
          t2 && (this._clientRoleOptions = Object.assign({}, t2)), CD("CLIENT_ROLE_OPTIONS") && (iP.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(CD("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " ")), this._clientRoleOptions = Object.assign({}, CD("CLIENT_ROLE_OPTIONS"))), this.role = e2;
        }
        async setClientRole(e2, t2) {
          if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), CD("CLIENT_ROLE_OPTIONS") && (this._clientRoleOptions = Object.assign({}, CD("CLIENT_ROLE_OPTIONS")), iP.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(CD("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " "))), "CONNECTED" !== this.state) return void (this.role = e2);
          let i2, n2 = 0;
          "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i2 = this._clientRoleOptions.delay, n2 = 1) : n2 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n2 = 0;
          const r2 = Object.assign({}, t2);
          delete r2.delay, delete r2.level, await this.signal.request(FV.SET_CLIENT_ROLE, dB(dB({ role: e2, level: n2, delay: i2 }, r2), {}, { client_ts: Date.now() })), this.role = e2;
        }
        async setDualStreamMode(e2, t2, i2) {
          await this.signal.request(FV.SET_DUAL_STREAM_MODE, { mode: e2 }, i2, t2);
        }
        async setRemoteVideoStreamType(e2, t2) {
          await this.signal.request(FV.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(FV.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t2) {
          await this.signal.request(FV.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
        }
        async pickSVCLayer(e2, t2) {
          await this.signal.request(FV.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
        }
        async setRTM2Flag(e2) {
          await this.signal.request(FV.SET_RTM2_FLAG, { rtm2_flag: e2 });
        }
        async sendExtensionMessage(e2, t2, i2) {
          if (this.store.useP2P) return this.signal.sendExtensionMessage(e2, t2, i2);
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), dB({}, this.inChannelInfo);
        }
        async setConfigure(e2) {
          if (e2 && Array.isArray(e2) && 0 !== e2.length) return this.signal.request(FV.CONFIGURE, e2);
        }
        async getGatewayVersion() {
          return (await this.signal.request(FV.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = lB.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0), this.usingProxy = false;
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo) return;
          const e2 = (function(e3) {
            let t2;
            return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: ED.username, password: ED.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
          })(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(dB(dB({}, ED), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state) return;
          const e2 = await this.signal.request(FV.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), null != e2.ntp_offset && (this.ntpOffset = e2.ntp_offset), e2.peer_delay.forEach(((e3) => {
            const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find(((t3) => t3.peer_uid === e3.peer_uid));
            t2 && t2.B_st !== e3.B_st && oN((() => {
              this.emit(sx.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            }));
          })), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          var t2, i2, n2, r2;
          if (!this.joinInfo || !this.key) throw new uP(hO.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const o2 = Object.assign({}, this.joinInfo.apResponse);
          let s2 = CD("REPORT_APP_SCENARIO");
          if ("string" != typeof s2) try {
            s2 = JSON.stringify(s2);
          } catch (e3) {
            s2 = void 0;
          }
          var a2;
          s2 && s2.length > 128 && (s2 = void 0), this.store.hasStartJoinChannel = true, this.store.isABTestSuccess || this.emit(sx.UPDATE_GATEWAY_CONFIG), a2 = this.store.clientId, Ln(YU).call(YU, a2) || YU.push(a2);
          const c2 = mP(this.store), d2 = !(null === (t2 = this.isPreallocation) || void 0 === t2 || !t2.call(this)), l2 = fP(this.store), u2 = iB(), h2 = Gw(87) || xw() || Yw(117), p2 = ((function() {
            const e3 = Dw();
            if (e3.name !== bw.SAFARI || !e3.browserVersion) return false;
            const t3 = e3.browserVersion.split(".");
            return Number(t3[0]) > 18 || 18 === Number(t3[0]) && Number(t3[1]) >= 4;
          })() || qw(18, 4, false)) && Jw(18, 6, true) && "h264" === this.spec.codec && CD("ENABLE_ABSSENDTIME_AS_SENTTS"), _2 = !("CN" !== (null === (i2 = o2.detail) || void 0 === i2 ? void 0 : i2[3]) || !CD("ENABLE_QUALITY_FALLBACK")) && CD("ENABLE_QUALITY_FALLBACK"), E2 = !!CD("ENABLE_AP_MULTI_IP") && "multi-ip" === (null === (n2 = o2.detail) || void 0 === n2 ? void 0 : n2[5]), m2 = dB({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: hD, browser: navigator.userAgent, process_id: CD("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: E2 || this.hasChangeBGPAddress, ap_response: o2, extend: CD("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: s2, attributes: { userAttributes: dB(dB({ enableEncodedTransform: (!!CD("ENABLE_AUDIO_METADATA") || !!CD("ENABLE_AUDIO_PTS")) && h2 || !!CD("ENABLE_AUDIO_TOPN") && Hw(bw.CHROME, 87, 116) || void 0, enableAudioMetadata: !!CD("ENABLE_AUDIO_METADATA") && h2, enableAudioPts: !!CD("ENABLE_AUDIO_PTS") && h2, topnSmoothLevel: CD("TOPN_SMOOTH_LEVEL"), topnNewSpeakerDelay: CD("TOPN_NEW_SPEAKER_DELAY"), topnSwitchHoldMs: CD("TOPN_SWITCH_HOLD_MS"), topnAudioGain: CD("TOPN_AUDIO_GAIN"), enableNetworkQualityProbe: this.store.networkQualityProbe, enablePublishedUserList: CD("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: CD("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: tB("SUBSCRIBE_AUDIO_FILTER_TOPN", "number"), enablePublishAudioFilter: tB("ENABLE_PUBLISH_AUDIO_FILTER", "boolean"), enableUserLicenseCheck: tB("ENABLE_USER_LICENSE_CHECK", "boolean"), enableRTX: true === CD("USE_PUB_RTX") || true === CD("USE_SUB_RTX") || void 0, disableFEC: CD("DISABLE_FEC"), enableNTPReport: !!CD("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: l2, enableFulllinkAvSync: !!CD("ENABLE_FULL_LINK_AV_SYNC") || void 0, enableDataStream2: tB("ENABLE_DATASTREAM_2", "boolean"), enableAutFeedback: !!CD("FORCE_ENABLE_AUT_CC") || !EP() && (!!CD("ENABLE_AUT_FEEDBACK") || void 0), rtm2Flag: "number" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!CD("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: tB("USE_XR", "boolean"), enableLossbasedBwe: tB("ENABLE_LOSSBASED_BWE", "boolean"), enableAutCC: !!CD("FORCE_ENABLE_AUT_CC") || !EP() && (!!CD("ENABLE_AUT_CC") || void 0), enableCCFallback: tB("ENABLE_CC_FALLBACK", "boolean"), enablePreallocPC: d2, preSubNum: c2 ? tB("PRE_SUB_NUM", "number") : void 0, enablePubTWCC: tB("PUBLISH_TWCC", "boolean"), enableSubTWCC: tB("SUBSCRIBE_TWCC", "boolean"), enablePubRTX: tB("USE_PUB_RTX", "boolean"), enableSubRTX: tB("USE_SUB_RTX", "boolean"), enableSubSVC: CD("ENABLE_SVC") ? CD("ENABLE_SVC_DEFAULT_CODECS") : Array.isArray(CD("SVC")) && 0 !== CD("SVC").length ? CD("SVC") : void 0, enableSvcExtended: CD("ENABLE_SVC") && Array.isArray(CD("SVC_EXTENDED")) && 0 !== CD("SVC_EXTENDED").length ? CD("SVC_EXTENDED") : void 0, enableVosFallback: CD("ENABLE_VOS_FALLBACK"), enableQualityFallback: _2 }, u2), {}, { audioDuplicate: tB("ENABLE_AUDIO_RED", "boolean") ? null !== (r2 = tB("AUDIO_DUPLICATE_NUM", "number")) && void 0 !== r2 ? r2 : 2 : void 0, senttsUsesAbsSendTime: !!p2 || void 0, enableDualStreamFlag: tB("ENABLE_DUAL_STREAM_FLAG", "boolean") }) }, join_ts: this.joinGatewayStartTime }, e2);
          return this.joinInfo.stringUid && (m2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (m2.aes_mode = this.joinInfo.aesmode, CD("ENCRYPT_AES") ? (m2.aes_secret = this.joinInfo.aespassword, m2.aes_encrypt = true) : m2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (m2.aes_salt = this.joinInfo.aessalt)), o2.addresses[this.signal.websocket.currentURLIndex] && (m2.ap_response.ticket = o2.addresses[this.signal.websocket.currentURLIndex].ticket, delete o2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (m2.default_video_stream = this.joinInfo.defaultVideoStream), m2;
        }
        getRejoinMessage() {
          if (!this.joinInfo) throw new uP(hO.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(xV.WS_RECONNECT_CREATE_CONNECTION, ((e2) => {
            this.joinGatewayStartTime = Date.now();
          })), this.signal.on(xV.WS_RECONNECTING, ((e2) => {
            this.joinInfo && lP.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || HO.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", lP.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: "live" === this.spec.mode ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: "audience" === this.role ? 2 : 1, buildFormat: 1 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          })), this.signal.on(xV.WS_CLOSED, ((e2) => {
            let t2;
            switch (e2) {
              case VO.LEAVE:
                t2 = HO.LEAVE;
                break;
              case VO.UID_BANNED:
              case VO.IP_BANNED:
              case VO.CHANNEL_BANNED:
              case VO.SERVER_ERROR:
                t2 = HO.SERVER_ERROR;
                break;
              case VO.FALLBACK:
                t2 = HO.FALLBACK;
                break;
              case VO.LICENSE_MISSING:
              case VO.LICENSE_EXPIRED:
              case VO.LICENSE_MINUTES_EXCEEDED:
              case VO.LICENSE_PERIOD_INVALID:
              case VO.LICENSE_MULTIPLE_SDK_SERVICE:
              case VO.LICENSE_ILLEGAL:
              case VO.TOKEN_EXPIRE:
                t2 = e2;
                break;
              default:
                t2 = HO.NETWORK_ERROR;
            }
            iP.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + HO.NETWORK_ERROR)), this.joinInfo && lP.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === VO.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== VO.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          })), this.signal.on(xV.WS_CONNECTED, (() => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo) {
              if ("audience" === this.role) {
                const e2 = CD("CLIENT_ROLE_OPTIONS") || this._clientRoleOptions;
                e2 && (e2.level || e2.delay) && (iP.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(e2.level, ", delay: ").concat(e2.delay)), this.setClientRole(this.role, e2));
              }
              if (lP.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, isProxy: !!this.joinInfo.proxyServer || this.usingProxy, signalChannel: "DataChannelSignal" === this.signal.__name__ ? "1" : "0", preload: this.joinInfo.preload, isABTestSuccess: this.store.isABTestSuccess }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion) {
                const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
                if (!e2) return void iP.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
                RD("EVENT_REPORT_DOMAIN", e2[1]), RD("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), RD("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
              }
            }
          })), this.signal.on(jV.ON_UPLINK_STATS, ((e2) => {
            this._statsCollector.updateUplinkStats(e2);
          })), this.signal.on(xV.REQUEST_RECOVER, ((e2, t2, i2) => {
            if (!this.joinInfo) return i2(new uP(hO.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, zO(this, sx.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i2);
          })), this.signal.on(xV.REQUEST_JOIN_INFO, (async (e2, t2, i2) => {
            var n2, r2, o2;
            if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e2(this.getJoinMessage({ ortc: {} }));
            const s2 = sN(null === (n2 = this.joinInfo) || void 0 === n2 ? void 0 : n2.turnServer);
            if (CD("NEW_TURN_MODE") && s2 && "disabled" === (null === (r2 = this.joinInfo) || void 0 === r2 ? void 0 : r2.cloudProxyServer)) {
              var a2;
              let e3 = s2.servers.map(((e4) => "turnServerURL" in e4 && CD("USE_TURN_IP") ? dB(dB({}, e4), {}, { turnServerURL: aF(e4.turnServerURL) }) : e4)), t3 = null === (a2 = s2.serversFromGateway) || void 0 === a2 ? void 0 : a2.map(((e4) => CD("USE_TURN_IP") ? dB(dB({}, e4), {}, { turnServerURL: aF(e4.turnServerURL) }) : e4));
              const i3 = this.signal.currentURLIndex;
              if (e3.length > 0) {
                e3 = [e3[i3 % e3.length]], s2.servers = e3;
              }
              Array.isArray(t3) && t3.length > 0 && (t3 = [t3[0]], s2.serversFromGateway = t3), iP.debug("[".concat(this.store.clientId, "] use single turn, use turn server index: ").concat(i3));
            }
            const { iceParameters: c2, dtlsParameters: d2, rtpCapabilities: l2 } = await zO(this, sx.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: s2, cloudProxyServer: null === (o2 = this.joinInfo) || void 0 === o2 ? void 0 : o2.cloudProxyServer });
            try {
              e2(this.getJoinMessage({ ortc: { iceParameters: c2, dtlsParameters: d2, rtpCapabilities: l2, version: "2" } }));
            } catch (e3) {
              t2(e3);
            }
          })), this.signal.on(xV.REQUEST_REJOIN_INFO, ((e2) => {
            e2(this.getRejoinMessage());
          })), this.signal.on(xV.REPORT_JOIN_GATEWAY, ((e2, t2) => {
            if (!this.joinInfo) return;
            let i2, n2 = "";
            var r2;
            e2 instanceof uP ? (i2 = (null === (r2 = e2.data) || void 0 === r2 ? void 0 : r2.desc) || e2.code, n2 = e2.message) : i2 = e2;
            lP.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: i2, errorMsg: n2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, isProxy: !!this.joinInfo.proxyServer || this.usingProxy, signalChannel: "DataChannelSignal" === this.signal.__name__ ? "1" : "0", preload: this.joinInfo.preload });
          })), this.signal.on(xV.IS_P2P_DISCONNECTED, ((e2) => {
            e2(JO(this, sx.IS_P2P_DISCONNECTED));
          })), this.signal.on(xV.DISCONNECT_P2P, (() => {
            this.emit(sx.DISCONNECT_P2P);
          })), this.signal.on(xV.REQUEST_SUCCESS, (() => {
            this._signalTimeout = false;
          })), this.signal.on(xV.REQUEST_TIMEOUT, (() => {
            this._signalTimeout = true;
          })), this.signal.on(xV.JOIN_RESPONSE, ((e2) => {
            const t2 = this.getCurrentGatewayAddress();
            this.emit(sx.JOIN_RESPONSE, e2, t2);
          })), this.signal.on(xV.PRE_CONNECT_PC, (async (e2, t2) => {
            if (this.joinInfo) {
              var i2, n2;
              this.updateTurnConfigFromSignal();
              const o2 = this.getCurrentGatewayAddress(), s2 = sN(null === (i2 = this.joinInfo) || void 0 === i2 ? void 0 : i2.turnServer);
              if (CD("NEW_TURN_MODE") && s2 && "disabled" === (null === (n2 = this.joinInfo) || void 0 === n2 ? void 0 : n2.cloudProxyServer)) {
                var r2;
                let e3 = s2.servers.map(((e4) => "turnServerURL" in e4 && CD("USE_TURN_IP") ? dB(dB({}, e4), {}, { turnServerURL: aF(e4.turnServerURL) }) : e4)), t3 = null === (r2 = s2.serversFromGateway) || void 0 === r2 ? void 0 : r2.map(((e4) => CD("USE_TURN_IP") ? dB(dB({}, e4), {}, { turnServerURL: aF(e4.turnServerURL) }) : e4));
                const i3 = this.signal.currentURLIndex;
                if (e3.length > 0) {
                  e3 = [e3[i3 % e3.length]], s2.servers = e3;
                }
                Array.isArray(t3) && t3.length > 0 && (t3 = [t3[0]], s2.serversFromGateway = t3), iP.debug("[".concat(this.store.clientId, "] use single turn, use turn server index: ").concat(i3, ",in pre pc"));
              }
              const a2 = CD("FINGERPRINT") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;
              if (o2 && a2) {
                const i3 = PF(o2);
                zO(this, sx.PRE_CONNECT_PC, { candidates: i3, fingerprint: a2, turnServer: s2 }).then(((t3) => {
                  null == e2 || e2(t3);
                })).catch(t2 || (() => {
                }));
              }
            }
          })), this.signal.on(xV.RECOVER_NOTIFICATION, ((e2) => {
            this.joinInfo && "string" == typeof CD("AP_REQUEST_DETAIL") && (this.joinInfo.apRequestDetail = "".concat(CD("AP_REQUEST_DETAIL"), ";").concat(e2));
          })), this.signal.on(xV.VOS_FALLBACK, ((e2) => {
            this.emit(sx.VOS_FALLBACK, e2);
          })), this.signal.on(xV.DATACHANNEL_FAILBACK, ((e2) => {
            iP.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(sx.DATACHANNEL_FAILBACK);
          }));
        }
        async tryUnsubBeforeResub(e2, t2) {
          try {
            await this.signal.request(FV.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
          }
        }
        async tryUnsubDataChannelBeforeResub(e2, t2) {
          try {
            await this.signal.request(FV.UNSUBSCRIBE, { stream_id: t2.id }, true);
          } catch (e3) {
            throw iP.warning("unsubscribe datachannel warning", e3), e3;
          }
        }
        async tryUnpubBeforeRepub(e2, t2) {
          try {
            await this.signal.request(FV.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
          }
        }
        async tryUnpubDataChannelBeforeRepub(e2, t2) {
          try {
            await this.signal.request(FV.UNPUBLISH_DATASTREAM, { channnel_id: t2.channelId }, true);
          } catch (e3) {
            throw iP.warning("unpublish datastream warning: ", e3), e3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t2 = { users: e2.map(((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type }))) };
          try {
            await this.signal.request(FV.UNSUBSCRIBE_STREAMS, t2, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
          }
        }
        async muteLocal(e2, t2) {
          const i2 = { action: e2.find(((e3) => e3.stream_type === ox.Audio)) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(FV.CONTROL, i2, true, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
          }
        }
        async unmuteLocal(e2, t2) {
          const i2 = { action: e2.find(((e3) => e3.stream_type === ox.Audio)) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(FV.CONTROL, i2, true, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
          }
        }
        async muteRemote(e2, t2) {
          const i2 = { action: e2 === fx.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(FV.CONTROL, i2, true, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e3), e3;
          }
        }
        async unmuteRemote(e2, t2) {
          const i2 = { action: e2 === fx.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
          try {
            await this.signal.request(FV.CONTROL, i2, true, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e3), e3;
          }
        }
        uploadWRTCStats(e2) {
          this.signal.uploadWRTCStats(e2);
        }
        upload(e2, t2) {
          this.signal.upload(e2, t2);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            return await this.signal.request(FV.RESTART_ICE, t2, true);
          } catch (e3) {
            throw iP.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
          }
        }
        reconnect(e2, t2) {
          "CONNECTED" === this.state && this.signal.reconnect(e2 || void 0, t2 || HO.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e2, t2;
          if (!CD("GATEWAY_WSS_ADDRESS")) return CD("USE_CANDIDATE_FROM_AP_DETAIL") && null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.apGatewayAddress ? (iP.debug("[".concat(this.store.clientId, "] use candidate from ap detail, ").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : null !== (t2 = this.joinInfo) && void 0 !== t2 && t2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e2) {
          await this.signal.request(FV.SET_PARAMETER, { enablePublishAudioFilter: e2 });
        }
        downgradeCodec(e2) {
          this.signal.downgradeCodec(e2);
        }
        resetSignal() {
          this.signal && (this.signal.removeAllListeners(), this.signal.close(VO.FALLBACK)), this.store.useDcSignal = false, this.signal = new eF(dB(dB({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(sx.RESET_SIGNAL);
        }
      }
      let hB = 0, pB = 0;
      function _B(e2, t2, i2, n2) {
        return new rp(((r2, o2) => {
          t2.timeout = t2.timeout || CD("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), hB += _N(t2.data)) : i2 && (t2.data.size ? hB += t2.data.size : t2.data instanceof FormData ? hB += EN(t2.data) : hB += _N(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, Tw.request(t2).then(((e3) => {
            "string" == typeof e3.data ? pB += _N(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? pB += e3.data.byteLength : pB += _N(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          })).catch(((e3) => {
            Tw.isCancel(e3) ? o2(new uP(hO.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new uP(hO.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new uP(hO.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new uP(hO.NETWORK_ERROR, e3.message));
          }));
        }));
      }
      !(function() {
        var e2;
        function i2(e3) {
          var t2 = 0;
          return function() {
            return t2 < e3.length ? { done: false, value: e3[t2++] } : { done: true };
          };
        }
        var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t2, i3) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t2] = i3.value), e3;
        };
        var r2, o2 = (function(e3) {
          e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
          for (var i3 = 0; i3 < e3.length; ++i3) {
            var n3 = e3[i3];
            if (n3 && n3.Math == Math) return n3;
          }
          throw Error("Cannot find global object");
        })(this);
        function s2(e3, t2) {
          if (t2) e: {
            var i3 = o2;
            e3 = e3.split(".");
            for (var r3 = 0; r3 < e3.length - 1; r3++) {
              var s3 = e3[r3];
              if (!(s3 in i3)) break e;
              i3 = i3[s3];
            }
            (t2 = t2(r3 = i3[e3 = e3[e3.length - 1]])) != r3 && null != t2 && n2(i3, e3, { configurable: true, writable: true, value: t2 });
          }
        }
        function a2(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c2(e3) {
          var t2 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t2 ? t2.call(e3) : { next: i2(e3) };
        }
        if (s2("Symbol", (function(e3) {
          function t2(e4, t3) {
            this.A = e4, n2(this, "description", { configurable: true, writable: true, value: t3 });
          }
          if (e3) return e3;
          t2.prototype.toString = function() {
            return this.A;
          };
          var i3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
          return function e4(n3) {
            if (this instanceof e4) throw new TypeError("Symbol is not a constructor");
            return new t2(i3 + (n3 || "") + "_" + r3++, n3);
          };
        })), s2("Symbol.iterator", (function(e3) {
          if (e3) return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
            var s3 = o2[t2[r3]];
            "function" == typeof s3 && "function" != typeof s3.prototype[e3] && n2(s3.prototype, e3, { configurable: true, writable: true, value: function() {
              return a2(i2(this));
            } });
          }
          return e3;
        })), "function" == typeof Object.setPrototypeOf) r2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var l2 = {};
            try {
              l2.__proto__ = { a: true }, d2 = l2.a;
              break e;
            } catch (e3) {
            }
            d2 = false;
          }
          r2 = d2 ? function(e3, t2) {
            if (e3.__proto__ = t2, e3.__proto__ !== t2) throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var u2 = r2;
        function h2() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function p2(e3) {
          if (e3.m) throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function _2(e3, t2) {
          return e3.h = 3, { value: t2 };
        }
        function E2(e3) {
          this.g = new h2(), this.G = e3;
        }
        function m2(e3, t2, i3, n3) {
          try {
            var r3 = t2.call(e3.g.j, i3);
            if (!(r3 instanceof Object)) throw new TypeError("Iterator result " + r3 + " is not an object");
            if (!r3.done) return e3.g.m = false, r3;
            var o3 = r3.value;
          } catch (t3) {
            return e3.g.j = null, e3.g.s(t3), f2(e3);
          }
          return e3.g.j = null, n3.call(e3.g, o3), f2(e3);
        }
        function f2(e3) {
          for (; e3.g.h; ) try {
            var t2 = e3.G(e3.g);
            if (t2) return e3.g.m = false, { value: t2.value, done: false };
          } catch (t3) {
            e3.g.v = void 0, e3.g.s(t3);
          }
          if (e3.g.m = false, e3.g.l) {
            if (t2 = e3.g.l, e3.g.l = null, t2.F) throw t2.D;
            return { value: t2.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function S2(e3) {
          this.next = function(t2) {
            return e3.o(t2);
          }, this.throw = function(t2) {
            return e3.s(t2);
          }, this.return = function(t2) {
            return (function(e4, t3) {
              p2(e4.g);
              var i3 = e4.g.j;
              return i3 ? m2(e4, "return" in i3 ? i3.return : function(e5) {
                return { value: e5, done: true };
              }, t3, e4.g.return) : (e4.g.return(t3), f2(e4));
            })(e3, t2);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function g2(e3, t2) {
          return t2 = new S2(new E2(t2)), u2 && e3.prototype && u2(t2, e3.prototype), t2;
        }
        if (h2.prototype.o = function(e3) {
          this.v = e3;
        }, h2.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, h2.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, E2.prototype.o = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f2(this));
        }, E2.prototype.s = function(e3) {
          return p2(this.g), this.g.j ? m2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f2(this));
        }, s2("Array.prototype.entries", (function(e3) {
          return e3 || function() {
            return (function(e4, t2) {
              e4 instanceof String && (e4 += "");
              var i3 = 0, n3 = false, r3 = { next: function() {
                if (!n3 && i3 < e4.length) {
                  var r4 = i3++;
                  return { value: t2(r4, e4[r4]), done: false };
                }
                return n3 = true, { done: true, value: void 0 };
              } };
              return r3[Symbol.iterator] = function() {
                return r3;
              }, r3;
            })(this, (function(e4, t2) {
              return [e4, t2];
            }));
          };
        })), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var T2 = function(e3, t2) {
            for (var i3 = 0; i3 < e3.length; i3++) t2(e3[i3]);
          }, R2 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, C2 = function(e3, t2, i3) {
            return t2 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i3)), [String(e3), t2]) : [String(e3), String(t2)];
          }, v2 = function(e3, t2) {
            if (e3.length < t2) throw new TypeError(t2 + " argument required, but only " + e3.length + " present.");
          }, y2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, I2 = y2.FormData, A2 = y2.XMLHttpRequest && y2.XMLHttpRequest.prototype.send, b2 = y2.Request && y2.fetch, w2 = y2.navigator && y2.navigator.sendBeacon, O2 = y2.Element && y2.Element.prototype, N2 = y2.Symbol && Symbol.toStringTag;
          N2 && (Blob.prototype[N2] || (Blob.prototype[N2] = "Blob"), "File" in y2 && !File.prototype[N2] && (File.prototype[N2] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            y2.File = function(e4, t2, i3) {
              return e4 = new Blob(e4, i3 || {}), Object.defineProperties(e4, { name: { value: t2 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), N2 && Object.defineProperty(e4, N2, { value: "File" }), e4;
            };
          }
          var D2 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P2 = function(e3) {
            this.i = [];
            var t2 = this;
            e3 && T2(e3.elements, (function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *")) if ("file" === e4.type) {
                var i3 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                T2(i3, (function(i4) {
                  t2.append(e4.name, i4);
                }));
              } else "select-multiple" === e4.type || "select-one" === e4.type ? T2(e4.options, (function(i4) {
                !i4.disabled && i4.selected && t2.append(e4.name, i4.value);
              })) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t2.append(e4.name, e4.value) : (i3 = "textarea" === e4.type ? R2(e4.value) : e4.value, t2.append(e4.name, i3));
            }));
          };
          if ((e2 = P2.prototype).append = function(e3, t2, i3) {
            v2(arguments, 2), this.i.push(C2(e3, t2, i3));
          }, e2.delete = function(e3) {
            v2(arguments, 1);
            var t2 = [];
            e3 = String(e3), T2(this.i, (function(i3) {
              i3[0] !== e3 && t2.push(i3);
            })), this.i = t2;
          }, e2.entries = function e3() {
            var t2, i3 = this;
            return g2(e3, (function(e4) {
              if (1 == e4.h && (t2 = 0), 3 != e4.h) return t2 < i3.i.length ? e4 = _2(e4, i3.i[t2]) : (e4.h = 0, e4 = void 0), e4;
              t2++, e4.h = 2;
            }));
          }, e2.forEach = function(e3, t2) {
            v2(arguments, 1);
            for (var i3 = c2(this), n3 = i3.next(); !n3.done; n3 = i3.next()) {
              var r3 = c2(n3.value);
              n3 = r3.next().value, r3 = r3.next().value, e3.call(t2, r3, n3, this);
            }
          }, e2.get = function(e3) {
            v2(arguments, 1);
            var t2 = this.i;
            e3 = String(e3);
            for (var i3 = 0; i3 < t2.length; i3++) if (t2[i3][0] === e3) return t2[i3][1];
            return null;
          }, e2.getAll = function(e3) {
            v2(arguments, 1);
            var t2 = [];
            return e3 = String(e3), T2(this.i, (function(i3) {
              i3[0] === e3 && t2.push(i3[1]);
            })), t2;
          }, e2.has = function(e3) {
            v2(arguments, 1), e3 = String(e3);
            for (var t2 = 0; t2 < this.i.length; t2++) if (this.i[t2][0] === e3) return true;
            return false;
          }, e2.keys = function e3() {
            var t2, i3, n3, r3, o3 = this;
            return g2(e3, (function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i3 = t2.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n3 = i3.value, r3 = c2(n3), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            }));
          }, e2.set = function(e3, t2, i3) {
            v2(arguments, 2), e3 = String(e3);
            var n3 = [], r3 = C2(e3, t2, i3), o3 = true;
            T2(this.i, (function(t3) {
              t3[0] === e3 ? o3 && (o3 = !n3.push(r3)) : n3.push(t3);
            })), o3 && n3.push(r3), this.i = n3;
          }, e2.values = function e3() {
            var t2, i3, n3, r3, o3 = this;
            return g2(e3, (function(e4) {
              if (1 == e4.h && (t2 = c2(o3), i3 = t2.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n3 = i3.value, (r3 = c2(n3)).next(), _2(e4, r3.next().value));
              i3 = t2.next(), e4.h = 2;
            }));
          }, P2.prototype._asNative = function() {
            for (var e3 = new I2(), t2 = c2(this), i3 = t2.next(); !i3.done; i3 = t2.next()) {
              var n3 = c2(i3.value);
              i3 = n3.next().value, n3 = n3.next().value, e3.append(i3, n3);
            }
            return e3;
          }, P2.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t2 = [], i3 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach((function(e4, n3) {
              return "string" == typeof e4 ? t2.push(i3 + D2(R2(n3)) + '"\r\n\r\n' + R2(e4) + "\r\n") : t2.push(i3 + D2(R2(n3)) + '"; filename="' + D2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            })), t2.push("--" + e3 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e3 });
          }, P2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P2.prototype.toString = function() {
            return "[object FormData]";
          }, O2 && !O2.matches && (O2.matches = O2.matchesSelector || O2.mozMatchesSelector || O2.msMatchesSelector || O2.oMatchesSelector || O2.webkitMatchesSelector || function(e3) {
            for (var t2 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t2 && e3.item(t2) !== this; ) ;
            return -1 < t2;
          }), N2 && (P2.prototype[N2] = "FormData"), A2) {
            var L2 = y2.XMLHttpRequest.prototype.setRequestHeader;
            y2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t2) {
              L2.call(this, e3, t2), "content-type" === e3.toLowerCase() && (this.B = true);
            }, y2.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), A2.call(this, e3)) : A2.call(this, e3);
            };
          }
          b2 && (y2.fetch = function(e3, t2) {
            return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), b2.call(this, e3, t2);
          }), w2 && (y2.navigator.sendBeacon = function(e3, t2) {
            return t2 instanceof P2 && (t2 = t2._asNative()), w2.call(this, e3, t2);
          }), y2.FormData = P2;
        }
      })();
      const EB = () => {
        const e2 = CD("AREAS");
        0 === e2.length && e2.push(dx.GLOBAL);
        return nr(e2).call(e2, ((e3, t2, i2) => {
          const n2 = mB(t2);
          return n2 ? 0 === i2 ? n2 : "".concat(e3, ",").concat(n2) : e3;
        }), "");
      }, mB = (e2) => e2 === dx.OVERSEA ? "".concat(ux.ASIA, ",").concat(ux.EUROPE, ",").concat(ux.AFRICA, ",").concat(ux.NORTH_AMERICA, ",").concat(ux.SOUTH_AMERICA, ",").concat(ux.OCEANIA) : ux[e2], fB = (e2) => {
        const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
        return e2.map(((e3) => {
          const i2 = hx[e3], n2 = Object.keys(i2);
          n2 && n2.map(((e4) => {
            "CODE" !== e4 && (t2[e4] = t2[e4].concat(i2[e4]));
          }));
        })), t2;
      }, SB = { GLOBAL: { ASIA: [dx.CHINA, dx.JAPAN, dx.INDIA, dx.KOREA, dx.HKMC], EUROPE: [], NORTH_AMERICA: [dx.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, gB = Object.keys(SB[dx.GLOBAL]), TB = [dx.CHINA, dx.NORTH_AMERICA, dx.EUROPE, dx.ASIA, dx.JAPAN, dx.INDIA, dx.OCEANIA, dx.SOUTH_AMERICA, dx.AFRICA, dx.KOREA, dx.HKMC, dx.US], RB = function(e2, t2) {
        let i2 = [];
        if (Ln(e2).call(e2, dx.GLOBAL)) {
          const o2 = [dx.GLOBAL, dx.OVERSEA], s2 = Object.keys(hx);
          if (t2 === dx.GLOBAL) throw new uP(hO.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t2 === dx.CHINA) i2 = [dx.OVERSEA];
          else if (r2 = t2, Ln(gB).call(gB, r2)) {
            const e3 = (n2 = t2, SB[dx.GLOBAL][n2] || []), r3 = [...o2, t2, ...e3];
            i2 = s2.filter(((e4) => !Ln(r3).call(r3, e4)));
          } else if ((function(e3) {
            let t3 = false;
            return gB.forEach(((i3) => {
              var n3;
              Ln(n3 = SB[dx.GLOBAL][i3]).call(n3, e3) && (t3 = true);
            })), t3;
          })(t2)) {
            const e3 = (function(e4) {
              let t3;
              return gB.forEach(((i3) => {
                var n4;
                Ln(n4 = SB[dx.GLOBAL][i3]).call(n4, e4) && (t3 = i3);
              })), t3;
            })(t2), n3 = [...o2, e3, t2];
            i2 = s2.filter(((e4) => !Ln(n3).call(n3, e4)));
          } else i2 = e2;
          i2 = (function(e3) {
            const t3 = [];
            return TB.forEach(((i3) => {
              Ln(e3).call(e3, i3) && t3.push(i3);
            })), t3.concat(e3.filter(((e4) => !Ln(TB).call(TB, e4))));
          })(i2);
        } else i2 = e2;
        var n2, r2;
        return i2;
      };
      function CB(e2) {
        var t2, i2;
        if (!e2 && Ln(t2 = CD("AREAS")).call(t2, dx.EXTENSIONS)) return iP.debug("update area from ap : reset"), void vB(WU, true);
        if (!Ln(i2 = CD("AREAS")).call(i2, dx.GLOBAL) || !e2) return;
        let n2 = hx.EXTENSIONS;
        n2 && (n2 = { CODE: mB(dx.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, iP.debug("update area from ap success: ".concat(e2, ",config is "), n2), RD("AREAS", [dx.EXTENSIONS], true), Object.keys(n2).map(((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            RD(e3, n2[e3][0]);
          } else RD(e3, n2[e3]);
        })));
      }
      function vB(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = lP.reportApiInvoke(null, { name: LO.SET_AREA, options: e2, tag: kO.TRACER });
        try {
          let n2 = [];
          if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach(((e3) => {
            if (!Ln(lx).call(lx, e3)) throw new uP(hO.INVALID_PARAMS, "invalid area code");
          })), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
            const { areaCode: t3, excludedArea: i3 } = e2;
            if (!t3) throw new uP(hO.INVALID_PARAMS, "area code is needed");
            let r3 = t3;
            "string" == typeof t3 && (r3 = [t3]), n2 = i3 ? RB(r3, i3) : r3;
          }
          if (!t2) {
            if (yD.AREAS) {
              const e3 = new uP(hO.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
              return i2.onError(e3), void iP.warning("setArea is prohibited because of config-distribute");
            }
            if (Ln(n2).call(n2, dx.GLOBAL) && CD("AREAS") === dx.EXTENSIONS) {
              const e3 = new uP(hO.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
              return i2.onError(e3), void iP.warning("setArea is prohibited because of ap extensions");
            }
          }
          RD("AREAS", n2, t2);
          const r2 = fB(n2);
          Object.keys(r2).map(((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              RD(e3, r2[e3][0]);
            } else RD(e3, r2[e3]);
          })), iP.debug("set area success:", n2.join(","));
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        i2.onSuccess();
      }
      function yB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function IB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? yB(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yB(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let AB = 1;
      function bB(e2, t2, i2, n2, r2) {
        AB += 1;
        const o2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: AB, requestId: AB, version: hD, cname: i2.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
        let a2, c2, d2 = e2[0];
        return UN((async () => {
          a2 = Date.now();
          const e3 = await _B(d2, { data: s2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c2 = Date.now() - a2, 0 !== e3.code) {
            const t3 = new uP(hO.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
            throw iP.error(t3.toString()), t3;
          }
          const i3 = JSON.parse(e3.json_body);
          if (200 !== i3.code) {
            const e4 = new uP(hO.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c2 });
            throw iP.error(e4.toString()), e4;
          }
          if (!i3.servers || 0 === i3.servers.length) {
            const e4 = new uP(hO.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c2 });
            throw iP.error(e4.toString()), e4;
          }
          const r3 = (function(e4, t3) {
            return { addressList: e4.servers.map(((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(CD("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3)))), workerToken: e4.workerToken, vid: e4.vid };
          })(i3, t2);
          return CD("LIVE_STREAMING_ADDRESS") && (r3.addressList = CD("LIVE_STREAMING_ADDRESS") instanceof Array ? CD("LIVE_STREAMING_ADDRESS") : [CD("LIVE_STREAMING_ADDRESS")]), IB(IB({}, r3), {}, { responseTime: c2 });
        }), ((n3, r3) => (lP.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false)), ((n3, r3) => (lP.apworkerEvent(i2.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== hO.OPERATION_ABORTED && n3.code !== hO.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true))), r2);
      }
      let wB = 1;
      function OB(e2, t2, i2, n2) {
        let { url: r2, areaCode: o2 } = e2;
        const { clientId: s2, sid: a2 } = t2, c2 = Date.now();
        let d2;
        const l2 = t2.role, [u2, h2] = kB(t2, o2, [iF.CHOOSE_SERVER]);
        let p2 = QO.networkState;
        return UN((async () => {
          p2 && QO.networkState === KO.OFFLINE && QO.onlineWaiter && await rp.race([QO.onlineWaiter, fN(n2 && n2.maxRetryTimeout || kN.maxRetryTimeout)]), p2 = QO.networkState;
          const { data: e3, headers: o3 } = await _B(r2, { data: u2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          d2 = "1" === o3.http3 ? 1 : -1, lP.reportResourceTiming(r2, a2), DB(e3, r2, t2, c2, [iF.CHOOSE_SERVER], d2);
          const s3 = hF(e3, iF.CHOOSE_SERVER);
          return PB(s3), cF(s3, r2);
        }), ((e3) => (e3 && lP.joinChooseServer(a2, { role: l2, lts: c2, succ: true, csAddr: r2, opid: h2, serverList: e3.gatewayAddrs.map(((e4) => e4.address)), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [iF.CHOOSE_SERVER].toString(), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e3.res.detail && e3.res.detail[38], vid: e3.vid }), false)), ((e3) => e3.code !== hO.OPERATION_ABORTED && (e3.code === hO.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (lP.joinChooseServer(a2, { role: l2, lts: c2, succ: false, csAddr: r2, serverList: null, opid: h2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [iF.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: p2 }), isHttp3: d2, corssRegionTagReq: t2.apRequestDetail }), iP.warning("[".concat(s2 || "sid-".concat(a2.slice(0, 6)), "] Choose server network error, retry"), e3), true))), n2);
      }
      function NB(e2, t2, i2, n2) {
        let r2, { url: o2, areaCode: s2, serviceIds: a2 } = e2;
        const c2 = Date.now(), d2 = t2.role, [l2, u2] = kB(t2, s2, a2);
        let h2;
        return UN((async () => {
          h2 && QO.networkState === KO.OFFLINE && QO.onlineWaiter && await rp.race([QO.onlineWaiter, fN(n2 && n2.maxRetryTimeout || kN.maxRetryTimeout)]), h2 = QO.networkState;
          const { data: e3, headers: s3 } = await _B(o2, { data: l2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          r2 = "1" === s3.http3 ? 1 : -1, lP.reportResourceTiming(o2, t2.sid), DB(e3, o2, t2, c2, a2, r2);
          const d3 = hF(e3, iF.CHOOSE_SERVER), u3 = hF(e3, "proxy5" === t2.cloudProxyServer ? iF.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK), p2 = performance.getEntriesByName(o2), _2 = p2[p2.length - 1];
          let E2;
          return _2 && (E2 = { name: _2.name, protocol: "nextHopProtocol" in _2 ? _2.nextHopProtocol : "", dnscost: "domainLookupEnd" in _2 && "domainLookupStart" in _2 && "number" == typeof _2.domainLookupEnd && "number" == typeof _2.domainLookupStart ? _2.domainLookupEnd - _2.domainLookupStart : -1, tcpTlsCost: "connectEnd" in _2 && "connectStart" in _2 && "number" == typeof _2.connectEnd && "number" == typeof _2.connectStart ? _2.connectEnd - _2.connectStart : -1, reqCost: "requestStart" in _2 && "number" == typeof _2.requestStart && "responseEnd" in _2 && "number" == typeof _2.responseEnd ? _2.responseEnd - _2.requestStart : -1, handleCost: "leave_ts" in e3 && "enter_ts" in e3 && "number" == typeof e3.leave_ts && "number" == typeof e3.enter_ts ? e3.leave_ts - e3.enter_ts : -1 }), PB(d3), { gatewayInfo: cF(d3, o2), proxyInfo: u3, url: o2, resourceTimingInfo: E2 };
        }), ((e3) => {
          var i3;
          return e3.gatewayInfo && lP.joinChooseServer(t2.sid, { role: d2, lts: c2, succ: true, csAddr: o2, serverList: e3.gatewayInfo.gatewayAddrs.map(((e4) => e4.address)), ec: null, opid: u2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2, corssRegionTagReq: t2.apRequestDetail, corssRegionTagRes: e3.gatewayInfo.res.detail && e3.gatewayInfo.res.detail[38], vid: null === (i3 = e3.gatewayInfo) || void 0 === i3 ? void 0 : i3.vid, resourceTimingInfo: e3.resourceTimingInfo ? JSON.stringify(e3.resourceTimingInfo) : void 0 }), e3.proxyInfo && lP.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: o2, turnServerAddrList: e3.proxyInfo.addresses.map(((e4) => e4.ip)).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false;
        }), ((e3) => e3.code !== hO.OPERATION_ABORTED && (e3.code === hO.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (lP.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: h2 }) }), iP.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true))), n2);
      }
      const DB = (e2, t2, i2, n2, r2, o2) => {
        const { sid: s2, clientId: a2, cloudProxyServer: c2 } = i2, d2 = [], l2 = (a3) => {
          4096 === a3.flag ? lP.joinChooseServer(s2, { role: i2.role, lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: a3.error.message, csIp: a3.error.data && a3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2, corssRegionTagReq: i2.apRequestDetail }) : 1048576 !== a3.flag && 4194304 !== a3.flag && 4194310 !== a3.flag || lP.joinWebProxyAP(s2, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: a3.error.code, eventType: c2, unilbsServerIds: r2.toString() });
        };
        if (e2.response_body.forEach(((t3) => {
          const i3 = t3.buffer.code;
          if (23 === t3.uri && 0 === i3 && !t3.buffer.edges_services) if (4194310 === t3.buffer.flag) iP.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
          else {
            const i4 = { error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: CD("NO_EDGES_RETRY"), csIp: e2.detail[502] }), flag: t3.buffer.flag };
            d2.push(i4), l2(i4);
          }
          if (0 !== i3) {
            const n3 = xx(i3), r3 = { error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            4194310 === t3.buffer.flag ? iP.warning(r3.error.toString()) : d2.push(r3), l2(r3);
          }
        })), d2.length) throw iP.warning("[".concat(a2 || "sid-".concat(s2.slice(0, 6)), "] multi unilbs ").concat(t2, " failed, ").concat(d2.map(((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry))).join(" | "))), new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, d2.map(((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message))).join(" | "), { retry: !!d2.find(((e3) => e3.error.data.retry)), csIp: e2.detail[502], desc: [...new Set(d2.map(((e3) => {
          var t3;
          return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (t3 = t3.data) || void 0 === t3 ? void 0 : t3.desc;
        })).filter(((e3) => !!e3)))] });
      }, PB = (e2) => {
        var t2, i2, n2, r2;
        if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code) throw new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        CD("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? CB(e2.detail[23].toLowerCase()) : CB());
        if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2[19])) {
          const t3 = e2.detail[19], i3 = null == t3 ? void 0 : t3.split(";");
          for (let t4 = 0; t4 < i3.length; t4++) {
            var o2;
            const n3 = kg(o2 = i3[t4]).call(o2);
            e2.addresses[t4] && i3 && (e2.addresses[t4].fingerprint = n3);
          }
        }
        if (CD("GATEWAY_ADDRESS") && CD("GATEWAY_ADDRESS").length > 0) {
          iP.debug("assign gateway address to", CD("GATEWAY_ADDRESS"));
          const t3 = CD("GATEWAY_ADDRESS").map(((t4) => {
            var i3, n3;
            const r3 = null !== (i3 = null === (n3 = e2.addresses.find(((e3) => e3.ip === t4.ip && e3.port === t4.port))) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i3 ? i3 : "";
            return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: t4.fingerprint || r3 };
          }));
          e2.addresses = t3;
        }
      }, LB = (e2, t2) => {
        if (e2.response_body && e2.response_body.length) {
          const t3 = e2.response_body[0];
          if (0 !== t3.buffer.code) {
            const e3 = xx(t3.buffer.code);
            throw new uP(hO.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t3.buffer.ticket;
        }
        throw iP.debug("update ticket request received ap response without response body:", t2), new uP(hO.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, kB = (e2, t2, i2) => {
        const n2 = Math.floor(Math.random() * 10 ** 12), r2 = "host" === e2.role ? "1" : "audience" === e2.role ? "2" : void 0, o2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: IB(IB(IB({ 6: e2.stringUid, 11: t2, 12: CD("USE_NEW_TOKEN") ? "1" : void 0 }, r2 ? { 17: r2 } : {}), {}, { 22: t2 }, e2.apRequestDetail ? { 33: e2.apRequestDetail } : {}), e2.apRTM ? { 26: "RTM2" } : {}), key: e2.token, service_ids: i2, uid: e2.uid || 0 } }] };
        o2.request_bodies.forEach(((t3) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        }));
        const s2 = new FormData();
        return s2.append("request", JSON.stringify(o2)), [s2, n2];
      }, MB = (e2, t2) => {
        const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map(((e3) => ({ ip: e3.ip, port: e3.port }))) } }] }, r2 = new FormData();
        return r2.append("request", JSON.stringify(n2)), [r2, i2];
      };
      let UB = 0;
      function VB(e2) {
        return rp.all(e2.map(((e3) => e3.then(((e4) => {
          throw e4;
        }), ((e4) => e4))))).then(((e3) => {
          throw e3;
        }), ((e3) => e3));
      }
      const xB = async (e2) => {
        let { fragementLength: t2, referenceList: i2, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: o2 } = e2, s2 = 0;
        const a2 = t2;
        let c2, d2 = 0;
        const l2 = async () => {
          const e3 = (() => {
            const e4 = s2 * a2, t3 = e4 + a2;
            return i2.slice(e4, t3).map(n2);
          })();
          o2 && o2.push(...e3);
          try {
            c2 = await VB(e3);
          } catch (e4) {
            if (d2 += a2, s2++, !(d2 >= i2.length)) return void await l2();
            r2(e4);
          }
          e3.forEach(((e4) => e4.cancel()));
        };
        return await l2(), c2;
      }, FB = async (e2) => {
        let { referenceList: t2, asyncMapHandler: i2, closeFn: n2 } = e2;
        const r2 = t2.length;
        let o2 = 0;
        const s2 = async () => {
          const e3 = i2(t2.shift());
          try {
            return await e3;
          } catch (e4) {
            if (o2++, o2 >= r2 || null != n2 && n2(e4)) throw e4;
            return s2();
          }
        };
        return s2();
      };
      async function BB() {
        if ("undefined" == typeof VideoDecoder) return true;
        let e2;
        const t2 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 85, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 149, 160, 133, 4, 144, 43, 122, 168, 159, 120, 159, 205, 39, 82, 131, 57, 52, 87, 187, 68, 23, 248, 134, 204, 226, 97, 17, 49, 183, 55, 236, 219, 249, 221, 98, 208, 215, 190, 59, 179, 167, 213, 47, 1, 246, 150, 14, 194, 245, 159, 83, 35, 64, 103, 218, 38, 21, 82, 3, 135, 21, 185, 84, 248, 134], i2 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 148, 62, 134, 140, 92, 172, 141, 77, 35, 94, 181, 164, 65, 169, 65, 156, 154, 43, 221, 162, 11, 252, 67, 102, 113, 48, 136, 137, 219, 62, 43, 113, 239, 23, 126, 250, 186, 252, 10, 138, 218, 25, 193, 244, 74, 68, 194, 209, 107, 23, 52, 206, 199, 78, 72, 98, 103, 151, 71, 96, 62, 51, 210, 158, 72, 231, 158], n2 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 143, 233, 163, 51, 196, 98, 95, 151, 224, 22, 134, 33, 240, 150, 248, 67, 18, 34, 196, 142, 81, 238, 173, 140, 80, 205, 232, 132, 144, 67, 12, 131, 157, 4, 171, 243, 86, 122, 35, 6, 166, 184, 243, 85, 126, 13, 206, 103, 152, 62, 168, 160, 187, 2, 241, 138, 52, 211, 72, 121, 128, 151, 63, 147, 128, 19, 42], r2 = [18, 0, 50, 138, 1, 48, 192, 64, 253, 248, 65, 17, 67, 192, 32, 0, 16, 0, 0, 0, 0, 0, 0, 0, 195, 12, 48, 144, 64, 32, 0, 209, 75, 61, 9, 204, 25, 115, 79, 226, 115, 63, 63, 208, 70, 210, 220, 153, 126, 241, 237, 37, 107, 195, 153, 1, 99, 112, 230, 189, 209, 169, 130, 10, 11, 22, 167, 215, 159, 205, 197, 7, 183, 162, 26, 48, 254, 141, 134, 103, 32, 16, 235, 45, 1, 15, 18, 119, 169, 110, 206, 251, 51, 115, 202, 60, 148, 1, 46, 39, 109, 25, 28, 86, 168, 15, 77, 211, 239, 2, 58, 43, 146, 26, 230, 184, 81, 48, 140, 226, 226, 250, 222, 146, 171, 133, 164, 13, 188, 180, 64, 122, 142, 146, 32, 208, 238, 170, 193, 35, 53, 44, 225], o2 = [18, 0, 50, 107, 48, 0, 133, 125, 248, 65, 26, 195, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 204, 24, 122, 65, 56, 165, 18, 52, 206, 218, 4, 187, 51, 97, 9, 29, 191, 90, 253, 106, 185, 31, 197, 155, 52, 205, 245, 185, 203, 131, 20, 226, 25, 124, 95, 113, 220, 113, 141, 15, 15, 104, 211, 144, 152, 237, 150, 157, 127, 51, 143, 24, 231, 218, 171, 255, 176, 241, 128, 229, 149, 150, 148, 66, 245, 228, 91, 27, 182, 228, 136, 61, 182, 237, 133, 45, 220, 24, 103, 214, 152], s2 = [18, 0, 50, 122, 48, 1, 9, 253, 248, 65, 26, 67, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 198, 182, 231, 242, 220, 235, 163, 140, 12, 36, 36, 166, 46, 132, 210, 4, 71, 23, 218, 132, 27, 30, 17, 45, 244, 79, 31, 243, 195, 136, 100, 169, 76, 88, 142, 85, 204, 217, 121, 168, 29, 163, 198, 17, 251, 223, 73, 12, 212, 244, 139, 123, 151, 179, 75, 216, 96, 208, 136, 40, 229, 42, 59, 149, 10, 116, 228, 85, 99, 93, 221, 108, 255, 140, 248, 20, 30, 167, 122, 109, 206, 164, 108, 197, 110, 251, 23, 243, 133, 160, 63, 13, 207, 177, 12, 128], a2 = await new rp(((a3, c2) => {
          let d2;
          !(async function() {
            e2 && "closed" !== e2.state || await (async function() {
              e2 = new VideoDecoder({ output: (e3) => {
                e3.close(), clearTimeout(d2), a3(true);
              }, error: (e3) => {
                clearTimeout(d2), a3(false);
              } }), await e2.configure({ codec: "av01.0.05M.08", width: 160, height: 90 });
            })();
            const c3 = [t2, i2, n2, r2, o2, s2];
            for (let t3 = 0; t3 < c3.length; t3++) {
              const i3 = new EncodedVideoChunk({ type: 0 == t3 ? "key" : "delta", timestamp: 33333 * t3, duration: 33333, data: new Uint8Array(c3[t3]) });
              try {
                await e2.decode(i3);
              } catch (e3) {
                return void a3(false);
              }
            }
          })(), d2 = setTimeout((() => {
            a3(false);
          }), 5e3);
        }));
        return a2;
      }
      async function jB(e2, t2, i2, n2) {
        const r2 = (async function(e3, t3, i3, n3) {
          let r3 = null;
          const o2 = [], s2 = async () => {
            const r4 = CD("WEBCS_DOMAIN").slice(0, CD("AJAX_REQUEST_CONCURRENT")).map(((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: EB() }))), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map(((e4) => e4.url)) }), a3 = await xB({ fragementLength: CD("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (iP.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), OB(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
          }, a2 = async () => {
            if (await fN(1e3), null !== r3) return r3;
            const s3 = CD("WEBCS_DOMAIN_BACKUP_LIST").map(((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: EB() }))), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map(((e4) => e4.url)) }), c2 = await xB({ fragementLength: CD("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n4) => (iP.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), OB(n4, e3, t3, i3)), allFailedhandler: (e4) => {
              throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
            }, promisesCollector: o2 });
            return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
          };
          try {
            return r3 = await VB([s2(), a2()]), o2.length && o2.forEach(((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel())), r3;
          } catch (e4) {
            throw e4[0];
          }
        })(e2, t2, i2, n2);
        return { gatewayInfo: await r2 };
      }
      async function GB(e2, t2, i2, n2, r2) {
        const o2 = e2.cloudProxyServer;
        if ("disabled" === o2) {
          if (!n2) return;
          if (e2.useLocalAccessPoint) return await jB(e2, t2, i2, r2);
          if (CD("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: n3, proxyInfo: o3 } = await zB(e2, t2, i2, r2);
            if (e2.turnServer && "auto" !== e2.turnServer.mode) return { gatewayInfo: n3 };
            const a3 = o3.map(((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || ED.tcpport, udpport: e3.udpport || ED.udpport, username: e3.username || ED.username, password: e3.password || ED.password, forceturn: false, security: true })));
            if (r2.useP2P) {
              var s2;
              const t3 = null !== (s2 = e2.uid) && void 0 !== s2 ? s2 : n3.uid, i3 = "glb:".concat(t3.toString()), r3 = await OO(i3), c3 = o3.map(((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || ED.tcpport, udpport: e3.udpport || ED.udpport, username: i3, password: r3, forceturn: false, security: true })));
              a3.push(...c3);
            }
            return e2.turnServer = { mode: "manual", servers: a3 }, { gatewayInfo: n3 };
          }
          return await jB(e2, t2, i2, r2);
        }
        const { proxyInfo: a2, gatewayInfo: c2 } = await zB(e2, t2, i2, r2), d2 = { gatewayInfo: c2 }, l2 = a2.map(((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport ? e3.tcpport : ED.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport ? e3.udpport : ED.udpport, username: e3.username || ED.username, password: e3.password || ED.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 })));
        if (r2.useP2P) {
          var u2;
          const t3 = null !== (u2 = e2.uid) && void 0 !== u2 ? u2 : c2.uid, i3 = "glb:".concat(t3.toString()), n3 = await OO(i3), r3 = a2.map(((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport || ED.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport || ED.udpport, username: i3, password: n3, forceturn: "proxy4" !== o2, security: "proxy5" === o2 })));
          l2.push(...r3);
        }
        return e2.turnServer = { mode: "manual", servers: l2 }, iP.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), d2;
      }
      async function WB(e2, t2, i2, n2, r2) {
        const o2 = CD("ACCOUNT_REGISTER").slice(0, CD("AJAX_REQUEST_CONCURRENT"));
        let s2 = [];
        s2 = t2.proxyServer ? o2.map(((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1"))) : o2.map(((e3) => "https://".concat(e3, "/api/v1")));
        const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
        try {
          const o3 = await (async function(e3, t3, i3, n3, r3) {
            const o4 = Date.now(), s3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
            let a3 = e3[0];
            const c2 = await UN((() => _B(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } })), ((i4, n4) => {
              if (0 === i4.code) {
                if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32)) throw iP.error("Invalid Uint Uid ".concat(t3, " => ").concat(i4.uid), i4), lP.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: hO.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new uP(hO.INVALID_UINT_UID_FROM_STRING_UID);
                return lP.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: null, extend: s3 }), false;
              }
              const r4 = xx(i4.code);
              return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), lP.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
            }), ((t4, i4) => t4.code !== hO.OPERATION_ABORTED && (lP.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e3[(i4 + 1) % e3.length], true)), r3);
            if (0 !== c2.code) {
              const e4 = xx(c2.code);
              throw new uP(hO.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c2;
          })(s2, e2, t2, i2, n2);
          return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
        } catch (e3) {
          throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
        }
      }
      async function HB(e2, t2, i2) {
        const n2 = CD("ACCOUNT_REGISTER");
        let r2 = [];
        r2 = t2.proxyServer ? n2.map(((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1"))) : n2.map(((e3) => "https://".concat(e3, "/api/v1")));
        try {
          const n3 = await FB({ referenceList: r2, asyncMapHandler: (n4) => (async function(e3, t3, i3, n5) {
            const r3 = Date.now(), o2 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
            try {
              const t4 = await _B(e3 + "".concat(-1 === e3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o2, cancelToken: n5, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } });
              if (0 !== t4.code) {
                const e4 = xx(t4.code);
                throw new uP(hO.UNEXPECTED_RESPONSE, "preload sua error:".concat(e4.desc), e4);
              }
              if (t4.uid <= 0 || t4.uid >= Math.pow(2, 32)) throw new uP(hO.INVALID_UINT_UID_FROM_STRING_UID);
              return { requestTime: r3, url: e3, req: o2, uid: t4.uid, elapse: Date.now() - r3 };
            } catch (e4) {
              throw e4;
            }
          })(n4, e2, t2, i2), closeFn: (e3) => e3.code === hO.OPERATION_ABORTED || e3.code === hO.UNEXPECTED_RESPONSE && !e3.data.retry });
          return n3;
        } catch (e3) {
          throw e3;
        }
      }
      async function KB(e2, t2, i2) {
        const n2 = CD("CDS_AP").slice(0, CD("AJAX_REQUEST_CONCURRENT")).map(((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config"))), r2 = n2.map(((n3) => (function(e3, t3, i3, n4) {
          const r3 = Dw(), o3 = { flag: 64, cipher_method: 0, features: IB(IB(IB(IB(IB({ install_id: uD(), device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: hD, cname: t3.cname, session_id: t3.sid, proxyServer: t3.proxyServer, sdk_type: tF.WEB_RTC, browser_name: r3.name, browser_version: r3.version, user_agent: navigator.userAgent, channel_name: t3.cname }, t3.stringUid && { string_uid: t3.stringUid }), t3.uid && { uid: t3.uid + "" }), r3.os && { os_name: r3.os }), r3.osVersion && { os_version: r3.osVersion }), {}, { detail: "" }) };
          return UN((() => _B(e3, { data: o3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } })), void 0, ((e4) => e4.code !== hO.OPERATION_ABORTED), n4);
        })(n3, e2, t2, i2)));
        let o2 = null, s2 = null, a2 = {};
        try {
          o2 = await VB(r2);
        } catch (e3) {
          if (e3.code === hO.OPERATION_ABORTED) throw e3;
          s2 = e3;
        }
        r2.forEach(((e3) => e3.cancel()));
        if (lP.reportApiInvoke(e2.sid, { name: LO.REQUEST_CONFIG_DISTRIBUTE, options: { error: s2, res: o2 } }).onSuccess(), o2 && o2.test_tags) try {
          a2 = (function(e3) {
            if (!e3.test_tags) return {};
            const t3 = e3.test_tags, i3 = Object.keys(t3), n3 = {};
            return i3.forEach(((e4) => {
              var i4;
              const r3 = kg(i4 = e4.slice(4)).call(i4), o3 = JSON.parse(t3[e4]), s3 = o3[1];
              n3[r3] = { tag: o3[0] || "", value: s3 };
            })), n3;
          })(o2);
        } catch (e3) {
        }
        return a2;
      }
      async function YB(e2, t2) {
        const i2 = CD("WEBCS_DOMAIN").concat(CD("WEBCS_DOMAIN_BACKUP_LIST")).map(((e3) => ({ url: "https://".concat(e3, "/api/v2/transpond/webrtc?v=2"), areaCode: EB(), serviceIds: [iF.CHOOSE_SERVER, iF.CLOUD_PROXY_FALLBACK] })));
        try {
          const n2 = await FB({ referenceList: i2, asyncMapHandler: (i3) => (async function(e3, t3, i4) {
            let n3, { url: r2, areaCode: o2, serviceIds: s2 } = e3;
            const a2 = Date.now(), [c2, d2] = kB(t3, o2, s2);
            let l2 = QO.networkState;
            try {
              l2 && QO.networkState === KO.OFFLINE && QO.onlineWaiter && await rp.race([QO.onlineWaiter, fN(kN.maxRetryTimeout)]), l2 = QO.networkState;
              const { data: e4, headers: t4 } = await _B(r2, { data: c2, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
              n3 = "1" === t4.http3 ? 1 : -1;
              const o3 = (e5) => {
                const t5 = [];
                if (e5.response_body.forEach(((i5) => {
                  const n4 = i5.buffer.code;
                  if (23 === i5.uri && 0 === n4 && !i5.buffer.edges_services) if (4194310 === i5.buffer.flag) i5.buffer.edges_services = [];
                  else {
                    const n5 = { error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: CD("NO_EDGES_RETRY"), csIp: e5.detail[502] }), flag: i5.buffer.flag };
                    t5.push(n5);
                  }
                  if (0 !== n4) {
                    const r3 = xx(n4), o4 = { error: new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, r3.desc, { desc: r3.desc, retry: r3.retry, csIp: e5.detail[502] }), flag: i5.buffer.flag };
                    4194310 === i5.buffer.flag ? iP.warning(o4.error.toString()) : t5.push(o4);
                  }
                })), t5.length) throw new uP(hO.CAN_NOT_GET_GATEWAY_SERVER, t5.map(((e6) => "flag: ".concat(e6.flag, ", message: ").concat(e6.error.message))).join(" | "), { retry: !!t5.find(((e6) => e6.error.data.retry)), csIp: e5.detail[502], desc: [...new Set(t5.map(((e6) => {
                  var t6;
                  return null == e6 || null === (t6 = e6.error) || void 0 === t6 || null === (t6 = t6.data) || void 0 === t6 ? void 0 : t6.desc;
                })).filter(((e6) => !!e6)))] });
              };
              o3(e4);
              const s3 = hF(e4, iF.CHOOSE_SERVER), u2 = hF(e4, iF.CLOUD_PROXY_FALLBACK);
              return PB(s3), { gatewayInfo: cF(s3, r2), proxyInfo: u2, opid: d2, requestTime: a2, url: r2, isHttp3: n3, elapse: Date.now() - a2 };
            } catch (e4) {
              throw e4;
            }
          })(i3, e2, t2), closeFn: (e3) => e3.code === hO.OPERATION_ABORTED || e3.code === hO.CAN_NOT_GET_GATEWAY_SERVER && !e3.data.retry });
          return n2;
        } catch (e3) {
          throw e3;
        }
      }
      async function zB(e2, t2, i2, n2) {
        const r2 = CD("PROXY_SERVER_TYPE3"), o2 = (e3, t3, i3) => {
          let n3 = i3 || r2;
          return Array.isArray(n3) && (n3 = t3 % 2 == 0 && r2[1] || r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
        };
        let s2 = null;
        const a2 = [], c2 = async () => {
          const r3 = CD("WEBCS_DOMAIN").slice(0, CD("AJAX_REQUEST_CONCURRENT")).map(((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: EB(), serviceIds: [iF.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? iF.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK] };
          })), s3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map(((e3) => e3.url)) }), c3 = await xB({ fragementLength: CD("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (iP.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), NB(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
        }, d2 = async () => {
          if (await fN(1e3), null !== s2) return s2;
          const r3 = CD("WEBCS_DOMAIN_BACKUP_LIST").map(((t3, i3) => {
            let n3;
            return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: EB(), serviceIds: [iF.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? iF.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? iF.CLOUD_PROXY : iF.CLOUD_PROXY_FALLBACK] };
          })), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map(((e3) => e3.url)) }), d3 = await xB({ fragementLength: CD("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (iP.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), NB(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
          }, promisesCollector: a2 });
          return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
        };
        let l2, u2, h2;
        try {
          ({ gatewayInfo: l2, proxyInfo: u2, url: h2 } = await VB([c2(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a2.length && a2.forEach(((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel())), !l2 || !u2) throw new uP(hO.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h2, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h2) {
          const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h2)[1];
          Ln(r2).call(r2, t3) && (e2.proxyServer = t3, iP.setProxyServer(t3), lP.setProxyServer(t3));
        }
        return s2 = { gatewayInfo: l2, proxyInfo: await pF(u2, l2.uid) }, s2;
      }
      async function qB(e2, t2, i2) {
        const n2 = CD("UAP_AP").slice(0, CD("AJAX_REQUEST_CONCURRENT")).map(((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap"))), r2 = n2.map(((n3) => (function(e3, t3, i3, n4) {
          const r3 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: hD, cname: t3.cname, uid: t3.uid.toString(), requestId: wB, seq: wB };
          wB += 1;
          const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r3) };
          return UN((async () => {
            const t4 = await _B(e3, { data: o2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t4.code) {
              const e4 = new uP(hO.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
              throw iP.error(e4.toString()), e4;
            }
            const n5 = JSON.parse(t4.json_body);
            if (200 !== n5.code) {
              const e4 = new uP(hO.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
              throw iP.error(e4.toString()), e4;
            }
            if (!n5.servers || 0 === n5.servers.length) {
              const e4 = new uP(hO.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw iP.error(e4.toString()), e4;
            }
            return { vid: n5.vid, workerToken: n5.workerToken, addressList: (CD("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map(((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(CD("WORKER_DOMAIN"), ":").concat(e4.wss))) };
          }), void 0, ((e4) => !!(e4.code !== hO.OPERATION_ABORTED && e4.code !== hO.UNEXPECTED_RESPONSE || e4.data && e4.data.retry)), n4);
        })(n3, e2, t2, i2)));
        try {
          const e3 = await VB(r2);
          return r2.forEach(((e4) => e4.cancel())), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function XB(e2, t2, i2) {
        let n2 = null;
        const r2 = [], o2 = async (o3) => {
          const s2 = CD(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map(((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2")));
          return o3 && (await fN(1e3), null !== n2) ? n2 : await xB({ fragementLength: CD("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n3) => (iP.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n3), (function(e3, t3, i3, n4) {
            const [r3] = MB(t3, [iF.CHOOSE_SERVER]);
            let o4 = QO.networkState;
            return UN((async () => {
              o4 && QO.networkState === KO.OFFLINE && QO.onlineWaiter && await rp.race([QO.onlineWaiter, fN(n4 && n4.maxRetryTimeout || kN.maxRetryTimeout)]), o4 = QO.networkState;
              const t4 = await _B(e3, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return LB(t4, e3);
            }), (() => false), ((e4) => e4.code !== hO.OPERATION_ABORTED && (e4.code === hO.UPDATE_TICKET_FAILED ? e4.data.retry : (iP.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true))), n4);
          })(n3, e2, t2, i2)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: r2 });
        };
        try {
          return n2 = await VB([o2(false), o2(true)]), r2.length && r2.forEach(((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel())), n2;
        } catch (e3) {
          throw e3[0];
        }
      }
      function JB(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function QB(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? JB(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : JB(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class ZB extends NO {
        get isSuccess() {
          return !!this.configs;
        }
        constructor(e2, t2) {
          super(), iA(this, "configs", void 0), iA(this, "store", void 0), iA(this, "joinInfo", void 0), iA(this, "cancelToken", void 0), iA(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), iA(this, "interval", void 0), iA(this, "mutex", void 0), iA(this, "mutableParamsRead", false), iA(this, "configCache", {}), iA(this, "limit_bitrate", void 0), this.mutex = new PN("config-distribute", e2), this.store = t2;
        }
        startGetConfigDistribute(e2, t2) {
          this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), CD("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval((() => {
            this.updateConfigDistribute();
          }), CD("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0, this.configs = void 0, this.limit_bitrate = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked) return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            lP.reportApiInvoke(null, { options: void 0, name: LO.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: kO.TRACER }).onSuccess(JSON.stringify(yD));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void iP.debug("[config-distribute] get config distribute interrupted have no joininfo");
          let e2;
          const t2 = await this.mutex.lock();
          try {
            e2 = await KB(this.joinInfo, this.cancelToken, this.retryConfig), iP.debug("[config-distribute] get config distribute", JSON.stringify(e2));
            const i2 = (function(e3) {
              var t3;
              const i3 = Qp(t3 = Object.keys(e3).filter(((e4) => /^webrtc_ng_global_parameter/.test(e4)))).call(t3);
              for (let t4 = 0; t4 < i3.length; t4++) for (let n3 = i3.length - 1; n3 > t4; n3--) {
                const t5 = i3[n3], r3 = e3[t5].value;
                if ("number" == typeof r3.__priority) {
                  const o2 = r3.__priority, s2 = i3[n3 - 1], a2 = e3[s2].value;
                  if ("number" == typeof a2.__priority) {
                    if (!(o2 > a2.__priority)) continue;
                    {
                      const e4 = t5;
                      i3[n3] = i3[n3 - 1], i3[n3 - 1] = e4;
                    }
                  } else {
                    const e4 = t5;
                    i3[n3] = i3[n3 - 1], i3[n3 - 1] = e4;
                  }
                }
              }
              const n2 = Date.now(), r2 = {};
              return i3.forEach(((t4) => {
                const i4 = e3[t4].value.__expires;
                i4 && i4 <= n2 || (r2[t4] = e3[t4]);
              })), r2;
            })(e2);
            this.cacheGlobalParameterConfig(i2), this.store.hasStartJoinChannel || (this.store.isABTestSuccess = true), this.configs = i2;
          } catch (e3) {
            const t3 = new uP(hO.NETWORK_RESPONSE_ERROR, e3);
            iP.warning("[config-distribute] ".concat(t3.toString()));
          } finally {
            t2();
          }
        }
        getBitrateLimit() {
          return this.limit_bitrate || void 0;
        }
        handleBitrateLimit(e2) {
          _x(e2) && (this.limit_bitrate ? this.limit_bitrate && this.limit_bitrate.id !== e2.id && this.emit(px.UPDATE_BITRATE_LIMIT, e2) : this.emit(px.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.limit_bitrate && QB({}, this.limit_bitrate.low_stream_uplink);
        }
        handleABTestConfigDistribute(e2) {
          try {
            const t2 = {}, i2 = Object.keys(e2), n2 = [];
            i2.forEach(((i3) => {
              const r2 = e2[i3].value;
              t2[i3] = r2;
              const o2 = r2.__id;
              if (o2 && this.configCache[i3] && this.configCache[i3].__id === o2) return;
              const s2 = r2.__type, a2 = e2[i3].value, c2 = e2[i3].tag;
              let d2 = 0;
              s2 ? s2 === vD.REALTIME && (d2 = 1) : Object.keys(a2).some(((e3) => Object.prototype.hasOwnProperty.call(gD, e3) || !qU() && Object.prototype.hasOwnProperty.call(mD, e3) ? (d2 = 1, true) : void 0)), n2.push({ tag: c2, isApplied: d2, feature: i3, params: JSON.stringify(r2) });
            })), n2.forEach(((e3) => {
              let { tag: t3, feature: i3, params: n3, isApplied: r2 } = e3;
              this.store.sessionId && lP.abTest(this.store.sessionId, { intSucc: 1, isApplied: r2, tag: t3, feature: i3, params: n3, cid: this.store.cid, uid: this.store.intUid });
            })), this.configCache = t2;
          } catch (e3) {
            iP.debug("handleABTestConfigDistribute error", e3);
          }
        }
        cacheGlobalParameterConfig(e2) {
          const t2 = (function(e3) {
            const t3 = {};
            return Object.keys(e3).forEach(((i3) => {
              const n2 = e3[i3].value, r2 = n2.__expires, o2 = n2.__type;
              Object.keys(n2).forEach(((e4) => {
                "__id" === e4 || "__type" === e4 || "__priority" === e4 || "__expires" === e4 || Object.prototype.hasOwnProperty.call(t3, e4) || (t3[e4] = QB(QB({ value: n2[e4] }, r2 && { expires: r2 }), o2 && { type: o2 }));
              }));
            })), t3;
          })(e2);
          try {
            var i2;
            const n2 = null === (i2 = t2.LIMIT_BITRATE) || void 0 === i2 ? void 0 : i2.value;
            delete t2.LIMIT_BITRATE, n2 && _x(n2) && this.handleBitrateLimit(n2), this.limit_bitrate = n2, this.handleGlobalParameterConfig(t2), this.handleABTestConfigDistribute(e2), (function(e3) {
              try {
                const t3 = Date.now();
                Object.keys(e3).forEach(((i3) => {
                  const { value: n3, type: r3, expires: o3 } = e3[i3];
                  o3 && o3 <= t3 || ((r3 === vD.REALTIME || Object.prototype.hasOwnProperty.call(gD, i3)) && (yD[i3] = n3, TD[i3] = n3, iP.debug("Update realtime parameters from config distribute", i3, n3)), r3 || qU() || !Object.prototype.hasOwnProperty.call(mD, i3) || (yD[i3] = n3, TD[i3] = n3, iP.debug("Update gateway parameters from config distribute", i3, n3)));
                }));
              } catch (t3) {
                iP.error("Error update config immediately: ".concat(e3), t3.message);
              }
            })(t2);
            const r2 = JSON.stringify(t2), o2 = window.btoa(r2);
            window.localStorage.setItem("websdk_ng_global_parameter", o2), iP.debug("Caching global parameters ".concat(r2));
          } catch (e3) {
            iP.error("Error caching global parameters:", e3.message);
          }
        }
        handleGlobalParameterConfig(e2) {
          try {
            const t2 = Date.now();
            Object.keys(e2).forEach(((i2) => {
              switch (i2) {
                case "CLIENT_ROLE_OPTIONS":
                  if (Object.prototype.hasOwnProperty.call(TD, i2)) {
                    const { value: n3, expires: r2 } = e2[i2];
                    if (r2 && r2 <= t2) return;
                    bN(TD[i2], n3) || (yD[i2] = n3, TD[i2] = n3, this.emit(px.UPDATE_CLIENT_ROLE_OPTIONS, n3), iP.debug("Updating client role options: ".concat(JSON.stringify(n3))));
                  }
                  break;
                case "REMOTE_VIDEO_STREAM_TYPE":
                  if (Object.prototype.hasOwnProperty.call(TD, i2)) {
                    var n2;
                    const { value: r2, expires: o2 } = e2[i2];
                    if (o2 && o2 <= t2) return;
                    "number" == typeof r2 && Ln(n2 = [0, 1, 4, 5, 6, 7, 8, 9]).call(n2, r2) && (yD[i2] = { value: r2 }, TD[i2] = r2, this.emit(px.UPDATE_REMOTE_VIDEO_STREAM_TYPE, r2), iP.debug("Updating client remote stream type: ".concat(JSON.stringify(r2))));
                  }
                  break;
                case "ENABLE_FORCE_HLS":
                  if (Object.prototype.hasOwnProperty.call(TD, i2)) {
                    const { value: n3, expires: r2 } = e2[i2];
                    if (r2 && r2 <= t2) return;
                    bN(TD[i2], n3) || (yD[i2] = n3, TD[i2] = n3, this.emit(px.FALLBACK_TO_HLS, n3), iP.debug("Updating enable force hls: ".concat(JSON.stringify(n3))));
                  }
                  break;
                case "VOS_CONFIGURE":
                  if (Object.prototype.hasOwnProperty.call(TD, i2)) {
                    const { value: n3, expires: r2 } = e2[i2];
                    if (r2 && r2 <= t2) return;
                    bN(TD[i2], n3) || (yD[i2] = n3, TD[i2] = n3, this.emit(px.UPDATE_VOS_CONFIGURE, n3), iP.debug("Updating vos configure: ".concat(JSON.stringify(n3))));
                  }
              }
            }));
          } catch (e3) {
            iP.error("Error handling global parameter config:", e3.message);
          }
        }
      }
      class $B extends NO {
        constructor() {
          super(...arguments), iA(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t2, i2) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i2, t2));
        }
        setLocalVideoStats(e2, t2, i2) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i2)), !t2.muted && this.record("VIDEO_ENCODE_FAILED", e2, this.checResolutionSent(i2));
        }
        setRemoteAudioStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t2));
        }
        setRemoteVideoStats(e2, t2) {
          const i2 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t2));
        }
        record(e2, t2, i2) {
          if (CD("STATS_UPDATE_INTERVAL") > 500) return;
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const n2 = this.resultStorage.get(e2);
          if (!n2) return;
          n2.result.push(i2);
          const r2 = "VIDEO_ENCODE_FAILED" === e2 ? CD("ENCODE_EXCEPTION_TIMES") : 5;
          if (n2.result.length >= r2) {
            var o2;
            const i3 = Ln(o2 = n2.result).call(o2, true);
            n2.isPrevNormal && !i3 && this.emit("exception", ej[e2], e2, t2), !n2.isPrevNormal && i3 && this.emit("exception", ej[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i3, n2.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
        }
        checkAudioInputLevel(e2, t2) {
          return t2 instanceof Wk && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
        }
        checkFramerateInput(e2, t2) {
          let i2 = null;
          t2._encoderConfig && t2._encoderConfig.frameRate && (i2 = dF(t2._encoderConfig.frameRate));
          const n2 = e2.captureFrameRate;
          return !i2 || !n2 || !(i2 > 10 && n2 < 5 || i2 < 10 && i2 >= 5 && n2 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checResolutionSent(e2) {
          var t2;
          return !(!e2.codecType || Ln(t2 = CD("ENCODE_EXCEPTION_VALIDATE_CODEC")).call(t2, e2.codecType.toLocaleLowerCase())) || (!e2.captureFrameRate || 0 !== e2.sendFrameRate || 0 !== e2.sendResolutionWidth || 0 !== e2.sendResolutionHeight);
        }
        checkSendVideoBitrate(e2, t2) {
          return !!t2.muted || 0 !== e2.sendBitrate;
        }
        checkSendAudioBitrate(e2, t2) {
          return t2 instanceof Wk && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
        }
        checkVideoDecode(e2) {
          return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
        }
      }
      const ej = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003, VIDEO_ENCODE_FAILED: 2004 };
      const tj = new class {
        markSubscribeStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        }
        markPublishStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        }
        measureFromSubscribeStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t2) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function ij(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function nj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ij(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ij(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class rj {
        constructor(e2) {
          iA(this, "store", void 0), iA(this, "onStatsException", void 0), iA(this, "onUploadPublishDuration", void 0), iA(this, "onStatsChanged", void 0), iA(this, "onVideoCodecChanged", void 0), iA(this, "localStats", /* @__PURE__ */ new Map()), iA(this, "remoteStats", /* @__PURE__ */ new Map()), iA(this, "updateStatsInterval", void 0), iA(this, "trafficStats", void 0), iA(this, "trafficStatsPeerList", []), iA(this, "uplinkStats", void 0), iA(this, "exceptionMonitor", void 0), iA(this, "p2pChannel", void 0), iA(this, "scalabilityMode", iD.L1T1), iA(this, "updateStats", (() => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          })), this.store = e2, this.exceptionMonitor = new $B(), this.exceptionMonitor.on("exception", ((e3, t2, i2) => {
            this.onStatsException && this.onStatsException(e3, t2, i2);
          }));
        }
        startUpdateStats() {
          this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
        }
        stopUpdateStats() {
          this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(Rx.LocalAudioTrack) || nj({}, YP);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(Rx.LocalVideoTrack) || nj({}, zP);
        }
        getRemoteAudioTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats) return t3;
            const i3 = this.trafficStats.peer_delay.find(((t4) => t4.peer_uid === e3));
            return i3 && (t3.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach(((e3) => {
            let [n3, { audioStats: r2 }] = e3;
            r2 && (i2[n3] = t2(n3, r2));
          }));
          return i2;
        }
        getRemoteNetworkQualityStats(e2) {
          const t2 = {};
          if (e2) {
            var i2;
            const n2 = null === (i2 = this.remoteStats.get(e2)) || void 0 === i2 ? void 0 : i2.networkStats;
            n2 && (t2[e2] = n2);
          } else Array.from(this.remoteStats.entries()).forEach(((e3) => {
            let [i3, { networkStats: n2 }] = e3;
            n2 && (t2[i3] = n2);
          }));
          return t2;
        }
        getNetworkQuality() {
          let e2 = 0, t2 = 0;
          return this.trafficStats && (e2 = uF(this.trafficStats.B_unq), t2 = uF(this.trafficStats.B_dnq)), { uplinkNetworkQuality: e2, downlinkNetworkQuality: t2 };
        }
        getRemoteVideoTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats) return t3;
            const i3 = this.trafficStats.peer_delay.find(((t4) => t4.peer_uid === e3));
            return i3 && (t3.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
          }, i2 = {};
          if (e2) {
            var n2;
            const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
            r2 && (i2[e2] = t2(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach(((e3) => {
            let [n3, { videoStats: r2 }] = e3;
            r2 && (i2[n3] = t2(n3, r2));
          }));
          return i2;
        }
        getRTCStats() {
          let e2 = 0, t2 = 0, i2 = 0, n2 = 0;
          const r2 = this.localStats.get(Rx.LocalAudioTrack);
          r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
          const o2 = this.localStats.get(Rx.LocalVideoTrack);
          o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate);
          const s2 = this.localStats.get(Rx.LocalVideoLowTrack);
          s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach(((e3) => {
            let { audioStats: t3, videoStats: r3 } = e3;
            t3 && (i2 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i2 += r3.receiveBytes, n2 += r3.receiveBitrate);
          }));
          let a2 = 1;
          return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i2, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter(((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd));
          e2.peer_delay.filter(((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid))).forEach(((e3) => {
            var t2;
            const i2 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i2 && i2.videoSSRC ? tj.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? tj.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
            void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
          })), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && iP.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t2, i2) {
          if (!e2) return false;
          const n2 = !!i2 && t2.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t2.framesDecodeCount > i2.framesDecodeCount;
          return n2 || !r2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach(((t2) => {
            let [i2, n2] = t2;
            switch (i2) {
              case Rx.LocalVideoTrack:
              case Rx.LocalVideoLowTrack: {
                const t3 = n2, s2 = nj({}, zP), a2 = e2.getStats(), c2 = e2.getLocalMedia(i2);
                if (a2) {
                  const i3 = a2.videoSend.find(((e3) => e3.ssrc === (null == c2 ? void 0 : c2.ssrcs[0].ssrcId)));
                  if (i3) {
                    const n3 = e2.getLocalVideoSize(), o3 = e2.getEncoderConfig(Rx.LocalVideoTrack);
                    var r2;
                    if ("H264" === i3.codec || "H265" === i3.codec || "VP8" === i3.codec || "VP9" === i3.codec || "AV1X" === i3.codec || "AV1" === i3.codec) {
                      if (s2.codecType = i3.codec, (null == t3 ? void 0 : t3.codecType) !== i3.codec) null === (r2 = this.onVideoCodecChanged) || void 0 === r2 || r2.call(this, i3.codec.toLocaleLowerCase());
                    }
                    s2.sendBytes = i3.bytes, s2.sendBitrate = t3 ? 8 * Math.max(0, s2.sendBytes - t3.sendBytes) : 0, i3.inputFrame ? (s2.captureFrameRate = i3.inputFrame.frameRate, s2.captureResolutionHeight = i3.inputFrame.height, s2.captureResolutionWidth = i3.inputFrame.width) : n3 && (s2.captureResolutionWidth = n3.width, s2.captureResolutionHeight = n3.height), i3.sentFrame ? (s2.sendFrameRate = i3.sentFrame.frameRate, s2.sendResolutionHeight = i3.sentFrame.height, s2.sendResolutionWidth = i3.sentFrame.width) : n3 && (s2.sendResolutionWidth = n3.width, s2.sendResolutionHeight = n3.height), i3.avgEncodeMs && (s2.encodeDelay = i3.avgEncodeMs), o3 && o3.bitrateMax ? s2.targetSendBitrate = 1e3 * o3.bitrateMax : i3.targetBitrate && (s2.targetSendBitrate = i3.targetBitrate), s2.sendPackets = i3.packets, s2.sendPacketsLost = i3.packetsLost, s2.sendJitterMs = i3.jitterMs, s2.sendRttMs = i3.rttMs, s2.totalDuration = t3 ? t3.totalDuration + 1 : 1, s2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (s2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (iP.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
                  }
                  this.trafficStats && (s2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
                }
                var o2;
                if (this.localStats.set(i2, s2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== s2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== s2.sendResolutionHeight) null === (o2 = this.onStatsChanged) || void 0 === o2 || o2.call(this, "resolution", { width: s2.sendResolutionWidth, height: s2.sendResolutionHeight });
                s2 && c2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, c2.track, s2);
                break;
              }
              case Rx.LocalAudioTrack: {
                const t3 = n2, r3 = nj({}, YP), o3 = e2.getStats(), s2 = e2.getLocalMedia(i2);
                if (o3) {
                  const i3 = o3.audioSend.find(((e3) => e3.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId)));
                  if (i3) {
                    if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel) r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
                    else {
                      const t4 = e2.getLocalAudioVolume();
                      t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                    }
                    r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendJitterMs = i3.jitterMs, r3.sendRttMs = i3.rttMs, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                  }
                }
                this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(Rx.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
                break;
              }
            }
          }));
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach(((t2) => {
            var i2, n2;
            let [r2, { videoStats: o2, audioStats: s2, videoPcStats: a2 }] = t2;
            const c2 = s2, d2 = o2, l2 = a2, u2 = nj({}, qP), h2 = nj({}, JP), p2 = nj({}, XP), { audioTrack: _2, videoTrack: E2, audioSSRC: m2, videoSSRC: f2 } = e2.getRemoteMedia(r2);
            let S2;
            S2 = this.store.useP2P ? e2.getStats(true) : e2.getStats();
            const g2 = null === (i2 = S2) || void 0 === i2 ? void 0 : i2.audioRecv.find(((e3) => e3.ssrc === m2)), T2 = null === (n2 = S2) || void 0 === n2 ? void 0 : n2.videoRecv.find(((e3) => e3.ssrc === f2)), R2 = this.trafficStats && this.trafficStats.peer_delay.find(((e3) => e3.peer_uid === r2));
            if (g2 && ("opus" !== g2.codec && "aac" !== g2.codec && "PCMU" !== g2.codec && "PCMA" !== g2.codec && "G722" !== g2.codec || (u2.codecType = g2.codec), g2.outputLevel ? u2.receiveLevel = Math.round(32767 * g2.outputLevel) : _2 && (u2.receiveLevel = Math.round(32767 * _2.getVolumeLevel())), u2.receiveBytes = g2.bytes, u2.receivePackets = g2.packets, u2.receivePacketsLost = g2.packetsLost, u2.receivePacketsDiscarded = g2.packetsDiscarded, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.receiveBitrate = c2 ? 8 * Math.max(0, u2.receiveBytes - c2.receiveBytes) : 0, u2.totalDuration = c2 ? c2.totalDuration + 1 : 1, u2.totalFreezeTime = c2 ? c2.totalFreezeTime : 0, u2.freezeRate = u2.totalFreezeTime / u2.totalDuration, u2.receiveDelay = g2.jitterBufferMs, u2.totalDuration > 10 && rj.isRemoteAudioFreeze(_2) && (u2.totalFreezeTime += 1)), T2) {
              var C2;
              "H264" !== T2.codec && "H265" !== T2.codec && "VP8" !== T2.codec && "VP9" !== T2.codec && "AV1X" !== T2.codec && "AV1" !== T2.codec || (h2.codecType = T2.codec), h2.receiveBytes = T2.bytes, h2.receiveBitrate = d2 ? 8 * Math.max(0, h2.receiveBytes - d2.receiveBytes) : 0, h2.decodeFrameRate = T2.decodeFrameRate < 0 ? 0 : T2.decodeFrameRate, h2.renderFrameRate = T2.decodeFrameRate < 0 ? 0 : T2.decodeFrameRate, T2.outputFrame && (h2.renderFrameRate = T2.outputFrame.frameRate), T2.receivedFrame ? (h2.receiveFrameRate = T2.receivedFrame.frameRate, h2.receiveResolutionHeight = T2.receivedFrame.height, h2.receiveResolutionWidth = T2.receivedFrame.width) : E2 && (h2.receiveResolutionHeight = E2._videoHeight || 0, h2.receiveResolutionWidth = E2._videoWidth || 0), void 0 !== T2.framesRateFirefox && (h2.receiveFrameRate = Math.round(T2.framesRateFirefox)), h2.receivePackets = T2.packets, h2.receivePacketsLost = T2.packetsLost, h2.packetLossRate = h2.receivePacketsLost / (h2.receivePackets + h2.receivePacketsLost);
              const t3 = d2 ? d2.totalFreezeTime : 0, i3 = d2 ? d2.totalDuration : 0;
              h2.totalDuration = d2 ? d2.totalDuration + 1 : 1, h2.totalFreezeTime = null !== (C2 = T2.totalFreezesDuration) && void 0 !== C2 ? C2 : t3 || 0, h2.receiveDelay = T2.jitterBufferMs || 0;
              const n3 = !!f2 && e2.getRemoteVideoIsReady(f2);
              void 0 === T2.totalFreezesDuration && E2 && n3 && rj.isRemoteVideoFreeze(E2, T2, l2) && (h2.totalFreezeTime += 1), h2.freezeRate = Math.max(0, Math.min((h2.totalFreezeTime - t3) / (h2.totalDuration - i3), 1));
            }
            R2 && (u2.end2EndDelay = R2.B_ad, h2.end2EndDelay = R2.B_vd, u2.transportDelay = R2.B_ed, h2.transportDelay = R2.B_ed, u2.currentPacketLossRate = R2.B_ealr4 / 100, h2.currentPacketLossRate = R2.B_evlr4 / 100, p2.uplinkNetworkQuality = R2.B_punq ? R2.B_punq : 0, p2.downlinkNetworkQuality = R2.B_pdnq ? R2.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: u2, videoStats: h2, videoPcStats: T2, networkStats: p2 }), _2 && this.exceptionMonitor.setRemoteAudioStats(_2, u2), E2 && this.exceptionMonitor.setRemoteVideoStats(E2, h2);
          }));
        }
      }
      class oj {
        constructor() {
          iA(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), iA(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          ex(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          ex(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          HV(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function sj(e2) {
        if (!(e2 instanceof oj)) {
          return new uP(hO.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t2 = e2.getSrcChannelMediaInfo(), i2 = e2.getDestChannelMediaInfo();
        if (!t2) {
          return new uP(hO.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i2.size) {
          return new uP(hO.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class aj {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
        }
        get dataChannels() {
          return this._dataChannels;
        }
        constructor(e2, t2) {
          iA(this, "uid", void 0), iA(this, "_uintid", void 0), iA(this, "_trust_in_room_", true), iA(this, "_trust_audio_enabled_state_", true), iA(this, "_trust_video_enabled_state_", true), iA(this, "_trust_audio_mute_state_", true), iA(this, "_trust_video_mute_state_", true), iA(this, "_audio_muted_", false), iA(this, "_video_muted_", false), iA(this, "_audio_enabled_", true), iA(this, "_video_enabled_", true), iA(this, "_audio_added_", false), iA(this, "_video_added_", false), iA(this, "_is_pre_created", false), iA(this, "_video_pre_subscribed", false), iA(this, "_audio_pre_subscribed", false), iA(this, "_trust_video_stream_added_state_", true), iA(this, "_trust_audio_stream_added_state_", true), iA(this, "_audioTrack", void 0), iA(this, "_videoTrack", void 0), iA(this, "_dataChannels", []), iA(this, "_audioSSRC", void 0), iA(this, "_videoSSRC", void 0), iA(this, "_audioOrtc", void 0), iA(this, "_videoOrtc", void 0), iA(this, "_cname", void 0), iA(this, "_rtxSsrcId", void 0), iA(this, "_videoMid", void 0), iA(this, "_audioMid", void 0), this.uid = e2, this._uintid = t2;
        }
      }
      function cj(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function dj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? cj(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : cj(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const lj = (e2) => "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1 2\na=msid-semantic: WMS\na=ice-lite".concat(e2 ? "\na=extmap-allow-mixed" : "", "\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:2\n"), uj = "9", hj = 2e4, pj = 4e4;
      let _j = class {
        get localCapabilities() {
          return sN(this._localCapabilities);
        }
        get rtpCapabilities() {
          return sN(this._rtpCapabilities);
        }
        get candidates() {
          return sN(this._candidates);
        }
        get iceParameters() {
          return sN(this._iceParameters);
        }
        get dtlsParameters() {
          return sN(this._dtlsParameters);
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          iA(this, "sessionDesc", void 0), iA(this, "_localCapabilities", void 0), iA(this, "_rtpCapabilities", void 0), iA(this, "_candidates", void 0), iA(this, "_originCandidates", void 0), iA(this, "_iceParameters", void 0), iA(this, "_isUseExtmapAllowMixed", void 0), iA(this, "_isUseLocalCodecs", void 0), iA(this, "_isUseDataChannel", void 0), iA(this, "_dtlsParameters", void 0), iA(this, "setup", void 0), iA(this, "currentMidIndex", void 0), iA(this, "cname", void 0), iA(this, "useLocalCodecsMids", []), iA(this, "preloadSsrcs", []), iA(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), this._isUseExtmapAllowMixed = t2, this._isUseLocalCodecs = i2, this._isUseDataChannel = n2, e2 = sN(e2);
          const { iceParameters: r2, dtlsParameters: o2, candidates: s2, rtpCapabilities: a2, setup: c2, localCapabilities: d2, cname: l2 } = e2;
          this._rtpCapabilities = a2, this._candidates = s2, this._originCandidates = sN(s2), this._iceParameters = r2, this._dtlsParameters = o2, this._localCapabilities = d2, this.setup = c2, this.cname = l2, [this.sessionDesc] = this.updateRemoteRTPCapabilities(a2), this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1;
        }
        checkPreloadSsrcs(e2) {
          return e2.length === this.preloadSsrcs.length && e2.every(((e3) => {
            var t2;
            return Ln(t2 = this.preloadSsrcs).call(t2, e3);
          }));
        }
        preloadRemoteMedia(e2) {
          let t2 = 0;
          const i2 = [], n2 = [];
          for (; e2 > 0; ) {
            const r2 = [dj({ ssrcId: pj + t2 }, CD("USE_SUB_RTX") ? { rtx: pj + t2 + 1 } : {})], o2 = "".concat(pj + t2, "_").concat(hj + t2), { ssrcs: s2, ssrcGroups: a2 } = LF(r2, this.cname, CD("SYNC_GROUP") ? o2 : void 0), c2 = this.preCreateOrRecycleSendMedia("video", s2, a2, void 0), d2 = [{ ssrcId: hj + t2 }], l2 = "".concat(pj + t2, "_").concat(hj + t2), { ssrcs: u2, ssrcGroups: h2 } = LF(d2, this.cname, CD("SYNC_GROUP") ? l2 : void 0), p2 = this.preCreateOrRecycleSendMedia("audio", u2, h2, void 0);
            e2--, t2 += 2, i2.push(c2, p2), n2.push(s2[0].ssrcId, u2[0].ssrcId);
          }
          return this.useLocalCodecsMids.push(...i2), this.preloadSsrcs = n2, { mids: i2, preSSRCs: n2, isAvailable: true };
        }
        preCreateOrRecycleSendMedia(e2, t2, i2, n2) {
          const r2 = this.rtpCapabilities.send.videoCodecs, o2 = this._isUseLocalCodecs || 0 === r2.length ? this.localCapabilities.recv : this.rtpCapabilities.send;
          iP.debug("create or recycle send media without remote rtp capabilities, ssrcs ", t2[0].ssrcId);
          const s2 = e2 === fx.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === fx.VIDEO ? o2.videoExtensions : o2.audioExtensions;
          this.currentMidIndex += 1;
          const c2 = "".concat(this.currentMidIndex);
          let d2 = { media: { mediaType: e2, port: uj, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map(((e3) => e3.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
          return d2 = this.mungSendMediaDesc(d2, n2), this.sessionDesc.mediaDescriptions.push(d2), this.updateBundleMids(), c2;
        }
        toString() {
          return kD(this.sessionDesc);
        }
        send(e2, t2, i2, n2) {
          const { ssrcs: r2, ssrcGroups: o2 } = LF(t2, this.cname, CD("SYNC_GROUP") ? i2 : void 0), s2 = this.findPreloadMediaDesc(r2);
          if (s2) {
            if (Bw() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, r2);
            let i3;
            return -1 === t3 || 1 === t3 && (Vw() || (function() {
              const e3 = Dw();
              return !(e3.name !== bw.CHROME || !e3.osVersion) && Number(e3.version) <= 90;
            })() || Gw(143) || Kw(143) || CD("RESERVE_MID_1_MLINE") || CD("ENABLE_ENCODED_TRANSFORM") && Uw()) || 0 === t3 && !(function(e3) {
              const t4 = Dw();
              return !(t4.name !== bw.FIREFOX || !t4.osVersion) && Number(t4.version) === e3;
            })(138) && CD("USE_SUB_RTX") || Zw() ? (i3 = this.createOrRecycleSendMedia(e2, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i3 = sN(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), Bw() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
          }
        }
        sendDataChannel() {
          const { mediaDesc: e2, needExchangeSDP: t2 } = this.createOrRecycleDataChannel();
          return this.updateBundleMids(), { mid: e2.attributes.mid, needExchangeSDP: t2 };
        }
        batchSend(e2) {
          const t2 = e2.map(((e3) => {
            let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e3;
            return this.send(t3, i3, n3);
          })), i2 = [];
          let n2 = false;
          return t2.forEach(((e3) => {
            let { mid: t3, needExchangeSDP: r2 } = e3;
            r2 && (n2 = true), i2.push(t3);
          })), { mids: i2, needExchangeSDP: n2 };
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid)));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach(((e3) => {
            "0" === e3.attributes.mid || Bw() || Zw() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
          })), this.updateBundleMids();
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find(((t3) => t3.attributes.mid === e2));
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find(((t3) => t3.attributes.mid === e2));
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => Ln(e2).call(e2, t3.attributes.mid || "")));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach(((e3) => {
            e3.attributes.direction = "inactive";
          }));
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => Ln(e2).call(e2, t3.attributes.mid || "")));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach(((e3) => {
            e3.attributes.direction = "recvonly";
          }));
        }
        receive(e2, t2, i2, n2) {
          e2.forEach(((e3, r2) => {
            this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2, n2[r2]);
          })), this.updateBundleMids();
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => -1 !== e2.indexOf(t3.attributes.mid)));
          if (t2.length !== e2.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach(((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          })), this.updateBundleMids();
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = this.sessionDesc || LD((i2 = this._isUseExtmapAllowMixed, this._isUseDataChannel ? lj(i2) : "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite".concat(i2 ? "\na=extmap-allow-mixed" : "", "\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n")));
          var i2;
          this._rtpCapabilities = e2;
          let n2 = false;
          const r2 = this.rtpCapabilities.send, o2 = this.localCapabilities.send, s2 = this.localCapabilities.recv, a2 = s2.videoCodecs, c2 = s2.audioCodecs, d2 = s2.videoExtensions, l2 = s2.audioExtensions;
          for (const e3 of t2.mediaDescriptions) {
            var u2;
            if ("sendonly" !== e3.attributes.direction || "string" != typeof e3.attributes.mid || !Ln(u2 = this.useLocalCodecsMids).call(u2, e3.attributes.mid)) {
              if (n2 = true, e3.attributes.iceUfrag = this._iceParameters.iceUfrag, e3.attributes.icePwd = this._iceParameters.icePwd, e3.attributes.fingerprints = this._dtlsParameters.fingerprints, e3.attributes.candidates = this._candidates, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType) if (this._isUseLocalCodecs && "sendonly" === e3.attributes.direction) {
                var h2;
                e3.media.fmts = a2.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = a2, e3.attributes.extmaps = d2;
                const t3 = e3.attributes.mid;
                "string" != typeof t3 || Ln(h2 = this.useLocalCodecsMids).call(h2, t3) || this.useLocalCodecsMids.push(t3);
              } else if (0 === r2.videoCodecs.length) {
                const t3 = o2.videoCodecs.filter(((e4) => {
                  var t4, i3;
                  return null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : Ln(i3 = t4.encodingName.toLowerCase()).call(i3, "vp8");
                }));
                0 === t3.length && t3.push(o2.videoCodecs[0]), e3.media.fmts = t3.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = t3, e3.attributes.extmaps = [];
              } else e3.media.fmts = r2.videoCodecs.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = r2.videoCodecs, e3.attributes.extmaps = r2.videoExtensions;
              if ("audio" === e3.media.mediaType) if (this._isUseLocalCodecs && "sendonly" === e3.attributes.direction) {
                var p2;
                e3.media.fmts = c2.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = c2, e3.attributes.extmaps = l2;
                const t3 = e3.attributes.mid;
                "string" != typeof t3 || Ln(p2 = this.useLocalCodecsMids).call(p2, t3) || this.useLocalCodecsMids.push(t3);
              } else if (0 === r2.audioCodecs.length) {
                const t3 = o2.audioCodecs.filter(((e4) => {
                  var t4, i3;
                  return null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : Ln(i3 = t4.encodingName.toLowerCase()).call(i3, "opus");
                })) || [o2.audioCodecs[0]];
                e3.media.fmts = t3.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = t3, e3.attributes.extmaps = [];
              } else e3.media.fmts = r2.audioCodecs.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = r2.audioCodecs, e3.attributes.extmaps = r2.audioExtensions, KF(e3);
            }
          }
          return this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1, [this.sessionDesc, n2];
        }
        updateCandidates(e2) {
          const t2 = this._originCandidates.filter(((e3) => "udp" === e3.transport)), i2 = [];
          if (t2.forEach(((e3) => {
            i2.push(dj(dj({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          })), 0 !== t2.length) {
            switch (e2) {
              case Sx.TCP_RELAY:
                this._candidates = i2;
                break;
              case Sx.UDP_TCP_RELAY:
              case Sx.RELAY:
                this._candidates = [...t2, ...i2];
                break;
              default:
                this._candidates = t2;
            }
            for (const e3 of this.sessionDesc.mediaDescriptions) e3.attributes.candidates = this.candidates;
          }
        }
        restartICE(e2) {
          e2 = sN(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach(((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          }));
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        findAvailableMediaIndex(e2, t2) {
          return this.sessionDesc.mediaDescriptions.findIndex(((i2) => {
            const n2 = i2.media.mediaType === e2 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
            if (Bw()) {
              if (n2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e3 || e3 !== i2.attributes.mid);
              }
              return false;
            }
            return n2;
          }));
        }
        createOrRecycleDataChannel() {
          for (const e3 of this.sessionDesc.mediaDescriptions) if ("application" === e3.media.mediaType) return { mediaDesc: e3, needExchangeSDP: false };
          this.currentMidIndex += 1;
          const e2 = "".concat(this.currentMidIndex), t2 = { media: { mediaType: "application", port: uj, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e2), sctpPort: "5000" } };
          return this.sessionDesc.mediaDescriptions.push(t2), { mediaDesc: t2, needExchangeSDP: true };
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2, o2) {
          const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = YF(s2, a2, this.localCapabilities.send, s2 === fx.VIDEO ? n2 : r2), d2 = s2 === fx.VIDEO ? a2.videoExtensions : a2.audioExtensions;
          this.currentMidIndex += 1;
          const l2 = "".concat(this.currentMidIndex);
          let u2 = { media: { mediaType: s2, port: uj, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c2.map(((e3) => e3.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
          u2 = this.mungRecvMediaDsec(u2, e2, o2);
          const h2 = this.findFirstClosedMedia(s2);
          if (h2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(h2);
            this.sessionDesc.mediaDescriptions[e3] = u2;
          } else this.sessionDesc.mediaDescriptions.push(u2);
          return u2;
        }
        updateRemoteDtlsParameters(e2) {
          const t2 = new Set(this._dtlsParameters.fingerprints.map(((e3) => e3.fingerprint))), i2 = new Set(e2.map(((e3) => e3.fingerprint)));
          let n2 = false;
          t2.size !== i2.size && (n2 = true);
          for (const e3 of t2) i2.has(e3) || (n2 = true);
          return n2;
        }
        updateRemoteCodec(e2, t2, i2) {
          const n2 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map(((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "")).filter(((e3) => {
            var t3;
            return Ln(t3 = Object.keys(AD)).call(t3, e3);
          })))], r2 = new Set(t2);
          if (n2.every(((e3) => r2.has(e3)))) return iP.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t2)), false;
          const o2 = this._rtpCapabilities.recv.videoCodecs.filter(((e3) => t2.some(((t3) => {
            var i3;
            return Ln(i3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(i3, t3);
          }))));
          if (0 === o2.length) return iP.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n2, " codecs: ").concat(t2)), false;
          const s2 = [...new Set(o2.map(((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "")))];
          let a2;
          if (iP.debug("updateRemoteCodec, from ".concat(n2, " to ").concat(s2)), 0 === e2.length) a2 = this.sessionDesc.mediaDescriptions.filter(((e3) => "video" === e3.media.mediaType && "recvonly" === e3.attributes.direction));
          else if (a2 = this.sessionDesc.mediaDescriptions.filter(((t3) => t3.attributes.mid && "video" === t3.media.mediaType && Ln(e2).call(e2, t3.attributes.mid) && "recvonly" === t3.attributes.direction)), a2.length !== e2.length) return iP.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e2, ", codecs: ").concat(t2)), false;
          if (CD("USE_PUB_RTX") || CD("USE_SUB_RTX")) {
            const e3 = zF(o2, this.rtpCapabilities.recv.videoCodecs);
            o2.push(...e3);
          }
          this._rtpCapabilities.recv.videoCodecs = o2;
          const c2 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = YF(fx.VIDEO, d2, c2, i2);
          return a2.forEach(((e3) => {
            const t3 = l2.map(((e4) => e4.payloadType.toString(10)));
            iP.debug("updateRemoteCodec mid: ".concat(e3.attributes.mid, ", from"), e3.attributes.payloads, "to", l2), e3.attributes.payloads = l2, e3.media.fmts = t3;
          })), iP.debug("updateRemoteCodec success, mids: ".concat(e2, ", codecs: ").concat(t2, ", remote recv: ").concat(this._rtpCapabilities.recv.videoCodecs.length, ", remote send: ").concat(this._rtpCapabilities.send.videoCodecs.length)), true;
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2) {
          const o2 = this.rtpCapabilities.send.videoCodecs, s2 = this._isUseLocalCodecs || 0 === o2.length ? this.localCapabilities.recv : this.rtpCapabilities.send, a2 = e2 === fx.VIDEO ? s2.videoCodecs : s2.audioCodecs, c2 = e2 === fx.VIDEO ? s2.videoExtensions : s2.audioExtensions;
          this.currentMidIndex += 1;
          const d2 = "".concat(this.currentMidIndex);
          let l2 = { media: { mediaType: e2, port: uj, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map(((e3) => e3.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
          l2 = this.mungSendMediaDesc(l2, r2);
          const u2 = this.findFirstClosedMedia(e2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = l2;
          } else this.sessionDesc.mediaDescriptions.push(l2);
          return l2;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(((e2) => "0" !== e2.media.port)).map(((e2) => e2.attributes.mid));
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = sN(e2);
          return MF(n2), kF(n2, t2), UF(n2, t2), VF(n2), xF(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = sN(e2);
          return i2.attributes && i2.attributes.payloads && Array.isArray(i2.attributes.payloads) && i2.attributes.payloads.length > 0 && i2.attributes.payloads.forEach(((e3) => {
            e3.rtpMap && "h264" === e3.rtpMap.encodingName.toLocaleLowerCase() && CD("ENABLE_DOWN_SPS_PPS") && (e3.fmtp && e3.fmtp.parameters || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["sps-pps-idr-in-keyframe"] = "1");
          })), xF(i2, t2, this.localCapabilities.recv), KF(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex(((t3) => t3.attributes.mid === e2));
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find(((t2) => Bw() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port));
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find(((t2) => {
            var i2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          }));
        }
        getSSRC(e2) {
          var t2;
          return null === (t2 = this.sessionDesc.mediaDescriptions.find(((t3) => t3.attributes.mid === e2))) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
        }
      };
      function Ej(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function mj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Ej(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Ej(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      var fj = (function(e2) {
        return e2[e2.DOWN = 0] = "DOWN", e2[e2.UP = 1] = "UP", e2;
      })(fj || {});
      const Sj = /* @__PURE__ */ new Map();
      function gj(e2, t2, i2, n2) {
        let { scale: r2 } = e2;
        if (0 === r2 && n2 === fj.UP || r2 >= t2.length - 1 && n2 === fj.DOWN) return e2;
        let o2 = mj(mj({}, e2), {}, { scale: n2 === fj.DOWN ? ++r2 : --r2 });
        switch (i2) {
          case "maintain-framerate":
            o2 = mj(mj({}, o2), t2[r2].motion);
            break;
          case "maintain-resolution":
            o2 = mj(mj({}, o2), t2[r2].detail);
            break;
          case "balanced":
            o2 = mj(mj({}, o2), t2[r2].balanced);
        }
        return o2;
      }
      function Tj(e2, t2) {
        if (t2) {
          const i2 = { overUse: 0, underUse: 0, adaptationList: Rj(t2) };
          Sj.set(e2, i2);
        } else Sj.delete(e2);
      }
      function Rj(e2) {
        const t2 = mj({}, e2), { bitrateMax: i2, frameRate: n2, scaleResolutionDownBy: r2, bitrateMin: o2 } = t2, { MIN_FRAME_RATE: s2, MAX_THRESHOLD_FRAMERATE: a2, MAX_SCALE: c2, BITRATE_MIN_THRESHOLD: d2, BITRATE_MAX_THRESHOLD: l2, BWE_SCALE_UP_THRESHOLD: u2, BWE_SCALE_DOWN_THRESHOLD: h2, PERF_SCALE_DOWN_THRESHOLD: p2, PERF_SCALE_UP_THRESHOLD: _2, BALANCE_BITRATE_FACTOR: E2, BALANCE_FRAMERATE_FACTOR: m2, BALANCE_RESOLUTION_FACTOR: f2, MOTION_RESOLUTION_FACTOR: S2, MOTION_BITRATE_FACTOR: g2, DETAIL_FRAMERATE_FACTOR: T2, DETAIL_BITRATE_FACTOR: R2 } = fD, C2 = Math.min(t2.frameRate, a2), v2 = [{ scale: 0, threshold: { bwe_down: Math.round(Math.pow(h2, 1) * i2), bwe_up: i2, fps_down: Math.round(Math.pow(p2, 1) * C2), fps_up: n2 }, balanced: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 }, motion: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 }, detail: { scaleResolutionDownBy: 1, frameRate: n2, bitrateMax: i2, bitrateMin: o2 } }];
        for (let e3 = 1; e3 <= c2; e3++) {
          const t3 = { bwe_up: Math.round(Math.pow(u2, e3) * i2), bwe_down: Math.round(Math.pow(h2, e3 + 1) * i2), fps_up: Math.round(Math.pow(_2, e3) * C2), fps_down: Math.round(Math.pow(p2, e3 + 1) * C2) }, a3 = { scaleResolutionDownBy: r2 / Math.pow(f2, e3), frameRate: Math.max(Math.round(Math.pow(m2, e3) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(E2, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(E2, e3) * o2), d2) }, c3 = { scaleResolutionDownBy: r2 / Math.pow(S2, e3), frameRate: n2, bitrateMax: Math.max(Math.round(Math.pow(g2, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(g2, e3) * o2), d2) }, y2 = { scaleResolutionDownBy: 1, frameRate: Math.max(Math.round(Math.pow(T2, e3) * n2), s2), bitrateMax: Math.max(Math.round(Math.pow(R2, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(R2, e3) * o2), d2) };
          v2.push({ scale: e3, threshold: t3, balanced: a3, motion: c3, detail: y2 });
        }
        return v2;
      }
      function Cj(e2, t2, i2, n2, r2, o2) {
        const s2 = Sj.get(e2) || { overUse: 0, underUse: 0, adaptationList: Rj(r2) }, { adaptationList: a2 } = s2;
        Sj.set(e2, s2);
        const { OVERUSE_TIMES_THRESHOLD: c2, UNDERUSE_TIMES_THRESHOLD: d2 } = fD, { scale: l2 } = n2;
        let u2, h2;
        return "number" == typeof t2 && t2 > 0 && (function(e3, t3, i3, n3) {
          if (t3 >= i3.length) return false;
          let { threshold: { fps_down: r3 } } = i3[t3];
          return CD("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i3[0].threshold.fps_down), e3 < r3;
        })(t2, l2, a2, o2) && (s2.overUse++, h2 = tD.CPU, s2.overUse > c2) || "number" == typeof i2 && i2 > 0 && (function(e3, t3, i3) {
          if (t3 >= i3.length) return false;
          const { threshold: { bwe_down: n3 } } = i3[t3];
          return e3 < n3;
        })(i2, l2, a2) && (s2.overUse++, h2 = tD.BANDWIDTH, s2.overUse > c2) ? (s2.overUse = 0, s2.underUse = 0, u2 = gj(n2, a2, o2, fj.DOWN), [u2, h2]) : ("number" == typeof t2 && t2 > 0 && "number" == typeof i2 && i2 > 0 && (function(e3, t3, i3, n3) {
          if (0 === t3) return;
          let { threshold: { fps_up: r3 } } = i3[t3];
          return CD("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n3 && (r3 = i3[1].threshold.fps_up), e3 > r3;
        })(t2, l2, a2, o2) && (function(e3, t3, i3) {
          if (0 === t3) return;
          const { threshold: { bwe_up: n3 } } = i3[t3];
          return e3 > n3;
        })(i2, l2, a2) && (s2.underUse++, s2.underUse > d2 && (s2.overUse = 0, s2.underUse = 0, u2 = gj(n2, a2, o2, fj.UP), 0 === u2.scale && (h2 = tD.NONE))), [u2, h2]);
      }
      function vj(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function yj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? vj(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : vj(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      function Ij(e2) {
        var t2;
        return !!CD("ENABLE_AG_ADAPTATION") && (!!(e2 instanceof MM || Ln(t2 = e2._hints).call(t2, VP.CUSTOM_TRACK)) && (!!CD("FORCE_SUPPORT_AG_ADAPTATION") || !!(qw(14, 0, false) && Xw(17, 4, true) || zw(14) && Jw(17, 4, true))));
      }
      const Aj = /* @__PURE__ */ new Map();
      function bj(e2, t2, i2, n2, r2, o2) {
        if (wj(e2, i2), r2(t2), "balanced" !== n2 && "maintain-framerate" !== n2 && "maintain-resolution" !== n2) return;
        let s2 = -1;
        Tj(e2, t2);
        const a2 = window.setInterval((() => {
          const a3 = Aj.get(e2);
          if (!CD("ENABLE_AG_ADAPTATION") || !a3) return wj(e2, i2), void r2(t2);
          const c3 = o2();
          if (c3.sendPackets > 0 && c3.OutgoingAvailableBandwidth > 0) {
            if (-1 === s2) return void (s2 = Date.now());
            if (Date.now() - s2 < 1e3) return;
            const o3 = c3.sendFrameRate, d2 = c3.OutgoingAvailableBandwidth, [l2, u2] = Cj(e2, o3, d2, a3.adaptationConfig, t2, n2);
            u2 && (i2.qualityLimitationReason = u2), l2 && a3.adaptationConfig.scale !== l2.scale && (iP.debug("[".concat(e2, "] applyAdaptation: ").concat(i2.qualityLimitationReason, "\n           sendFps ").concat(o3, ", bwe ").concat(d2, ", switch from ").concat(a3.adaptationConfig.scale, " to ").concat(l2.scale, " ")), a3.adaptationConfig = yj(yj({}, a3.adaptationConfig), l2), r2(l2));
          }
        }), CD("CHECK_LOCAL_STATS_INTERVAL")), c2 = yj({}, t2);
        Aj.set(e2, { timer: a2, adaptationConfig: c2, originConfig: t2, adaptationFunc: r2 }), iP.debug("[".concat(e2, "] start adaptation, originConfig: ").concat(JSON.stringify(t2), ", degradationPreference: ").concat(n2));
      }
      function wj(e2, t2) {
        const i2 = Aj.get(e2);
        if (i2) {
          const { timer: t3 } = i2;
          window.clearTimeout(t3), Aj.delete(e2);
        }
        t2.qualityLimitationReason = tD.NONE, Tj(e2);
      }
      function Oj(e2, t2) {
        var i2;
        let n2;
        switch (t2) {
          case Rx.LocalAudioTrack:
            n2 = ox.Audio;
            break;
          case Rx.LocalVideoTrack:
            n2 = Ln(i2 = e2._hints).call(i2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
            break;
          case Rx.LocalVideoLowTrack:
            n2 = ox.Low;
        }
        return n2;
      }
      function Nj(e2) {
        const t2 = pP();
        if (e2.some(((e3) => e3._bypassWebAudio))) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
        if (!t2.webAudioMediaStreamDest) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
      }
      function Dj(e2, t2) {
        Nj(e2);
        const i2 = t2 || new Wk();
        return e2.forEach(((e3) => i2.addAudioTrack(e3))), i2;
      }
      const Pj = !pP().supportUnifiedPlan || CD("CHROME_FORCE_PLAN_B") && sO();
      function Lj(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (e2.useDcSignal) return i2 = { spec: t2, store: e2 }, oB("DataChannelConnection").create(i2);
        var i2;
        const n2 = Pj ? (function(e3) {
          return oB("PlanBConnection").create(e3);
        })({ spec: t2, store: e2 }) : new Fj(t2, e2);
        return n2;
      }
      function kj(e2) {
        return e2 && ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState);
      }
      function Mj(e2) {
        try {
          if (e2.iceServers) return false;
          if (e2.turnServer && "off" !== e2.turnServer.mode) {
            if (xO(e2.turnServer.servers)) return false;
            if (CD("FORCE_TURN_TCP") || e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).some(((e3) => e3.forceturn))) return true;
          }
          return false;
        } catch (e3) {
          return false;
        }
      }
      var Uj;
      function Vj(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function xj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Vj(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Vj(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let Fj = (Uj = class e2 extends mx {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map(((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "")).filter(((e3) => {
            var t2;
            return Ln(t2 = Object.keys(AD)).call(t2, e3);
          })))];
        }
        constructor(t2, i2) {
          super(t2, i2), iA(this, "id", SN(5, "connection-")), iA(this, "store", void 0), iA(this, "peerConnection", void 0), iA(this, "forceTurn", false), iA(this, "remoteSDP", void 0), iA(this, "initialOffer", void 0), iA(this, "transportEventReceiver", void 0), iA(this, "statsFilter", void 0), iA(this, "extension", { useXR: CD("USE_XR") }), iA(this, "localCapabilities", void 0), iA(this, "remoteCodecs", void 0), iA(this, "localCandidateCount", 0), iA(this, "allCandidatesReceived", false), iA(this, "isPreallocation", false), iA(this, "isPreRender", false), iA(this, "preMediaMap", /* @__PURE__ */ new Map()), iA(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), iA(this, "establishPromise", void 0), iA(this, "recoveredDataChannelIds", []), iA(this, "currentDataChannelId", 1), iA(this, "supportAV1RtpSpec", false), iA(this, "mutex", void 0), iA(this, "qualityLimitationReason", tD.NONE), iA(this, "isFirstConnected", false), this.store = i2, this.forceTurn = Mj(t2), this.mutex = new PN("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.isFirstConnected = false, this.statsFilter = dD(this.peerConnection, CD("STATS_UPDATE_INTERVAL"), void 0, Bw() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, t2.isPreallocation && (this.isPreallocation = true), this.establishPromise = this.establish();
        }
        getPreMedia(e3) {
          return this.preMediaMap.get(e3);
        }
        isPreSub() {
          return this.preMediaMap.size > 0;
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          if (this.remoteCodecs = t2, !this.remoteSDP) return void iP.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
          if (this.remoteSDP.updateRemoteCodec(e3, t2, this.store.codec)) {
            const e4 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e4.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e4);
            const i2 = this.remoteSDP.toString();
            null == t3 || t3(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } else iP.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const t2 = await this.peerConnection.createOffer();
            if (!t2.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const i2 = OF(t2.sdp), n2 = await jF({ filterRTX: !CD("USE_PUB_RTX") && !CD("USE_SUB_RTX"), filterVideoFec: CD("FILTER_VIDEO_FEC"), filterAudioFec: CD("FILTER_AUDIO_FEC"), filterVideoCodec: CD("FILTER_VIDEO_CODEC"), unsupportedVideoUplinkCodec: CD("UNSUPPORTED_VIDEO_UPLINK_CODEC"), unsupportedVideoDownlinkCodec: CD("UNSUPPORTED_VIDEO_DOWNLINK_CODEC") }, this.extension);
            if (this.localCapabilities = HF(n2), this.initialOffer = t2, CD("ENABLE_SVC") && "av1" == this.store.codec) {
              const t3 = await BF();
              var e3;
              if (t3) this.supportAV1RtpSpec = true, null === (e3 = n2.send) || void 0 === e3 || e3.videoExtensions.push(t3);
            }
            let r2;
            return t2.sdp && ZF(t2.sdp) && (r2 = sN(n2), TF(r2)), xj(xj({}, i2), {}, { rtpCapabilities: r2 || n2, offerSDP: t2.sdp });
          } catch (e4) {
            throw new pO(hO.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.initialOffer.sdp && ZF(this.initialOffer.sdp) && RF(e3.rtpCapabilities, this.localCapabilities), this.remoteSDP = new _j(xj(xj({}, e3), {}, { localCapabilities: this.localCapabilities }), this.supportAV1RtpSpec, !(!CD("ENABLE_PRE_SUB_WITH_PRE_PC") || !CD("PRE_USE_LOCAL_CODECS")) && mP(this.store)), e3.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const t2 = this.remoteSDP.toString(), i2 = XF(this.initialOffer.sdp, this.extension), n2 = this.logSDPExchange(i2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), null == n2 || n2(t2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
            const r2 = this.peerConnection.getTransceivers()[0];
            if (null != r2 && r2.receiver && this.tryBindTransportEvents(r2.receiver), mP(this.store)) if (e3.preallocation && CD("ENABLE_PRE_SUB_WITH_PRE_PC")) {
              const e4 = CD("PRE_SUB_NUM"), { mids: t3, preSSRCs: i3 } = this.remoteSDP.preloadRemoteMedia(e4);
              await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [P2PConnection] preload media, in pre pc,add preload ssrcs ").concat(i3)), this.presetMedia(t3, i3);
            } else {
              const { preSSRCs: t3 = [] } = e3, i3 = t3.map(((e4) => e4.ssrcMsg[0].ssrcId));
              if (0 === t3.length) return;
              const { mids: n3 } = this.remoteSDP.batchSend(t3.map(((e4) => Object.assign({}, e4))));
              await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[P2PConnection.connect] preload media, after join, add preload ssrcs ".concat(i3)), this.presetMedia(n3, i3);
            }
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        presetMedia(e3, t2) {
          e3.forEach(((e4, i2) => {
            this.peerConnection.getTransceivers().forEach(((n2) => {
              if (null != n2.mid && e4 === n2.mid && n2.receiver.track) {
                const r2 = n2.receiver.track;
                let o2;
                "video" === r2.kind && CD("ENABLE_PRE_RENDER") && (o2 = new Xk({ trackId: "track-".concat(r2.kind, "-unknown-").concat(this.store.clientId, "_").concat(SN(5, "")) }, true), o2.updateVideoTrack(r2), o2.onFirstVideoFrameRender = () => {
                  var e5;
                  const n3 = this.preMediaMap.get(t2[i2]);
                  n3 && (n3.firstVideoRender = Date.now()), null === (e5 = this.onFirstVideoRender) || void 0 === e5 || e5.call(this, t2[i2]);
                }, o2.onVideoBufferReady = () => {
                  var e5;
                  null === (e5 = this.onFirstVideoBufferReady) || void 0 === e5 || e5.call(this, t2[i2]);
                }, o2.play(this.store.sessionId || void 0), this.isPreRender = true), this.preMediaMap.set(t2[i2], { mid: e4, track: r2, player: o2, transceiver: n2 });
              }
            })), this.store.peerReceiver();
          }));
        }
        checkDtlsParameters(e3) {
          return !!this.remoteSDP && (e3.length > 0 && this.remoteSDP.updateRemoteDtlsParameters(e3));
        }
        async updateRemoteConnect(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateRemoteConnect before remote SDP created");
            let t2 = false;
            const { rtpCapabilities: i2 } = e3;
            if ([, t2] = this.remoteSDP.updateRemoteRTPCapabilities(i2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) {
              const e4 = this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
              t2 = t2 || e4;
            }
            const { preSSRCs: n2 = [] } = e3, r2 = n2.map(((e4) => e4.ssrcMsg[0].ssrcId));
            if (!this.remoteSDP.checkPreloadSsrcs(r2)) {
              const e4 = [], t3 = [];
              if (Array.from(this.preMediaMap.entries()).every(((i3) => {
                let [n3, { mid: r3, player: o2, track: s2 }] = i3;
                return e4.push(r3), t3.push(n3), this.preMediaMap.delete(n3), o2 && o2.destroy(), true;
              })), e4.length > 0 && (this.remoteSDP.stopSending(e4), await qF(this.peerConnection, this.remoteSDP, this.extension), iP.warn("[P2PConnection.updateRemoteConnect] preload media, failed, del preload ssrcs ".concat(t3)), lP.reportApiInvoke(this.store.sessionId, { name: LO.PRELOAD_MEDIA_FAILED, options: [n2, t3], tag: kO.TRACER }).onSuccess()), n2.length > 0) {
                const { mids: e5 } = this.remoteSDP.batchSend(n2.map(((e6) => Object.assign({}, e6))));
                await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[P2PConnection.updateRemoteConnect] preload media, after join, add preload ssrcs ".concat(r2)), this.presetMedia(e5, r2);
              }
            }
            t2 ? (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[P2PConnection] updateRemoteConnect by exchanging SDP.")) : iP.debug("[P2PConnection] updateRemoteConnect no need to exchange SDP, because no need to update remote codecs (use local codecs)");
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.updateRemoteConnect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = SF();
              e3.forEach(((e4) => {
                const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, xj({ direction: "sendonly" }, "video" === e4.trackMediaType && n2.supportAV1RtpSpec && s2 ? { sendEncodings: [{ scalabilityMode: s2 }] } : {}));
                o2.push(t3), e4._updateRtpTransceiver(t3);
              })), Bw() && true === CD("SIMULCAST") && (yield Vb(n2.applySimulcastForFirefox(o2, e3)));
              const a2 = yield Vb(n2.peerConnection.createOffer()), c2 = n2.remoteSDP.predictReceivingMids(e3.length), d2 = n2.mungSendOfferSDP(a2.sdp, e3, c2), l2 = LD(d2), u2 = c2.map(((e4) => {
                const t3 = l2.mediaDescriptions.find(((t4) => t4.attributes.mid === e4));
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return NF(t3, CD("USE_PUB_RTX"));
              }));
              let h2;
              try {
                h2 = yield u2;
              } catch (r3) {
                h2 = [], n2.remoteSDP.receive(e3, t2, i2, h2);
                const o3 = n2.remoteSDP.toString();
                throw yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield Vb(n2.stopSending(c2, true)), r3;
              }
              n2.remoteSDP.receive(e3, t2, i2, h2);
              const p2 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(n2.applySimulcastEncodings(o2, e3)), yield Vb(n2.applySendEncodings(o2, e3)), null == _2 || _2(p2), yield Vb(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map(((e4, t3) => {
                const i3 = c2[t3];
                return { localSSRC: u2[t3], id: i3, transceiver: e4 };
              }));
            } catch (e4) {
              throw e4 instanceof pO ? e4 : new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          }))();
        }
        async createDataChannels(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
            let i2 = this.dataStreamChannelMap.get(e3);
            if (i2 && "open" === i2.readyState) iP.debug("[P2PConnection] Channels are already available and can be reused directly.");
            else {
              const t3 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
              if ("number" != typeof t3) throw new Error("create DataChannel error, because cannot get dc id");
              i2 = this.peerConnection.createDataChannel("datastream-channel", { id: t3, negotiated: true, ordered: false, maxRetransmits: CD("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e3, i2);
            }
            t2.forEach(((e4) => {
              e4._updateOriginDataChannel(i2);
            }));
            const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
            if (n2) {
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3), iP.debug("[P2PConnection] createDataChannels by exchanging SDP.");
            } else iP.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
            return;
          } catch (e4) {
            throw e4 instanceof pO ? e4 : new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopDataChannels(e3) {
          try {
            const t2 = this.dataStreamChannelMap.get(e3);
            return t2 && (t2.id && this.recoveredDataChannelIds.push(t2.id), t2.close()), void this.dataStreamChannelMap.delete(e3);
          } catch (e4) {
            throw e4 instanceof pO ? e4 : new pO(hO.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter(((t4) => -1 !== e3.indexOf(t4.mid)));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map(((e4) => {
              var t4;
              wj(this.id + e4.mid, this), e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            }));
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            o2 && (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP.")));
            const s2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === r2));
            if (!s2) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2, transceiver: s2 };
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
            return i2 && (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."))), t2.map(((e4) => {
              const t3 = this.peerConnection.getTransceivers().find(((t4) => t4.mid === e4));
              if (!t3) throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4, transceiver: t3 };
            }));
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            e3.forEach(((e4) => {
              Array.from(this.preMediaMap.entries()).some(((t3) => {
                let [i3, { mid: n3, player: r2 }] = t3;
                if (n3 === e4) return this.preMediaMap.delete(i3), r2 && r2.destroy(), true;
              }));
            })), this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(((e4) => {
              e4.direction = "inactive";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((async (e4, t3) => {
              e4.direction = "sendonly";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec(e3, this.remoteCodecs, this.store.codec);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return Mb((function* () {
            const i2 = yield Vb(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              const n2 = pP().supportPCSetConfiguration, r2 = CD("FORCE_TURN_TCP") || t2.forceTurn;
              if (e3 === Sx.RELAY && !n2) return;
              if (n2 && !r2) {
                const i3 = e3 === Sx.RELAY ? "relay" : "all", n3 = t2.peerConnection.getConfiguration();
                n3.iceTransportPolicy !== i3 && (iP.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n3.iceTransportPolicy, "] to [").concat(i3, "]")), n3.iceTransportPolicy = i3, t2.peerConnection.setConfiguration(n3));
              }
              t2.remoteSDP.updateCandidates(e3);
              const o2 = yield Vb(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!o2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const s2 = OF(o2.sdp), { remoteIceParameters: a2 } = yield s2.iceParameters;
              t2.remoteSDP.restartICE(a2);
              const c2 = t2.remoteSDP.toString(), d2 = t2.logSDPExchange(o2.sdp || "", "offer", "local", "restartICE");
              t2.store.descriptionStart(), yield Vb(t2.peerConnection.setLocalDescription(o2)), null == d2 || d2(c2), yield Vb(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: c2 }));
            } catch (e4) {
              iP.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          }))();
        }
        async extendCandidate() {
          if (!this.remoteSDP || this.isFirstConnected) return;
          const e3 = await this.mutex.lock("From P2PConnection.extendCandidate");
          try {
            this.remoteSDP.updateCandidates(Sx.TCP_RELAY), await qF(this.peerConnection, this.remoteSDP, this.extension);
          } catch (e4) {
            iP.warning("[".concat(this.store.clientId, "] extend candidate failed, abort operation"), e4);
          } finally {
            e3();
          }
        }
        close() {
          var e3;
          this.peerConnection.getTransceivers().forEach(((e4) => {
            wj(this.id + e4.mid, this);
          })), this.preMediaMap.forEach(((e4) => {
            let { player: t2 } = e4;
            t2 && t2.destroy();
          })), this.preMediaMap.clear(), this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
        }
        getStats() {
          return xj(xj({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid === e3));
          1 === i2.length && (this.isVP8Simulcast(t2) ? Bw() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === t2));
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: xj(xj({}, zN), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: xj(xj({}, zN), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.isFirstConnected = true), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidateerror = (e3) => {
            if (e3 && (e3.errorCode || e3.errorText)) {
              var t2;
              const i2 = "code: ".concat(e3.errorCode, ", message: ").concat(e3.errorText), n2 = e3.port ? "local: ".concat(e3.port) : "", r2 = mF(e3.url || "");
              iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICECandidateError(").concat(i2, "), url: ").concat(r2 || "", ", host_candidate:").concat(n2)), null === (t2 = this.onICECandidateError) || void 0 === t2 || t2.call(this, i2);
            }
          }, this.peerConnection.onicegatheringstatechange = (e3) => {
            e3 && e3.target && "iceGatheringState" in e3.target && iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] RTCPeerConnection.onicegatheringstatechange(").concat(e3.target.iceGatheringState, ")"));
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout((() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }), CD("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] }, n2 = t2.cloudProxyServer || "disabled";
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && (xO(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : CD("NEW_TURN_MODE") && i2.iceServers && "disabled" === n2 ? (CD("USE_TURN_SERVER_OF_GATEWAY") ? t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t2.turnServer.serversFromGateway)) : i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t2.turnServer.servers)), CD("NEW_FORCE_TURN") && (i2.iceTransportPolicy = "relay")) : "off" !== t2.turnServer.mode && (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), CD("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), CD("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach(((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          })))), CD("ENABLE_ENCODED_TRANSFORM") && pP().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !CD("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          })), t2;
        }
        static newTurnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            const i2 = CD("NEW_TURN_MODE");
            1 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }) : 2 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }) : 3 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":443?transport=tcp") }) : 4 === i2 && (t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }), t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }), t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":443?transport=tcp") }));
          })), t2;
        }
        tryBindTransportEvents(e3) {
          const t2 = e3.transport;
          if (t2) {
            this.transportEventReceiver = e3, t2.onstatechange = () => {
              var e4;
              null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
            }, t2.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const i2 = t2.iceTransport;
            i2 && (i2.onstatechange = () => {
              const e4 = null == t2 ? void 0 : t2.iceTransport.state;
              var i3;
              e4 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e4));
            }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
              if (i2.getSelectedCandidatePair()) {
                const { local: e4, remote: t3 } = i2.getSelectedCandidatePair() || {};
                if (e4 && t3) {
                  const i3 = e4.address + ":" + e4.port, n2 = t3.address + ":" + t3.port;
                  iP.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify(mF(i3)), ", remote ").concat(JSON.stringify(mF(n2))));
                }
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i2, n2;
          if (!t2) {
            const i3 = this.peerConnection.getSenders();
            t2 = i3.find(((t3) => t3.track === e3._mediaStreamTrack));
          }
          if (!t2) return iP.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return iP.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!pP().supportSetRtpSenderParameters) return iP.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const r2 = {}, o2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              r2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              r2.degradationPreference = "maintain-resolution";
              break;
            case "balanced":
              r2.degradationPreference = "balanced";
          }
          const s2 = fF(this.peerConnection, e3._mediaStreamTrack), a2 = JL(e3);
          if (Ij(e3) && s2 && t2 && a2 && this.getLocalVideoStats && Ln(i2 = ["vp8", "vp9"]).call(i2, this.store.codec)) {
            var c2;
            const i3 = r2.degradationPreference || (Ln(c2 = e3._hints).call(c2, VP.CUSTOM_TRACK) ? CD("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
            bj(this.id + s2.mid, a2, this, i3, ((e4) => {
              t2 && this.updateAdaptation(t2, e4);
            }), this.getLocalVideoStats.bind(this));
          }
          if (e3._encoderConfig) {
            var d2;
            const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (o2.maxBitrate = 1e3 * t3), (Ln(d2 = e3._hints).call(d2, VP.LOW_STREAM) || e3.isUseScaleResolutionDownBy) && (i3 && (o2.maxFramerate = dF(i3)), n3 && n3 >= 1 && (o2.scaleResolutionDownBy = n3));
          }
          const { maxFramerate: l2 } = CD("ENCODER_CONFIG_LIMIT");
          if (l2 && "number" == typeof l2 && (o2.maxFramerate = o2.maxFramerate ? Math.min(o2.maxFramerate, l2) : l2), CD("DSCP_TYPE") && sO()) {
            var u2;
            const e4 = CD("DSCP_TYPE");
            Ln(u2 = ["very-low", "low", "medium", "high"]).call(u2, e4) && (o2.networkPriority = e4);
          }
          const h2 = t2.getParameters(), p2 = null === (n2 = h2.encodings) || void 0 === n2 ? void 0 : n2[0];
          Bw() && !p2 && (r2.encodings = [o2]), p2 && Object.assign(p2, o2), Object.assign(h2, r2), iP.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(h2.encodings))), await t2.setParameters(h2), await QF(this.store.codec, t2, CD("SVC_MODE"));
        }
        async updateAdaptation(e3, t2) {
          var i2, n2;
          if (!e3) return iP.debug("[updateAdaptation] no rtpSender found");
          if (!pP().supportSetRtpSenderParameters) return iP.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
          const r2 = {}, { bitrateMax: o2, frameRate: s2, scaleResolutionDownBy: a2 } = t2;
          o2 && (r2.maxBitrate = 1e3 * o2), s2 && (r2.maxFramerate = dF(s2)), a2 && a2 >= 1 && Ln(i2 = ["vp8", "vp9"]).call(i2, this.store.codec) && (r2.scaleResolutionDownBy = a2);
          const c2 = e3.getParameters(), d2 = null === (n2 = c2.encodings) || void 0 === n2 ? void 0 : n2[0];
          d2 && Object.assign(d2, r2), Object.assign(c2, {});
          try {
            await e3.setParameters(c2), iP.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(c2.encodings)));
          } catch (t3) {
            !("transport" in e3) || e3.transport && "connected" === e3.transport.state ? "connected" !== this.peerConnectionState ? iP.debug("[updateAdaptation] peerConnection not connected}") : iP.debug("[updateAdaptation] updateRtpSenderEncodings failed", t3) : iP.debug("[updateAdaptation] rtpSender transport not connected}");
          }
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!pP().supportSetRtpSenderParameters) return;
            if (e3.length !== t2.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = e3[i2], r2 = t2[i2];
              r2 instanceof kM && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            iP.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          if (CD("FORBID_MODIFY_LOCAL_OFFER_SDP")) return e3;
          const n2 = LD(e3);
          return t2.forEach(((e4, t3) => {
            const r2 = i2[t3], o2 = n2.mediaDescriptions.find(((e5) => e5.attributes.mid === r2));
            o2 && (kF(o2, e4), FF(o2, e4, this.store.codec));
          })), kD(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length) for (let a2 = 0; a2 < e3.length; a2++) {
            var i2, n2, r2, o2, s2;
            const c2 = e3[a2], d2 = t2[a2];
            if (d2 instanceof kM && !Ln(i2 = d2._hints).call(i2, VP.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Bw() && e3.length === t2.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof kM && this.isVP8Simulcast(n2)) {
              const t3 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(s2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2, o2;
          return !!(e3 instanceof kM && CD("SIMULCAST") && "vp8" === this.store.codec && !Ln(t2 = e3._hints).call(t2, VP.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (CD("SDP_LOGGING")) return iP.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return t2 && 0 !== t2.length ? t2[0].ssrcId : void 0;
        }
        setConfiguration(t2) {
          if (pP().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
          t2.isPreallocation && (this.isPreallocation = true);
        }
      }, DV(Uj.prototype, "updateRemoteRTPCapabilities", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "updateRemoteRTPCapabilities"), Uj.prototype), DV(Uj.prototype, "connect", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "connect"), Uj.prototype), DV(Uj.prototype, "updateRemoteConnect", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "updateRemoteConnect"), Uj.prototype), DV(Uj.prototype, "createDataChannels", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "createDataChannels"), Uj.prototype), DV(Uj.prototype, "receive", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "receive"), Uj.prototype), DV(Uj.prototype, "batchReceive", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "batchReceive"), Uj.prototype), DV(Uj.prototype, "stopReceiving", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "stopReceiving"), Uj.prototype), DV(Uj.prototype, "muteRemote", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "muteRemote"), Uj.prototype), DV(Uj.prototype, "unmuteRemote", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "unmuteRemote"), Uj.prototype), DV(Uj.prototype, "muteLocal", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "muteLocal"), Uj.prototype), DV(Uj.prototype, "unmuteLocal", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "unmuteLocal"), Uj.prototype), DV(Uj.prototype, "close", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "close"), Uj.prototype), DV(Uj.prototype, "updateEncoderConfig", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "updateEncoderConfig"), Uj.prototype), DV(Uj.prototype, "updateSendParameters", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "updateSendParameters"), Uj.prototype), DV(Uj.prototype, "replaceTrack", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "replaceTrack"), Uj.prototype), DV(Uj.prototype, "updateAdaptation", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "updateAdaptation"), Uj.prototype), DV(Uj.prototype, "getRemoteSSRC", [Bj], Object.getOwnPropertyDescriptor(Uj.prototype, "getRemoteSSRC"), Uj.prototype), Uj);
      function Bj(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function jj(e2, t2) {
        let i2 = document.createElement("video"), n2 = document.createElement("canvas");
        i2.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n2.width = dF(t2.width), n2.height = dF(t2.height);
        const r2 = dF(t2.framerate || 15);
        document.body.append(i2), document.body.append(n2);
        let o2 = e2._mediaStreamTrack;
        i2.srcObject = new MediaStream([o2]), i2.play().catch(TN);
        const s2 = n2.getContext("2d");
        if (!s2) throw new uP(hO.UNEXPECTED_ERROR, "can not get canvas context");
        const a2 = pP(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
        c2.canvas || (c2.canvas = n2), n2.startCapture = () => {
          if (!i2) return n2.stopCapture && n2.stopCapture();
          if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
            const e3 = i2.videoWidth, t3 = i2.videoHeight / e3, r3 = n2.width * t3;
            Math.abs(r3 - n2.height) >= 2 && (iP.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
          }
          s2.drawImage(i2, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, i2.srcObject = new MediaStream([o2]));
        }, n2.stopCapture = SL((() => n2.startCapture && n2.startCapture()), r2);
        const d2 = c2.stop;
        return c2.stop = () => {
          d2.call(c2), i2 && (i2.remove(), i2.srcObject = null, i2 = null), n2 && (n2.width = 0, n2.remove(), n2.stopCapture && n2.stopCapture(), n2.startCapture = void 0, n2.stopCapture = void 0, n2 = null), iP.debug("clean low stream renderer");
        }, c2;
      }
      var Gj = (function(e2) {
        return e2[e2.Video_Send_Type = 190] = "Video_Send_Type", e2;
      })(Gj || {}), Wj = (function(e2) {
        return e2[e2.Video_Send_Qp_Sum = 2143] = "Video_Send_Qp_Sum", e2[e2.Video_Send_Freeze = 2082] = "Video_Send_Freeze", e2[e2.Video_Recv_Qp_Sum = 2144] = "Video_Recv_Qp_Sum", e2[e2.Video_Recv_Freeze = 2084] = "Video_Recv_Freeze", e2[e2.Video_Render_Freeze_Time = 2109] = "Video_Render_Freeze_Time", e2[e2.Video_Render_Freeze_Time_Render = 2147] = "Video_Render_Freeze_Time_Render", e2[e2.Video_Render_Freeze_Time_Render2 = 2223] = "Video_Render_Freeze_Time_Render2", e2[e2.Audio_Recv_Freeze = 2083] = "Audio_Recv_Freeze", e2;
      })(Wj || {}), Hj = (function(e2) {
        return e2[e2.Video_Send_Retransmit = 2062] = "Video_Send_Retransmit", e2[e2.Video_Send_Target_Encoded = 2064] = "Video_Send_Target_Encoded", e2[e2.Video_Send_Actual_Encoded = 2060] = "Video_Send_Actual_Encoded", e2[e2.Video_Send_Transmit = 2066] = "Video_Send_Transmit", e2[e2.Video_Send_Bandwidth = 2061] = "Video_Send_Bandwidth", e2[e2.Video_Capture_Height = 2033] = "Video_Capture_Height", e2[e2.Video_Capture_Width = 2035] = "Video_Capture_Width", e2[e2.Video_Capture_Frame_Rate = 2034] = "Video_Capture_Frame_Rate", e2[e2.Video_Send_Low_Height = 2073] = "Video_Send_Low_Height", e2[e2.Video_Send_Low_Frame_Rate = 2075] = "Video_Send_Low_Frame_Rate", e2[e2.Video_Send_Low_Width = 2077] = "Video_Send_Low_Width", e2[e2.Video_Send_Low_Bitrate = 2069] = "Video_Send_Low_Bitrate", e2[e2.Video_Send_Low_Package_Lost = 2070] = "Video_Send_Low_Package_Lost", e2[e2.Video_Send_Low_Package_Rate = 2071] = "Video_Send_Low_Package_Rate", e2[e2.Video_Send_Frame_Rate = 2002] = "Video_Send_Frame_Rate", e2[e2.Video_Send_Width = 2003] = "Video_Send_Width", e2[e2.Video_Send_Height = 2004] = "Video_Send_Height", e2[e2.Video_Send_Disabled = 2095] = "Video_Send_Disabled", e2[e2.Video_Send_Adaptation = 2032] = "Video_Send_Adaptation", e2[e2.Video_Send_Player_Status = 2128] = "Video_Send_Player_Status", e2[e2.Video_Send_Nacks = 2009] = "Video_Send_Nacks", e2[e2.Video_Send_Plis = 2010] = "Video_Send_Plis", e2[e2.Video_Send_Firs = 2011] = "Video_Send_Firs", e2[e2.Video_Send_Avg_Encode = 2007] = "Video_Send_Avg_Encode", e2[e2.Video_Send_Huge_Frame_Sent = 2174] = "Video_Send_Huge_Frame_Sent", e2[e2.Video_Send_Bytes_Retransmit = 2173] = "Video_Send_Bytes_Retransmit", e2[e2.Video_Send_Packages_Retransmit = 2172] = "Video_Send_Packages_Retransmit", e2[e2.Video_Send_Key_Frames_Encoded = 2207] = "Video_Send_Key_Frames_Encoded", e2[e2.Video_Send_Bitrate = 2012] = "Video_Send_Bitrate", e2[e2.Video_Send_Package_Rate = 2031] = "Video_Send_Package_Rate", e2[e2.Video_Send_Package_Lost = 2005] = "Video_Send_Package_Lost", e2[e2.Audio_Capture_PCM_Level = 2104] = "Audio_Capture_PCM_Level", e2[e2.Audio_Send_Level = 2038] = "Audio_Send_Level", e2[e2.Audio_Send_Bitrate = 2039] = "Audio_Send_Bitrate", e2[e2.Audio_Send_Package_Rate = 2040] = "Audio_Send_Package_Rate", e2[e2.Audio_Send_AEC_Return_Loss = 2041] = "Audio_Send_AEC_Return_Loss", e2[e2.Audio_Send_AEC_Return_Loss_Enhancement = 2042] = "Audio_Send_AEC_Return_Loss_Enhancement", e2[e2.Audio_Send_Freeze = 2081] = "Audio_Send_Freeze", e2[e2.Audio_Send_Disabled = 2096] = "Audio_Send_Disabled", e2[e2.Audio_Send_Bytes_Retransmit = 2179] = "Audio_Send_Bytes_Retransmit", e2[e2.Audio_Send_Packages_Retransmit = 2180] = "Audio_Send_Packages_Retransmit", e2[e2.Video_Recv_Height = 2019] = "Video_Recv_Height", e2[e2.Video_Recv_Width = 2018] = "Video_Recv_Width", e2[e2.Video_Recv_Frame_Rate_Output = 2155] = "Video_Recv_Frame_Rate_Output", e2[e2.Video_Recv_Jitter_Buffer = 2023] = "Video_Recv_Jitter_Buffer", e2[e2.Video_Recv_Current_Delay = 2024] = "Video_Recv_Current_Delay", e2[e2.Video_Recv_Nacks = 2026] = "Video_Recv_Nacks", e2[e2.Video_Recv_Plis = 2027] = "Video_Recv_Plis", e2[e2.Video_Recv_Firs = 2028] = "Video_Recv_Firs", e2[e2.Video_Recv_Disabled = 2101] = "Video_Recv_Disabled", e2[e2.Video_Recv_Player_Status = 2129] = "Video_Recv_Player_Status", e2[e2.Video_Recv_I_Frame_Delay = 2149] = "Video_Recv_I_Frame_Delay", e2[e2.Video_Render_Frame_Rate_Render = 2022] = "Video_Render_Frame_Rate_Render", e2[e2.Video_Render_Freeze_Duration = 2156] = "Video_Render_Freeze_Duration", e2[e2.Audio_Render_Level = 2043] = "Audio_Render_Level", e2[e2.Audio_Render_Freeze_Time_80ms = 2226] = "Audio_Render_Freeze_Time_80ms", e2[e2.Audio_Render_Freeze_Time_200ms = 2227] = "Audio_Render_Freeze_Time_200ms", e2[e2.Audio_Render_Freeze_Samples_80ms = 2228] = "Audio_Render_Freeze_Samples_80ms", e2[e2.Audio_Render_Freeze_Samples_200ms = 2229] = "Audio_Render_Freeze_Samples_200ms", e2[e2.Audio_Recv_PCM_Level = 2105] = "Audio_Recv_PCM_Level", e2[e2.Audio_Recv_Disabled = 2102] = "Audio_Recv_Disabled", e2[e2.Audio_Recv_Jitter_Buffer = 2054] = "Audio_Recv_Jitter_Buffer", e2[e2.Audio_Recv_Current_Delay = 2047] = "Audio_Recv_Current_Delay", e2[e2.Audio_Recv_Player_Status = 2130] = "Audio_Recv_Player_Status", e2[e2.Audio_Recv_Bitrate = 2044] = "Audio_Recv_Bitrate", e2[e2.Audio_Recv_Concealed_Samples = 2148] = "Audio_Recv_Concealed_Samples", e2[e2.Audio_Recv_Total_Samples_Received = 2224] = "Audio_Recv_Total_Samples_Received", e2;
      })(Hj || {}), Kj = (function(e2) {
        return e2[e2.Video_Render_Frame_Rate_Decode = 2021] = "Video_Render_Frame_Rate_Decode", e2[e2.Video_Recv_Frame_Rate = 2020] = "Video_Recv_Frame_Rate", e2[e2.Video_Recv_Frame_Dropped = 2181] = "Video_Recv_Frame_Dropped", e2[e2.Video_Recv_Bytes_Retransmit = 2175] = "Video_Recv_Bytes_Retransmit", e2[e2.Video_Recv_Packages_Retransmit = 2176] = "Video_Recv_Packages_Retransmit", e2[e2.Video_Recv_Packages_Discarded = 2198] = "Video_Recv_Packages_Discarded", e2[e2.Video_Recv_Avg_Decode = 2200] = "Video_Recv_Avg_Decode", e2[e2.Video_Recv_Avg_Processing_Delay = 2202] = "Video_Recv_Avg_Processing_Delay", e2[e2.Video_Recv_Avg_Assembly_Time = 2203] = "Video_Recv_Avg_Assembly_Time", e2[e2.Video_Recv_Avg_Inter_Frame_Delay = 2204] = "Video_Recv_Avg_Inter_Frame_Delay", e2[e2.Video_Recv_Key_Frames_Decoded = 2206] = "Video_Recv_Key_Frames_Decoded", e2[e2.Video_Recv_Package_Lost = 2014] = "Video_Recv_Package_Lost", e2[e2.Video_Recv_Bitrate = 2029] = "Video_Recv_Bitrate", e2[e2.Video_Recv_Package_Rate = 2078] = "Video_Recv_Package_Rate", e2[e2.Audio_Recv_Jitter = 2055] = "Audio_Recv_Jitter", e2[e2.Audio_Recv_Bytes_Retransmit = 2178] = "Audio_Recv_Bytes_Retransmit", e2[e2.Audio_Recv_Packages_Retransmit = 2177] = "Audio_Recv_Packages_Retransmit", e2[e2.Audio_Recv_Packages_Discarded = 2199] = "Audio_Recv_Packages_Discarded", e2[e2.Audio_Recv_Avg_Processing_Delay = 2201] = "Audio_Recv_Avg_Processing_Delay", e2[e2.Audio_Recv_Package_Rate = 2046] = "Audio_Recv_Package_Rate", e2[e2.Audio_Recv_Package_Lost = 2045] = "Audio_Recv_Package_Lost", e2[e2.Audio_Recv_AV_Sync_TIME = 2237] = "Audio_Recv_AV_Sync_TIME", e2;
      })(Kj || {}), Yj = (function(e2) {
        return e2[e2.RTT = 2006] = "RTT", e2[e2.CONN_TYPE = 801] = "CONN_TYPE", e2[e2.STATS_UPDATE_INTERVAL = 2205] = "STATS_UPDATE_INTERVAL", e2;
      })(Yj || {}), zj = (function(e2) {
        return e2[e2.RTC_PEER_CONNECTION_STATE = 2219] = "RTC_PEER_CONNECTION_STATE", e2[e2.PAGE_VISIBILITY = 2233] = "PAGE_VISIBILITY", e2;
      })(zj || {}), qj = (function(e2) {
        return e2[e2.Transport_Send_Bitrate = 2234] = "Transport_Send_Bitrate", e2[e2.Transport_Recv_Bitrate = 2235] = "Transport_Recv_Bitrate", e2;
      })(qj || {});
      const Xj = 1e3, Jj = 6, Qj = 3, Zj = Math.max(Jj, Qj, 60);
      function $j(e2, t2, i2) {
        null != i2 && Number.isFinite(i2) && (e2[t2] = Math.round(Math.max(0, i2)));
      }
      function eG(e2) {
        const t2 = { [Yj.CONN_TYPE]: 0, [Yj.RTT]: e2.rtt, [Yj.STATS_UPDATE_INTERVAL]: e2.updateInterval ? Math.round(Math.max(0, e2.updateInterval)) : void 0 };
        switch (e2.selectedCandidatePair.localCandidate.candidateType) {
          case "relay": {
            const i2 = e2.selectedCandidatePair.localCandidate.relayProtocol;
            "udp" === i2 && (t2[Yj.CONN_TYPE] = 1), "tcp" === i2 && (t2[Yj.CONN_TYPE] = 3), "tls" === i2 && (t2[Yj.CONN_TYPE] = 4);
            break;
          }
          case "srflx":
            t2[Yj.CONN_TYPE] = 2;
            break;
          case "unknown":
            t2[Yj.CONN_TYPE] = 5;
            break;
          default:
            t2[Yj.CONN_TYPE] = 0;
        }
        return t2;
      }
      function tG(e2) {
        let t2 = 0;
        switch (e2) {
          case "none":
            t2 = 0;
            break;
          case "cpu":
            t2 = 1;
            break;
          case "bandwidth":
            t2 = 2;
            break;
          case "other":
            t2 = 3;
        }
        return t2;
      }
      class iG extends NO {
        constructor(e2) {
          super(), iA(this, "store", void 0), iA(this, "uploadWRTCStatsTimer", void 0), iA(this, "uploadOutboundDenoiserStatsTimer", void 0), iA(this, "uploadExtStatsTimer", void 0), iA(this, "uploadExtUsageStatsTimer", void 0), iA(this, "uploadInboundExtStatsTimer", void 0), iA(this, "requestStats", void 0), iA(this, "requestTransportStats", void 0), iA(this, "requestLocalMedia", void 0), iA(this, "requestRemoteMedia", void 0), iA(this, "requestAllTracks", void 0), iA(this, "requestVideoIsReady", void 0), iA(this, "requestUploadStats", void 0), iA(this, "requestUpload", void 0), iA(this, "uploadOutboundStarted", false), iA(this, "uploadInboundStarted", false), iA(this, "uploadTransportStarted", false), iA(this, "uploadBaseStatsStarted", false), iA(this, "uploadExtensionUsageStarted", false), iA(this, "lastRecvStats", void 0), iA(this, "lastSendStats", void 0), iA(this, "lastRefRecvStats", void 0), iA(this, "lastRefSendStats", void 0), iA(this, "lastNormalRecvStats", void 0), iA(this, "lastNormalSendStats", void 0), iA(this, "lastExtendStats", {}), iA(this, "needUploadStats", {}), iA(this, "needUploadRenderFreezeTime", true), iA(this, "lastUploadCompensateTime", -1), iA(this, "uploadCompensateDeltaTime", 0), this.store = e2;
        }
        uploadWRTCStats(e2) {
          if (!this.requestStats || !this.requestUploadStats) return;
          const t2 = e2 % Qj == 0, i2 = e2 % Jj == 0, n2 = e2 % 60 == 0;
          let r2, o2;
          if (this.uploadTransportStarted && (r2 = this.requestStats(), this.store.useP2P && (o2 = this.requestStats(true))), !r2 && this.uploadOutboundStarted && (r2 = this.requestStats()), !o2 && this.uploadInboundStarted && (o2 = this.requestStats(true)), r2 || o2) {
            var s2;
            const a2 = {};
            if (this.uploadTransportStarted && r2) {
              const e3 = this.getTransportStats(r2, t2 ? this.lastRefSendStats : void 0, o2, t2);
              e3 && (a2.misc = [e3]);
            }
            if (this.uploadOutboundStarted && r2) {
              const e3 = this.getOutboundStats(r2, i2 ? this.lastNormalSendStats : void 0, t2 ? this.lastRefSendStats : void 0, this.lastSendStats, n2);
              e3 && (a2.outbound = [e3]);
            }
            if (this.uploadInboundStarted && o2) {
              this.uploadCompensateStats(e2);
              const n3 = this.getInboundStats(o2, i2 ? this.lastNormalRecvStats : void 0, t2 ? this.lastRefRecvStats : void 0, this.lastRecvStats);
              n3 && (a2.inbound = n3);
            }
            const c2 = null === (s2 = this.requestTransportStats) || void 0 === s2 ? void 0 : s2.call(this).connectState;
            if (c2 && (Array.isArray(a2.misc) ? a2.misc[0] && a2.misc[0].addition && (a2.misc[0].addition[zj.RTC_PEER_CONNECTION_STATE] = nD[c2]) : a2.misc = [{ addition: { [zj.RTC_PEER_CONNECTION_STATE]: nD[c2] } }]), eU.needUploadStats.length > 0 || i2) {
              const e3 = eU.needUploadStats.shift() || ("visible" === eU.visibility ? 1 : 0);
              Array.isArray(a2.misc) ? a2.misc[0] && a2.misc[0].addition && (a2.misc[0].addition[zj.PAGE_VISIBILITY] = e3) : a2.misc = [{ addition: { [zj.PAGE_VISIBILITY]: e3 } }];
            }
            this.needUploadStats.sendType && (Array.isArray(a2.outbound) && a2.outbound[0] && a2.outbound[0].high && (a2.outbound[0].high[Gj.Video_Send_Type] = this.needUploadStats.sendType), this.needUploadStats.sendType = void 0), this.requestUploadStats(a2);
          }
          this.lastRecvStats = o2, this.lastSendStats = r2, i2 && (this.lastNormalRecvStats = o2, this.lastNormalSendStats = r2), t2 && (this.lastRefRecvStats = o2, this.lastRefSendStats = r2);
        }
        startUploadWRTCStats() {
          if (this.uploadWRTCStatsTimer) return;
          this.uploadBaseStatsStarted = true, eU.startCollectStats();
          let e2 = 1;
          this.uploadWRTCStatsTimer = window.setInterval((() => {
            if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) {
              if (this.uploadBaseStatsStarted) {
                var t2, i2;
                const e3 = null === (t2 = this.requestTransportStats) || void 0 === t2 ? void 0 : t2.call(this);
                return void (e3 && (null === (i2 = this.requestUploadStats) || void 0 === i2 || i2.call(this, { misc: [{ addition: { [zj.RTC_PEER_CONNECTION_STATE]: nD[e3.connectState] } }] })));
              }
              return this.stopUploadWRTCStats();
            }
            this.uploadWRTCStats(e2), ++e2 === Zj + 1 && (e2 = 1);
          }), Xj);
        }
        uploadCompensateStats(e2) {
          if (!this.requestStats || !this.requestUploadStats || !this.requestRemoteMedia) return;
          const t2 = e2 % Qj == 0 && this.needUploadRenderFreezeTime;
          if (!this.uploadInboundStarted || !t2) return;
          if (-1 === this.lastUploadCompensateTime) return void (this.lastUploadCompensateTime = Date.now());
          const i2 = Math.max(-6e3, Date.now() - this.lastUploadCompensateTime - 6e3);
          if (this.uploadCompensateDeltaTime += i2, this.lastUploadCompensateTime = Date.now(), this.uploadCompensateDeltaTime < 6e3) return;
          const n2 = Math.min(Math.floor(this.uploadCompensateDeltaTime / 6e3), 10);
          this.uploadCompensateDeltaTime -= 6e3 * n2;
          const r2 = this.requestStats(true);
          new Array(n2).fill(0).forEach((() => {
            if (!this.requestStats || !this.requestUploadStats || !this.requestRemoteMedia) return;
            const e3 = {};
            if (this.uploadInboundStarted && r2) {
              const t3 = this.requestRemoteMedia() || [], i3 = [];
              t3.forEach(((e4) => {
                let [t4, n3] = e4;
                const o2 = { peer: t4.uid };
                if ((t4._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(t4._videoSSRC) || false) && n3.has(fx.VIDEO) && t4.videoTrack) {
                  const e5 = (function(e6, t5, i4) {
                    if (!t5.videoRecv.find(((t6) => t6.ssrc === e6))) return;
                    const n4 = {};
                    if (i4 && i4._player) {
                      const e7 = i4._player, { renderFreezeAccTime2: t6, videoElementStatus: r3 } = e7;
                      if ("visible" === eU.visibility && r3 === tL.PLAYING && pP().supportRequestVideoFrameCallback) {
                        const i5 = Math.min(6e3, t6);
                        e7.renderFreezeAccTime2 = Math.max(0, t6 - i5), $j(n4, Wj.Video_Render_Freeze_Time_Render2, i5), CD("USE_NEW_RENDER_FREEZE_TIME") && $j(n4, Wj.Video_Render_Freeze_Time_Render, i5);
                      }
                    }
                    return n4;
                  })(t4._videoSSRC, r2, t4.videoTrack);
                  e5 && (o2.video = e5);
                }
                o2.video && i3.push(o2);
              })), i3.length > 0 && (e3.inbound = i3, this.requestUploadStats(e3));
            }
          }));
        }
        stopUploadWRTCStats() {
          window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0), this.lastRefSendStats && (this.lastRefSendStats.videoSend = [], this.lastRefSendStats.audioSend = [], this.lastRefSendStats = void 0), this.lastRefRecvStats && (this.lastRefRecvStats.videoRecv = [], this.lastRefRecvStats.audioRecv = [], this.lastRefRecvStats = void 0), this.lastNormalSendStats && (this.lastNormalSendStats.videoSend = [], this.lastNormalSendStats.audioSend = [], this.lastNormalSendStats = void 0), this.lastNormalRecvStats && (this.lastNormalRecvStats.videoRecv = [], this.lastNormalRecvStats.audioRecv = [], this.lastNormalRecvStats = void 0), this.lastExtendStats = {}, this.needUploadStats = {}, this.lastUploadCompensateTime = -1, this.uploadCompensateDeltaTime = 0, this.needUploadRenderFreezeTime = true;
        }
        getTransportStats(e2, t2, i2, n2) {
          if (!this.requestStats) return;
          if (!n2) return null == e2.rtt ? void 0 : { addition: { [Yj.RTT]: e2.rtt, [Yj.CONN_TYPE]: void 0, [Yj.STATS_UPDATE_INTERVAL]: e2.updateInterval || void 0 } };
          const r2 = eG(e2);
          if (this.store.useP2P) {
            if (i2) {
              const e3 = eG(i2);
              r2[Yj.CONN_TYPE] && e3[Yj.CONN_TYPE] && (r2[Yj.CONN_TYPE] += e3[Yj.CONN_TYPE] << 3);
            }
            r2[Yj.CONN_TYPE] ? r2[Yj.CONN_TYPE] += 110 : r2[Yj.CONN_TYPE] = 110;
          } else {
            r2[Yj.CONN_TYPE] ? r2[Yj.CONN_TYPE] += 100 : r2[Yj.CONN_TYPE] = 100;
            const i3 = (function(e3, t3) {
              if (t3) return [Math.ceil(8 * (e3.transport.bytesSent - t3.transport.bytesSent) / (e3.timestamp - t3.timestamp)), Math.ceil(8 * (e3.transport.bytesReceived - t3.transport.bytesReceived) / (e3.timestamp - t3.timestamp))];
              return [0, 0];
            })(e2, t2);
            r2[qj.Transport_Send_Bitrate] = i3[0], r2[qj.Transport_Recv_Bitrate] = i3[1];
          }
          return { addition: r2 };
        }
        getOutboundStats(e2, t2, i2, n2, r2) {
          if (!this.requestUploadStats || !this.requestLocalMedia) return;
          const o2 = this.requestLocalMedia();
          if (!o2 || 0 === o2.length) return;
          let s2, a2, c2;
          return o2.forEach(((n3) => {
            let [o3, { track: d2, ssrcs: l2 }] = n3;
            switch (o3) {
              case Rx.LocalVideoLowTrack:
              case Rx.LocalVideoTrack:
                if (o3 === Rx.LocalVideoTrack) {
                  var u2;
                  const n4 = (function(e3, t3, i3, n5, r3, o5) {
                    const s4 = t3.videoSend.find(((t4) => t4.ssrc === e3));
                    if (!s4) return;
                    const a3 = {}, { sentFrame: c4, inputFrame: d3 } = s4;
                    if (n5 && ($j(a3, Wj.Video_Send_Qp_Sum, s4.qpSumPerFrame), d3 && c4)) {
                      const e4 = d3.frameRate, t4 = c4.frameRate;
                      a3[Wj.Video_Send_Freeze] = (function(e5, t5) {
                        let i4 = true;
                        return i4 = !(e5 <= 5) && (e5 <= 10 ? t5 < 3 : e5 <= 20 ? t5 < 4 : t5 < 5), i4;
                      })(e4, t4) ? 1 : 0;
                    }
                    if (r3) {
                      switch (c4 && ($j(a3, Hj.Video_Send_Height, c4.height), $j(a3, Hj.Video_Send_Width, c4.width), $j(a3, Hj.Video_Send_Frame_Rate, c4.frameRate)), a3[Hj.Video_Send_Disabled] = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? 1 : 0, s4.adaptionChangeReason) {
                        case "none":
                          a3[Hj.Video_Send_Adaptation] = 0;
                          break;
                        case "cpu":
                          a3[Hj.Video_Send_Adaptation] = 1;
                          break;
                        case "bandwidth":
                          a3[Hj.Video_Send_Adaptation] = 2;
                          break;
                        case "other":
                          a3[Hj.Video_Send_Adaptation] = 3;
                      }
                      let n6 = 0;
                      s4.adaptionChangeReason && (n6 += tG(s4.adaptionChangeReason)), t3.qualityLimitationReason && (n6 += tG(t3.qualityLimitationReason) << 3), a3[Hj.Video_Send_Adaptation] = n6, a3[Hj.Video_Send_Player_Status] = nL[i3._player ? i3._player.videoElementStatus : "uninit"], $j(a3, Hj.Video_Send_Nacks, s4.nacksCount), $j(a3, Hj.Video_Send_Plis, s4.plisCount), $j(a3, Hj.Video_Send_Firs, s4.firsCount), $j(a3, Hj.Video_Send_Avg_Encode, s4.avgEncodeMs), $j(a3, Hj.Video_Send_Huge_Frame_Sent, s4.hugeFramesSent), $j(a3, Hj.Video_Send_Bytes_Retransmit, s4.retransmittedBytesSent), $j(a3, Hj.Video_Send_Packages_Retransmit, s4.retransmittedPacketsSent), $j(a3, Hj.Video_Send_Key_Frames_Encoded, s4.keyFramesEncoded);
                      const o6 = r3.videoSend.find(((t4) => t4.ssrc === e3));
                      if (o6) {
                        let e4 = Xj * Qj;
                        o6.timestamp && s4.timestamp && (e4 = s4.timestamp - o6.timestamp), null != o6.packets && null != s4.packets && $j(a3, Hj.Video_Send_Package_Rate, 1e3 * (s4.packets - o6.packets) / e4), null != s4.packetsLost && null != o6.packetsLost && $j(a3, Hj.Video_Send_Package_Lost, s4.packetsLost - o6.packetsLost), null != o6.bytes && null != s4.bytes && $j(a3, Hj.Video_Send_Bitrate, 8 * (s4.bytes - o6.bytes) / e4);
                      }
                    }
                    return a3;
                  })(l2[0].ssrcId, e2, d2, t2, i2), o4 = "CameraVideoTrack" === d2.__className__ ? 3 : Ln(u2 = d2._hints).call(u2, VP.SCREEN_TRACK) ? 7 : 10;
                  (this.lastExtendStats.sendType !== o4 || r2) && (this.needUploadStats = { sendType: o4 }, this.lastExtendStats.sendType = o4);
                  const s3 = d2 && (function(e3, t3, i3, n5) {
                    const r3 = t3.videoSend.find(((t4) => t4.ssrc === e3));
                    if (!r3) return null;
                    const o5 = {};
                    if (n5) {
                      const e4 = r3.inputFrame, t4 = e4 && e4.height || i3.videoHeight || 0, n6 = e4 && e4.width || i3.videoWidth || 0, s4 = e4 && e4.frameRate || 0;
                      $j(o5, Hj.Video_Capture_Height, t4), $j(o5, Hj.Video_Capture_Width, n6), $j(o5, Hj.Video_Capture_Frame_Rate, s4);
                    }
                    return o5;
                  })(l2[0].ssrcId, e2, d2, !!i2), c3 = (function(e3, t3) {
                    const i3 = {};
                    return t3 && ($j(i3, Hj.Video_Send_Retransmit, e3.bitrate.retransmit), $j(i3, Hj.Video_Send_Target_Encoded, e3.bitrate.targetEncoded), $j(i3, Hj.Video_Send_Actual_Encoded, e3.bitrate.actualEncoded), $j(i3, Hj.Video_Send_Transmit, e3.bitrate.transmit), $j(i3, Hj.Video_Send_Bandwidth, e3.sendBandwidth)), i3;
                  })(e2, !!i2);
                  a2 = Object.assign({}, n4, s3, c3);
                } else c2 = (function(e3, t3, i3, n4, r3) {
                  const o4 = t3.videoSend.find(((t4) => t4.ssrc === e3));
                  if (!o4) return;
                  const s3 = {};
                  if (n4) {
                    const t4 = o4.sentFrame;
                    t4 && ($j(s3, Hj.Video_Send_Low_Height, t4.height), $j(s3, Hj.Video_Send_Low_Width, t4.width), $j(s3, Hj.Video_Send_Low_Frame_Rate, t4.frameRate));
                    const i4 = n4.videoSend.find(((t5) => t5.ssrc === e3));
                    if (i4) {
                      let e4 = Xj * Jj;
                      i4.timestamp && o4.timestamp && (e4 = o4.timestamp - i4.timestamp), null != i4.packets && null != o4.packets && $j(s3, Hj.Video_Send_Low_Package_Rate, 1e3 * (o4.packets - i4.packets) / e4), null != o4.packetsLost && null != i4.packetsLost && $j(s3, Hj.Video_Send_Low_Package_Lost, o4.packetsLost - i4.packetsLost), null != i4.bytes && null != o4.bytes && $j(s3, Hj.Video_Send_Low_Bitrate, 8 * (o4.bytes - i4.bytes) / e4);
                    }
                  }
                  return s3;
                })(l2[0].ssrcId, e2, 0, i2);
                break;
              case Rx.LocalAudioTrack:
                s2 = d2 && (function(e3, t3, i3, n4, r3, o4) {
                  const s3 = t3.audioSend.find(((t4) => t4.ssrc === e3));
                  if (!s3) return;
                  const a3 = {};
                  if (r3) {
                    a3[Hj.Audio_Send_Disabled] = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? 1 : 0;
                    const t4 = 100 * i3._source.getAccurateVolumeLevel(), n5 = s3.inputLevel;
                    if (null != n5) {
                      const e4 = Math.ceil(50 * Math.log10(100 * n5 + 1));
                      $j(a3, Hj.Audio_Send_Level, e4);
                    }
                    $j(a3, Hj.Audio_Capture_PCM_Level, t4), $j(a3, Hj.Audio_Send_AEC_Return_Loss, s3.aecReturnLoss), $j(a3, Hj.Audio_Send_AEC_Return_Loss_Enhancement, s3.aecReturnLossEnhancement), $j(a3, Hj.Audio_Send_Bytes_Retransmit, s3.retransmittedBytesSent), $j(a3, Hj.Audio_Send_Packages_Retransmit, s3.retransmittedPacketsSent), a3[Hj.Audio_Send_Freeze] = 0;
                    const o5 = r3.audioSend.find(((t5) => t5.ssrc === e3));
                    if (o5) {
                      let e4 = Xj * Jj;
                      o5.timestamp && s3.timestamp && (e4 = s3.timestamp - o5.timestamp), null != o5.bytes && null != s3.bytes && $j(a3, Hj.Audio_Send_Bitrate, 8 * (s3.bytes - o5.bytes) / e4), null != o5.packets && null != s3.packets && $j(a3, Hj.Audio_Send_Package_Rate, 1e3 * (s3.packets - o5.packets) / e4);
                    }
                  }
                  return a3;
                })(l2[0].ssrcId, e2, d2, 0, i2);
            }
          })), { high: a2, low: c2, audio: s2 };
        }
        getInboundStats(e2, t2, i2, n2) {
          if (!this.requestRemoteMedia) return;
          const r2 = this.requestRemoteMedia() || [], o2 = [];
          return r2.forEach(((r3) => {
            let [s2, a2] = r3;
            const c2 = { peer: s2.uid };
            let d2;
            if (a2.has(fx.VIDEO) && s2.videoTrack) {
              const r4 = s2._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(s2._videoSSRC) || false, o3 = s2.videoTrack ? (function(e3, t3, i3, n3, r5, o4, s3, a3) {
                const c3 = t3.videoRecv.find(((t4) => t4.ssrc === e3));
                if (!c3) return;
                const d3 = {}, { receivedFrame: l2, outputFrame: u2, decodeFrameRate: h2 } = c3;
                $j(d3, Kj.Video_Render_Frame_Rate_Decode, h2), c3.framesRateFirefox && $j(d3, Kj.Video_Recv_Frame_Rate, c3.framesRateFirefox), l2 && $j(d3, Kj.Video_Recv_Frame_Rate, l2.frameRate), $j(d3, Kj.Video_Recv_Frame_Dropped, c3.framesDroppedCount), $j(d3, Kj.Video_Recv_Bytes_Retransmit, c3.retransmittedBytesReceived), $j(d3, Kj.Video_Recv_Packages_Retransmit, c3.retransmittedPacketsReceived), $j(d3, Kj.Video_Recv_Packages_Discarded, c3.packetsDiscarded), $j(d3, Kj.Video_Recv_Avg_Decode, c3.avgDecodeMs), $j(d3, Kj.Video_Recv_Avg_Processing_Delay, c3.avgProcessingDelayMs), $j(d3, Kj.Video_Recv_Avg_Assembly_Time, c3.avgFramesAssembledFromMultiplePacketsMs), $j(d3, Kj.Video_Recv_Avg_Inter_Frame_Delay, c3.avgInterFrameDelayMs), $j(d3, Kj.Video_Recv_Key_Frames_Decoded, c3.keyFramesDecoded);
                const p2 = a3 && a3.videoRecv.find(((t4) => t4.ssrc === e3));
                if (p2) {
                  const e4 = t3.timestamp - a3.timestamp || Xj;
                  null != c3.packetsLost && null != p2.packetsLost && $j(d3, Kj.Video_Recv_Package_Lost, c3.packetsLost - p2.packetsLost), null != p2.bytes && null != c3.bytes && $j(d3, Kj.Video_Recv_Bitrate, 8 * (c3.bytes - p2.bytes) / e4), null != p2.packets && null != c3.packets && $j(d3, Kj.Video_Recv_Package_Rate, 1e3 * (c3.packets - p2.packets) / e4);
                }
                const _2 = o4 && o4.videoRecv.find(((t4) => t4.ssrc === e3));
                if (_2 && ($j(d3, Wj.Video_Recv_Qp_Sum, c3.qpSumPerFrame), d3[Wj.Video_Recv_Freeze] = n3 && rj.isRemoteVideoFreeze(i3, c3, _2) ? 1 : 0), s3) {
                  var E2;
                  const t4 = s3.videoRecv.find(((t5) => t5.ssrc === e3));
                  l2 ? ($j(d3, Hj.Video_Recv_Height, l2.height), $j(d3, Hj.Video_Recv_Width, l2.width)) : i3 && ($j(d3, Hj.Video_Recv_Height, i3._videoHeight || 0), $j(d3, Hj.Video_Recv_Width, i3._videoWidth || 0)), u2 && $j(d3, Hj.Video_Recv_Frame_Rate_Output, u2.frameRate);
                  const n4 = null === (E2 = i3._player) || void 0 === E2 ? void 0 : E2.rendFrameRate.toFixed(0);
                  if (n4 && $j(d3, Hj.Video_Render_Frame_Rate_Render, +n4), $j(d3, Hj.Video_Recv_Jitter_Buffer, c3.jitterBufferMs), $j(d3, Hj.Video_Recv_Current_Delay, c3.currentDelayMs), $j(d3, Hj.Video_Recv_Firs, c3.firsCount), $j(d3, Hj.Video_Recv_Nacks, c3.nacksCount), $j(d3, Hj.Video_Recv_Plis, c3.plisCount), i3) {
                    d3[Hj.Video_Recv_Disabled] = i3._originMediaStreamTrack.enabled && i3._mediaStreamTrack.enabled ? 0 : 1;
                    const e4 = i3._player;
                    if (e4) {
                      const { freezeTimeCounterList: i4, renderFreezeAccTime: n5, renderFreezeAccTime2: o5, videoElementStatus: s4 } = e4;
                      if (i4 && i4.length > 0 && $j(d3, Wj.Video_Render_Freeze_Time, i4.splice(0, 1)[0]), r5 && "visible" === eU.visibility && s4 === tL.PLAYING && pP().supportRequestVideoFrameCallback) {
                        const t5 = Math.min(6e3, o5);
                        e4.renderFreezeAccTime2 = Math.max(0, o5 - t5), $j(d3, Wj.Video_Render_Freeze_Time_Render2, t5);
                        const i5 = Math.min(6e3, n5);
                        e4.renderFreezeAccTime = Math.max(0, n5 - i5), $j(d3, Wj.Video_Render_Freeze_Time_Render, CD("USE_NEW_RENDER_FREEZE_TIME") ? t5 : i5);
                      }
                      if ("number" == typeof c3.totalFreezesDuration) {
                        const e5 = t4 && t4.totalFreezesDuration ? c3.totalFreezesDuration - t4.totalFreezesDuration : c3.totalFreezesDuration;
                        $j(d3, Hj.Video_Render_Freeze_Duration, 1e3 * e5);
                      }
                    }
                  }
                  if (d3[Hj.Video_Recv_Player_Status] = nL[i3._player ? i3._player.videoElementStatus : "uninit"], t4 && void 0 !== c3.totalInterFrameDelay && void 0 !== c3.totalSquaredInterFrameDelay && void 0 !== t4.totalInterFrameDelay && void 0 !== t4.totalSquaredInterFrameDelay) {
                    const e4 = c3.totalInterFrameDelay - t4.totalInterFrameDelay, i4 = c3.totalSquaredInterFrameDelay - t4.totalSquaredInterFrameDelay, n5 = c3.framesDecodeCount - t4.framesDecodeCount, r6 = e4 / n5 * 1e3, o5 = Math.round(1e3 * Math.sqrt((i4 - Math.pow(e4, 2) / n5) / n5));
                    !isNaN(o5) && r6 + o5 > Math.max(3 * r6, r6 + 150) && (d3[Hj.Video_Recv_I_Frame_Delay] = o5);
                  }
                }
                return d3;
              })(s2._videoSSRC, e2, s2.videoTrack, true === r4, this.needUploadRenderFreezeTime, t2, i2, n2) : void 0;
              if (o3 && (c2.video = o3), s2.videoTrack) {
                const t3 = e2.videoRecv.find(((e3) => e3.ssrc === s2._videoSSRC));
                t3 && t3.estimatedPlayoutTimestamp && (d2 = t3.estimatedPlayoutTimestamp);
              }
            }
            if (a2.has(fx.AUDIO) && s2.audioTrack) {
              const r4 = s2.audioTrack ? (function(e3, t3, i3, n3, r5, o3) {
                const s3 = t3.audioRecv.find(((t4) => t4.ssrc === e3));
                if (!s3) return;
                const a3 = {};
                $j(a3, Kj.Audio_Recv_Jitter, s3.jitterMs), $j(a3, Kj.Audio_Recv_Bytes_Retransmit, s3.retransmittedBytesReceived), $j(a3, Kj.Audio_Recv_Packages_Retransmit, s3.retransmittedPacketsReceived), $j(a3, Kj.Audio_Recv_Packages_Discarded, s3.packetsDiscarded), $j(a3, Kj.Audio_Recv_Avg_Processing_Delay, s3.avgProcessingDelayMs);
                const c3 = o3 && o3.audioRecv.find(((t4) => t4.ssrc === e3));
                if (c3) {
                  const e4 = Xj;
                  null != s3.packets && null != c3.packets && $j(a3, Kj.Audio_Recv_Package_Rate, 1e3 * (s3.packets - c3.packets) / e4), null != s3.packetsLost && null != c3.packetsLost && $j(a3, Kj.Audio_Recv_Package_Lost, s3.packetsLost - c3.packetsLost);
                }
                if (n3) {
                  const { receivedFrames: e4, droppedFrames: t4 } = s3;
                  null != e4 && null != t4 && (a3[Wj.Audio_Recv_Freeze] = 0 === (d3 = e4) || 100 * t4 / d3 > 20 ? 1 : 0);
                }
                var d3;
                if (r5) {
                  const t4 = 100 * i3._source.getAccurateVolumeLevel(), n4 = s3.outputLevel;
                  if (null != n4) {
                    const e4 = Math.ceil(50 * Math.log10(100 * n4 + 1));
                    $j(a3, Hj.Audio_Render_Level, e4);
                  }
                  $j(a3, Hj.Audio_Recv_PCM_Level, t4), i3 && (a3[Hj.Audio_Recv_Disabled] = i3._originMediaStreamTrack.enabled && i3._mediaStreamTrack.enabled ? 0 : 1), $j(a3, Hj.Audio_Recv_Jitter_Buffer, s3.jitterBufferMs), $j(a3, Hj.Audio_Recv_Current_Delay, s3.jitterBufferMs), a3[Hj.Audio_Recv_Player_Status] = nL[xL.getPlayerState(i3.getTrackId())];
                  const o4 = r5.audioRecv.find(((t5) => t5.ssrc === e3));
                  if (o4) {
                    null != o4.bytes && null != s3.bytes && $j(a3, Hj.Audio_Recv_Bitrate, 8 * (s3.bytes - o4.bytes) / (Xj * Qj));
                    const e4 = s3.concealedSamples - o4.concealedSamples;
                    e4 > 0 && $j(a3, Hj.Audio_Recv_Concealed_Samples, e4);
                    const t5 = s3.totalSamplesReceived - o4.totalSamplesReceived;
                    t5 > 0 && $j(a3, Hj.Audio_Recv_Total_Samples_Received, t5);
                    const i4 = s3.freezeSamples80 - o4.freezeSamples80;
                    i4 > 0 && $j(a3, Hj.Audio_Render_Freeze_Samples_80ms, i4);
                    const n5 = s3.freezeSamples200 - o4.freezeSamples200;
                    n5 > 0 && $j(a3, Hj.Audio_Render_Freeze_Samples_200ms, n5);
                    const r6 = s3.freezeMs80 - o4.freezeMs80;
                    $j(a3, Hj.Audio_Render_Freeze_Time_80ms, r6 < 0 ? 0 : r6);
                    const c4 = s3.freezeMs200 - o4.freezeMs200;
                    $j(a3, Hj.Audio_Render_Freeze_Time_200ms, c4 < 0 ? 0 : c4);
                  }
                }
                return a3;
              })(s2._audioSSRC, e2, s2.audioTrack, t2, i2, n2) : void 0;
              if (r4 && (c2.audio = r4), s2.audioTrack && d2) {
                const t3 = e2.audioRecv.find(((e3) => e3.ssrc === s2._audioSSRC));
                if (t3 && t3.estimatedPlayoutTimestamp) {
                  const e3 = t3.estimatedPlayoutTimestamp - d2;
                  c2.audio ? c2.audio[Kj.Audio_Recv_AV_Sync_TIME] = e3 : c2.audio = { [Kj.Audio_Recv_AV_Sync_TIME]: e3 };
                }
              }
            }
            (c2.video || c2.audio) && o2.push(c2);
          })), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, o2;
        }
        startUploadTransportStats() {
          this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted = false;
        }
        startUploadOutboundStats() {
          this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval((() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            const e2 = (this.requestAllTracks() || []).find(((e3) => e3 instanceof jk));
            if (e2 && e2._external.getDenoiserStats) {
              const t2 = e2._external.getDenoiserStats();
              t2 && this.requestUpload(BV.DENOISER_STATS, t2);
            }
          }), 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval((() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            this.requestAllTracks().forEach(((e2) => {
              e2.getProcessorStats().forEach(((e3) => {
                this.requestUpload && this.requestUpload(e3.type, e3.stats);
              }));
            }));
          }), 2e3));
        }
        stopUploadOutboundStats() {
          this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRefSendStats && (this.lastRefSendStats.videoSend = [], this.lastRefSendStats.audioSend = [], this.lastRefSendStats = void 0), this.lastNormalSendStats && (this.lastNormalSendStats.videoSend = [], this.lastNormalSendStats.audioSend = [], this.lastNormalSendStats = void 0), this.lastExtendStats = {}, this.needUploadStats = {}, this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0, this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = void 0);
        }
        startUploadInboundStats() {
          this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval((() => {
            if (!this.requestUpload || !this.requestRemoteMedia) return;
            (this.requestRemoteMedia() || []).forEach(((e2) => {
              let [t2, i2] = e2;
              if (i2.has(fx.VIDEO) && t2.videoTrack) {
                t2.videoTrack.getProcessorStats().forEach(((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                }));
              }
              if (i2.has(fx.AUDIO) && t2.audioTrack) {
                t2.audioTrack.getProcessorStats().forEach(((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                }));
              }
            }));
          }), 2e3));
        }
        stopUploadInboundStats() {
          this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0), this.lastRefRecvStats && (this.lastRefRecvStats.videoRecv = [], this.lastRefRecvStats.audioRecv = [], this.lastRefRecvStats = void 0), this.lastNormalRecvStats && (this.lastNormalRecvStats.videoRecv = [], this.lastNormalRecvStats.audioRecv = [], this.lastNormalRecvStats = void 0), this.lastUploadCompensateTime = -1, this.uploadCompensateDeltaTime = 0, this.needUploadRenderFreezeTime = true, this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = void 0);
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted) return;
          this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
          const e2 = /* @__PURE__ */ new Map();
          this.uploadExtUsageStatsTimer = window.setInterval((async () => {
            const t2 = Date.now(), i2 = { connectionInterval: CD("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: t2 };
            let n2 = [];
            const r2 = this.requestAllTracks && this.requestAllTracks() || [];
            for (const e3 of r2) !e3.muted && e3.enabled && (n2 = n2.concat(await e3.getProcessorUsage()));
            const o2 = this.requestRemoteMedia && this.requestRemoteMedia() || [];
            for (const [e3, t3] of o2) t3.has(fx.VIDEO) && e3.videoTrack && (n2 = n2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(fx.AUDIO) && e3.audioTrack && (n2 = n2.concat(await e3.audioTrack.getProcessorUsage()));
            if (0 === n2.length) return;
            i2.details = (function(e3, t3) {
              const i3 = {};
              for (const { id: s3, value: a3, level: c2, direction: d2 } of e3) {
                var n3;
                const e4 = null !== (n3 = t3.get(s3)) && void 0 !== n3 ? n3 : 0, l2 = 2 === a3 ? e4 + CD("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                var r3, o3;
                t3.set(s3, l2), i3[s3] ? (2 === a3 && (i3[s3].value = a3), c2 > i3[s3].level && (i3[s3].level = c2), "remote" === d2 && (i3[s3].remoteUidCount += 1), i3[s3].totalTs = null !== (r3 = t3.get(s3)) && void 0 !== r3 ? r3 : 0) : i3[s3] = { value: a3, level: c2, remoteUidCount: "local" === d2 ? 0 : 1, totalTs: null !== (o3 = t3.get(s3)) && void 0 !== o3 ? o3 : 0 };
              }
              return Object.keys(i3).map(((e4) => {
                const { level: t4, value: n4, totalTs: r4 } = i3[e4];
                return { id: e4, level: t4, value: n4, totalTs: r4 };
              }));
            })(n2, e2);
            const s2 = Date.now(), a2 = s2 > t2 ? s2 : t2 + 1;
            this.requestUpload && this.requestUpload(BV.EXTENSION_USAGE_STATS, { usageStats: i2, sendTs: a2 });
          }), CD("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
        }
        stopUploadBaseStats() {
          this.uploadBaseStatsStarted = false, eU.stopCollectStats();
        }
      }
      const nG = CD("ICE_RESTART_INTERVAL");
      let rG = /* @__PURE__ */ new Map(), oG = /* @__PURE__ */ new Map(), sG = [Sx.UDP_TCP_RELAY, Sx.TCP_RELAY, Sx.RELAY], aG = CD("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && pP().supportPCSetConfiguration;
      function cG(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = rG.get(e2.id);
        i2 && (window.clearTimeout(i2), rG.delete(e2.id));
        const n2 = oG.get(e2.id);
        t2 && n2 && n2.index === sG.length - 1 && (iP.debug("[".concat(e2.id, "] reset ICE restart policy")), oG.delete(e2.id));
      }
      function dG(e2, t2, i2) {
        if (0 === rG.size && 0 === oG.size && (Array.isArray(CD("RESTART_SEQUENCE")) && CD("RESTART_SEQUENCE").length > 0 && !(function(e3, t3) {
          if (e3.length !== t3.length) return false;
          for (let i3 = 0; i3 < e3.length; i3 += 1) {
            const n3 = e3[i3];
            if (e3.filter(((e4) => e4 === n3)).length !== t3.filter(((e4) => e4 === n3)).length) return false;
          }
          return true;
        })(sG, CD("RESTART_SEQUENCE")) && (sG = CD("RESTART_SEQUENCE").filter(((e3) => {
          var t3;
          if (Ln(t3 = Object.values(Sx)).call(t3, e3)) return true;
        })), iP.debug("use reconnection policy from config distribution, queues: ".concat(sG.join(" => ")))), aG = CD("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && pP().supportPCSetConfiguration), 0 === sG.length) return void i2();
        let n2, { index: r2 = 0, type: o2 } = oG.get(e2.id) || {};
        if (aG && o2 === Sx.RELAY) return void i2();
        let s2 = o2 && r2 >= sG.length - 1;
        if (aG) o2 = Sx.RELAY;
        else {
          if (s2) return void i2();
          o2 ? (r2++, o2 = sG[r2]) : (o2 = sG[0], r2 = 0);
        }
        iP.debug("[".concat(e2.id, "] choose ICE restart policy: ").concat(o2, ", index: ").concat(r2)), t2(o2), oG.set(e2.id, { index: r2, type: o2 }), n2 = window.setTimeout((() => dG(e2, t2, i2)), nG), rG.set(e2.id, n2);
      }
      var lG;
      function uG(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function hG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? uG(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : uG(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      function pG(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = Fb, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2])) return t2.call(e2);
          if (n2 && null != (t2 = e2[n2])) return new _G(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function _G(e2) {
        function t2(e3) {
          if (Object(e3) !== e3) return rp.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return rp.resolve(e3.value).then((function(e4) {
            return { value: e4, done: t3 };
          }));
        }
        return _G = function(e3) {
          this.s = e3, this.n = e3.next;
        }, _G.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new _G(e2);
      }
      let EG = (lG = class extends NO {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(vx.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), iA(this, "isPlanB", void 0), iA(this, "store", void 0), iA(this, "statsUploader", void 0), iA(this, "connection", void 0), iA(this, "localTrackMap", /* @__PURE__ */ new Map()), iA(this, "remoteUserMap", /* @__PURE__ */ new Map()), iA(this, "localDataChannels", []), iA(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), iA(this, "pendingLocalTracks", []), iA(this, "pendingRemoteTracks", []), iA(this, "pendingLocalDataChannels", []), iA(this, "pendingRemoteDataChannels", []), iA(this, "statsCollector", void 0), iA(this, "shouldForwardP2PCreation", void 0), iA(this, "iceFailedCount", 0), iA(this, "dtlsFailedCount", 0), iA(this, "mutex", void 0), iA(this, "_state", Cx.Disconnected), iA(this, "_pcStatsUploadType", CD("NEW_ICE_RESTART") ? gx.FIRST_CONNECTION : gx.OLD_FIRST_CONNECTION), iA(this, "_isStartRestartIce", false), iA(this, "_restartTimer", void 0), iA(this, "_isTryConnecting", false), iA(this, "_iceError", null), iA(this, "_forceTurn", false), iA(this, "_isWaitPcToRePub", false), iA(this, "handleMuteLocalTrack", (async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection || this.state !== Cx.Connected) return void i2(new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              const r2 = this.filterTobeMutedTracks(e3);
              if (0 === r2.length) return void t3();
              const o2 = r2.find(((e4) => "videoLowTrack" === e4[0]));
              if (o2) {
                const e4 = o2[1];
                this.store.enableInstantMuteRestore ? (e4.track._originMediaStreamTrack.enabled = false, iP.info("[".concat(this.store.clientId, "] P2PChannel muteLocalLowTrack without close sender because enableInstantMuteRestore is true"))) : e4.track._originMediaStreamTrack.stop();
              }
              this.store.enableInstantMuteRestore ? iP.info("[".concat(this.store.clientId, "] P2PChannel muteLocalTrack without close sender because enableInstantMuteRestore is true")) : await this.connection.muteLocal(r2.map(((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              })));
              const s2 = this.createMuteMessage(r2);
              await qO(this, vx.RequestMuteLocal, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleUnmuteLocalTrack", (async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection || this.state !== Cx.Connected) return void i2(new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t3();
              const o2 = r2.find(((e4) => "videoLowTrack" === e4[0]));
              if (o2) {
                const t4 = o2[1];
                if (this.store.enableInstantMuteRestore) t4.track._originMediaStreamTrack.enabled = true, iP.info("[".concat(this.store.clientId, "] P2PChannel unmuteLocalLowTrack without close sender because enableInstantMuteRestore is true"));
                else {
                  if (t4.track._originMediaStreamTrack.stop(), !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding) {
                    const i3 = e3._mediaStreamTrack.clone();
                    t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                  } else {
                    const i3 = jj(e3, JO(this, vx.RequestLowStreamParameter));
                    t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                  }
                  await new rp(((e4, i3) => {
                    this.handleReplaceTrack(t4.track, e4, i3, true);
                  }));
                }
              }
              this.store.enableInstantMuteRestore ? iP.info("[".concat(this.store.clientId, "] P2PChannel unmuteLocalTrack without close sender because enableInstantMuteRestore is true")) : await this.connection.unmuteLocal(r2.map(((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              })));
              const s2 = this.createUnmuteMessage(r2);
              await qO(this, vx.RequestUnmuteLocal, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleUpdateVideoEncoder", (async (e3, t3, i2, n2) => {
            let r2;
            n2 || (r2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoEncoder"));
            try {
              const i3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== Cx.Connected) return void t3();
              const { id: n3, track: s2 } = i3;
              await this.connection.updateSendParameters(n3, s2), await this.connection.updateEncoderConfig(n3, s2), this.emit(vx.UpdateVideoEncoder, s2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          })), iA(this, "handleUpdateVideoSendParameters", (async (e3, t3, i2) => {
            const n2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoSendParameters");
            try {
              const i3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== Cx.Connected) return void t3();
              const { id: r2, track: o2 } = i3;
              await this.connection.updateSendParameters(r2, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleReplaceMixingTrack", (async (e3, t3, i2, n2) => {
            if (!this.connection || this.state !== Cx.Connected) return void t3();
            const r2 = Dj([e3]);
            let o2;
            iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(r2.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (o2 = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
            try {
              await this.replaceTrack(e3, r2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = o2) || void 0 === s2 || s2();
            }
          })), iA(this, "handleReplaceTrack", (async (e3, t3, i2, n2) => {
            let r2;
            iP.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var o2;
              const i3 = Array.from(this.localTrackMap.entries()).find(((t4) => {
                let [, { track: i4 }] = t4;
                return e3 === i4;
              }));
              if (!this.connection || !i3 || this.state !== Cx.Connected) return void t3();
              if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i3[1].id)), this.isPlanB) {
                const t4 = i3[1];
                t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t4);
              }
              if (i3[0] === Rx.LocalVideoTrack && !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
                if (t4) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new rp(((e4, i5) => {
                    this.handleReplaceTrack(t4.track, e4, i5, true);
                  }));
                }
              }
              t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          })), iA(this, "handleGetRTCStats", ((e3) => {
            e3(this.statsCollector.getRTCStats());
          })), iA(this, "handleGetLocalVideoStats", ((e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          })), iA(this, "handleGetLocalAudioStats", ((e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          })), iA(this, "handleGetRemoteVideoStats", ((e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid])), iA(this, "handleGetRemoteAudioStats", ((e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid])), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new iG(this.store), this.bindStatsUploaderEvents(), this.mutex = new PN("P2PChannel-mutex", this.store.clientId), this.isPlanB = !pP().supportUnifiedPlan || CD("CHROME_FORCE_PLAN_B") && sO(), this.shouldForwardP2PCreation = CD("FORWARD_P2P_CREATION") && pP().supportPCSetConfiguration && oO(), this.shouldForwardP2PCreation && (this.connection = Lj(this.store), this.emit(vx.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection));
        }
        async startP2PConnection(e2, t2) {
          var i2;
          this.state = Cx.New, this._forceTurn = Mj(e2), iP.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] forceTurn: ").concat(this._forceTurn));
          const n2 = this.shouldForwardP2PCreation && "closed" === (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.peerConnectionState);
          if ((!this.shouldForwardP2PCreation || n2 || t2) && ((n2 || t2) && this.connection && (iP.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.resetConnection(this.connection)), this.connection = Lj(this.store, e2), this.emit(vx.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), !this.connection) throw new pO(hO.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
          return this._pcStatsUploadType = CD("NEW_ICE_RESTART") ? gx.FIRST_CONNECTION : gx.OLD_FIRST_CONNECTION, this._isTryConnecting = true, this._isStartRestartIce = false, this._iceError = null, this.connection.setConfiguration(e2), this.connection.establishPromise;
        }
        async connect(e2) {
          if (!this.connection) throw new pO(hO.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          if (!this.isPreallocation() || this.state !== Cx.Connected) {
            this.store.peerConnectionStart();
            const t2 = await this.connection.connect(e2);
            return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Cx.Connected, t2;
          }
          if (this.connection instanceof Fj) {
            if (this.connection.checkDtlsParameters(e2.dtlsParameters.fingerprints)) {
              iP.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] dtls parameters mismatch, try next."));
              return lP.reportApiInvoke(this.store.sessionId, { name: LO.MISMATCH_DTLS_PARAMETERS, options: [e2.dtlsParameters.fingerprints], tag: kO.TRACER }).onSuccess(), void setTimeout((() => {
                this.emit(vx.RequestReconnect);
              }));
            }
          }
          await this.connection.updateRemoteConnect(e2);
        }
        updateRemoteRTPCapabilities(e2) {
          const t2 = Array.from(this.localTrackMap.entries()).filter(((e3) => {
            var t3;
            let [i3] = e3;
            return Ln(t3 = [Rx.LocalVideoLowTrack, Rx.LocalVideoTrack]).call(t3, i3);
          })), i2 = t2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), n2 = t2.map(((e3) => {
            let [t3] = e3;
            return t3;
          }));
          if (this.connection instanceof Fj || this.connection && "name" in this.connection && "DataChannelConnection" === this.connection.name) {
            if (lP.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(n2), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(e2) }), !Ln(e2).call(e2, this.store.codec)) {
              const t3 = ["vp9", "vp8", "h264"].find(((t4) => Ln(e2).call(e2, t4)));
              t3 && (this.store.codec = t3, iP.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t3, ".")));
            }
            this.connection.updateRemoteRTPCapabilities(i2, e2);
          }
        }
        async getEstablishParams() {
          var e2;
          return this.connection && "name" in this.connection && "DataChannelConnection" === this.connection.name && "closed" !== this.connection.peerConnectionState || this.connection instanceof Fj && "closed" !== this.connection.peerConnectionState && Ln(e2 = [Cx.New, Cx.Connected]).call(e2, this.state) ? this.connection.establishPromise : void 0;
        }
        async publishDataChannel(e2) {
          if (!this.connection || this.state !== Cx.Connected) {
            if (this.state === Cx.Disconnected) throw new pO(hO.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            return e2.forEach(((e3) => {
              var t3;
              Ln(t3 = this.pendingLocalDataChannels).call(t3, e3) || this.pendingLocalDataChannels.push(e3);
            })), [];
          }
          const t2 = this.filterTobePublishedDataChannels(e2);
          return 0 === t2.length ? [] : (t2.forEach(((e3) => {
            const t3 = Date.now();
            this.store.publish(e3.id.toString(), "datachannel", t3);
          })), await this.connection.createDataChannels(this.store.uid, t2), t2.forEach(((e3) => {
            this.localDataChannels.push(e3);
            const t3 = Date.now();
            this.store.publish(e3.id + "", "datachannel", void 0, t3);
          })), e2.map(((e3) => ({ streamId: e3.id, ordered: e3.ordered, maxRetransmits: e3.maxRetransmits, metadata: e3.metadata, channelId: e3._originDataChannelId }))));
        }
        publish(e2, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.mutex.lock("From P2PChannel.publish"));
            try {
              var o2;
              const s2 = n2.connection && Ln(o2 = ["disconnected", "failed"]).call(o2, n2.connection.peerConnectionState);
              if (!n2.connection || n2.state !== Cx.Connected || s2) {
                if (n2.state === Cx.Disconnected) throw new pO(hO.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter(((e3) => -1 === n2.pendingLocalTracks.indexOf(e3)));
                return n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3), void (s2 && (n2._isWaitPcToRePub = true));
              }
              n2.store.pubId = n2.store.pubId + 1, tj.markPublishStart(n2.store.clientId, n2.store.pubId);
              const a2 = n2.filterTobePublishedTracks(e2, t2, i2);
              if (0 === a2.length) return void (yield Vb(n2.tryToUnmuteAudio(e2)));
              yield* xb(pG(n2.doPublish(n2.connection, a2)));
            } finally {
              r2();
            }
          }))();
        }
        doPublish(e2, t2) {
          var i2 = this;
          return Mb((function* () {
            t2.forEach(((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === Rx.LocalAudioTrack ? "audio" : "video", r3);
            })), i2.bindLocalTrackEvents(t2);
            const n2 = t2.map(((e3) => {
              let { track: t3 } = e3;
              return t3;
            })), r2 = yield Vb(e2.send(n2, i2.store.codec, i2.store.audioCodec)), o2 = (yield Vb(r2.next())).value, s2 = i2.createGatewayPublishMessage(t2, o2);
            let a2;
            try {
              a2 = yield s2;
            } catch (e3) {
              throw r2.throw(e3), (null == e3 ? void 0 : e3.code) === hO.WS_ABORT && t2.forEach(((e4) => {
                let { track: t3 } = e4;
                -1 === i2.pendingLocalTracks.indexOf(t3) && i2.pendingLocalTracks.push(t3);
              })), i2.unbindLocalTrackEvents(t2), e3;
            }
            const c2 = i2.mapPubResToRemoteConfig(s2, a2, n2), d2 = (yield Vb(r2.next(c2))).value;
            if (i2.state === Cx.Disconnected) throw new pO(hO.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            CD("ENABLE_VIDEO_SEI");
            const l2 = CD("ENABLE_ENCODED_TRANSFORM"), u2 = CD("ENABLE_AUDIO_METADATA");
            n2.forEach((async (e3) => {
              const t3 = e3.getRTCRtpTransceiver();
              if (!t3 || !l2) return;
              const { interceptLocalVideoFrame: i3, interceptLocalAudioFrame: n3 } = aB();
              e3.trackMediaType === fx.VIDEO ? await i3(t3.sender, e3) : e3.trackMediaType === fx.AUDIO && await n3(t3.sender, { metadata: u2 ? () => {
                const t4 = e3.metadata.shift();
                return t4 && t4.value;
              } : void 0 });
            })), t2.forEach(((e3) => {
              let { type: t3 } = e3;
              i2.statsCollector.addLocalStats(t3);
            })), i2.assignLocalTracks(t2, d2), i2.statsUploader.startUploadOutboundStats(), t2.forEach(((e3) => {
              let { track: t3, type: n3 } = e3;
              const r3 = Date.now();
              i2.store.publish(t3.getTrackId(), n3 === Rx.LocalAudioTrack ? "audio" : "video", void 0, r3);
            }));
          }))();
        }
        async updateVideoStreamParameter(e2, t2) {
          const i2 = this.localTrackMap.get(t2);
          if (!i2 || !this.connection) return;
          if (!(i2.track instanceof kM)) return iP.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
          const { track: n2 } = i2, r2 = (function(e3, t3) {
            const i3 = {};
            return e3.height && e3.width && (i3.scaleResolutionDownBy = _F(e3, t3)), i3.maxFramerate = e3.framerate ? dF(e3.framerate) : void 0, i3.maxBitrate = e3.bitrate ? 1e3 * e3.bitrate : void 0, i3;
          })(e2, n2);
          if (n2._encoderConfig || (n2._encoderConfig = {}), t2 !== Rx.LocalVideoLowTrack || !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding) null != r2.scaleResolutionDownBy && (n2._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
          else {
            const t3 = n2._originMediaStreamTrack;
            if (!t3.canvas) return iP.warn("[".concat(n2.getTrackId(), "] no canvas on track"));
            !(function(e3, t4) {
              const i3 = e3.canvas;
              t4.width && (i3.width = dF(t4.width)), t4.height && (i3.height = dF(t4.height)), t4.framerate && (i3.stopCapture && i3.stopCapture(), i3.stopCapture = SL((() => {
                !i3.startCapture && i3.stopCapture && i3.stopCapture(), i3.startCapture && i3.startCapture();
              }), dF(t4.framerate)));
            })(t3, e2);
          }
          null != r2.maxBitrate && (n2._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n2._encoderConfig.frameRate && "object" == typeof n2._encoderConfig.frameRate ? n2._encoderConfig.frameRate.max = r2.maxFramerate : n2._encoderConfig.frameRate = { max: r2.maxFramerate }), iP.debug("[".concat(n2.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n2._encoderConfig))), await this.connection.updateRtpSenderEncodings(n2);
        }
        publishLowStream(e2) {
          var t2 = this;
          return Mb((function* () {
            if (!t2.connection || t2.state !== Cx.Connected) return;
            const i2 = yield Vb(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const r2 = t2.localTrackMap.get(Rx.LocalVideoTrack);
              if (!r2) throw new pO(hO.UNEXPECTED_ERROR, "Could not find high stream");
              if (t2.localTrackMap.has(Rx.LocalVideoLowTrack)) throw new pO(hO.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
              const o2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: Rx.LocalVideoLowTrack }];
              if (yield* xb(pG(t2.doPublish(t2.connection, o2))), r2.track.muted || !r2.track.enabled) {
                var n2;
                const e3 = null === (n2 = t2.localTrackMap.get(Rx.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
                void 0 !== e3 && (yield Vb(t2.connection.muteLocal([e3])));
              }
            } finally {
              i2();
            }
          }))();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (iP.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await zO(this, vx.RequestRePublish, this.pendingLocalTracks), this.emit(vx.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (iP.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await zO(this, vx.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []), this._isWaitPcToRePub = false;
        }
        async reSubscribe(e2) {
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t2, kind: i2 } = this.pendingRemoteTracks[e3];
            (i2 !== fx.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i2 !== fx.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2) await zO(this, vx.RequestReSubscribe, this.pendingRemoteTracks);
          else for (const { user: e3, kind: t2 } of this.pendingRemoteTracks) await this.subscribe(e3, t2, t2 === fx.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach(((e3) => {
            let { user: t2 } = e3;
            this.emit(vx.MediaReconnectEnd, t2.uid);
          })), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection || this.state !== Cx.Connected) return void e2.forEach(((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          }));
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length) return;
          const i2 = t2.find(((e3) => "videoLowTrack" === e3[0]));
          if (i2) {
            i2[1].track.close();
          }
          return this.doUnpublish(this.connection, t2);
        }
        async unpublishDataChannel(e2) {
          if (!this.connection || this.state !== Cx.Connected) return void e2.forEach(((e3) => {
            const t3 = this.pendingLocalDataChannels.indexOf(e3);
            -1 !== t3 && this.pendingLocalDataChannels.splice(t3, 1);
          }));
          const t2 = this.filterTobeUnpublishedDataChannels(e2);
          return 0 !== t2.length ? (t2.forEach(((e3) => {
            const t3 = this.localDataChannels.indexOf(e3);
            -1 !== t3 && this.localDataChannels.splice(t3, 1);
          })), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t2.map(((e3) => e3.id))) : void 0;
        }
        async unpublishLowStream() {
          if (!this.connection || this.state !== Cx.Connected) return;
          const e2 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
          if (!e2) return;
          e2.track.close();
          const t2 = [[Rx.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t2);
        }
        async doUnpublish(e2, t2) {
          const i2 = this.createGatewayUnpublishMessage(t2);
          return await e2.stopSending(t2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }))), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map(((e3) => {
            let [t3, { track: i3 }] = e3;
            return { type: t3, track: i3 };
          }))), t2.forEach(((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          })), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i2;
        }
        async subscribeDataChannel(e2, t2) {
          if (!this.connection || this.state !== Cx.Connected) throw new pO(hO.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          const i2 = t2.filter(((t3) => {
            var i3;
            return !(null !== (i3 = this.remoteDataChannelMap.get(e2)) && void 0 !== i3 && i3.get(t3.id));
          }));
          if (0 !== i2.length) return await this.connection.createDataChannels(e2.uid, i2), i2.forEach(((t3) => {
            var i3;
            this.remoteDataChannelMap.has(e2) ? null === (i3 = this.remoteDataChannelMap.get(e2)) || void 0 === i3 || i3.set(t3.id, t3) : this.remoteDataChannelMap.set(e2, /* @__PURE__ */ new Map([[t3.id, t3]]));
            const n2 = this.pendingRemoteDataChannels.findIndex(((i4) => {
              let { user: n3, id: r2 } = i4;
              return n3.uid === e2.uid && r2 === t3.id;
            }));
            -1 !== n2 && this.pendingRemoteDataChannels.splice(n2, 1);
          })), i2.map(((e3) => e3.id));
        }
        async subscribe(e2, t2, i2, n2, r2) {
          var o2;
          if (!this.connection || this.state !== Cx.Connected) throw new pO(hO.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (null !== (o2 = this.remoteUserMap.get(e2)) && void 0 !== o2 && o2.has(t2)) return;
          let s2, a2, c2, d2;
          const l2 = this.connection.getPreMedia(i2);
          if (l2) iP.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] preSSRCMap has ssrcId: ").concat(i2, ", no need to send sub to gateway.")), c2 = l2.transceiver, s2 = l2.track, a2 = l2.mid, d2 = l2.player, l2.firstVideoRender && this.store.firstVideoFrameDecoded(e2.uid, { firstPreRender: l2.firstVideoRender });
          else if (r2) {
            const i3 = r2.find(((e3) => {
              let { stream_type: i4 } = e3;
              return i4 === t2;
            }));
            if (!i3) throw new pO(hO.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
            const n3 = await this.connection.receive(t2, i3.ssrcs, String(e2._uintid), i3.attributes);
            (this.connection instanceof Fj || "name" in this.connection && "DataChannelConnection" === this.connection.name) && (c2 = n3.transceiver), s2 = n3.track, a2 = n3.id;
          } else {
            const r3 = await this.connection.receive(t2, [{ ssrcId: i2, rtx: n2 }], String(e2._uintid), void 0);
            (this.connection instanceof Fj || "name" in this.connection && "DataChannelConnection" === this.connection.name) && (c2 = r3.transceiver), s2 = r3.track, a2 = r3.id;
          }
          if (t2 === fx.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new $M(s2, e2.uid, e2._uintid, this.store), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new ZM(s2, e2.uid, e2._uintid, this.store, d2), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId())), e2._videoTrack.once(WP.PLAY_START, (() => {
            this.store.firstVideoFrameDecoded(e2.uid, { playStart: Date.now() });
          })), e2._videoTrack.once(WP.PLAY_END, (() => {
            this.store.firstVideoFrameDecoded(e2.uid, { playEnd: Date.now() }), this.reportVideoFirstFrameRender(e2);
          })), d2 ? e2._videoTrack.once(WP.FIRST_FRAME_RENDER, (() => {
            this.store.firstVideoFrameDecoded(e2.uid, { firstRender: Date.now() }), this.reportVideoFirstFrameRender(e2);
          })) : e2._videoTrack.once(WP.FIRST_FRAME_DECODED, (() => {
            this.store.firstVideoFrameDecoded(e2.uid, { firstRender: Date.now() }), this.reportVideoFirstFrameRender(e2);
          }))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack)), c2 && CD("ENABLE_ENCODED_TRANSFORM")) {
            const { interceptRemoteVideoFrame: i3, interceptRemoteAudioFrame: n3 } = aB();
            t2 == fx.VIDEO ? await i3(c2.receiver, { onSei: CD("ENABLE_VIDEO_SEI") && ((t3) => {
              var i4;
              return null === (i4 = e2._videoTrack) || void 0 === i4 ? void 0 : i4._onSei(t3);
            }), onFirstFrame: (e3) => {
              var t3;
              const i4 = Array.from(WD(t3 = this.remoteUserMap).call(t3)).find(((t4) => t4._videoSSRC === e3.ssrc));
              i4 && this.store.firstVideoFrameDecoded(i4.uid, { firstReceivedEncodedFrame: Date.now(), frameType: e3.type, rtpTimestamp: e3.rtpTimestamp, framePayloadType: e3.payloadType, frameDataLength: e3.length, mimeType: e3.mimeType });
            } }) : t2 == fx.AUDIO && await n3(c2.receiver, { enableTopn: !!CD("ENABLE_AUDIO_TOPN"), enableMetadata: !!CD("ENABLE_AUDIO_METADATA"), enablePts: !!CD("ENABLE_AUDIO_PTS"), onMetadata: (e3) => {
              this.safeEmit(vx.AudioMetadata, e3);
            }, onPts: (e3) => {
              this.safeEmit(vx.AudioPts, e3);
            } });
          }
          const u2 = this.remoteUserMap.get(e2);
          u2 ? u2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats();
          const h2 = this.pendingRemoteTracks.findIndex(((i3) => {
            let { user: n3, kind: r3 } = i3;
            return n3.uid === e2.uid && t2 === r3;
          }));
          -1 !== h2 && (this.pendingRemoteTracks.splice(h2, 1), this.emit(vx.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection || this.state !== Cx.Connected) throw new pO(hO.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          e2 = e2.filter(((e3) => {
            var t3;
            let { user: i3, mediaType: n3 } = e3;
            return !(null !== (t3 = this.remoteUserMap.get(i3)) && void 0 !== t3 && t3.has(n3));
          }));
          const t2 = [], i2 = /* @__PURE__ */ new Map();
          e2.forEach(((e3) => {
            if (!this.connection) return;
            const n3 = this.connection.getPreMedia(e3.ssrcId);
            if (n3) {
              const { track: t3, mid: r2, transceiver: o2, player: s2 } = n3;
              i2.set(e3.ssrcId, { track: t3, id: r2, transceiver: o2, player: s2 });
            } else t2.push(e3);
          }));
          const n2 = await this.connection.batchReceive(t2.map(((e3) => {
            let { user: t3, mediaType: i3, ssrcId: n3, rtxSsrcId: r2 } = e3;
            return { kind: i3, ssrcMsg: [{ ssrcId: n3, rtx: r2 }], mslabel: String(t3._uintid) };
          })));
          t2.forEach(((e3, t3) => {
            i2.set(e3.ssrcId, n2[t3]);
          }));
          for (const { user: t3, mediaType: n3, ssrcId: r2 } of e2) {
            const e3 = i2.get(r2);
            if (!e3) return void iP.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] cannot find ").concat(t3.uid, " subscribe data,").concat(n3, ", ").concat(r2));
            const { track: o2, id: s2, transceiver: a2, player: c2 } = e3;
            if (a2 && CD("ENABLE_ENCODED_TRANSFORM")) {
              const { interceptRemoteVideoFrame: e4, interceptRemoteAudioFrame: i3 } = aB();
              n3 == fx.VIDEO ? await e4(a2.receiver, { onSei: CD("ENABLE_VIDEO_SEI") && ((e5) => {
                var i4;
                return null === (i4 = t3._videoTrack) || void 0 === i4 ? void 0 : i4._onSei(e5);
              }), onFirstFrame: (e5) => {
                var t4;
                const i4 = Array.from(WD(t4 = this.remoteUserMap).call(t4)).find(((t5) => t5._videoSSRC === e5.ssrc));
                i4 && this.store.firstVideoFrameDecoded(i4.uid, { firstReceivedEncodedFrame: Date.now(), frameType: e5.type, rtpTimestamp: e5.rtpTimestamp, framePayloadType: e5.payloadType, frameDataLength: e5.length, mimeType: e5.mimeType });
              } }) : n3 == fx.AUDIO && await i3(a2.receiver, { enableTopn: !!CD("ENABLE_AUDIO_TOPN"), enableMetadata: !!CD("ENABLE_AUDIO_METADATA"), enablePts: !!CD("ENABLE_AUDIO_PTS"), onMetadata: (e5) => {
                this.safeEmit(vx.AudioMetadata, e5);
              }, onPts: (e5) => {
                this.safeEmit(vx.AudioPts, e5);
              } });
            }
            if (n3 === fx.AUDIO ? (t3._audioTrack ? t3._audioTrack._updateOriginMediaStreamTrack(o2) : (t3._audioTrack = new $M(o2, t3.uid, t3._uintid, this.store), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t3._audioTrack.getTrackId()))), a2 && t3._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(t3, t3._audioTrack)) : (t3._videoTrack ? t3._videoTrack._updateOriginMediaStreamTrack(o2) : (t3._videoTrack = new ZM(o2, t3.uid, t3._uintid, this.store, c2), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t3._videoTrack.getTrackId()))), a2 && t3._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(t3, t3._videoTrack)), CD("ENABLE_VIDEO_SEI") && a2) {
              const { interceptRemoteVideoFrame: e4, interceptRemoteAudioFrame: i3 } = aB();
              n3 == fx.VIDEO ? await e4(a2.receiver, { onSei: (e5) => {
                var i4;
                null === (i4 = t3._videoTrack) || void 0 === i4 || i4._onSei(e5);
              }, onFirstFrame: (e5) => {
                var t4;
                const i4 = Array.from(WD(t4 = this.remoteUserMap).call(t4)).find(((t5) => t5._videoSSRC === e5.ssrc));
                i4 && this.store.firstVideoFrameDecoded(i4.uid, { firstReceivedEncodedFrame: Date.now(), frameType: e5.type, rtpTimestamp: e5.rtpTimestamp, framePayloadType: e5.payloadType, frameDataLength: e5.length, mimeType: e5.mimeType });
              } }) : n3 == fx.AUDIO && await i3(a2.receiver);
            }
            const d2 = this.remoteUserMap.get(t3);
            d2 ? d2.set(n3, s2) : this.remoteUserMap.set(t3, /* @__PURE__ */ new Map([[n3, s2]])), this.statsCollector.addRemoteStats(t3.uid), this.statsUploader.startUploadInboundStats();
            const l2 = this.pendingRemoteTracks.findIndex(((e4) => {
              let { user: i3, kind: r3 } = e4;
              return i3.uid === t3.uid && n3 === r3;
            }));
            -1 !== l2 && (this.pendingRemoteTracks.splice(l2, 1), this.emit(vx.MediaReconnectEnd, t3.uid));
          }
        }
        async unsubscribe(e2, t2, i2) {
          const n2 = this.pendingRemoteTracks.filter(((i3) => {
            let { user: n3, kind: r3 } = i3;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          }));
          if (n2.forEach(((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          })), this.connection && this.state === Cx.Connected || i2 || n2.forEach(((t3) => {
            let { kind: i3 } = t3;
            var n3;
            if (i3 === fx.AUDIO) null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i3 === fx.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          })), !this.connection || this.state !== Cx.Connected) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          if (0 === r2.length) return;
          await this.connection.stopReceiving(r2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })));
          const o2 = this.createUnsubscribeMessage(r2);
          return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r2.forEach(((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, o3;
            n3 === fx.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === fx.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (o3 = t3._videoTrack) || void 0 === o3 || o3._destroy(), t3._videoTrack = void 0);
            else if (n3 === fx.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          })), o2;
        }
        async unsubscribeDataChannel(e2, t2) {
          if (t2.forEach(((e3) => {
            const t3 = this.pendingRemoteDataChannels.findIndex(((t4) => t4.id === e3.id));
            -1 !== t3 && this.pendingRemoteDataChannels.splice(t3, 1);
          })), !this.connection) return;
          const i2 = this.filterTobeUnSubscribedDataChannels(e2, t2);
          if (0 === i2.length) return;
          t2.forEach(((e3) => {
            e3._close();
          }));
          const n2 = this.remoteDataChannelMap.get(e2);
          return i2.forEach(((e3) => {
            n2 && n2.delete(e3.id);
          })), n2 && 0 === n2.size && (this.remoteDataChannelMap.delete(e2), await this.connection.stopDataChannels(e2.uid)), i2.map(((e3) => e3.id));
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t2 = [];
          for (const { user: i3, mediaType: n3 } of e2) {
            const e3 = this.pendingRemoteTracks.filter(((e4) => {
              let { user: t3, kind: r2 } = e4;
              return void 0 !== n3 ? t3.uid === i3.uid && n3 === r2 : t3.uid === i3.uid;
            }));
            e3.forEach(((e4) => {
              const t3 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t3, 1);
            })), t2 = t2.concat(e3);
          }
          if (!this.connection || this.state !== Cx.Connected) return void t2.forEach(((e3) => {
            let { user: t3, kind: i3 } = e3;
            var n3;
            if (i3 === fx.AUDIO) null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
            else if (i3 === fx.VIDEO) {
              var r2;
              null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            }
          }));
          const i2 = nr(e2).call(e2, ((e3, t3) => {
            let { user: i3, mediaType: n3 } = t3;
            const r2 = this.filterTobeUnSubscribedTracks(i3, n3);
            return e3.concat(r2);
          }), []);
          if (0 === i2.length) return;
          await this.connection.stopReceiving(i2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })));
          const n2 = this.createUnsubscribeAllMessage(i2);
          return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i2.forEach(((e3) => {
            let [t3, { kind: i3 }] = e3;
            var n3, r2;
            i3 === fx.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (i3 === fx.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            else if (i3 === fx.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t3._audioTrack), null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
            }
          })), n2;
        }
        isPreSubScribe(e2) {
          if (!this.connection || this.state !== Cx.Connected) return false;
          return !!this.connection.getPreMedia(e2);
        }
        async muteRemote(e2, t2) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t2)) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === fx.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t2) || iP.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        addAudioMetadata(e2) {
          const t2 = this.localTrackMap.get(Rx.LocalAudioTrack), i2 = t2 && t2.track;
          i2 && i2.metadata.push(e2);
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof Wk) {
            const i2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter(((e3) => {
              let [t3] = e3;
              return t3 !== Rx.LocalAudioTrack;
            })).filter(((t3) => {
              let [i3] = t3;
              return !(e2 && i3 === Rx.LocalVideoLowTrack);
            })).map(((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            })).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter(((t3) => {
            let [i2] = t3;
            return !(e2 && i2 === Rx.LocalVideoLowTrack);
          })).map(((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          }));
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        reportPublishEvent(e2, t2, i2, n2, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(Rx.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(Rx.LocalVideoLowTrack) : this.localTrackMap.get(Rx.LocalVideoTrack);
            lP.publish(this.store.sessionId, { eventElapse: tj.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(VP.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i2 || (i2 = []);
            const s2 = i2.find(((e3) => e3 instanceof Bk)), a2 = n2 ? null === (o2 = this.localTrackMap.get(Rx.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find(((e3) => e3 instanceof kM));
            lP.publish(this.store.sessionId, { eventElapse: tj.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(VP.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i2, n2) {
          const r2 = n2 === fx.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && lP.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === fx.VIDEO, audio: n2 === fx.AUDIO, peerid: i2.uid, subscribeRequestid: r2, p2pid: this.store.p2pId, eventElapse: tj.measureFromSubscribeStart(this.store.clientId, r2), preSsrc: this.isPreSubScribe(r2) });
        }
        reset() {
          iP.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new PN("P2PChannel-mutex", this.store.clientId), this.connection && (this.resetConnection(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = Lj(this.store), this.emit(vx.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.statsUploader.stopUploadBaseStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof Wk) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach(((e3) => {
                t2.removeAudioTrack(e3);
              }));
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = Cx.Disconnected;
        }
        getStats() {
          var e2;
          return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(Rx.LocalVideoTrack);
          if (e2) return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof kM || t2 && t2.track instanceof Bk ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3.uid === e2));
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map(((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          }));
          const t2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Qp(e2).call(e2, ((e3, t3) => e3.level - t3.level)), e2;
        }
        async disconnectForReconnect() {
          this.connection && (iP.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = Cx.Reconnecting, CD("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2] = e2;
            var i2;
            t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          })), this.resetConnection(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = Lj(this.store), this.emit(vx.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(((e2) => {
            var t2;
            let [i2, { track: n2 }] = e2;
            switch (i2) {
              case Rx.LocalVideoTrack:
                Ln(t2 = n2._hints).call(t2, VP.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case Rx.LocalAudioTrack:
                n2 instanceof Wk ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case Rx.LocalVideoLowTrack:
            }
          })), this.emit(vx.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            Array.from(WD(i2).call(i2)).forEach(((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            })), this.emit(vx.MediaReconnectStart, t2.uid);
          })), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach(((e2) => {
            this.pendingLocalDataChannels.push(e2);
          })), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            Array.from(WD(i2).call(i2)).forEach(((e3) => {
              this.setPendingRemoteDataChannel(t2, e3);
            }));
          })), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), iP.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteDataChannel(e2, t2) {
          for (const i2 of this.pendingRemoteDataChannels) {
            const { user: n2, id: r2 } = i2;
            if ((e2 instanceof aj ? e2.uid : e2) === n2.uid && r2 === t2) return true;
          }
          return false;
        }
        setPendingRemoteDataChannel(e2, t2) {
          this.hasPendingRemoteDataChannel(e2, t2) || this.pendingRemoteDataChannels.push({ user: e2, id: t2 });
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i2;
            if ((e2 instanceof aj ? e2.uid : e2) === n2.uid && t2 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        restartICE(e2) {
          var t2 = this;
          return Mb((function* () {
            if (!t2.connection || t2.state !== Cx.Connected) return;
            const i2 = yield Vb(t2.mutex.lock("From P2PChannel.restartICE"));
            let n2;
            try {
              n2 = yield Vb(t2.connection.restartICE(e2));
              const r3 = yield Vb(n2.next());
              if (r3.done) return;
              const o2 = r3.value, s2 = yield o2;
              switch (kj(t2.connection) && t2.reportPCStats(Date.now(), false, t2._pcStatsUploadType), e2) {
                case Sx.UDP_TCP_RELAY:
                  t2._pcStatsUploadType = gx.UDP_TCP_RESTART;
                  break;
                case Sx.TCP_RELAY:
                  t2._pcStatsUploadType = gx.TCP_RESTART;
                  break;
                case Sx.RELAY:
                  t2._pcStatsUploadType = gx.RELAY_RESTART;
                  break;
                default:
                  t2._pcStatsUploadType = gx.OLD_RESTART;
              }
              t2._isTryConnecting = true, n2.next(s2);
            } catch (e3) {
              var r2;
              null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
            } finally {
              i2();
            }
          }))();
        }
        getUplinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(Rx.LocalVideoTrack), i2 = this.localTrackMap.get(Rx.LocalAudioTrack), n2 = e2.videoSend.find(((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId))), r2 = e2.audioSend.find(((e3) => e3.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId)));
          if (!n2 || !r2) return 1;
          const o2 = XO(this, vx.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(VP.SCREEN_TRACK)) {
            const t3 = h2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t3 && i3) {
              const e3 = (1e3 * t3 - i3) / (1e3 * t3);
              return HU[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach(((i2) => {
            let [n2] = i2;
            const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find(((e3) => e3.ssrc === r2)), a2 = e2.videoRecv.find(((e3) => e3.ssrc === o2));
            if (!s2 && !a2) return void (t2 += 1);
            const c2 = XO(this, vx.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          })), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new rp(((t2, i2) => {
            this.handleMuteLocalTrack(e2, t2, i2);
          }));
        }
        async replaceTrack(e2, t2) {
          var i2;
          if (iP.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(e2.getTrackId(), "] to [").concat(t2.getTrackId(), "]")), !this.connection || this.state !== Cx.Connected) return;
          const n2 = Array.from(this.localTrackMap.entries()).find(((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          }));
          if (!n2) return;
          const r2 = n2[0];
          if (e2 !== t2 && (this.unbindLocalTrackEvents([{ track: e2, type: r2 }]), this.bindLocalTrackEvents([{ track: t2, type: r2 }]), n2[1].track = t2), await (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.replaceTrack(t2, n2[1].id)), this.isPlanB) {
            const e3 = n2[1];
            e3.id = t2._mediaStreamTrack.id, this.localTrackMap.set(r2, e3);
          }
          if (r2 === Rx.LocalVideoTrack && !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding) {
            const t3 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
            if (t3) {
              const i3 = e2._mediaStreamTrack.clone();
              t3.track._originMediaStreamTrack.stop(), t3.track._mediaStreamTrack = i3, t3.track._originMediaStreamTrack = i3, await new rp(((e3, i4) => {
                this.handleReplaceTrack(t3.track, e3, i4, true);
              }));
            }
          }
        }
        filterTobePublishedTracks(e2, t2, i2) {
          const n2 = [], r2 = this.getAllTracks();
          e2 = rN(e2 = e2.filter(((e3) => -1 === r2.indexOf(e3))));
          let o2, s2 = false;
          const a2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          for (const r3 of e2) {
            if (r3 instanceof kM && (this.localTrackMap.has(Rx.LocalVideoTrack) || s2 ? new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: r3, type: Rx.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(r3, i2);
              n2.push({ track: e3, type: Rx.LocalVideoLowTrack });
            }
            if (r3 instanceof Bk) if (a2) {
              const e3 = a2.track;
              if (e3 instanceof Wk) Nj([r3]), e3.addAudioTrack(r3), this.bindLocalAudioTrackEvents(r3, true);
              else {
                const t3 = Dj([e3, r3]);
                iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(t3.getTrackId(), "]")), this.replaceTrack(e3, t3);
              }
            } else if (o2 instanceof Wk) Nj([r3]), o2.addAudioTrack(r3);
            else if (o2 || !r3._useAudioElement && pP().webAudioMediaStreamDest && !r3._bypassWebAudio) {
              o2 = Dj(o2 ? [r3, o2] : [r3]);
            } else o2 = r3;
          }
          return o2 && (iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(o2.getTrackId(), "]")), n2.push({ track: o2, type: Rx.LocalAudioTrack })), n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i2 = this.getAllTracks();
          e2 = rN(e2 = e2.filter(((e3) => -1 !== i2.indexOf(e3))));
          for (const i3 of e2) {
            if (i3 instanceof Bk) {
              const e3 = this.localTrackMap.get(Rx.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof Wk ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([Rx.LocalAudioTrack, e3]), e3.track.close())) : t2.push([Rx.LocalAudioTrack, e3]);
            }
            if (i3 instanceof kM) {
              const e3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!e3) continue;
              t2.push([Rx.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
              i4 && t2.push([Rx.LocalVideoLowTrack, i4]);
            }
          }
          return t2;
        }
        filterTobePublishedDataChannels(e2) {
          return e2 = (e2 = rN(e2)).filter(((e3) => -1 === this.localDataChannels.findIndex(((t2) => t2.id === e3.id))));
        }
        filterTobeUnpublishedDataChannels(e2) {
          return e2 = (e2 = (e2 = rN(e2)).filter(((e3) => -1 !== this.localDataChannels.indexOf(e3)))).filter(((e3) => e3._originDataChannel));
        }
        bindLocalTrackEvents(e2) {
          e2.forEach(((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case Rx.LocalVideoTrack:
                t2.addListener(UP.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(UP.GET_RTC_STATS, this.handleGetRTCStats), t2.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(UP.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Rx.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case Rx.LocalVideoLowTrack:
            }
          }));
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof Wk ? e2.trackList.forEach(((e3) => {
            e3.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(UP.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          })) : (e2.addListener(UP.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || (e2.addListener(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.addListener(UP.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map(((e3) => {
            let [t2, { track: i2 }] = e3;
            return { track: i2, type: t2 };
          }))), e2.forEach(((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case Rx.LocalVideoTrack:
                t2.off(UP.GET_STATS, this.handleGetLocalVideoStats), t2.off(UP.GET_RTC_STATS, this.handleGetRTCStats), t2.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(UP.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Rx.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case Rx.LocalVideoLowTrack:
            }
          }));
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof Wk ? e2.trackList.forEach(((e3) => {
            e3.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(UP.GET_STATS, this.handleGetLocalAudioStats), e3.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          })) : (e2.off(UP.GET_STATS, this.handleGetLocalAudioStats), e2.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(UP.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e2.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof ZM && t2.addListener(UP.GET_STATS, ((t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          })), t2 instanceof $M && t2.addListener(UP.GET_STATS, ((t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          }));
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(UP.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            i2.has(fx.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(fx.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          }));
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map(((e3, i2) => {
            var n2;
            let r2, o2, { track: s2, type: a2 } = e3;
            switch (a2) {
              case Rx.LocalAudioTrack:
                r2 = ox.Audio, o2 = { dtx: s2 instanceof jk && s2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case Rx.LocalVideoTrack:
                r2 = Ln(n2 = s2._hints).call(n2, VP.SCREEN_TRACK) ? ox.Screen : ox.High, o2 = hG(hG({}, lF(s2)), {}, { codec: this.store.codec, svc_mode: SF() });
                break;
              case Rx.LocalVideoLowTrack:
                r2 = ox.Low, o2 = hG(hG({}, lF(s2)), {}, { codec: this.store.codec, svc_mode: SF() });
            }
            return { stream_type: r2, attributes: o2, ssrcs: t2[i2] };
          }));
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        assignLocalTracks(e2, t2) {
          e2.forEach(((e3, i2) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
          }));
        }
        withdrawLocalTracks(e2) {
          e2.forEach(((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          }));
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            if (iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(vx.PeerConnectionStateChange, t2), "connecting" === t2 && e2 instanceof Fj && !Bw() && CD("FIRST_TCP_CANDIDATE") && window.setTimeout((() => {
              "connecting" === t2 && e2.extendCandidate();
            }), CD("FIRST_TCP_CANDIDATE_INTERVAL")), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2) {
              this._restartTimer && (window.clearTimeout(this._restartTimer), this._restartTimer = void 0), e2 instanceof Fj && cG(e2, true), this._isTryConnecting && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isTryConnecting = false, this._isStartRestartIce = false, this._pcStatsUploadType = gx.DISCONNECTED_OR_FAILED;
              if ("CONNECTED" === XO(this, vx.QueryClientConnectionState) && this._isWaitPcToRePub) {
                const e3 = this.pendingLocalTracks.map(((e4) => e4.getTrackId())), t3 = this.pendingLocalDataChannels.map(((e4) => "dc_".concat(e4.id)));
                lP.reportApiInvoke(this.store.sessionId, { name: LO.REPUB_AFTER_PC_CONNECTED, options: e3.concat(t3), tag: kO.TRACER }).onSuccess(), this.republish();
              }
            }
            if (CD("NEW_ICE_RESTART") && e2 instanceof Fj && !Bw() && !this._forceTurn && !this.store.useDcSignal) {
              if (Ln(Tx).call(Tx, t2)) {
                if (this._isStartRestartIce) return;
                this._isStartRestartIce = true;
                const t3 = (t4) => {
                  if (kj(e2)) {
                    iP.debug("[".concat(this.store.clientId, "] [P2PChannel] try to restartICE, type is ").concat(t4));
                    "CONNECTED" === XO(this, vx.QueryClientConnectionState) && this.emit(vx.RequestRestartICE, t4);
                  }
                }, i2 = () => {
                  kj(e2) && (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), iP.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout((() => this.emit(vx.P2PLost)), 0), this.iceFailedCount += 1, this.requestReconnect());
                };
                return void (this._restartTimer = window.setTimeout((() => {
                  dG(e2, t3, i2);
                }), 800));
              }
            } else {
              if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState) return setTimeout((() => {
                if ("disconnected" === e2.iceConnectionState && CD("ICE_RESTART")) {
                  "CONNECTED" === XO(this, vx.QueryClientConnectionState) && this.emit(vx.RequestRestartICE);
                }
              }), 800), void setTimeout((() => {
                "disconnected" === e2.peerConnectionState && (iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isTryConnecting = false, setTimeout((() => this.emit(vx.P2PLost)), 0), this.iceFailedCount += 1, this.requestReconnect());
              }), 4e3);
              "failed" === t2 && (iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), setTimeout((() => this.emit(vx.P2PLost)), 0), this.iceFailedCount += 1, await this.requestReconnect());
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), lP.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: kO.TRACER }).onSuccess(), this.emit(vx.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._audioSSRC === e3));
            var n2;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(WP.FIRST_FRAME_DECODED), lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_AUDIO_DECODE, aP.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._audioSSRC === e3));
            i2 && lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_AUDIO_RECEIVED, aP.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            const r2 = Array.from(WD(n2 = this.remoteUserMap).call(n2)).find(((t3) => t3._videoSSRC === e3));
            r2 && this.store.firstVideoFrameDecoded(r2.uid, { firstDecoded: Date.now() }), this.reportVideoFirstFrameDecoded(e3, t2, i2);
          }, e2.onFirstVideoRender = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._videoSSRC === e3));
            i2 && (this.store.firstVideoFrameDecoded(i2.uid, { firstPreRender: Date.now() }), this.reportVideoFirstFrameRender(i2), this.emit(vx.FirstVideoPreRender, i2.uid, e3));
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._videoSSRC === e3));
            i2 && (this.store.firstVideoFrameDecoded(i2.uid, { firstReceived: Date.now() }), lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_VIDEO_RECEIVED, aP.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstVideoBufferReady = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._videoSSRC === e3));
            i2 && this.emit(vx.FirstVideoBufferReady, i2.uid, e3);
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i2 === n2 || this.emit(vx.ConnectionTypeChange, i2), iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(EF(t2)), " -> ").concat(JSON.stringify(EF(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(EF(t2)), " -> ").concat(JSON.stringify(EF(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.getLocalVideoStats = () => {
            const e3 = this.statsCollector.getLocalVideoTrackStats(), t2 = this.statsCollector.getRTCStats();
            return hG(hG({}, e3), t2);
          }, e2.onICECandidateError = (e3) => {
            this._iceError = e3;
          };
        }
        fallbackConnection() {
          iP.debug("[".concat(this.store.clientId, "] [P2PChannel] try to fallback connection")), this.state === Cx.Connected ? (iP.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && this.resetConnection(this.connection), this.shouldForwardP2PCreation && (this.connection = Lj(this.store), this.emit(vx.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)));
        }
        resetConnection(e2) {
          e2 instanceof Fj && (function(e3) {
            oG.delete(e3.id), cG(e3);
          })(e2), e2.close(), this.emit(vx.PeerConnectionStateChange, "closed"), (function(e3) {
            e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0, e3.getLocalVideoStats = void 0;
          })(e2), this._isWaitPcToRePub = false;
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t2;
          const i2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2 instanceof Bk && (null == i2 ? void 0 : i2.track) instanceof Wk) return i2.track.isActive || t2.push([Rx.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find(((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          }));
          if (n2 && (t2.push(n2), n2[0] === Rx.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
            e3 && t2.push([Rx.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2 instanceof Bk && (null == i2 ? void 0 : i2.track) instanceof Wk) return i2.track.isActive && t2.push([Rx.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find(((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          }));
          if (n2) if (n2[0] === Rx.LocalVideoTrack) {
            t2.push(n2);
            const e3 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
            e3 && t2.push([Rx.LocalVideoLowTrack, e3]);
          } else t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        createUnmuteMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i2 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2) return i2;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2) return i2;
            i2.push([e2, { kind: t2, id: r2 }]);
          } else Array.from(n2.entries()).forEach(((t3) => {
            let [n3, r2] = t3;
            i2.push([e2, { kind: n3, id: r2 }]);
          }));
          return i2;
        }
        filterTobeUnSubscribedDataChannels(e2, t2) {
          const i2 = [];
          return t2.forEach(((t3) => {
            var n2;
            null !== (n2 = this.remoteDataChannelMap.get(e2)) && void 0 !== n2 && n2.has(t3.id) && i2.push(t3);
          })), i2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach(((e3) => {
            let [i2, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case fx.VIDEO:
                return void (i2._videoSSRC && t2.push({ stream_type: fx.VIDEO, ssrcId: i2._videoSSRC }));
              case fx.AUDIO:
                return void (i2._audioSSRC && t2.push({ stream_type: fx.AUDIO, ssrcId: i2._audioSSRC }));
            }
          })), t2;
        }
        createUnsubscribeAllMessage(e2) {
          const t2 = /* @__PURE__ */ new Map();
          return e2.forEach(((e3) => {
            let [i2, { kind: n2 }] = e3;
            if (t2.has(i2)) {
              let e4 = t2.get(i2);
              n2 === fx.VIDEO ? e4 |= cx.Video : e4 |= cx.Audio, t2.set(i2, e4);
            } else n2 === fx.VIDEO ? t2.set(i2, cx.Video) : t2.set(i2, cx.Audio);
          })), { users: Array.from(t2.entries()).map(((e3) => {
            let [t3, i2] = e3;
            return { stream_id: t3.uid, stream_type: i2 };
          })) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach(((e3) => {
            let [t2, { kind: i2 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          }));
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(Rx.LocalVideoTrack), i2 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
          t2 && (await t2.track.setBitrateLimit(e2.uplink), await new rp(((e3, i3) => {
            this.handleUpdateVideoEncoder(t2.track, e3, i3, true);
          }))), i2 && e2.low_stream_uplink && (await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new rp(((e3, t3) => {
            this.handleUpdateVideoEncoder(i2.track, e3, t3, true);
          })));
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        isPreallocation() {
          return !(!this.connection || !("name" in this.connection) || "DataChannelConnection" !== this.connection.name || "closed" === this.connection.peerConnectionState) || this.connection instanceof Fj && this.connection.isPreallocation;
        }
        isPreSub() {
          return (this.connection && "name" in this.connection && "DataChannelConnection" === this.connection.name && "closed" !== this.connection.peerConnectionState || this.connection instanceof Fj) && this.connection.isPreSub();
        }
        isPreRender() {
          return this.connection instanceof Fj && this.connection.isPreRender;
        }
        mapPubResToRemoteConfig(e2, t2, i2) {
          return e2.map(((e3, n2) => {
            var r2;
            let { stream_type: o2 } = e3;
            const s2 = null === (r2 = t2.find(((e4) => {
              let { stream_type: t3 } = e4;
              return o2 === t3;
            }))) || void 0 === r2 ? void 0 : r2.attributes;
            if (s2 && CD("DISABLE_SCREEN_SHARE_REMB")) {
              const e4 = i2[n2]._hints;
              (Ln(e4).call(e4, VP.SCREEN_TRACK) || Ln(e4).call(e4, VP.SCREEN_LOW_TRACK)) && (s2.remb = false, iP.debug("disable remb for screen share, hints:", e4));
            }
            return s2;
          }));
        }
        async tryToUnmuteAudio(e2) {
          for (let i2 = 0; i2 < e2.length; i2++) if (e2[i2] instanceof Bk) {
            var t2;
            const n2 = this.filterTobeUnmutedTracks(e2[i2]);
            if (0 === n2.length) continue;
            await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map(((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            }))));
            const r2 = this.createUnmuteMessage(n2);
            return void await qO(this, vx.RequestUnmuteLocal, r2);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(vx.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(vx.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks(), this.statsUploader.requestTransportStats = () => {
            var e2;
            return { connectState: (null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.peerConnectionState) || "closed" };
          };
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await fN(MN(this.dtlsFailedCount, kN)), this.emit(vx.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t2.length > 0 && await zO(this, vx.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(vx.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(Rx.LocalVideoTrack) || this.pendingLocalTracks.some(((e2) => e2 instanceof kM));
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter(((e3) => e3 instanceof kM)).length > 1) throw new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter(((e3) => e3 instanceof Bk)).length > 1 && (e2.some(((e3) => e3 instanceof Bk && e3._bypassWebAudio)) || !pP().webAudioMediaStreamDest)) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof kM && this.pendingLocalTracks.some(((e3) => e3 instanceof kM))) throw new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof Bk && this.pendingLocalTracks.some(((e3) => e3 instanceof Bk)) && (!pP().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some(((e3) => e3 instanceof Bk && e3._bypassWebAudio)))) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          var i2;
          const n2 = !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding, r2 = hG(hG({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let o2;
          o2 = n2 ? e2._mediaStreamTrack.clone() : jj(e2, r2);
          const s2 = SN(8, "track-low-"), a2 = new kM(o2, hG(hG({}, n2 && { scaleResolutionDownBy: _F(r2, e2) }), {}, { frameRate: r2.framerate, bitrateMax: r2.bitrate, bitrateMin: r2.bitrate }), void 0, void 0, s2);
          return a2.on(jP.TRANSCEIVER_UPDATED, ((t3) => {
            e2._updateRtpTransceiver(t3, xP.LOW_STREAM);
          })), a2._hints.push(VP.LOW_STREAM), Ln(i2 = e2._hints).call(i2, VP.SCREEN_TRACK) && a2._hints.push(VP.SCREEN_LOW_TRACK), e2.on("sei-to-send", ((e3) => {
            a2.emit("sei-to-send", e3);
          })), e2.addListener(UP.NEED_CLOSE, (() => {
            a2.close();
          })), a2;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        async reportPCStats(e2, t2, i2) {
          let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          if (this.connection && this.connection instanceof Fj) {
            var r2, o2, s2, a2;
            const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: u2 } = this.connection, { local: h2, remote: p2 } = await this.connection.getSelectedCandidatePair();
            lP.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: u2, intSucc: t2 ? 1 : 2, error: this._iceError || n2 || "", selectedLocalCandidateProtocol: null !== (r2 = null == h2 ? void 0 : h2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h2.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h2.address, ":").concat(h2.port), selectedRemoteCandidateProtocol: null !== (s2 = p2.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a2 = p2.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2, preallocation: this.connection.isPreallocation }), this._iceError = null;
          }
        }
        reportVideoFirstFrameRender(e2) {
          const t2 = this.store.keyMetrics, i2 = t2.firstVideoFrameDecoded.find(((t3) => t3.userId === e2.uid));
          if (!i2) return;
          const { isInternalUpload: n2, isExternalUpload: r2 } = i2;
          if (n2 && r2) return;
          const { subscribeEnd: o2, firstPreRender: s2, peerPublishDuration: a2, peerPubStatusMs: c2 } = i2;
          let { firstRender: d2 = 0 } = i2;
          if (o2 && (d2 || s2) && a2 && c2) {
            i2.isInternalUpload = true;
            const { playEnd: n3 } = i2;
            n3 && (i2.isExternalUpload = true);
            const { firstPreRender: r3 = 0 } = i2;
            d2 = r3 || d2;
            const s3 = e2.videoTrack, l2 = { peer: e2._uintid, width: (null == s3 ? void 0 : s3._videoWidth) || 0, height: (null == s3 ? void 0 : s3._videoHeight) || 0, ssrc: e2._videoSSRC || 0, p2pid: this.store.p2pId, peerPublishDuration: a2, peerPubStatusMs: c2, joinChannelStart: t2.joinStart || 0, preloadStart: t2.preloadStart || 0, preloadEnd: t2.preloadEnd || 0, apStart: t2.requestAPStart || 0, apEnd: t2.requestAPEnd || 0, suaEnd: t2.requestSUAEnd || 0, beforeConnect: t2.beforeConnect || 0, peerReceiver: t2.peerReceiver || 0, ice: t2.iceConnectionEnd || 0, pc: t2.peerConnectionEnd || 0, signalConnected: t2.signalConnected || 0, joinReq: t2.joinReq || 0, joinRes: t2.joinRep || 0, userJoinNotify: i2.userJoinNotify || 0, videoAddNotify: i2.videoAddNotify || 0, subscribeStart: i2.subscribeStart || 0, subscribeEnd: i2.subscribeEnd || 0, firstReceived: i2.firstReceived || 0, firstDecoded: i2.firstDecoded || 0, firstPreRender: r3 || 0, firstRender: n3 ? Math.max(d2, n3) : Math.max(d2, o2), playStart: i2.playStart || 0, playEnd: i2.playEnd || 0, isPreSub: !(!e2._videoSSRC || !this.isPreSubScribe(e2._videoSSRC)), isPrePc: this.isPreallocation(), isPreInstantVideo: fP(this.store), firstReceivedEncodedFrame: i2.firstReceivedEncodedFrame || 0, frameType: i2.frameType || "", rtpTimestamp: i2.rtpTimestamp || 0, framePayloadType: i2.framePayloadType || 0, frameDataLength: i2.frameDataLength || 0, mimeType: i2.mimeType || "" };
            lP.firstXLAPeerFirstVideoFrame(this.store.sessionId, l2);
          }
        }
        reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
          var r2;
          const o2 = Array.from(WD(r2 = this.remoteUserMap).call(r2)).find(((t3) => t3._videoSSRC === e2));
          if (o2) {
            n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find(((e3) => e3.userId === o2.uid && "video" === e3.type));
            lP.firstRemoteVideoDecode(this.store.sessionId, sP.FIRST_VIDEO_DECODE, aP.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0, firstFrame: (null == s2 ? void 0 : s2.firstFrame) || 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i2) {
          if (!this.connection) return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2) return false;
          const r2 = n2.get(t2);
          if (!r2) return false;
          const o2 = await this.connection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i2;
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach(((e2) => {
            let [t2, { track: i2 }] = e2;
            t2 === Rx.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, xP.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          }));
        }
      }, DV(lG.prototype, "startP2PConnection", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "startP2PConnection"), lG.prototype), DV(lG.prototype, "connect", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "connect"), lG.prototype), DV(lG.prototype, "updateRemoteRTPCapabilities", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "updateRemoteRTPCapabilities"), lG.prototype), DV(lG.prototype, "publishDataChannel", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "publishDataChannel"), lG.prototype), DV(lG.prototype, "unpublish", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unpublish"), lG.prototype), DV(lG.prototype, "unpublishDataChannel", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unpublishDataChannel"), lG.prototype), DV(lG.prototype, "unpublishLowStream", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unpublishLowStream"), lG.prototype), DV(lG.prototype, "subscribeDataChannel", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "subscribeDataChannel"), lG.prototype), DV(lG.prototype, "subscribe", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "subscribe"), lG.prototype), DV(lG.prototype, "massSubscribe", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "massSubscribe"), lG.prototype), DV(lG.prototype, "unsubscribe", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unsubscribe"), lG.prototype), DV(lG.prototype, "unsubscribeDataChannel", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unsubscribeDataChannel"), lG.prototype), DV(lG.prototype, "massUnsubscribe", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "massUnsubscribe"), lG.prototype), DV(lG.prototype, "muteRemote", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "muteRemote"), lG.prototype), DV(lG.prototype, "unmuteRemote", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "unmuteRemote"), lG.prototype), DV(lG.prototype, "hasRemoteMediaWithLock", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "hasRemoteMediaWithLock"), lG.prototype), DV(lG.prototype, "disconnectForReconnect", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "disconnectForReconnect"), lG.prototype), DV(lG.prototype, "updateBitrateLimit", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "updateBitrateLimit"), lG.prototype), DV(lG.prototype, "remoteMediaSsrcChanged", [mG], Object.getOwnPropertyDescriptor(lG.prototype, "remoteMediaSsrcChanged"), lG.prototype), lG);
      function mG(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PChannel.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function fG(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function SG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? fG(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : fG(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const gG = Date.now(), TG = 20, RG = /* @__PURE__ */ new Map(), CG = /* @__PURE__ */ new Map();
      async function vG(e2) {
        const t2 = RG.get(e2), i2 = Array.isArray(t2) && t2[t2.length - 1], n2 = CG.get(e2);
        if (!i2) return void (n2.isSyncing = false);
        const r2 = { uid: i2.uid, payload: i2.payload };
        0 === n2.firstRecvTs && (n2.firstRecvTs = i2.recvTs, n2.firstSendTs = i2.sendTs);
        const o2 = i2.sendTs - n2.firstSendTs, s2 = o2 - (Date.now() - n2.firstRecvTs);
        s2 > 0 && (n2.firstRecvTs = Date.now() - o2);
        let a2 = i2.mediaDelay + s2;
        a2 <= 0 ? (t2.pop(), yG(i2.context, r2), a2 = 0) : a2 = Math.min(a2, TG), setTimeout((() => t2.length && vG(e2)), a2);
      }
      function yG(e2, t2) {
        e2.safeEmit(GO.STREAM_MESSAGE, t2.uid, t2.payload), e2.onStreamMessage && e2.onStreamMessage(t2);
      }
      function IG(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
        if (!e2.syncWithAudio) return yG(i2, { uid: e2.uid, payload: e2.payload });
        const n2 = "".concat(i2.id, "-").concat(e2.uid), r2 = RG.get(n2) || [], o2 = r2.findIndex(((t3) => e2.sendTs >= t3.sendTs)), s2 = SG(SG({}, e2), {}, { context: i2, mediaDelay: t2, recvTs: Date.now() });
        -1 === o2 ? r2.push(s2) : r2.splice(o2, 0, s2), RG.set(n2, r2);
        let a2 = false;
        var c2;
        CG.has(n2) ? a2 = !(null === (c2 = CG.get(n2)) || void 0 === c2 || !c2.isSyncing) : CG.set(n2, { isSyncing: a2, firstRecvTs: 0, firstSendTs: 0 });
        a2 || vG(n2);
      }
      const AG = Dw().name;
      function bG(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function wG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? bG(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : bG(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const OG = "websdk_ng_cache_parameter", NG = CD("MAX_PRELOAD_ASYNC_LENGTH"), DG = 1e4, PG = /* @__PURE__ */ new Map(), LG = [];
      let kG = null, MG = 0, UG = 0;
      const VG = /* @__PURE__ */ new Map(), xG = new Uint8Array([241, 141, 127, 212, 103, 139, 200, 225, 251, 157, 127, 139, 143, 2, 22, 163]), FG = /* @__PURE__ */ (function(e2, t2) {
        const i2 = [];
        let n2 = 0;
        const r2 = async () => {
          const e3 = i2.shift();
          e3 && await e3(), i2.length > 0 && n2 < t2 ? r2() : n2--;
        };
        return async function() {
          for (var o2 = arguments.length, s2 = new Array(o2), a2 = 0; a2 < o2; a2++) s2[a2] = arguments[a2];
          return new rp((async (o3, a3) => {
            i2.push((async () => {
              try {
                const t3 = await e2(...s2);
                o3(t3);
              } catch (e3) {
                a3(e3);
              }
            })), n2 < t2 && (n2++, r2());
          }));
        };
      })(GG, NG), BG = Tw.CancelToken.source();
      class jG {
        constructor() {
          iA(this, "_audioContext", null);
        }
        createMuteAudioTrack() {
          this._audioContext = new AudioContext();
          const e2 = this._audioContext.sampleRate, t2 = 10 * e2, i2 = this._audioContext.createBuffer(2, t2, e2), n2 = this._audioContext.createBufferSource();
          n2.buffer = i2;
          const r2 = this._audioContext.createMediaStreamDestination();
          n2.connect(r2), n2.start();
          return r2.stream.getAudioTracks()[0];
        }
        close() {
          this._audioContext && (this._audioContext.close(), this._audioContext = null);
        }
      }
      async function GG(e2, t2, i2, n2, r2, o2, s2) {
        try {
          if (!CD("ENABLE_PRELOAD")) return;
          if (!pP().supportWebCrypto) return void dN((() => {
            iP.warn("Your browser does not support preloading, this feature  be run in a secure environment");
          }), "preload_webcrypto_not_supported");
          if (!i2 && null !== i2) throw new pO(hO.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
          i2 && SO(i2, "token", 1, 2047), SO(e2, "appid", 1, 2047), HV(t2), n2 && KV(n2);
          const a2 = gN();
          iP.debug("preload channel ".concat(t2, ", uid is ").concat(n2));
          const c2 = { appId: e2, cname: t2, token: i2 || e2, uid: "string" != typeof n2 ? n2 : null, sid: a2, proxyServer: r2, role: s2 };
          let d2, l2;
          "string" == typeof n2 ? (c2.stringUid = n2, [l2, d2] = await rp.all([HB(n2, { sid: a2, appId: e2 }, BG.token), YB(wG(wG({}, c2), {}, { token: i2 || e2, uid: 0 }), BG.token)]), c2.uid = l2.uid, d2.gatewayInfo.uid = c2.uid, d2.gatewayInfo.res.uid = c2.uid) : (o2 && (c2.stringUid = o2), d2 = await YB(c2, BG.token));
          const u2 = { sid: a2, appId: e2, cname: t2, token: i2 || e2, uid: c2.stringUid || n2, intUid: c2.uid || d2.gatewayInfo.uid, stringUid: c2.stringUid, ts: Date.now(), sua: l2, ap: d2 };
          await KG(u2), MG++;
        } catch (e3) {
          throw UG++, (function(e4) {
            kG || (kG = window.setTimeout((() => {
              let t4 = "";
              VG.forEach(((e5, i3) => {
                t4 += "".concat(i3, ": ").concat(e5, " ;");
              })), lP.reportApiInvoke(null, { name: LO.PRELOAD, options: { success: MG, failed: UG, err: t4 } }).onError(e4), MG = 0, UG = 0, VG.clear(), kG = null;
            }), DG));
            const t3 = VG.get(e4.code) || 0;
            VG.set(e4.code, t3 + 1);
          })(e3), e3;
        }
      }
      async function WG(e2) {
        try {
          if (CD("AP_REQUEST_DETAIL") || CD("ENABLE_ROLE_SELECT_EDGE")) return;
          const t2 = HG(e2);
          if (!t2 || "disabled" !== e2.cloudProxyServer) return;
          const i2 = await (async function(e3, t3) {
            try {
              const i3 = await window.crypto.subtle.importKey("raw", hN(t3), "AES-GCM", false, ["decrypt"]), n2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: xG }, i3, lN(e3));
              return JSON.parse(window.atob(uN(new Uint8Array(n2))));
            } catch (e4) {
              return;
            }
          })(t2, e2.token || e2.appId);
          if (!i2) return;
          if (!(function(e3, t3) {
            const i3 = e3.cname === t3.cname && e3.appId === t3.appId && e3.token === t3.token;
            if (!i3) return false;
            return t3.stringUid ? e3.stringUid === t3.stringUid : "number" == typeof t3.uid ? e3.uid === t3.uid : e3.uid == t3.uid;
          })(i2, e2)) return;
          if (i2 && Date.now() - i2.ts < CD("AP_CACHE_LIFETIME")) return i2;
        } catch (e3) {
          iP.warn("Error get preloadInfo", e3.message);
        }
      }
      function HG(e2) {
        let t2;
        try {
          if (t2 = XG(OG), !t2) return;
          const i2 = JSON.parse(t2), n2 = QG(e2), r2 = (function(e3, t3) {
            for (let i3 = e3.length - 1; i3 >= 0; i3--) if (t3(e3[i3])) return i3;
            return -1;
          })(i2, ((e3) => n2 in e3));
          if (-1 === r2) return;
          const o2 = i2.splice(r2, 1)[0];
          return JG(OG, JSON.stringify(i2)), o2[n2];
        } catch (e3) {
          iP.warn("Error delete preload info: ".concat(t2), e3.message), JG(OG, "");
        }
      }
      async function KG(e2) {
        let t2;
        try {
          e2.uid && HG({ appId: e2.appId, cname: e2.cname, token: e2.token, uid: e2.uid, stringUid: e2.stringUid });
          const i2 = QG(e2), n2 = await (async function(e3, t3) {
            try {
              const i3 = await window.crypto.subtle.importKey("raw", hN(t3), "AES-GCM", false, ["encrypt"]), n3 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: xG }, i3, lN(window.btoa(JSON.stringify(e3))));
              return uN(new Uint8Array(n3));
            } catch (e4) {
              return;
            }
          })(e2, e2.token || e2.appId);
          if (!n2) return;
          t2 = XG(OG);
          const r2 = t2 ? JSON.parse(t2) : [];
          r2.push({ [i2]: n2 }), r2.length > CD("AP_CACHE_NUM") && r2.shift(), JG(OG, JSON.stringify(r2));
        } catch (e3) {
          iP.warn("Error caching server parameters:", e3.message), JG(OG, "");
        }
      }
      function YG(e2) {
        if (e2) {
          let t2 = PG.get(e2);
          t2 && (window.clearTimeout(t2), t2 = null, PG.delete(e2)), Ln(LG).call(LG, e2) || "disabled" !== e2.cloudProxyServer || LG.push(e2);
        }
        if (PG.size < CD("AP_CACHE_NUM") && LG.length > 0) {
          const e3 = LG.shift();
          PG.set(e3, window.setTimeout((async () => {
            const { appId: t2, cname: i2, token: n2, stringUid: r2, uid: o2, proxyServer: s2, role: a2 } = e3;
            try {
              await FG(t2, i2, n2, o2, s2, r2, a2), PG.has(e3) && YG(e3);
            } catch (t3) {
              iP.warn("update preload failed", t3.message), zG(e3);
            }
          }), CD("AP_UPDATE_INTERVAL")));
        }
      }
      function zG(e2) {
        const t2 = LG.indexOf(e2);
        -1 !== t2 && LG.splice(t2, 1);
        let i2 = PG.get(e2);
        i2 && (window.clearTimeout(i2), i2 = null, PG.delete(e2), YG());
      }
      function qG(e2, t2) {
        const i2 = e2.sua, n2 = e2.ap;
        t2 && i2 && lP.reqUserAccount(e2.sid, { lts: i2.requestTime, elapse: i2.elapse, success: true, serverAddr: i2.url, stringUid: t2, uid: e2.intUid, errorCode: null, extend: i2.req }), lP.reportResourceTiming(e2.ap.url, e2.sid), lP.joinWebProxyAP(e2.sid, { lts: n2.requestTime, elapse: n2.elapse, sucess: 1, apServerAddr: n2.url, turnServerAddrList: n2.proxyInfo.addresses.map(((e3) => e3.ip)).join(","), eventType: "disabled", unilbsServerIds: [iF.CHOOSE_SERVER, iF.CLOUD_PROXY_FALLBACK].toString() }), lP.joinChooseServer(e2.sid, { lts: n2.requestTime, elapse: n2.elapse, succ: true, csAddr: n2.url, opid: n2.opid, serverList: n2.gatewayInfo.gatewayAddrs.map(((e3) => e3.address)), ec: null, cid: n2.gatewayInfo.cid.toString(), uid: n2.gatewayInfo.uid.toString(), csIp: n2.gatewayInfo.csIp, unilbsServerIds: [iF.CHOOSE_SERVER].toString(), isHttp3: n2.isHttp3 });
      }
      function XG(e2) {
        return window.atob(window.localStorage.getItem(e2) || "");
      }
      function JG(e2, t2) {
        window.localStorage.setItem(e2, window.btoa(t2));
      }
      function QG(e2) {
        let t2 = "".concat(e2.appId, "_").concat(e2.cname);
        return "string" == typeof e2.uid && (t2 += "_s_".concat(e2.uid)), "number" == typeof e2.uid && (t2 += "_".concat(e2.uid)), e2.token && (t2 += "_".concat(e2.token)), ON(t2);
      }
      function ZG(e2) {
        let t2 = (function() {
          const e3 = iW.pop();
          return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        })();
        return (function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && (pW(t3, 10), dW(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && (pW(t3, 16), pW(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && (pW(t3, 26), dW(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (pW(t3, 34), dW(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (pW(t3, 40), EW(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && (pW(t3, 48), EW(t3, tW(a2)));
          let c2 = e3.height;
          void 0 !== c2 && (pW(t3, 56), EW(t3, tW(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && (pW(t3, 66), pW(t3, d2.length), aW(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (pW(t3, 72), EW(t3, tW(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && (pW(t3, 80), EW(t3, tW(u2)));
          let h2 = e3.requestId;
          void 0 !== h2 && (pW(t3, 90), dW(t3, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (pW(t3, 98), dW(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (pW(t3, 104), EW(t3, tW(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && (pW(t3, 114), dW(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && (pW(t3, 120), EW(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && (pW(t3, 128), pW(t3, f2));
          let S2 = e3.vid;
          void 0 !== S2 && (pW(t3, 136), pW(t3, S2));
          let g2 = e3.width;
          void 0 !== g2 && (pW(t3, 144), EW(t3, tW(g2)));
          let T2 = e3.service;
          void 0 !== T2 && (pW(t3, 152), pW(t3, T2));
          let R2 = e3.callbackData;
          void 0 !== R2 && (pW(t3, 162), pW(t3, R2.length), aW(t3, R2));
          let C2 = e3.ticket;
          void 0 !== C2 && (pW(t3, 170), dW(t3, C2));
          let v2 = e3.vendorConfigs;
          void 0 !== v2 && (pW(t3, 178), dW(t3, v2));
        })(e2, t2), (function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        })(t2);
      }
      function $G(e2) {
        return (function(e3) {
          let t3 = {};
          e: for (; !rW(e3); ) {
            let i2 = hW(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = hW(e3);
                break;
              case 2:
                t3.msg = cW(e3, hW(e3));
                break;
              case 3:
                t3.requestId = cW(e3, hW(e3));
                break;
              case 4:
                t3.timestamp = _W(e3, false);
                break;
              default:
                eW(e3, 7 & i2);
            }
          }
          return t3;
        })({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function eW(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & lW(e2); ) ;
            break;
          case 2:
            nW(e2, hW(e2));
            break;
          case 5:
            nW(e2, 4);
            break;
          case 1:
            nW(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      function tW(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let iW = [];
      function nW(e2, t2) {
        if (e2.offset + t2 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function rW(e2) {
        return e2.offset >= e2.limit;
      }
      function oW(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i2.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function sW(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function aW(e2, t2) {
        let i2 = oW(e2, t2.length);
        e2.bytes.set(t2, i2);
      }
      function cW(e2, t2) {
        let i2 = sW(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i2];
          0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function dW(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        pW(e2, n2);
        let r2 = oW(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function lW(e2) {
        return e2.bytes[sW(e2, 1)];
      }
      function uW(e2, t2) {
        let i2 = oW(e2, 1);
        e2.bytes[i2] = t2;
      }
      function hW(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = lW(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function pW(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; ) uW(e2, 127 & t2 | 128), t2 >>>= 7;
        uW(e2, t2);
      }
      function _W(e2, t2) {
        let i2, n2 = 0, r2 = 0, o2 = 0;
        return i2 = lW(e2), n2 = 127 & i2, 128 & i2 && (i2 = lW(e2), n2 |= (127 & i2) << 7, 128 & i2 && (i2 = lW(e2), n2 |= (127 & i2) << 14, 128 & i2 && (i2 = lW(e2), n2 |= (127 & i2) << 21, 128 & i2 && (i2 = lW(e2), r2 = 127 & i2, 128 & i2 && (i2 = lW(e2), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = lW(e2), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = lW(e2), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = lW(e2), o2 = 127 & i2, 128 & i2 && (i2 = lW(e2), o2 |= (127 & i2) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t2 };
      }
      function EW(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = oW(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      const mW = {}, fW = {}, SW = 4294967296, gW = SW * SW, TW = gW / 2, RW = AW(0, true), CW = AW(0), vW = bW(0, -2147483648, false), yW = bW(-1, 2147483647, false), IW = bW(-1, -1, true);
      function AW(e2, t2) {
        let i2, n2, r2;
        return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = fW[e2], n2) ? n2 : (i2 = bW(e2, 0, true), r2 && (fW[e2] = i2), i2) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = mW[e2], n2) ? n2 : (i2 = bW(e2, e2 < 0 ? -1 : 0, false), r2 && (mW[e2] = i2), i2);
      }
      function bW(e2, t2, i2) {
        return { low: 0 | e2, high: 0 | t2, unsigned: !!i2 };
      }
      function wW(e2, t2) {
        if (isNaN(e2)) return t2 ? RW : CW;
        if (t2) {
          if (e2 < 0) return RW;
          if (e2 >= gW) return IW;
        } else {
          if (e2 <= -TW) return vW;
          if (e2 + 1 >= TW) return yW;
        }
        return e2 < 0 ? t2 ? RW : CW : bW(e2 % SW | 0, e2 / SW | 0, t2);
      }
      function OW(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class NW extends NO {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(Dx.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout((() => {
            this.quality = this._quality / this._qualityRatio;
          }), 6e4));
        }
        constructor(e2) {
          var t2;
          super(), iA(this, "name", "AgoraRTCImageModeration"), iA(this, "_connectionState", Nx.CONNECTING), iA(this, "_sequence", 0), iA(this, "_moderationStartTime", void 0), iA(this, "_workerConnection", void 0), iA(this, "_workerMessageLengthLimit", void 0), iA(this, "_qualityRatio", void 0), iA(this, "_connectInfo", void 0), iA(this, "_cancelTokenSource", Tw.CancelToken.source()), iA(this, "_retryConfig", void 0), iA(this, "_moderationInterval", void 0), iA(this, "_moderationTimer", null), iA(this, "_moderationMode", 1), iA(this, "_quality", 1), iA(this, "_qualityTimer", null), iA(this, "_ticket", void 0), iA(this, "_moderationIntervalMinimum", void 0), iA(this, "_uploadFailedNum", 0), iA(this, "_uploadNum", 0), iA(this, "_uploadTimer", null), iA(this, "_extraInfo", void 0), iA(this, "_vendor", ""), iA(this, "_encoder", new TextEncoder()), iA(this, "_moderationId", void 0), iA(this, "inspectImage", (() => {
            if (this.connectionState !== Nx.CONNECTED) throw new uP(hO.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
            this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval((() => {
              this.connectionState === Nx.CONNECTED ? this.requestToInspectImage() : iP.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
            }), this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
          })), this._moderationId = SN(5, "image-moderation-"), this._workerMessageLengthLimit = CD("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = CD("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), this._qualityRatio = CD("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new $x("worker-" + this._moderationId, kN), this.on(Dx.STATE_CHANGE, ((e3, t3) => {
            iP.debug("[".concat(this._moderationId, "] Moderation operation :").concat(Px[e3], " ").concat(t3 || ""));
          })), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(Dx.STATE_CHANGE, Px.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new rp(((n2, r2) => {
            this.on(Dx.CONNECTION_STATE_CHANGE, ((e3, t3) => {
              e3 === Nx.CONNECTED && n2();
            })), this.requestAP(e2, i2, t2).then(((e3) => {
              this.connectWorker(e3);
            })).catch(((e3) => {
              r2(e3);
            }));
          }));
        }
        updateConfig(e2) {
          var t2;
          this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), iP.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === Nx.CONNECTED && this.inspectImage();
        }
        async requestAP(e2, t2, i2) {
          const n2 = CD("WEBCS_DOMAIN").map(((e3) => "https://".concat(e3, "/api/v1"))), r2 = await (function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: o3, cname: s3, sid: a2, token: c2, uid: d2 } = t3;
            UB++;
            const l2 = "moderation_plugin", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: UB, seq: UB, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return UN((async () => {
              h2 = Date.now();
              const e4 = await _B(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new uP(hO.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw iP.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new uP(hO.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw iP.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new uP(hO.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p2 });
                throw iP.error(e5.toString()), e5;
              }
              if (!t4.servers.some(((e5) => !!e5.wss))) {
                const e5 = new uP(hO.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p2 });
                throw iP.error(e5.toString()), e5;
              }
              const n4 = CD("IMAGE_MODERATION_WORKER_WSS");
              if (n4) return { addressList: [n4], workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
              const r4 = CD("IMAGE_MODERATION_WORKER_HOST"), o4 = t4.servers.map(((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(r4, ":").concat(i4, "/moderation");
              })).filter(((e5) => !!e5));
              return { addressList: o4, workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p2 };
            }), ((t4, i4) => (lP.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false)), ((t4, i4) => (lP.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== hO.OPERATION_ABORTED && t4.code !== hO.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true))), n3);
          })(n2, e2, t2, i2);
          this.emit(Dx.STATE_CHANGE, Px.AP_CONNECTED);
          const { addressList: o2, ticket: s2 } = r2;
          return this._ticket = s2, o2;
        }
        async connectWorker(e2) {
          this.emit(Dx.STATE_CHANGE, Px.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
        }
        handleWorkerEvents() {
          this._workerConnection.on(WV.CONNECTED, (async () => {
            this.emit(Dx.STATE_CHANGE, Px.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = Nx.CONNECTED;
          })), this._workerConnection.on(WV.CLOSED, (() => {
            this.connectionState = Nx.CLOSED;
          })), this._workerConnection.on(WV.FAILED, (() => {
            this.connectionState = Nx.CLOSED;
          })), this._workerConnection.on(WV.RECONNECTING, (() => {
            this.connectionState = this.connectionState === Nx.CONNECTED ? Nx.RECONNECTING : Nx.CONNECTING;
          })), this._workerConnection.on(WV.ON_MESSAGE, (async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const t2 = $G(new Uint8Array(e2.data));
              CD("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && iP.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, iP.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout((() => {
                lP.reportApiInvoke(this._connectInfo.sid || null, { name: LO.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: kO.TRACER }).onError(new uP(hO.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
              }), CD("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
            } else iP.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
          })), this._workerConnection.on(WV.WILL_RECONNECT, ((e2, t2, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          })), this._workerConnection.on(WV.REQUEST_NEW_URLS, ((e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          }));
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          const e2 = XO(this, Dx.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void (CD("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && iP.debug("Only the track being played can be inspected"));
            this._sequence++;
            const i2 = await this.generateRequestData(e2, t2);
            this._workerConnection.sendMessage(i2, true, true);
          } else CD("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && iP.debug("Only the track being published can be inspected");
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await QL(d2, i2, n2), u2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + SN(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: NW.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.24.2", sequence: this._sequence, sid: s2, timestamp: wW(c2), uid: a2, vid: o2, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
          void 0 === this._extraInfo && delete h2.callbackData;
          const p2 = ZG(h2);
          if (p2.byteLength < this._workerMessageLengthLimit) {
            if (CD("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
              const e3 = (function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? OW(Object(i3), true).forEach((function(t4) {
                    iA(e4, t4, i3[t4]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : OW(Object(i3)).forEach((function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  }));
                }
                return e4;
              })({}, h2);
              delete e3.jpg, iP.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t3 = this.quality * this._qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = Tw.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = Nx.CLOSED, this.emit(Dx.STATE_CHANGE, Px.CLOSED);
        }
      }
      function DW(e2) {
        if (mO(e2.interval, "interval", 1e3, 1 / 0), e2 && e2.extraInfo && e2.extraInfo.length > 1024) throw new uP(hO.INVALID_PARAMS, "config.extraInfo length cannot exceed 1024 bytes");
        if (e2 && e2.vendor && e2.vendor.length > 1024) throw new uP(hO.INVALID_PARAMS, "config.vendor length cannot exceed 1024 bytes");
      }
      const PW = { name: "ImageModeration", create: function(e2) {
        let { config: t2 } = e2;
        return DW(t2), new NW(t2);
      } };
      var LW, kW, MW, UW, VW, xW, FW, BW, jW, GW, WW, HW, KW, YW, zW, qW, XW, JW, QW, ZW, $W, eH, tH, iH, nH, rH, oH, sH, aH, cH, dH, lH, uH, hH, pH, _H, EH, mH, fH, SH, gH, TH, RH;
      function CH(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function vH(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? CH(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : CH(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      PN.setLogger(iP);
      let yH = (LW = dP(), kW = dP({ argsMap: (e2, t2) => {
        if (!Array.isArray(t2)) {
          if (!(t2 instanceof lL)) return [t2];
          t2 = [t2];
        }
        return t2.map(((e3) => e3 ? Object(e3).toString() : "null"));
      } }), MW = dP({ argsMap: (e2, t2) => (t2 || (t2 = []), Array.isArray(t2) || t2.trackMediaType !== HP.DATA ? (Array.isArray(t2) || (t2 = [t2]), t2.map(((e3) => e3.getTrackId()))) : [t2.getChannelId()]) }), UW = dP({ argsMap: (e2, t2, i2, n2) => ["object" == typeof t2 ? t2.uid : t2, i2, n2] }), VW = dP({ argsMap: (e2, t2, i2) => [t2, i2] }), xW = dP({ argsMap: (e2, t2) => t2.map(((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return [null == t3 ? void 0 : t3.uid, i2];
      })) }), FW = dP({ argsMap: (e2, t2, i2, n2) => ["object" == typeof t2 ? t2.uid : t2, i2, n2] }), BW = dP({ argsMap: (e2, t2) => t2.map(((e3) => {
        let { user: t3, mediaType: i2 } = e3;
        return { uid: null == t3 ? void 0 : t3.uid, mediaType: i2 };
      })) }), jW = dP(), GW = dP(), WW = dP(), HW = dP(), KW = dP(), YW = dP(), zW = dP(), qW = dP(), XW = dP(), JW = dP(), QW = dP(), ZW = dP(), $W = dP(), eH = dP(), tH = dP(), iH = dP(), nH = dP({ argsMap: (e2, t2) => [t2] }), rH = dP(), oH = dP(), sH = dP(), aH = dP(), cH = dP(), dH = dP(), lH = dP(), uH = dP(), hH = dP({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), pH = dP(), _H = dP(), EH = dP(), mH = dP(), fH = dP(), SH = dP(), gH = dP({ reportResult: true }), TH = dP(), RH = class extends NO {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get localDataChannels() {
          return this._p2pChannel.getAllDataChannels();
        }
        get mode() {
          return this._config.mode;
        }
        get role() {
          var e2;
          return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
        }
        get codec() {
          return this._config.codec;
        }
        get audioCodec() {
          return this._config.audioCodec || "opus";
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        get __className__() {
          return "Client";
        }
        constructor(e2, t2) {
          let i2;
          if (super(), iA(this, "store", void 0), iA(this, "_uid", void 0), iA(this, "_channelName", void 0), iA(this, "_uintUid", void 0), iA(this, "_users", []), iA(this, "_config", void 0), iA(this, "_clientId", void 0), iA(this, "_appId", void 0), iA(this, "_sessionId", null), iA(this, "_key", void 0), iA(this, "_rtmConfig", {}), iA(this, "_joinInfo", void 0), iA(this, "_gateway", void 0), iA(this, "_statsCollector", void 0), iA(this, "_configDistribute", void 0), iA(this, "_leaveMutex", void 0), iA(this, "_publishMutex", void 0), iA(this, "_renewTokenMutex", void 0), iA(this, "_subscribeMutex", void 0), iA(this, "_encryptionMode", "none"), iA(this, "_encryptionSecret", null), iA(this, "_encryptionSalt", null), iA(this, "_encryptDataStream", false), iA(this, "_encryptDataStreamKey", null), iA(this, "_encryptDataStreamIv", null), iA(this, "_proxyServer", void 0), iA(this, "_turnServer", { servers: [], mode: "auto" }), iA(this, "_cloudProxyServerMode", "disabled"), iA(this, "_isDualStreamEnabled", false), iA(this, "_defaultStreamFallbackType", void 0), iA(this, "_lowStreamParameter", void 0), iA(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), iA(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), iA(this, "_axiosCancelSource", Tw.CancelToken.source()), iA(this, "_audioVolumeIndicationInterval", void 0), iA(this, "_networkQualityInterval", void 0), iA(this, "_userOfflineTimeout", void 0), iA(this, "_streamRemovedTimeout", void 0), iA(this, "_rteDetailInterval", void 0), iA(this, "_liveTranscodeStreamingClient", void 0), iA(this, "_liveRawStreamingClient", void 0), iA(this, "_channelMediaRelayClient", void 0), iA(this, "_networkQualitySensitivity", "normal"), iA(this, "_p2pChannel", void 0), iA(this, "_useLocalAccessPoint", false), iA(this, "_setLocalAPVersion", void 0), iA(this, "_joinAndNotLeaveYet", false), iA(this, "_numberOfJoinCount", 0), iA(this, "_joinResponse", null), iA(this, "_remoteDefaultVideoStreamType", void 0), iA(this, "_inspect", void 0), iA(this, "_moderation", void 0), iA(this, "_license", void 0), iA(this, "_pendingPublishedUsers", []), iA(this, "ntpAlignErrorCount", 0), iA(this, "remoteInboundOffset", 0), iA(this, "_peerConnectionState", void 0), iA(this, "_pendingRtpCapabilityChange", void 0), iA(this, "_fallbackServerInfo", void 0), iA(this, "_dualStreamMode", void 0), iA(this, "_handleLocalTrackEnable", ((e3, t3, i3) => {
            this.publish(e3, false).then(t3).catch(i3);
          })), iA(this, "_handleLocalTrackDisable", ((e3, t3, i3) => {
            this.unpublish(e3).then(t3).catch(i3);
          })), iA(this, "_handleUserOnline", ((e3) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(e3.uid, this.channelName)) return void iP.debug("[".concat(e3.uid, "] will be ignored in local"));
            this.isStringUID && "string" != typeof e3.uid && iP.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
            const t3 = this._users.find(((t4) => t4.uid === e3.uid));
            if (t3) t3._trust_in_room_ = true, t3._is_pre_created && (t3._is_pre_created = false, this.safeEmit(GO.USER_JOINED, t3));
            else {
              const t4 = new aj(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t4), iP.debug("[".concat(this._clientId, "] user online"), e3.uid), this.store.firstVideoFrameDecoded(t4.uid, { userJoinNotify: Date.now() }), this.safeEmit(GO.USER_JOINED, t4);
            }
          })), iA(this, "_handleUserOffline", ((e3) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(e3.uid, this.channelName)) return;
            const t3 = this._users.find(((t4) => t4.uid === e3.uid));
            t3 && (this._handleRemoveStream(e3), this._handleRemoveDataChannels(e3), t3._audio_pre_subscribed || t3._video_pre_subscribed ? t3._is_pre_created = true : nN(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), iP.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(GO.USER_LEAVED, t3, e3.reason));
          })), iA(this, "_handleAddAudioOrVideoStream", ((e3, t3, i3, n3, r2, o2, s2, a2) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(t3, this.channelName)) return;
            const c2 = this._users.find(((e4) => e4.uid === t3));
            if (!c2) return void iP.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            iP.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(c2.uid, e3, void 0, void 0, void 0, Date.now()), "video" === e3 && this.store.firstVideoFrameDecoded(c2.uid, { videoAddNotify: Date.now() });
            const d2 = "audio" === e3 ? c2.hasAudio : c2.hasVideo;
            c2._uintid || (c2._uintid = o2 || t3), "audio" === e3 ? c2._trust_audio_stream_added_state_ = true : c2._trust_video_stream_added_state_ = true, "audio" === e3 ? (c2._audio_added_ = true, void 0 !== i3 && (c2._audioSSRC = i3), void 0 !== n3 && (c2._cname = n3), s2 && (c2._audioOrtc = s2)) : (c2._video_added_ = true, void 0 !== i3 && (c2._videoSSRC = i3), void 0 !== n3 && (c2._cname = n3), void 0 !== a2 && (c2._rtxSsrcId = a2), s2 && (c2._videoOrtc = s2)), ("audio" === e3 ? c2.hasAudio : c2.hasVideo) && !d2 && (iP.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published ").concat(e3)), this.safeEmit(GO.USER_PUBLISHED, c2, e3)), "video" === e3 ? lP.onGatewayStream(this._sessionId, sP.ON_ADD_VIDEO_STREAM, aP.ON_ADD_VIDEO_STREAM, { peer: o2 || t3, ssrc: c2._videoSSRC }) : lP.onGatewayStream(this._sessionId, sP.ON_ADD_AUDIO_STREAM, aP.ON_ADD_AUDIO_STREAM, { peer: o2 || t3, ssrc: c2._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(c2, e3, i3).then(((t4) => {
              if (t4 && (iP.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(c2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof EG)) return this._p2pChannel.unsubscribe(c2, e3, true).then((() => this._subscribe(c2, e3, true).catch(((e4) => {
                iP.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }))));
            })), this._p2pChannel.hasPendingRemoteMedia(c2, e3) && (iP.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(c2.uid, " after reconnect.")), this._subscribe(c2, e3, true).catch(((e4) => {
              iP.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            })));
            const l2 = this._getEncodingName(r2);
            "video" === e3 && ("unknown" === l2 ? this.safeEmit(GO.AV1_DECODABLE_RESULT, false) : Vw() || jw() || (null == l2 ? void 0 : l2.toLocaleLowerCase()) !== AD.av1 || BB().then(((e4) => {
              CD("FLS_ENABLE_AV1_DECODE_DETECT") && this.safeEmit(GO.AV1_DECODABLE_RESULT, e4), e4 || this._gateway.downgradeCodec(l2);
            })));
          })), iA(this, "_handleRemoveStream", ((e3) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(e3.uid, this.channelName)) return;
            const t3 = this._users.find(((t4) => t4.uid === e3.uid));
            if (!t3) return void iP.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
            iP.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
            let i3 = () => {
            };
            t3.hasAudio && t3.hasVideo ? i3 = () => {
              iP.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(GO.USER_UNPUBLISHED, t3, "audio"), iP.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(GO.USER_UNPUBLISHED, t3, "video");
            } : t3.hasVideo ? i3 = () => {
              iP.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(GO.USER_UNPUBLISHED, t3, "video");
            } : t3.hasAudio && (i3 = () => {
              iP.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(GO.USER_UNPUBLISHED, t3, "audio");
            }), t3._video_pre_subscribed || t3._audio_pre_subscribed || (t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel instanceof EG && this._p2pChannel.unsubscribe(t3).then(((e4) => {
              if (e4) return this._gateway.unsubscribe(e4, t3.uid);
            })), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0), lP.onGatewayStream(this._sessionId, sP.ON_REMOVE_STREAM, aP.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i3();
          })), iA(this, "_handleSetStreamLocalEnable", ((e3, t3, i3) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(t3, this.channelName)) return;
            const n3 = this._users.find(((e4) => e4.uid === t3));
            if (!n3) return void iP.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
            iP.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i3 ? "enabled" : "disabled", " with uid ").concat(t3));
            const r2 = "audio" === e3 ? n3.hasAudio : n3.hasVideo;
            if ("audio" === e3) {
              n3._trust_audio_enabled_state_ = true;
              const e4 = n3._audio_enabled_;
              if (n3._audio_enabled_ = i3, n3._audio_enabled_ === e4) return;
              {
                const e5 = n3._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                iP.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(GO.USER_INFO_UPDATED, t3, e5);
              }
            } else {
              n3._trust_video_enabled_state_ = true;
              const e4 = n3._video_enabled_;
              if (n3._video_enabled_ = i3, n3._video_enabled_ === e4) return;
              {
                const e5 = n3._video_enabled_ ? "enable-local-video" : "disable-local-video";
                iP.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(GO.USER_INFO_UPDATED, t3, e5);
              }
            }
            const o2 = "audio" === e3 ? n3.hasAudio : n3.hasVideo;
            return r2 !== o2 ? !r2 && o2 ? (iP.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(GO.USER_PUBLISHED, n3, e3)) : ("video" === e3 && n3._videoTrack && n3._videoTrack._destroy(), "audio" === e3 && n3._audioTrack, this._p2pChannel.muteRemote(n3, e3), iP.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(GO.USER_UNPUBLISHED, n3, e3)) : void 0;
          })), iA(this, "_handleMuteStream", ((e3, t3, i3) => {
            if (CD("BLOCK_LOCAL_CLIENT") && zU(e3, this.channelName)) return;
            iP.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i3);
            const n3 = this._users.find(((t4) => t4.uid === e3));
            if (!n3) return void iP.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
            const r2 = "audio" === t3 ? n3.hasAudio : n3.hasVideo;
            if ("audio" === t3) {
              n3._trust_audio_mute_state_ = true;
              const t4 = n3._audio_muted_;
              if (n3._audio_muted_ = i3, n3._audio_muted_ === t4) return;
              {
                const t5 = n3._audio_muted_ ? "mute-audio" : "unmute-audio";
                iP.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(GO.USER_INFO_UPDATED, e3, t5);
              }
            } else {
              n3._trust_video_mute_state_ = true;
              const t4 = n3._video_muted_;
              if (n3._video_muted_ = i3, n3._video_muted_ === t4) return;
              {
                const t5 = n3._video_muted_ ? "mute-video" : "unmute-video";
                iP.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(GO.USER_INFO_UPDATED, e3, t5);
              }
            }
            const o2 = "audio" === t3 ? n3.hasAudio : n3.hasVideo;
            if (r2 !== o2) {
              if (!r2 && o2) {
                return ("audio" === t3 ? n3._audioSSRC : n3._videoSSRC) ? (iP.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(GO.USER_PUBLISHED, n3, t3)) : void iP.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
              }
              "video" === t3 && n3._videoTrack && !n3._video_pre_subscribed && n3._videoTrack._destroy(), "audio" === t3 && n3._audioTrack, this._p2pChannel.muteRemote(n3, t3), iP.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(GO.USER_UNPUBLISHED, n3, t3);
            }
          })), iA(this, "_handleP2PLost", (async (e3) => {
            iP.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : iP.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
          })), iA(this, "_handleTokenWillExpire", (() => {
            iP.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(GO.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          })), iA(this, "_handleBeforeUnload", ((e3) => {
            "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), iP.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
          })), iA(this, "_handleUpdateNetworkQuality", (() => {
            if ("normal" === this._networkQualitySensitivity) return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(GO.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(GO.NETWORK_QUALITY, e3);
          })), iA(this, "_handleP2PAddAudioOrVideoStream", ((e3, t3, i3, n3) => {
            const r2 = this._users.find(((e4) => e4.uid === t3));
            if (!r2) return void iP.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            iP.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(r2.uid, e3, void 0, void 0, void 0, Date.now());
            const o2 = "audio" === e3 ? r2.hasAudio : r2.hasVideo;
            "audio" === e3 ? r2._trust_audio_stream_added_state_ = true : r2._trust_video_stream_added_state_ = true, "audio" === e3 ? (r2._audio_added_ = true, void 0 !== i3 && (r2._audioSSRC = i3), void 0 !== n3 && (r2._audioMid = n3)) : (r2._video_added_ = true, void 0 !== i3 && (r2._videoSSRC = i3), void 0 !== n3 && (r2._videoMid = n3)), ("audio" === e3 ? r2.hasAudio : r2.hasVideo) && !o2 && (iP.info("[".concat(this._clientId, "] remote user ").concat(r2.uid, " published ").concat(e3)), this.safeEmit(GO.USER_PUBLISHED, r2, e3)), this._p2pChannel.hasPendingRemoteMedia(r2, e3) && (iP.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(r2.uid, " after reconnect.")), this._subscribe(r2, e3, true).catch(((e4) => {
              iP.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            })));
          })), this._config = e2, this._clientId = t2 || SN(5, "client-"), this.store = new class {
            constructor(e3, t3, i3, n3, r2) {
              dO(this, "state", void 0), this.state = { codec: e3, audioCodec: t3, mode: i3, clientId: n3, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, keyMetrics: { publish: [], subscribe: [], firstVideoFrameDecoded: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useP2P: false, p2pTransport: _D.Default, hasStartJoinChannel: false, isABTestSuccess: false, rteUrl: void 0, rteSid: void 0, autoSubscribe: false, enableInstantMuteRestore: false, networkQualityProbe: false, useDcSignal: !!r2 };
            }
            dispatch(e3) {
              this.state = (function(e4, t3) {
                switch (t3.type) {
                  case ID.SET_SESSION_ID:
                    return uO(uO({}, e4), {}, { sessionId: t3.sessionId });
                  case ID.SET_P2P_ID:
                    return uO(uO({}, e4), {}, { p2pId: t3.p2pId });
                  case ID.SET_UID:
                    return uO(uO({}, e4), {}, { uid: t3.uid });
                  case ID.SET_INT_UID:
                    return uO(uO({}, e4), {}, { intUid: t3.intUid });
                  case ID.SET_PUB_ID:
                    return uO(uO({}, e4), {}, { pubId: t3.pubId });
                  case ID.KEY_METRIC_CLIENT_CREATED:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { clientCreated: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinStart: t3.metric }) });
                  case ID.KEY_METRIC_PRELOAD_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { preloadStart: t3.metric }) });
                  case ID.KEY_METRIC_PRELOAD_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { preloadEnd: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinEnd: t3.metric }) });
                  case ID.KEY_METRIC_REQUEST_AP_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { requestAPStart: t3.metric }) });
                  case ID.KEY_METRIC_REQUEST_AP_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { requestAPEnd: t3.metric }) });
                  case ID.KEY_METRIC_REQUEST_SUA_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { requestSUAEnd: t3.metric }) });
                  case ID.KEY_METRIC_BEFORE_CONNECT:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { beforeConnect: t3.metric }) });
                  case ID.KEY_METRIC_PEER_RECEIVER:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { peerReceiver: t3.metric }) });
                  case ID.KEY_METRIC_SIGNAL_CONNECTED:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { signalConnected: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_REQ:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinReq: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_REP:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinRep: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_GATEWAY_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinGatewayStart: t3.metric }) });
                  case ID.KEY_METRIC_JOIN_GATEWAY_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { joinGatewayEnd: t3.metric }) });
                  case ID.KEY_METRIC_PEER_CONNECTION_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { peerConnectionStart: t3.metric }) });
                  case ID.KEY_METRIC_PEER_CONNECTION_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { peerConnectionEnd: t3.metric }) });
                  case ID.KEY_METRIC_DESCRIPTION_START:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { descriptionStart: t3.metric }) });
                  case ID.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { signalChannelOpen: t3.metric }) });
                  case ID.KEY_METRIC_ICE_CONNECTION_END:
                    return uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { iceConnectionEnd: t3.metric }) });
                  case ID.KEY_METRIC_PUBLISH: {
                    const i3 = e4.keyMetrics.publish, n3 = i3.findIndex(((e5) => e5.trackId === t3.metric.trackId));
                    return -1 !== n3 ? (i3[n3] = uO(uO({}, i3[n3]), t3.metric), uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { publish: [...i3] }) })) : uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { publish: [...e4.keyMetrics.publish, t3.metric] }) });
                  }
                  case ID.KEY_METRIC_SUBSCRIBE: {
                    const i3 = e4.keyMetrics.subscribe, n3 = i3.findIndex(((e5) => e5.userId === t3.metric.userId && e5.type === t3.metric.type));
                    return -1 !== n3 ? (i3[n3] = uO(uO({}, i3[n3]), t3.metric), uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { subscribe: [...i3] }) })) : uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { subscribe: [...e4.keyMetrics.subscribe, t3.metric] }) });
                  }
                  case ID.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED: {
                    const i3 = e4.keyMetrics.firstVideoFrameDecoded, n3 = i3.findIndex(((e5) => e5.userId === t3.metric.userId));
                    return -1 !== n3 ? (i3[n3] = uO(uO({}, i3[n3]), t3.metric), uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { firstVideoFrameDecoded: [...i3] }) })) : uO(uO({}, e4), {}, { keyMetrics: uO(uO({}, e4.keyMetrics), {}, { firstVideoFrameDecoded: [...e4.keyMetrics.firstVideoFrameDecoded, t3.metric] }) });
                  }
                  case ID.RESET_FIRST_VIDEO_FRAME_DECODED:
                    return e4.keyMetrics.firstVideoFrameDecoded = [], e4;
                  case ID.SET_CLOUD_PROXY_SERVER_MODE:
                    return e4.cloudProxyServerMode = t3.mode, e4;
                  case ID.RECORD_JOIN_CHANNEL_SERVICE:
                    return "number" != typeof t3.index ? e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords, t3.record] : (e4.joinChannelServiceRecords[t3.index] = uO(uO({}, e4.joinChannelServiceRecords[t3.index]), t3.record), e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords]), e4;
                  case ID.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                    return e4.joinChannelServiceRecords = [], e4;
                  case ID.RESET_KEY_METRICS:
                    return e4.keyMetrics = { publish: [], subscribe: [], firstVideoFrameDecoded: [] }, e4;
                  case ID.SET_USE_P2P:
                    return uO(uO({}, e4), {}, { useP2P: t3.val });
                  case ID.SET_TRANSPORT_TYPE:
                    return uO(uO({}, e4), {}, { p2pTransport: t3.val });
                  case ID.SET_RTE_URL:
                    return uO(uO({}, e4), {}, { rteUrl: t3.rteUrl });
                  case ID.SET_RTE_SID:
                    return uO(uO({}, e4), {}, { rteSid: t3.rteSid });
                  default:
                    return e4;
                }
              })(this.state, e3);
            }
            get useDcSignal() {
              return this.state.useDcSignal;
            }
            set useDcSignal(e3) {
              this.state.useDcSignal = e3;
            }
            set autoSubscribe(e3) {
              this.state.autoSubscribe = e3;
            }
            get autoSubscribe() {
              return this.state.autoSubscribe;
            }
            set enableInstantMuteRestore(e3) {
              this.state.enableInstantMuteRestore = e3;
            }
            get enableInstantMuteRestore() {
              return this.state.enableInstantMuteRestore;
            }
            set networkQualityProbe(e3) {
              this.state.networkQualityProbe = e3;
            }
            get networkQualityProbe() {
              return this.state.networkQualityProbe;
            }
            set sessionId(e3) {
              this.dispatch({ type: ID.SET_SESSION_ID, sessionId: e3 });
            }
            get sessionId() {
              return this.state.sessionId;
            }
            set rteUrl(e3) {
              this.dispatch({ type: ID.SET_RTE_URL, rteUrl: e3 });
            }
            get rteUrl() {
              return this.state.rteUrl;
            }
            set rteSid(e3) {
              this.dispatch({ type: ID.SET_RTE_SID, rteSid: e3 });
            }
            get rteSid() {
              return this.state.rteSid;
            }
            set cid(e3) {
              this.state.cid = e3;
            }
            get cid() {
              return this.state.cid;
            }
            set codec(e3) {
              this.state.codec = e3;
            }
            get codec() {
              return this.state.codec;
            }
            get mode() {
              return this.state.mode;
            }
            get audioCodec() {
              return this.state.audioCodec;
            }
            get clientId() {
              return this.state.clientId;
            }
            set p2pId(e3) {
              this.dispatch({ type: ID.SET_P2P_ID, p2pId: e3 });
            }
            get p2pId() {
              return this.state.p2pId;
            }
            set dcId(e3) {
              this.dispatch({ type: ID.SET_DC_ID, dcId: e3 });
            }
            get dcId() {
              return this.state.dcId;
            }
            set uid(e3) {
              this.dispatch({ type: ID.SET_UID, uid: e3 });
            }
            get uid() {
              return this.state.uid;
            }
            set intUid(e3) {
              this.dispatch({ type: ID.SET_INT_UID, intUid: e3 });
            }
            get intUid() {
              return this.state.intUid;
            }
            set pubId(e3) {
              this.dispatch({ type: ID.SET_PUB_ID, pubId: e3 });
            }
            get pubId() {
              return this.state.pubId;
            }
            set cloudProxyServerMode(e3) {
              this.dispatch({ type: ID.SET_CLOUD_PROXY_SERVER_MODE, mode: e3 });
            }
            get cloudProxyServerMode() {
              return this.state.cloudProxyServerMode;
            }
            set useP2P(e3) {
              this.dispatch({ type: ID.SET_USE_P2P, val: e3 });
            }
            get useP2P() {
              return this.state.useP2P;
            }
            set p2pTransport(e3) {
              this.dispatch({ type: ID.SET_TRANSPORT_TYPE, val: e3 });
            }
            get p2pTransport() {
              return this.state.p2pTransport;
            }
            set hasStartJoinChannel(e3) {
              this.state.hasStartJoinChannel = e3;
            }
            get hasStartJoinChannel() {
              return this.state.hasStartJoinChannel;
            }
            set isABTestSuccess(e3) {
              this.state.isABTestSuccess = e3;
            }
            get isABTestSuccess() {
              return this.state.isABTestSuccess;
            }
            clientCreated() {
              this.dispatch({ type: ID.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
            }
            joinStart() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_START, metric: Date.now() });
            }
            preloadStart() {
              this.dispatch({ type: ID.KEY_METRIC_PRELOAD_START, metric: Date.now() });
            }
            preloadEnd() {
              this.dispatch({ type: ID.KEY_METRIC_PRELOAD_END, metric: Date.now() });
            }
            joinEnd() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_END, metric: Date.now() });
            }
            requestAPStart() {
              this.dispatch({ type: ID.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
            }
            requestAPEnd() {
              this.dispatch({ type: ID.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
            }
            requestSUAEnd() {
              this.dispatch({ type: ID.KEY_METRIC_REQUEST_SUA_END, metric: Date.now() });
            }
            beforeConnect() {
              this.dispatch({ type: ID.KEY_METRIC_BEFORE_CONNECT, metric: Date.now() });
            }
            peerReceiver() {
              this.dispatch({ type: ID.KEY_METRIC_PEER_RECEIVER, metric: Date.now() });
            }
            signalConnected() {
              this.dispatch({ type: ID.KEY_METRIC_SIGNAL_CONNECTED, metric: Date.now() });
            }
            joinReq() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_REQ, metric: Date.now() });
            }
            joinRep() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_REP, metric: Date.now() });
            }
            joinGatewayStart() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
            }
            joinGatewayEnd() {
              this.dispatch({ type: ID.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
            }
            peerConnectionStart() {
              this.dispatch({ type: ID.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
            }
            peerConnectionEnd() {
              this.dispatch({ type: ID.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
            }
            firstVideoFrameDecoded(e3, t3) {
              this.dispatch({ type: ID.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED, metric: uO({ userId: e3 }, t3) });
            }
            descriptionStart() {
              this.dispatch({ type: ID.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
            }
            signalChannelOpen() {
              this.dispatch({ type: ID.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
            }
            iceConnectionEnd() {
              this.dispatch({ type: ID.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
            }
            publish(e3, t3, i3, n3) {
              this.dispatch({ type: ID.KEY_METRIC_PUBLISH, metric: uO(uO({ trackId: e3, type: t3 }, i3 && { publishStart: i3 }), n3 && { publishEnd: n3 }) });
            }
            subscribe(e3, t3, i3, n3, r2, o2, s2) {
              this.dispatch({ type: ID.KEY_METRIC_SUBSCRIBE, metric: uO(uO(uO(uO(uO({ userId: e3, type: t3 }, i3 && { subscribeStart: i3 }), n3 && { subscribeEnd: n3 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
            }
            massSubscribe(e3, t3, i3, n3) {
              e3.forEach(((e4) => {
                this.dispatch({ type: ID.KEY_METRIC_SUBSCRIBE, metric: uO(uO(uO({ userId: e4.userId, type: e4.type }, t3 && { subscribeStart: t3 }), i3 && { subscribeEnd: i3 }), n3 && { firstFrame: n3 }) });
              }));
            }
            get keyMetrics() {
              return this.state.keyMetrics;
            }
            recordJoinChannelService(e3, t3) {
              "gateway" === e3.service && Array.isArray(e3.urls) && (e3.urls = e3.urls.map(((e4) => e4.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2"))));
              try {
                return "number" != typeof t3 ? (this.dispatch({ type: ID.RECORD_JOIN_CHANNEL_SERVICE, record: uO(uO({}, e3), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t3 < 0 || t3 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: ID.RECORD_JOIN_CHANNEL_SERVICE, record: e3, index: t3 }), t3);
              } catch (e4) {
                return 0;
              }
            }
            resetJoinChannelServiceRecords() {
              this.dispatch({ type: ID.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
            }
            resetKeyMetrics() {
              this.dispatch({ type: ID.RESET_KEY_METRICS });
            }
            resetFirstVideoFrameDecoded() {
              this.dispatch({ type: ID.RESET_FIRST_VIDEO_FRAME_DECODED });
            }
            get joinChannelServiceRecords() {
              try {
                return this.state.joinChannelServiceRecords;
              } catch (e3) {
                return [];
              }
            }
          }(e2.codec, e2.audioCodec, e2.mode, this._clientId, 1 === CD("SIGNAL_CHANNEL")), this._leaveMutex = new PN("client-leave", this._clientId), this._publishMutex = new PN("client-publish", this._clientId), this._renewTokenMutex = new PN("client-renewtoken", this._clientId), this._subscribeMutex = new PN("client-subscribe", this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), iP.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(hD, " build: ").concat(SD, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions) try {
            jO(e2.clientRoleOptions), i2 = Object.assign({}, e2.clientRoleOptions);
          } catch (e3) {
            iP.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
          }
          var n2;
          this._statsCollector = new rj(this.store), this._statsCollector.onStatsException = (e3, t3, i3) => {
            iP.warn("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i3)), e3 === ej.VIDEO_ENCODE_FAILED && this.localTracks.forEach(((e4) => {
              e4 instanceof MM && CD("ENABLE_ENCODE_EXCEPTION") && e4.findClosestProfile();
            })), this.safeEmit(GO.EXCEPTION, { code: e3, msg: t3, uid: i3 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t3, i3, n3) => {
            const r2 = this._users.find(((t4) => t4.uid === e3));
            if (r2) {
              this.store.keyMetrics && (this.store.firstVideoFrameDecoded(r2.uid, { peerPublishDuration: i3, peerPubStatusMs: Date.now() }), this._p2pChannel.reportVideoFirstFrameRender(r2)), lP.peerPublishStatus(this._sessionId, { subscribeElapse: n3, audioPublishDuration: t3, videoPublishDuration: i3, peer: r2._uintid });
            }
          }, this._statsCollector.onVideoCodecChanged = (e3) => {
            if (CD("VIDEO_STANDARD_BITRATE_VERSION") && ("av1" === e3 || "h265" === e3 || "h264" === e3)) {
              const t3 = this.localTracks.find(((e4) => e4 instanceof kM));
              t3 && 1 !== t3._saveEncodeBitrateRatio && t3.setSaveEncodeBitrateRatio("h264" === e3 ? CD("BASELINE_MORE_H264_BITRATE_RATIO") : void 0);
            }
          }, this.store.useP2P = "p2p" === e2.mode, this._gateway = new uB(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || kN, httpRetryConfig: e2.httpRetryConfig || kN, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: i2 }), this._configDistribute = new ZB(this._clientId, this.store), this.store.useP2P ? (this._p2pChannel = (n2 = { store: this.store, statsCollector: this._statsCollector }, oB("P2PChannel").create(n2)), this._handleP2PEvents()) : this._p2pChannel = new EG(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async joinMeta(e2, t2, i2, n2, r2) {
          let o2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], s2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
          RD("JOIN_GATEWAY_USE_443PORT_ONLY", o2), RD("JOIN_GATEWAY_USE_DUAL_DOMAIN", s2);
          const a2 = this._gateway.signal.websocket;
          return a2 instanceof Zx && (a2.use443PortOnly = o2, a2.tryDoubleDomain = s2), (async function(e3, t3, i3) {
            vw.get(e3) || vw.set(e3, []), yw.get(e3) || yw.set(e3, t3), Iw.get(e3) || Iw.set(e3, 0);
            const n3 = vw.get(e3), r3 = yw.get(e3);
            if (!n3 || !r3) throw new Error("concurrent: deferQueue or maxConcurrency is null");
            if (Iw.get(e3) === r3) {
              const e4 = Cw();
              n3.push(e4), await e4.promise;
            }
            Iw.set(e3, Iw.get(e3) + 1);
            for (var o3 = arguments.length, s3 = new Array(o3 > 3 ? o3 - 3 : 0), a3 = 3; a3 < o3; a3++) s3[a3 - 3] = arguments[a3];
            const c2 = await i3(...s3);
            return Iw.set(e3, Iw.get(e3) - 1), Iw.get(e3) === r3 - 1 && n3.length > 0 && (n3[0].resolve(), n3.shift()), 0 === Iw.get(e3) && (vw.set(e3, []), yw.set(e3, 0), Iw.set(e3, 0)), c2;
          })("client.join", CD("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e2, t2, i2, n2, r2);
        }
        async join(e2, t2, i2, n2, r2) {
          const o2 = ++this._numberOfJoinCount;
          this.store.joinStart(), n2 && (this.store.uid = n2);
          const s2 = "HTTPS" === (VN || VN || (VN = (window.location.protocol.split(":")[0] || "").toUpperCase(), VN)), a2 = WN() ? window.isSecureContext : "Browser Not Support";
          if (!WN() && !s2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            iP.warning(e3);
          }
          let c2;
          lP.setAppId(e2);
          try {
            if (!i2 && null !== i2) throw new uP(hO.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
            if (i2 && SO(i2, "token", 1, 2047), SO(e2, "appid", 1, 2047), HV(t2), n2 && KV(n2), r2) if ("string" == typeof r2) SO(r2, "optionalInfo", 1, 256), c2 = r2;
            else {
              if ("object" != typeof r2) throw new uP(hO.INVALID_PARAMS, "Invalid options: options is not a string or object");
              {
                const { autoSubscribe: e3, enableInstantMuteRestore: t3, networkQualityProbe: i3 } = r2;
                e3 && (_O(e3, "autoSubscribe"), iP.info("[".concat(this._clientId, "] join: autoSubscribe: ").concat(e3)), this.store.autoSubscribe = e3), t3 && (_O(t3, "enableInstantMuteRestore"), iP.info("[".concat(this._clientId, "] join: enableInstantMuteRestore: ").concat(t3)), this.store.enableInstantMuteRestore = t3), i3 && (_O(i3, "networkQualityProbe"), iP.info("[".concat(this._clientId, "] join: networkQualityProbe: ").concat(i3)), this.store.networkQualityProbe = i3);
              }
            }
          } catch (r3) {
            throw lP.reportApiInvoke(gN(), { name: LO.JOIN, options: [e2, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kO.TRACER }).onError(r3), r3;
          }
          if (this._leaveMutex.isLocked) {
            iP.debug("[".concat(this._clientId, "] join: waiting leave operation"));
            (await this._leaveMutex.lock())(), iP.debug("[".concat(this._clientId, "] join: continue"));
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const r3 = new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw lP.reportApiInvoke(gN(), { name: LO.JOIN, options: [e2, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kO.TRACER }).onError(r3), r3;
          }
          this._gateway.state = "CONNECTING", this.store.preloadStart();
          const d2 = await WG({ appId: e2, cname: t2, uid: n2, stringUid: "string" == typeof n2 ? n2 : void 0, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode });
          if (this.store.preloadEnd(), !this._joinAndNotLeaveYet) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          const l2 = (null == d2 ? void 0 : d2.sid) || gN();
          iP.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), this._sessionId || (this._sessionId = l2, this.store.sessionId = this._sessionId);
          const u2 = lP.reportApiInvoke(this._sessionId, { id: this._clientId, name: LO.JOIN, options: [e2, t2, i2, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: kO.TRACER }), h2 = vH(vH(vH({}, this._rtmConfig), {}, { role: this.role, clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: c2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint, preload: !!d2 }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType }), {}, { apRequestDetail: CD("AP_REQUEST_DETAIL") || void 0 });
          if (this._useLocalAccessPoint && (h2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (h2.stringUid = n2, this._uintUid ? (h2.uid = this._uintUid, this._uintUid = void 0) : h2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (h2.aesmode = this._encryptionMode, h2.aespassword = await (async (e3) => {
              const t3 = (function(e4) {
                const t4 = window.atob("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i4 = new Uint8Array(new ArrayBuffer(t4.length));
                for (let e5 = 0; e5 < t4.length; e5 += 1) i4[e5] = t4.charCodeAt(e5);
                return i4;
              })(), i3 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n3 = bO(e3), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i3, n3);
              return (function(e4) {
                let t4 = "";
                for (let i4 = 0; i4 < e4.length; i4 += 1) t4 += String.fromCharCode(e4[i4]);
                return window.btoa(t4);
              })(new Uint8Array(r3));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (h2.aessalt = this._encryptionSalt);
          }
          if (this._encryptDataStream && ("aes-128-gcm2" === this._encryptionMode || "aes-256-gcm2" === this._encryptionMode)) if (this._encryptionSalt && this._encryptionSecret) if (window.crypto.subtle) {
            const e3 = new TextEncoder(), t3 = CD("USE_PURE_ENCRYPTION_MASTER_KEY") ? e3.encode(h2.appId + this._encryptionSecret + this._encryptionSecret) : e3.encode(h2.appId + h2.cname + this._encryptionSecret);
            this._encryptDataStreamIv = await (async function(e4, t4, i3) {
              const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256, o3 = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: OD, hash: "SHA-256", salt: i3 }, n3, r3 + wD);
              return new Uint8Array(o3).subarray(r3 / 8);
            })(this._encryptionMode, t3, lN(this._encryptionSalt)), this._encryptDataStreamKey = await (async function(e4, t4, i3) {
              const n3 = await window.crypto.subtle.importKey("raw", t4, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256;
              return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: OD, hash: "SHA-256", salt: i3 }, n3, { name: "AES-GCM", length: r3 }, true, ["encrypt", "decrypt"]);
            })(this._encryptionMode, t3, lN(this._encryptionSalt));
          } else a2 ? iP.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : iP.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
          else this._encryptDataStream = false, iP.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
          this._startSession(this._sessionId, { channel: t2, appId: e2, stringUid: h2.stringUid });
          const p2 = this._sessionId;
          setTimeout((() => {
            "CONNECTING" === this.connectionState && p2 === this._sessionId && lP.joinChannelTimeout(this._sessionId, 5);
          }), 5e3);
          try {
            var _2;
            let n3;
            const r3 = h2.cloudProxyServer;
            if (Ln(_2 = ["proxy3", "proxy4", "proxy5"]).call(_2, r3)) {
              const e3 = CD("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? h2.proxyServer = e3[0] : h2.proxyServer = e3;
            }
            if (lP.setProxyServer(h2.proxyServer), iP.setProxyServer(h2.proxyServer), this.store.requestAPStart(), d2) {
              if (iP.debug("[".concat(this._clientId, "] get serverInfo Success from Preload Cache ").concat(h2.stringUid ? ", ".concat(h2.stringUid, " => ").concat(d2.intUid) : "", " ")), h2.stringUid && !h2.uid && (h2.uid = d2.intUid), n3 = { gatewayInfo: d2.ap.gatewayInfo }, CD("JOIN_WITH_FALLBACK_MEDIA_PROXY") && "auto" === h2.turnServer.mode) if (0 === d2.ap.proxyInfo.addresses.length) iP.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers");
              else {
                const e3 = (await pF(d2.ap.proxyInfo, d2.ap.gatewayInfo.uid)).map(((e4) => ({ turnServerURL: e4.address, tcpport: e4.tcpport || ED.tcpport, udpport: e4.udpport || ED.udpport, username: e4.username || ED.username, password: e4.password || ED.password, forceturn: false, security: true })));
                h2.turnServer = { mode: "manual", servers: e3 };
              }
              qG(d2, h2.stringUid);
            } else {
              if (h2.stringUid && !h2.uid) {
                let e3;
                [e3, n3] = await rp.all([WB(h2.stringUid, h2, this._axiosCancelSource.token, this._config.httpRetryConfig || kN, this.store).finally((() => {
                  this.store.requestSUAEnd();
                })), GB(h2, this._axiosCancelSource.token, this._config.httpRetryConfig || kN, true, this.store).finally((() => {
                  this.store.requestAPEnd();
                }))]), iP.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(h2.stringUid, " => ").concat(e3)), h2.uid = e3, n3.gatewayInfo.uid = e3, n3.gatewayInfo.res.uid = e3;
              } else n3 = await GB(h2, this._axiosCancelSource.token, this._config.httpRetryConfig || kN, true, this.store);
              if (!this._joinAndNotLeaveYet) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            }
            this.store.requestAPEnd(), setTimeout((() => {
              this._configDistribute.startGetConfigDistribute(h2, this._axiosCancelSource.token), this._configDistribute.on(px.UPDATE_BITRATE_LIMIT, ((e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              })), this._configDistribute.on(px.UPDATE_CLIENT_ROLE_OPTIONS, ((e3) => {
                this._setClientRoleOptions(e3);
              })), this._configDistribute.on(px.UPDATE_REMOTE_VIDEO_STREAM_TYPE, ((e3) => {
                var t3;
                Ln(t3 = [0, 1, 4, 5, 6, 7, 8, 9]).call(t3, e3) && (this.remoteUsers.forEach(((t4) => {
                  this._remoteStreamTypeCacheMap.get(t4.uid) !== e3 && this.setRemoteVideoStreamType(t4.uid, e3);
                })), this.setRemoteDefaultVideoStreamType(e3));
              })), this._configDistribute.on(px.FALLBACK_TO_HLS, ((e3) => {
                e3 && this.safeEmit(GO.FALLBACK_TO_HLS, WO.CONFIG);
              })), this._configDistribute.on(px.UPDATE_VOS_CONFIGURE, ((e3) => {
                this._gateway.setConfigure(e3).catch(((e4) => {
                  iP.debug("[".concat(this._clientId, "] auto set vos config failed"), e4);
                }));
              }));
            }), 0), this._key = i2 || e2;
            const o3 = n3.gatewayInfo, s3 = h2.uid ? h2.uid : o3.uid;
            this._joinInfo = vH(vH({}, h2), {}, { cid: o3.cid, uid: s3, vid: o3.vid, apResponse: o3.res, apGatewayAddress: o3.apGatewayAddress, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs }), this.store.intUid = s3, this.store.cid = o3.cid;
            const a3 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            u2.onSuccess(a3), this._appId = e2, this._channelName = h2.cname, this._uid = a3, this.store.uid = a3, setTimeout((() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), !Vw() && this.store.useDcSignal ? (window.addEventListener("beforeunload", this._handleBeforeUnload), window.addEventListener("pagehide", this._handleBeforeUnload)) : window.addEventListener(Vw() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._statsCollector.startUpdateStats();
            }), 0);
            const c3 = h2.stringUid ? "string uid: ".concat(h2.stringUid, ",uid: ").concat(h2.uid) : "uid: ".concat(this._uid);
            return iP.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(c3)), setTimeout((() => {
              iP.startUpload();
            }), 5e3), this.store.joinEnd(), E2 = this, Ln(KU).call(KU, E2) || KU.push(E2), "disabled" === this._cloudProxyServerMode && pP().supportWebCrypto && CD("ENABLE_PRELOAD") && YG(this._joinInfo), this._rteDetailInterval && (window.clearInterval(this._rteDetailInterval), this._rteDetailInterval = void 0), this._sessionId && lP.reportRteDetail(this._sessionId), this._rteDetailInterval = window.setInterval((() => {
              this._sessionId && lP.reportRteDetail(this._sessionId);
            }), CD("RTE_DETAIL_REPORT_INTERVAL") || 6e4), a3;
          } catch (e3) {
            const t3 = Array.isArray(e3) ? e3[0] : e3;
            throw t3 && t3.code === hO.OPERATION_ABORTED ? iP.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3) : iP.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3), t3.code !== hO.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), u2.onError(t3), t3;
          }
          var E2;
        }
        async _joinGateway() {
          if (!this._joinInfo || !this._key) throw new uP(hO.INVALID_OPERATION);
          try {
            return await this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !CD("JOIN_WITH_FALLBACK_SIGNAL_PROXY")));
          } catch (e2) {
            if (e2.code === hO.INIT_DATACHANNEL_TIMEOUT) {
              if (this._gateway.leave(true, VO.FALLBACK), iP.debug("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key) throw new uP(hO.INVALID_OPERATION);
              return lP.reportApiInvoke(this._sessionId, { name: LO.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: kO.TRACER }).onSuccess(), await this._joinGateway();
            }
            throw e2;
          }
        }
        async leave() {
          iP.info("[".concat(this._clientId, "] Leaving channel"));
          const e2 = () => {
            !Vw() && this.store.useDcSignal ? (window.addEventListener("beforeunload", this._handleBeforeUnload), window.addEventListener("pagehide", this._handleBeforeUnload)) : window.addEventListener(Vw() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), (function(e3) {
              const t3 = KU.indexOf(e3);
              -1 !== t3 && KU.splice(t3, 1);
            })(this), this._statsCollector.stopUpdateStats();
          };
          this.store.useDcSignal || e2();
          const t2 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState) return iP.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void t2();
          await this._gateway.leave("CONNECTED" !== this.connectionState, VO.LEAVE), iP.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), t2(), this.store.useDcSignal && e2();
        }
        async publish(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!Array.isArray(e2)) {
            if (!(e2 instanceof lL)) return this._publishDataChannel(e2);
            e2 = [e2];
          }
          if (0 === e2.length) throw new uP(hO.INVALID_PARAMS, "param list is empty");
          const i2 = e2;
          if ("audience" === this._gateway.role) throw new uP(hO.INVALID_OPERATION, "audience can not publish stream");
          for (const e3 of i2) {
            if (!(e3 instanceof lL)) throw new uP(hO.INVALID_PARAMS, "parameter is not local track");
            if (!e3._enabled && t2) throw new uP(hO.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e3.getTrackId()));
          }
          iP.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i2.map(((e3) => "".concat(e3.getTrackId(), " ")))));
          const n2 = await this._publishMutex.lock();
          await this._configDistribute.awaitConfigDistributeComplete(), t2 && i2.forEach(((e3) => {
            const t3 = this._configDistribute.getBitrateLimit();
            e3 instanceof kM && t3 && e3.setBitrateLimit(t3.uplink);
          }));
          try {
            await this._publishHighStream(i2), iP.info("[".concat(this._clientId, "] Publish success, id ").concat(i2.map(((e3) => "".concat(e3.getTrackId(), " ")))));
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
          } finally {
            n2();
          }
        }
        async _publishDataChannel(e2) {
          if (null == e2) throw new uP(hO.INVALID_PARAMS, "parameter is not local track or datachannel config, config is ".concat(JSON.stringify(e2)));
          mO(e2.id, "id", 0, 65535, true), _O(e2.ordered, "ordered"), SO(e2.metadata, "metadata", 0, 512), iP.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e2.id));
          const t2 = await this._publishMutex.lock();
          try {
            if (-1 !== this._p2pChannel.getAllDataChannels().findIndex(((t3) => t3.id === e2.id))) throw new uP(hO.INVALID_PARAMS, "Invalid id: ".concat(e2.id, ". If you want to republish the datachannel, unpublish first"));
            if (!this._joinInfo || void 0 === this._uid) throw new uP(hO.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
            if ("auto" === this._turnServer.mode && CD("FORCE_TURN") && !CD("TURN_ENABLE_TCP") && !CD("TURN_ENABLE_UDP")) throw new uP(hO.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
            const i2 = (function(e3) {
              return sB(e3, false);
            })(e2), n2 = await this._p2pChannel.publishDataChannel([i2]);
            if (n2.length > 0) {
              if ("number" != typeof i2._originDataChannelId) throw iP.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new uP(hO.CREATE_DATACHANNEL_ERROR);
              try {
                await rp.all(n2.map(((e3) => this._uid && this._gateway.publishDataChannel(this._uid, e3, true)))), await i2._waitTillOpen();
              } catch (e3) {
                if (e3.code !== hO.DISCONNECT_P2P) throw e3;
              }
            }
            return iP.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i2.id)), i2;
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] publish datachannels error"), e3.toString()), e3;
          } finally {
            t2();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new uP(hO.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          let t2 = [];
          if (e2) if (Array.isArray(e2)) t2 = e2;
          else {
            if (!(e2 instanceof lL)) return this._unpublishDataChannel([e2]);
            t2 = [e2];
          }
          else this.store.useP2P || await this._unpublishDataChannel(), t2 = this._p2pChannel.getAllTracks(true);
          iP.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t2.map(((e3) => "".concat(e3.getTrackId(), " "))), " "));
          const i2 = await this._publishMutex.lock();
          try {
            if (this.store.useP2P) {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.sendExtensionMessage(Lx.UNPUBLISH, { unpubMsg: e3 }, true);
            } else {
              const e3 = await this._p2pChannel.unpublish(t2);
              e3 && await this._gateway.unpublish(e3, this._uid), iP.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t2.map(((e4) => "".concat(e4.getTrackId())))));
            }
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
          } finally {
            i2 && i2();
          }
        }
        async _unpublishDataChannel(e2) {
          void 0 !== e2 && 0 !== e2.length || (e2 = this._p2pChannel.getAllDataChannels()), iP.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e2.map(((e3) => "".concat(e3.id, " "))), " "));
          const t2 = await this._publishMutex.lock();
          try {
            const i2 = await this._p2pChannel.unpublishDataChannel(e2);
            i2 && await this._gateway.unpublishDataChannel(i2), iP.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e2.map(((e3) => "".concat(e3.id)))));
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] unpublish dataChannel error"), e3.toString()), e3;
          } finally {
            t2 && t2();
          }
        }
        async subscribe(e2, t2, i2) {
          if (!(e2 instanceof aj)) {
            const t3 = this.remoteUsers.find(((t4) => t4.uid === e2));
            if (!t3) throw new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t3;
          }
          return "datachannel" === t2 ? this._subscribeDataChannel(e2, i2) : this._subscribe(e2, t2);
        }
        async presubscribe(e2, t2) {
          if (EO(t2, "mediaType", ["audio", "video"]), this.store.useP2P) throw new uP(hO.INVALID_OPERATION, "can't presub at p2p mode");
          if (!this._joinInfo) throw new uP(hO.INVALID_OPERATION, "can't presub when not join");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
          const i2 = t2 === fx.AUDIO, n2 = t2 === fx.VIDEO, r2 = await this._subscribeMutex.lock();
          try {
            const { ssrcId: o2, ortc: s2, rtxSsrcId: a2, cname: c2, uint_id: d2 } = await this._gateway.presubscribe(e2, t2, true);
            if (null == o2) throw new uP(hO.UNEXPECTED_RESPONSE, "no ssrc id");
            let l2 = this._users.find(((t3) => t3.uid === e2));
            l2 || (l2 = new aj(e2, d2 || e2), l2._is_pre_created = true, this._users.push(l2)), c2 && (l2._cname = c2), l2._uintid || (l2._uintid = d2 || e2), i2 && (l2._audioSSRC = o2, l2._audio_pre_subscribed = true, s2 && (l2._audioOrtc = s2)), n2 && (l2._videoSSRC = o2, l2._video_pre_subscribed = true, s2 && (l2._videoOrtc = s2), null != a2 && (l2._rtxSsrcId = a2)), iP.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(o2)), await this._p2pChannel.subscribe(l2, t2, o2, a2, s2);
            const u2 = i2 ? l2._audioTrack : l2._videoTrack;
            if (!u2) throw new uP(hO.UNEXPECTED_ERROR, "can not find remote track in user");
            return i2 && (l2._trust_audio_stream_added_state_ = true, l2._audio_added_ = true), n2 && (l2._trust_video_stream_added_state_ = true, l2._video_added_ = true), u2;
          } catch (t3) {
            throw iP.error("[".concat(this._clientId, "] presub user ").concat(e2, " error"), t3), t3;
          } finally {
            r2();
          }
        }
        async _subscribeDataChannel(e2, t2) {
          var i2;
          if (mO(t2, "channelId", 0, 65535, true), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
          const n2 = this._users.find(((t3) => t3 === e2));
          if (!n2) throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
          if (!e2.hasAudio && !e2.hasVideo && 0 === e2._dataChannels.length) throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), new uP(hO.INVALID_REMOTE_USER, "user is not published");
          const r2 = null === (i2 = e2._dataChannels) || void 0 === i2 ? void 0 : i2.find(((e3) => e3.id === t2));
          if (!r2) throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, remote datachannel is not published")), new uP(hO.REMOTE_USER_IS_NOT_PUBLISHED);
          const o2 = await this._subscribeMutex.lock();
          iP.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: datachannel"));
          try {
            const t3 = await this._p2pChannel.subscribeDataChannel(e2, [r2]);
            if (t3 && Ln(t3).call(t3, r2.id)) try {
              var s2;
              if ("number" != typeof r2._originDataChannelId) throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new uP(hO.CREATE_DATACHANNEL_ERROR);
              const t4 = { id: r2.id, datachannelId: r2._originDataChannelId, ordered: r2.ordered, maxRetransmits: r2.maxRetransmits, metadata: null !== (s2 = r2.metadata) && void 0 !== s2 ? s2 : "" };
              await this._gateway.subscribeDataChannel(e2.uid, t4, true), await r2._waitTillOpen();
            } catch (t4) {
              if ((null == t4 ? void 0 : t4.code) !== hO.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), t4;
              await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), this._p2pChannel.setPendingRemoteDataChannel(e2, r2.id);
            }
            return iP.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: datachannel")), r2;
          } finally {
            o2();
          }
        }
        async _p2pSubscribe(e2, t2, i2) {
          if (EO(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n2 = this._users.find(((t3) => t3 === e2));
          if (!n2) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not published");
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!i2 && ("audio" === t2 && !e2.hasAudio || "video" === t2 && !e2.hasVideo)) {
            const i3 = new uP(hO.REMOTE_USER_IS_NOT_PUBLISHED);
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
          }
          const r2 = await this._subscribeMutex.lock();
          iP.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2)) await this._p2pChannel.unmuteRemote(e2, t2);
            else try {
              const i4 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, n3 = "audio" === t2 ? e2._audioMid : e2._videoMid;
              this.store.subscribe(e2.uid, t2, Date.now()), this.store.useP2P && await this._p2pChannel.subscribe(e2, t2, i4, n3);
            } catch (e3) {
              throw e3;
            }
            iP.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), void 0 !== this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch(((e3) => {
              iP.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            }));
            const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new uP(hO.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i3;
          } catch (t3) {
            throw iP.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            r2();
          }
        }
        async _subscribe(e2, t2, i2) {
          if (this.store.useP2P) return this._p2pSubscribe(e2, t2);
          if (EO(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n2 = this._users.find(((t3) => t3 === e2));
          if (!n2) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not published");
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
          }
          if (!(i2 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
            const i3 = new uP(hO.REMOTE_USER_IS_NOT_PUBLISHED);
            throw iP.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
          }
          let r2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, o2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? fx.AUDIO : fx.VIDEO, ssrcId: r2 };
          "video" === t2 && this.store.firstVideoFrameDecoded(e2.uid, { subscribeStart: Date.now() });
          const c2 = await this._subscribeMutex.lock();
          iP.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2)) await this._p2pChannel.unmuteRemote(e2, t2);
            else try {
              const i4 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC;
              void 0 !== i4 && i4 !== r2 && (r2 = i4, o2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, a2 = { stream_type: "audio" === t2 ? fx.AUDIO : fx.VIDEO, ssrcId: r2 }), tj.markSubscribeStart(this.store.clientId, r2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, r2, s2, o2);
              try {
                this._p2pChannel.isPreSubScribe(r2) || await this._gateway.subscribe(e2.uid, a2, true);
              } catch (i5) {
                if ((null == i5 ? void 0 : i5.code) !== hO.WS_ABORT) throw await this._p2pChannel.unsubscribe(e2, t2), i5;
                await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
              }
              this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
            } catch (i4) {
              throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e2, t2), i4;
            }
            iP.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), void 0 !== this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch(((e3) => {
              iP.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            }));
            const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new uP(hO.UNEXPECTED_ERROR, "can not find remote track in user object");
            return "video" === t2 && (this.store.firstVideoFrameDecoded(e2.uid, { subscribeEnd: Date.now() }), this._p2pChannel.reportVideoFirstFrameRender(e2)), i3;
          } catch (t3) {
            throw iP.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
          } finally {
            c2();
          }
        }
        async massSubscribe(e2) {
          if (gO(e2, "subscribeList"), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const t2 = Date.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
          iP.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map(((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3);
          })).join("; ")));
          const r2 = (e2 = [...e2]).map(((e3) => {
            let { user: t3, mediaType: i3 } = e3;
            return { user: t3, mediaType: i3 };
          })), o2 = await this._p2pChannel.globalLock();
          try {
            var s2;
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: o3, mediaType: s3 } = n3;
              if (EO(s3, "mediaType", ["audio", "video"]), !o3) {
                const e3 = new uP(hO.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw iP.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
              }
              const a3 = this._users.find(((e3) => e3 === o3));
              if (!a3) {
                const i3 = new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
                iP.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
                const i3 = new uP(hO.REMOTE_USER_IS_NOT_PUBLISHED);
                iP.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t3].error = i3, e2.splice(t3, 1);
                continue;
              }
              const c2 = cx.Video | cx.LwoVideo, d2 = i2.get(o3);
              if (d2) {
                if ("video" === s3 ? d2 & c2 : d2 & cx.Audio) {
                  e2.splice(t3, 1), iP.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
                  continue;
                }
                i2.set(o3, d2 | ("video" === s3 ? c2 : cx.Audio));
              } else i2.set(o3, "video" === s3 ? c2 : cx.Audio);
            }
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const n3 = e2[t3], { user: r3, mediaType: o3 } = n3, s3 = cx.Video | cx.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
                await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
                const n4 = i2.get(r3);
                i2.set(r3, "video" === o3 ? n4 ^ s3 : n4 ^ cx.Audio), e2.splice(t3, 1);
              }
            }
            this.store.massSubscribe(e2.map(((e3) => ({ userId: e3.user.uid, type: e3.mediaType }))), t2);
            let a2 = nr(s2 = Array.from(i2.entries())).call(s2, ((e3, t3) => {
              let [i3, n3] = t3;
              if (0 === n3) return e3;
              const r3 = { stream_id: i3.uid, stream_type: n3 };
              return n3 & cx.Audio && (r3.audio_ssrc = i3._audioSSRC), n3 & cx.Video && (r3.video_ssrc = i3._videoSSRC), e3.push(r3), e3;
            }), []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map(((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return { user: t3, mediaType: i4, ssrcId: i4 === fx.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i4 === fx.VIDEO ? t3._rtxSsrcId : void 0 };
              })));
              const i3 = /* @__PURE__ */ new Map();
              if (a2 = a2.filter(((e3) => e3.video_ssrc && !this._p2pChannel.isPreSubScribe(e3.video_ssrc) || e3.audio_ssrc && !this._p2pChannel.isPreSubScribe(e3.audio_ssrc) || !e3.video_ssrc && !e3.audio_ssrc)), a2.length > 0) {
                const e3 = await this._gateway.subscribeAll(a2, true);
                ((null == e3 ? void 0 : e3.users) || []).forEach(((e4) => {
                  let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: o3 } = e4;
                  (n3 || r3 || o3) && i3.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: o3 });
                }));
              }
              if (Array.from(i3.entries()).length > 0) {
                const e3 = [];
                Array.from(i3.entries()).forEach(((t3) => {
                  let [i4, n3] = t3;
                  const r3 = this.remoteUsers.find(((e4) => e4.uid === i4));
                  if (r3) {
                    let t4;
                    n3.error_code || n3.video_error_code && n3.audio_error_code ? t4 = void 0 : n3.video_error_code ? t4 = fx.VIDEO : n3.audio_error_code && (t4 = fx.AUDIO), e3.push({ user: r3, mediaType: t4 });
                  }
                })), e3.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of r2) {
                const t3 = i3.get(e3.user.uid);
                if (t3) {
                  const i4 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                  if (i4) {
                    const t4 = Bx(i4);
                    iP.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new uP(hO.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t4.desc));
                  }
                }
                e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(r2.filter(((e3) => !e3.error)).map(((e3) => ({ userId: e3.user.uid, type: e3.mediaType }))), void 0, Date.now()), r2.forEach(((e3) => {
                var i4;
                lP.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i4 = e3.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e3.mediaType === fx.VIDEO, audio: e3.mediaType === fx.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === fx.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2), preSsrc: this._p2pChannel.isPreSubScribe(e3.user._videoSSRC) }, true);
              })), iP.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map(((e3) => {
                let { user: t3, mediaType: i4 } = e3;
                return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
              })).join("; "))), r2;
            } catch (t3) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
            }
          } finally {
            o2(), n2();
          }
        }
        async unsubscribe(e2, t2, i2) {
          if (!(e2 instanceof aj)) {
            const t3 = this.remoteUsers.find(((t4) => t4.uid === e2));
            if (!t3) throw new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t3;
          }
          if (t2 || this.store.useP2P) {
            if ("datachannel" === t2) return this._unsubscribeDataChannel(e2, i2);
          } else await this._unsubscribeDataChannel(e2, i2);
          if (t2 && EO(t2, "mediaType", ["audio", "video"]), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          const n2 = this._users.find(((t3) => t3 === e2));
          if (!n2) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            throw iP.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          iP.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
          const r2 = await this._subscribeMutex.lock();
          try {
            if (this.store.useP2P) await this._p2pChannel.unsubscribe(e2, t2);
            else {
              const i3 = await this._p2pChannel.unsubscribe(e2, t2);
              i3 && await this._gateway.unsubscribe(i3, e2.uid), t2 && "audio" !== t2 || (e2._audio_pre_subscribed = false), t2 && "video" !== t2 || (e2._video_pre_subscribed = false), e2._is_pre_created && nN(this._users, e2), iP.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
            }
          } catch (t3) {
            if (t3.code === hO.DISCONNECT_P2P) return void iP.warning("disconnecting p2p, abort unsubscribe request.");
            throw iP.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          } finally {
            r2();
          }
        }
        async _unsubscribeDataChannel(e2, t2) {
          if (t2 && mO(t2, "id", 0, 65535, true), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
          const i2 = this._users.find(((t3) => t3 === e2));
          if (!i2) {
            const t3 = new uP(hO.INVALID_REMOTE_USER, "user is not in the channel");
            throw iP.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
          }
          let n2;
          if ("number" == typeof t2) {
            const i3 = e2._dataChannels.find(((e3) => e3.id === t2));
            i3 && (n2 = [i3]);
          } else n2 = e2._dataChannels;
          if (void 0 === n2) {
            const i3 = new uP(hO.REMOTE_USER_IS_NOT_PUBLISHED);
            throw iP.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, " with channelId ").concat(t2, ", remote datachannel is not published")), i3;
          }
          iP.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(n2.map(((e3) => e3.id))));
          try {
            const t3 = await this._p2pChannel.unsubscribeDataChannel(e2, n2);
            t3 && await this._gateway.unsubscribeDataChannel(t3, e2.uid), iP.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(t3));
          } catch (t3) {
            if (t3.code === hO.DISCONNECT_P2P) return void iP.warning("disconnecting p2p, abort unsubscribe request.");
            throw iP.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
          }
        }
        async massUnsubscribe(e2) {
          if (gO(e2, "unsubscribeList"), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
          iP.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map(((e3) => {
            let { user: t3, mediaType: i2 } = e3;
            return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i2, ";");
          })).join())), e2 = [...e2];
          const t2 = /* @__PURE__ */ new Map();
          for (let i2 = e2.length - 1; i2 >= 0; i2--) {
            const { user: n2, mediaType: r2 } = e2[i2];
            if (!n2) {
              const e3 = new uP(hO.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw iP.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
            }
            EO(r2, "mediaType", ["video", "audio", void 0]);
            const o2 = this._users.find(((e3) => e3 === n2));
            if (!o2) {
              iP.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i2, 1);
              continue;
            }
            const s2 = cx.Video | cx.LwoVideo;
            if (t2.has(n2)) {
              const o3 = t2.get(n2);
              let a2;
              switch (r2) {
                case "video":
                  a2 = o3 & s2;
                  break;
                case "audio":
                  a2 = o3 & cx.Audio;
                  break;
                default:
                  a2 = o3 & (cx.Audio | s2);
              }
              if (a2) {
                iP.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i2, 1);
                continue;
              }
              r2 ? "audio" === r2 ? t2.set(n2, o3 | cx.Audio) : "video" === r2 && t2.set(n2, o3 | s2) : t2.set(n2, o3 | cx.Audio | s2);
            } else r2 ? "audio" === r2 ? t2.set(n2, cx.Audio) : "video" === r2 && t2.set(n2, s2) : t2.set(n2, cx.Audio | s2);
          }
          try {
            const t3 = await this._p2pChannel.massUnsubscribe(e2);
            t3 && await this._gateway.massUnsubscribe(t3), iP.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map(((e3) => {
              let { user: t4, mediaType: i2 } = e3;
              return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
            })).join()));
          } catch (e3) {
            if (e3.code === hO.DISCONNECT_P2P) return void iP.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
            throw iP.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
          }
        }
        async setLowStreamParameter(e2) {
          !(function(e3) {
            if (!e3) throw new pO(hO.INVALID_PARAMS);
            TO(e3.width) || fO(e3.width, "streamParameter.width"), TO(e3.height) || fO(e3.height, "streamParameter.height"), TO(e3.framerate) || fO(e3.framerate, "streamParameter.framerate"), TO(e3.bitrate) || mO(e3.bitrate, "streamParameter.bitrate");
          })(e2), (!e2.width && e2.height || e2.width && !e2.height) && iP.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), iP.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
          const t2 = this._configDistribute.getLowStreamConfigDistribute();
          if (t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(e2, Rx.LocalVideoLowTrack);
        }
        async setDualStreamMode(e2, t2) {
          EO(e2, "mode", [0, 1, -1]);
          try {
            switch (t2 && await this.setLowStreamParameter(t2), this._dualStreamMode = e2, this._joinInfo ? this._gateway.setDualStreamMode(e2).catch(((e3) => {
              iP.warning("[".concat(this._clientId, "] set dual stream mode failed"), e3.toString());
            })) : iP.debug("[".concat(this._clientId, "] haven't joined yet, cache dual stream mode ").concat(e2)), e2) {
              case BO.AUTO_SIMULCAST_STREAM:
                iP.info("[".concat(this._clientId, "] set dual stream mode to ").concat(e2));
                break;
              case BO.DISABLE_SIMULCAST_STREM:
                return this.disableDualStream();
              case BO.ENABLE_SIMULCAST_STREAM:
                return this.enableDualStream();
            }
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] set dual stream mode error"), e3.toString()), e3;
          }
        }
        async enableDualStream() {
          if (!pP().supportDualStream) throw lP.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new uP(hO.NOT_SUPPORTED, "Your browser is not support dual stream");
          if (this._isDualStreamEnabled) throw new uP(hO.INVALID_OPERATION, "Dual stream is already enabled");
          if (this._p2pChannel.canPublishLowStream()) try {
            await this._publishLowStream();
          } catch (e2) {
            throw lP.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
          }
          this._isDualStreamEnabled = true, this._dualStreamMode = BO.ENABLE_SIMULCAST_STREAM, this._joinInfo && this._gateway.setDualStreamMode(this._dualStreamMode, true, true).catch(((e2) => {
            iP.debug("[".concat(this._clientId, "] try to inform gateway to set dual stream mode to ").concat(this._dualStreamMode, " ,but failed"), e2.toString());
          })), lP.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), iP.info("[".concat(this._clientId, "] enable dual stream"));
        }
        async disableDualStream() {
          if (this._isDualStreamEnabled) {
            if (!this._joinInfo) return this._isDualStreamEnabled = false, void iP.info("[".concat(this._clientId, "] disable dual stream before join"));
            if (this._p2pChannel.getLocalMedia(Rx.LocalVideoLowTrack)) try {
              const e2 = await this._p2pChannel.unpublishLowStream();
              e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (e2) {
              throw lP.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
            }
            this._isDualStreamEnabled = false, this._dualStreamMode = BO.DISABLE_SIMULCAST_STREM, this._joinInfo && this._gateway.setDualStreamMode(this._dualStreamMode, true, true).catch(((e2) => {
              iP.debug("[".concat(this._clientId, "] try to inform gateway to set dual stream mode to ").concat(this._dualStreamMode, " ,but failed"), e2.toString());
            })), lP.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), iP.info("[".concat(this._clientId, "] disable dual stream"));
          }
        }
        async setClientRole(e2, t2) {
          if ((function(e3) {
            EO(e3, "role", ["audience", "host"]);
          })(e2), t2 && jO(t2), "rtc" === this.mode || "p2p" === this.mode) throw iP.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new uP(hO.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
          if (t2 && t2.level && "host" === e2) throw new uP(hO.INVALID_OPERATION, "host mode can not set audience latency level");
          if ("audience" === e2 && this._p2pChannel.hasLocalMedia()) throw new uP(hO.INVALID_OPERATION, "can not set client role to audience when publishing stream");
          const i2 = this._config.role;
          if (this._joinInfo && (this._joinInfo.role = e2), e2 !== i2 && CD("ENABLE_ROLE_SELECT_EDGE") ? (this._gateway.updateClientRole(e2, t2), this._config.role = e2, this._gateway.reconnect("recover", HO.REGIONAL_DISTRIBUTION)) : (await this._gateway.setClientRole(e2, t2), this._config.role = e2), iP.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level)), "audience" === i2 && "audience" !== e2 && this._pendingRtpCapabilityChange && this._p2pChannel instanceof EG) {
            const { video_codec: e3 } = this._pendingRtpCapabilityChange;
            this._p2pChannel.updateRemoteRTPCapabilities(e3.map(((e4) => e4.toLowerCase())).filter(((e4) => {
              var t3;
              return Ln(t3 = Object.keys(AD)).call(t3, e4);
            })));
          }
        }
        async _setClientRoleOptions(e2) {
          if ("rtc" === this.mode || "p2p" === this.mode) return;
          if ("audience" !== this._config.role || this._p2pChannel.hasLocalMedia()) return;
          let t2 = false;
          try {
            e2 && jO(e2), await this._gateway.setClientRole(this._config.role, e2), t2 = true;
          } catch (e3) {
          } finally {
            iP.info("[".concat(this._clientId, "] set client role options ").concat(t2 ? "succeed" : "failed", ", options is ").concat(e2));
          }
        }
        getRemoteInboundOffset() {
          var e2;
          const t2 = null === (e2 = this._p2pChannel.getStats()) || void 0 === e2 ? void 0 : e2.audioSend[0];
          if (!t2 || !t2.timestamp) return 0;
          const i2 = t2.timestamp - Date.now();
          return Math.abs(i2) > 1e3 + t2.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i2 : 0;
        }
        getNtpWallTimeInMs() {
          return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
        }
        setProxyServer(e2, t2) {
          if (SO(e2, "proxyServer"), !t2) {
            if ("DISCONNECTED" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new uP(hO.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, lP.setProxyServer(this._proxyServer), iP.setProxyServer(this._proxyServer), iP.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setTurnServer(e2, t2) {
          if (Array.isArray(e2) || (e2 = [e2]), !t2) {
            if ("DISCONNECTED" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new uP(hO.INVALID_OPERATION, "You have already set the proxy");
          }
          if (xO(e2)) return this._turnServer = { servers: e2, mode: "original-manual" }, void iP.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map(((e3) => e3.urls)).join(","), "."));
          e2.forEach(((e3) => FO(e3))), this._turnServer = { servers: e2, mode: "manual" }, iP.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
        }
        setLicense(e2) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new uP(hO.INVALID_OPERATION, "you should set license before join channel");
          }
          if (SO(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2)) throw new uP(hO.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e2, iP.info("[".concat(this._clientId, "] set license success"), e2);
        }
        startProxyServer(e2) {
          if ("DISCONNECTED" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Start proxy server before join channel");
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new uP(hO.INVALID_OPERATION, "You have already set the proxy");
          const t2 = [3, 4, 5];
          let i2;
          switch (void 0 === e2 && (e2 = 3), e2) {
            case 1:
            case 2:
              throw new uP(hO.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              i2 = "proxy3";
              break;
            case 4:
              i2 = "proxy4";
              break;
            case 5:
              i2 = "proxy5";
              break;
            default:
              throw new uP(hO.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
          }
          this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, iP.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
        }
        stopProxyServer() {
          if ("DISCONNECTED" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "Stop proxy server after leave channel");
          lP.setProxyServer(), iP.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", iP.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
        }
        setLocalAccessPointsV2(e2) {
          if (!e2.accessPoints) throw new uP(hO.INVALID_PARAMS, "accessPoints is required.");
          gO(e2.accessPoints.serverList, "accessPoints.serverList"), SO(e2.accessPoints.domain, "accessPoints.domain");
          const t2 = (e3, t3) => {
            mO(e3, t3, 0, 65535, true);
          };
          let i2 = 443;
          if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i2 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new uP(hO.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          CD("CLOSE_AFB_FOR_LOCAL_AP") && (RD("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), RD("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, o2 = e2.accessPoints.serverList.map(((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3)), s2 = o2.map(((e3) => "".concat(e3, ":").concat(i2)));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, RD("WEBCS_DOMAIN", s2), RD("WEBCS_DOMAIN_BACKUP_LIST", s2), RD("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (gO(e2.report.hostname, "report.hostname"), RD("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), RD("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (RD("EVENT_REPORT_DOMAIN", o2[0]), RD("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
          let a2 = 6443;
          e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), RD("STATS_COLLECTOR_PORT", a2), e2.report ? RD("ENABLE_EVENT_REPORT", true) : RD("ENABLE_EVENT_REPORT", false);
          let c2 = "";
          e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (gO(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = o2[0];
          let d2 = 6444;
          e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), RD("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
          let l2 = [];
          e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (gO(e2.cds.hostname, "cds.hostname"), l2 = e2.cds.hostname) : l2 = o2;
          let u2 = 443;
          e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), u2 = e2.cds.port), RD("CDS_AP", l2.map(((e3) => "".concat(e3, ":").concat(u2)))), e2.cds ? RD("ENABLE_CONFIG_DISTRIBUTE", true) : RD("ENABLE_CONFIG_DISTRIBUTE", false), iP.info("set local access point v2 success");
        }
        setLocalAccessPoints(e2, t2) {
          if (gO(e2, "serverList"), SO(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new uP(hO.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map(((e3) => i2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3)), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, RD("WEBCS_DOMAIN", e2), RD("WEBCS_DOMAIN_BACKUP_LIST", e2), RD("GATEWAY_DOMAINS", [t2]), RD("EVENT_REPORT_DOMAIN", e2[0]), RD("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), RD("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), iP.info("[".concat(this._clientId, "] set local access point success"));
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (EO(e2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]), this._remoteDefaultVideoStreamType = e2, this._joinInfo) try {
            await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
          }
          else iP.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
        }
        async setRemoteVideoStreamType(e2, t2) {
          EO(t2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]);
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout((() => {
              const t3 = this._users.find(((t4) => t4.uid === e2));
              t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
            }), 2e3);
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
          }
          iP.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
        }
        async setStreamFallbackOption(e2, t2) {
          EO(t2, "fallbackType", [0, 1, 2, 3, 4, 5, 6, 7, 8]);
          try {
            await this._gateway.setStreamFallbackOption(e2, t2);
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
          }
          iP.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
        }
        setEncryptionConfig(e2, t2, i2, n2) {
          !(function(e3) {
            EO(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          })(e2), SO(t2, "secret");
          const r2 = ["aes-128-gcm2", "aes-256-gcm2"];
          if (Ln(r2).call(r2, e2)) {
            if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length)) throw new uP(hO.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (i2) throw new uP(hO.INVALID_PARAMS, "current encrypt mode does not need salt");
          if (n2) {
            if (_O(n2, "encryptDataStream"), !Ln(r2).call(r2, e2)) throw new uP(hO.INVALID_PARAMS, "current encrypt mode does not support data stream");
            this._encryptDataStream = true;
          }
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || iP.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i2 && (this._encryptionSalt = uN(i2));
        }
        async renewToken(e2) {
          if (SO(e2, "token", 1, 2047), !this._key || !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "renewToken should not be called before user join");
          const t2 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i2 = await this._renewTokenMutex.lock();
          try {
            if (CD("USE_NEW_TOKEN")) {
              iP.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
              const t3 = await XB(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || kN);
              iP.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
            } else iP.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
            iP.debug("[".concat(this._clientId, "] renewToken success"));
          } catch (e3) {
            throw this._key = t2, this._joinInfo.token = t2, iP.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
          } finally {
            i2();
          }
        }
        enableAudioVolumeIndicator() {
          this._audioVolumeIndicationInterval ? iP.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval((() => {
            const e2 = this._p2pChannel.getAudioLevels();
            this.safeEmit(GO.VOLUME_INDICATOR, e2);
          }), CD("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t2.duration / 1e3), e2;
        }
        async startLiveStreaming(e2, t2) {
          if (!t2) {
            if ("h264" !== this.codec) throw new uP(hO.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
            if (!this._p2pChannel.hasLocalMedia()) throw new uP(hO.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2)) throw new uP(hO.LIVE_STREAMING_TASK_CONFLICT);
          const i2 = t2 ? YV.TRANSCODE : YV.RAW;
          return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2);
        }
        setLiveTranscoding(e2) {
          return this._createLiveStreamingClient(YV.TRANSCODE).setTranscodingConfig(e2);
        }
        async stopLiveStreaming(e2) {
          const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter(((t3) => t3 && t3.hasUrl(e2)));
          if (!t2.length) throw new uP(hO.INVALID_PARAMS, "can not find live streaming url to stop");
          await rp.all(t2.map(((t3) => t3 && t3.stopLiveStreamingTask(e2))));
        }
        async startChannelMediaRelay(e2) {
          sj(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.startChannelMediaRelay(e2);
        }
        async updateChannelMediaRelay(e2) {
          sj(e2);
          const t2 = this._createChannelMediaRelayClient();
          await t2.updateChannelMediaRelay(e2);
        }
        async stopChannelMediaRelay() {
          const e2 = this._createChannelMediaRelayClient();
          await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
        }
        sendAudioMetadata(e2) {
          this._p2pChannel instanceof EG && this._p2pChannel.addAudioMetadata(e2);
        }
        async sendStreamMessage(e2) {
          var t2;
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo) throw new uP(hO.INVALID_OPERATION, "can not send data stream, not joined");
          if (("string" == typeof e2 || e2 instanceof Uint8Array) && (e2 = { payload: e2 }), "string" == typeof e2.payload) {
            const t3 = new TextEncoder();
            e2.payload = t3.encode(e2.payload);
          }
          let n2 = false;
          this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Ln(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode) && (n2 = true, e2.payload = await (async function(e3, t3, i3) {
            var n3;
            const r2 = nr(n3 = Array.from(i3)).call(n3, ((e4, t4) => e4 + t4), 0), o2 = { serverTs: 0, seq: DD++, length: i3.length, checkSum: r2 }, s2 = new Uint8Array(IN(r2, 2)), a2 = new ArrayBuffer(ND), c2 = new DataView(a2);
            c2.setUint32(0, o2.serverTs), c2.setUint16(4, o2.seq), c2.setUint16(6, o2.length), c2.setUint16(8, o2.checkSum);
            const d2 = 16 - i3.length % 16;
            i3 = pN(i3, new Uint8Array(d2));
            const l2 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: e3, tagLength: bD, additionalData: s2 }, t3, i3);
            return pN(new Uint8Array(a2), new Uint8Array(l2));
          })(this._encryptDataStreamIv, this._encryptDataStreamKey, e2.payload));
          if (new Blob([e2.payload]).size > 1024) throw new uP(hO.INVALID_PARAMS, n2 ? "encrypted stream message out of range." : "stream message out of range.");
          return this._gateway.signal.request(FV.DATA_STREAM, { payload: uN(e2.payload), syncWithAudio: e2.syncWithAudio, sendTs: Date.now() - gG }, !i2);
        }
        sendMetadata(e2) {
          if (!this._joinInfo) throw new uP(hO.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024) throw new uP(hO.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(FV.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: uN(e2) });
        }
        async sendCustomReportMessage(e2) {
          if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(rP), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "can not send custom report, not joined");
          await lP.sendCustomReportMessage(this._joinInfo.sid, e2);
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          const e2 = this._statsCollector.getRemoteNetworkQualityStats();
          if (CD("DELETE_NEQ_AFTER_USER_LEAVE")) {
            const t2 = this._users.map(((e3) => e3.uid + ""));
            Object.keys(e2).forEach(((i2) => {
              Ln(t2).call(t2, i2) || delete e2[i2];
            }));
          }
          return e2;
        }
        getNetworkQuality() {
          return this._statsCollector.getNetworkQuality();
        }
        async pickSVCLayer(e2, t2) {
          EO(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), EO(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t2);
          } catch (e3) {
            throw iP.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
          }
        }
        async setRTMConfig(e2) {
          const { apRTM: t2 = false, rtmFlag: i2 } = e2;
          if (_O(t2, "apRTM"), mO(i2, "rtmFlag", 0), this._rtmConfig.apRTM = t2, this._rtmConfig.rtmFlag = i2, iP.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(e2), " in ").concat(this.connectionState, " state")), ("CONNECTED" === this.connectionState || "RECONNECTING" === this.connectionState) && this._joinInfo) return this._joinInfo.apRTM = t2, this._joinInfo.rtmFlag = i2, this._gateway.setRTM2Flag(i2);
        }
        _reset() {
          if (iP.debug("[".concat(this._clientId, "] reset client")), (function(e2) {
            const t2 = YU.indexOf(e2);
            -1 !== t2 && YU.splice(t2, 1);
          })(this._clientId), this.store.hasStartJoinChannel = false, this.store.isABTestSuccess = false, this.store.autoSubscribe = false, this._pendingRtpCapabilityChange = void 0, this._axiosCancelSource.cancel(), this._axiosCancelSource = Tw.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && zG(this._joinInfo), this._rteDetailInterval && (window.clearInterval(this._rteDetailInterval), this._rteDetailInterval = void 0, this._sessionId && lP.reportRteDetail(this._sessionId)), this._fallbackServerInfo = void 0, this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId && lP.removeSid(this._sessionId), this._sessionId = null, this.store.sessionId = null, this.store.resetFirstVideoFrameDecoded(), this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach(((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy(), e2._dataChannels && (e2._dataChannels.forEach(((e3) => e3._close())), e2._dataChannels.length = 0);
          })), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new PN("client-publish", this._clientId), this._subscribeMutex = new PN("client-subscribe", this._clientId), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
          }
          if (this._moderation) try {
            this.setImageModeration(false);
          } catch (e2) {
          }
        }
        _startSession(e2, t2) {
          var i2;
          const n2 = e2 || gN();
          e2 ? iP.debug("[".concat(this._clientId, "] new Session ").concat(n2)) : iP.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n2));
          const r2 = e2 ? "" : this._sessionId || "";
          this._sessionId = n2, this.store.sessionId = n2, lP.addSid(n2);
          const o2 = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, buildFormat: 1, stringUid: (null == t2 ? void 0 : t2.stringUid) || (null === (i2 = this._joinInfo) || void 0 === i2 ? void 0 : i2.stringUid), channelProfile: "live" === this.mode ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r2, clientRole: "audience" === this.role ? 2 : 1, rteUrl: this.store.rteUrl, rteSid: this.store.rteSid };
          lP.sessionInit(this._sessionId, vH({ cname: t2.channel, appid: t2.appId }, o2)), this._joinInfo && (this._joinInfo.sid = n2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n2);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new uP(hO.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && CD("FORCE_TURN") && !CD("TURN_ENABLE_TCP") && !CD("TURN_ENABLE_UDP")) throw new uP(hO.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          iP.debug("[".concat(this._clientId, "] publish high stream"));
          try {
            const i2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter);
            if (this.store.useP2P) {
              const e3 = (await i2.next()).value;
              if (e3) {
                try {
                  await this._gateway.sendExtensionMessage(Lx.PUBLISH, e3, true);
                } catch (e4) {
                  throw i2.throw(e4), e4;
                }
                await i2.next();
              }
              this._p2pChannel.reportPublishEvent(true, null);
            } else {
              const n2 = (await i2.next()).value;
              if (n2) {
                var t2;
                let e3;
                try {
                  e3 = await this._gateway.publish(this._uid, n2, true);
                } catch (e4) {
                  if (e4.code !== hO.DISCONNECT_P2P) throw i2.throw(e4), e4;
                }
                await i2.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
              }
              this._p2pChannel.reportPublishEvent(true, null);
              for (const t3 of e2) t3 instanceof kM && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig).catch(((e3) => {
                iP.debug("[".concat(this._clientId, "] stop setVideoProfile, because websocket is closed"));
              })), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
            }
          } catch (t3) {
            if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === hO.WS_ABORT) return;
            throw t3;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid) throw new uP(hO.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          iP.debug("[".concat(this._clientId, "] publish low stream"));
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e3.next()).value;
            if (i2) {
              var t2;
              let n2;
              try {
                n2 = await this._gateway.publish(this._uid, i2, true);
              } catch (t3) {
                if (t3.code !== hO.DISCONNECT_P2P) throw e3.throw(t3), t3;
              }
              e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === hO.WS_ABORT) return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          const t2 = () => {
            if (!this._joinInfo || !this._appId) {
              return new uP(hO.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
            }
            const e3 = (t3 = { joinInfo: this._joinInfo, appId: this._appId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig }, oB("LiveStreaming").create(t3));
            var t3;
            return e3.onLiveStreamError = (e4, t4) => {
              lP.reportApiInvoke(this._sessionId, { name: LO.ON_LIVE_STREAM_ERROR, options: [e4, t4], tag: kO.TRACER }).onSuccess(), this.safeEmit(GO.LIVE_STREAMING_ERROR, e4, t4);
            }, e3.onLiveStreamWarning = (e4, t4) => {
              lP.reportApiInvoke(this._sessionId, { name: LO.ON_LIVE_STREAM_WARNING, options: [e4, t4], tag: kO.TRACER }).onSuccess(), this.safeEmit(GO.LIVE_STREAMING_WARNING, e4, t4);
            }, e3.on(ZV.REQUEST_WORKER_MANAGER_LIST, ((e4, t4, i2) => {
              if (!this._joinInfo) return i2(new uP(hO.INVALID_OPERATION, "can not find join info to get worker manager"));
              (async function(e5, t5, i3, n2) {
                const r2 = CD("UAP_AP").slice(0, CD("AJAX_REQUEST_CONCURRENT")).map(((e6) => t5.proxyServer ? "https://".concat(t5.proxyServer, "/ap/?url=").concat(e6 + "/api/v1?action=uap") : "https://".concat(e6, "/api/v1?action=uap")));
                return await bB(r2, e5, t5, i3, n2);
              })(e4, this._joinInfo, this._axiosCancelSource.token, kN).then(t4).catch(i2);
            })), e3;
          };
          return e2 === YV.RAW ? (this._liveRawStreamingClient = this._liveRawStreamingClient || t2(), this._liveRawStreamingClient) : (this._liveTranscodeStreamingClient = this._liveTranscodeStreamingClient || t2(), this._liveTranscodeStreamingClient);
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new uP(hO.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          if (!this._channelMediaRelayClient) {
            const { sendResolutionWidth: t2, sendResolutionHeight: i2 } = this.getLocalVideoStats(), n2 = (e2 = { joinInfo: this._joinInfo, clientId: this._clientId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig, resolution: { width: t2, height: i2 } }, oB("ChannelMediaRelay").create(e2));
            n2.on("state", ((e3) => {
              e3 === nx.RELAY_STATE_FAILURE && n2 && n2.dispose(), this.safeEmit(GO.CHANNEL_MEDIA_RELAY_STATE, e3);
            })), n2.on("event", ((e3) => {
              this.safeEmit(GO.CHANNEL_MEDIA_RELAY_EVENT, e3);
            })), this._channelMediaRelayClient = n2, this._statsCollector.onStatsChanged = (e3, t3) => {
              var i3;
              "resolution" === e3 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t3));
            };
          }
          var e2;
          return this._channelMediaRelayClient;
        }
        _handleUpdateDataChannel(e2, t2) {
          const { added: i2, deleted: n2 } = e2, r2 = [];
          if (t2) {
            const e3 = [];
            this._users.forEach(((t3) => {
              t3._dataChannels.forEach(((n3) => {
                i2.every(((e4) => e4.uid !== t3._uintid || e4.stream_id !== n3.id)) && e3.push({ uid: t3._uintid, stream_id: n3.id, ordered: n3.ordered, max_retrans_times: n3.maxRetransmits, metadata: n3.metadata });
              }));
            })), e3.length > 0 && this._handleUpdateDataChannel({ added: [], deleted: e3 });
          }
          Array.isArray(i2) && i2.length > 0 && i2.forEach(((e3) => {
            const { uid: i3, stream_id: n3, ordered: o2, max_retrans_times: s2, metadata: a2 } = e3, c2 = this._users.find(((e4) => e4._uintid === i3));
            if (!c2) return void iP.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
            iP.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i3)), Ln(r2).call(r2, c2) || r2.push(c2), c2._uintid || (c2._uintid = i3);
            if (!(-1 !== c2._dataChannels.findIndex(((t3) => t3.id === e3.stream_id)))) {
              const e4 = { id: n3, ordered: !!o2, maxRetransmits: s2, metadata: a2 }, i4 = (function(e5) {
                return sB(e5, true);
              })(e4);
              c2._dataChannels.push(i4), iP.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published datachannel")), t2 || this.safeEmit(GO.USER_PUBLISHED, c2, "datachannel", e4);
            }
            this._p2pChannel.hasPendingRemoteDataChannel(c2, e3.stream_id) && (iP.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c2.uid, " after reconnect.")), this._subscribeDataChannel(c2, e3.stream_id).catch(((e4) => {
              iP.error("[".concat(this._clientId, "] resubscribe datachannel error"), e4.toString());
            })));
          })), t2 && (this.safeEmit(GO.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n2) && n2.length > 0 && n2.forEach(((e3) => {
            const { uid: t3, stream_id: i3 } = e3, n3 = this._users.find(((e4) => e4._uintid === t3));
            if (!n3) return void iP.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
            const r3 = n3._dataChannels.find(((t4) => t4.id === e3.stream_id));
            r3 && (iP.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t3)), this._p2pChannel.unsubscribeDataChannel(n3, [r3]).then(((e4) => {
              if (n3._dataChannels = n3._dataChannels.filter(((e5) => e5 !== r3)), e4) return this._gateway.unsubscribeDataChannel(e4, n3.uid);
            })), iP.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(GO.USER_UNPUBLISHED, n3, "datachannel", r3._config));
          }));
        }
        _getEncodingName(e2) {
          var t2, i2;
          if (!this._joinResponse) return;
          const n2 = null === (t2 = this._joinResponse.ortc.rtpCapabilities.sendrecv) || void 0 === t2 ? void 0 : t2.videoCodecs;
          if (!n2) return;
          for (const t3 of n2) {
            var r2;
            if (t3.payloadType === e2) return null == t3 || null === (r2 = t3.rtpMap) || void 0 === r2 ? void 0 : r2.encodingName;
          }
          const o2 = null === (i2 = this._joinResponse.ortc.rtpCapabilities.recv) || void 0 === i2 ? void 0 : i2.videoCodecs;
          if (o2) for (const t3 of o2) {
            var s2;
            if (t3.payloadType === e2) return null == t3 || null === (s2 = t3.rtpMap) || void 0 === s2 ? void 0 : s2.encodingName;
          }
          return 0 === e2 ? "unknown" : void 0;
        }
        _handleRemoveDataChannels(e2) {
          const t2 = this._users.find(((t3) => t3.uid === e2.uid));
          if (t2) {
            if (void 0 !== t2._dataChannels && t2._dataChannels.length > 0) {
              iP.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e2.uid));
              const i2 = () => {
                iP.info("[".concat(this._clientId, "] remote user ").concat(t2.uid, " unpublished datachannel")), t2._dataChannels.forEach(((e3) => {
                  this.safeEmit(GO.USER_UNPUBLISHED, t2, "datachannel", e3._config);
                }));
              };
              this._p2pChannel.unsubscribeDataChannel(t2, t2._dataChannels).then(((e3) => {
                if (e3) return this._gateway.unsubscribeDataChannel(e3, t2.uid);
              })), i2();
            }
          } else iP.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
        }
        _handleGatewayEvents() {
          this._gateway.on(sx.UPDATE_GATEWAY_CONFIG, (() => {
            !(function() {
              let e2;
              try {
                e2 = window.localStorage.getItem("websdk_ng_global_parameter");
              } catch (e3) {
                return void iP.error("Error loading sdk config", e3.message);
              }
              if (e2) try {
                const t2 = JSON.parse(window.atob(e2)), i2 = Date.now();
                Object.keys(t2).forEach(((e3) => {
                  const { value: n2, type: r2, expires: o2 } = t2[e3];
                  o2 && o2 <= i2 || r2 || qU() || !Object.prototype.hasOwnProperty.call(mD, e3) || (yD[e3] = n2, TD[e3] = n2, iP.debug("Update gateway parameters from config distribute", e3, n2));
                }));
              } catch (e3) {
                iP.error("Error update config from local cache", e3.message);
              }
            })();
          })), this._gateway.on(sx.DISCONNECT_P2P, (async () => {
            await this._p2pChannel.disconnectForReconnect();
          })), this._gateway.on(sx.CONNECTION_STATE_CHANGE, ((e2, t2, i2) => {
            var n2;
            if (i2 === VO.FALLBACK) return;
            const r2 = () => {
              this.safeEmit(GO.CONNECTION_STATE_CHANGE, e2, t2, i2);
            };
            if (lP.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: LO.CONNECTION_STATE_CHANGE, options: [e2, t2, i2], tag: kO.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i2 })), iP.info("[".concat(this._clientId, "] signal connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2) return this._reset(), void r2();
            if ("RECONNECTING" === e2) this._users.forEach(((e3) => {
              e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._is_pre_created || (e3._audio_pre_subscribed || (e3._audioSSRC = void 0, e3._audioOrtc = void 0), e3._video_pre_subscribed || (e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._rtxSsrcId = void 0), e3._cname = void 0);
            })), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e2) {
              var o2;
              this._streamFallbackTypeCacheMap.forEach(((e3, t3) => {
                this._gateway.setStreamFallbackOption(t3, e3).catch(((e4) => {
                  iP.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                }));
              })), this._remoteStreamTypeCacheMap.forEach(((e3, t3) => {
                this._gateway.setRemoteVideoStreamType(t3, e3).catch(((e4) => {
                  iP.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                }));
              })), CD("VOS_CONFIGURE") && Array.isArray(CD("VOS_CONFIGURE")) && CD("VOS_CONFIGURE").length > 0 && (this._gateway.setConfigure(CD("VOS_CONFIGURE")).catch(((e3) => {
                iP.debug("[".concat(this._clientId, "] auto set vos config failed"), e3);
              })), iP.debug("[".concat(this._clientId, "] ws connected auto set vos config"))), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then((() => {
                iP.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              })).catch(((e3) => {
                iP.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              })), this._dualStreamMode && this._gateway.setDualStreamMode(this._dualStreamMode).catch(((e3) => {
                iP.warning("[".concat(this._clientId, "] auto set dual stream mode failed"), e3);
              })), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout((() => {
                if ("CONNECTED" !== this.connectionState) return;
                this._userOfflineTimeout = void 0;
                this._users.filter(((e3) => !e3._trust_in_room_)).forEach(((e3) => {
                  iP.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                }));
              }), 3e3), this._streamRemovedTimeout = window.setTimeout((() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach(((e3) => {
                  e3._trust_audio_mute_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, fx.AUDIO, false)), e3._trust_video_mute_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, fx.VIDEO, false)), e3._trust_audio_enabled_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (iP.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (iP.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                })));
              }), 1e3));
            }
            r2();
          })), this._gateway.on(sx.REQUEST_NEW_GATEWAY_LIST, (async (e2, t2) => {
            if (!this._joinInfo) return t2(new uP(hO.UNEXPECTED_ERROR, "can not recover, no join info"));
            try {
              let t3;
              if (this._fallbackServerInfo) t3 = this._fallbackServerInfo, this._fallbackServerInfo = void 0, this._joinInfo.preload = false, lP.reportApiInvoke(this._sessionId, { name: LO.VOS_FALLBACK_CN, options: { cur: t3.gatewayInfo.gatewayAddrs, prev: this._joinInfo.gatewayAddrs, is_done: true }, tag: kO.TRACER }).onSuccess(), iP.info("[".concat(this._clientId, "] use fallback cn server info"));
              else {
                const e3 = await WG(vH(vH({}, this._joinInfo), {}, { uid: this._joinInfo.uid, stringUid: void 0 }));
                e3 ? (t3 = e3.ap, qG(e3), this._joinInfo.preload = true) : (t3 = await jB(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || kN, this.store), this._joinInfo.preload = false);
              }
              this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip);
              const i2 = [];
              t3.gatewayInfo.gatewayAddrs.forEach(((e3) => {
                let { address: t4 } = e3;
                const [n2, r2] = t4.split(":");
                this._joinInfo && this._joinInfo.proxyServer ? i2.push({ proxy: this._joinInfo.proxyServer, host: n2, port: r2 }) : i2.push({ host: n2, port: r2 });
              })), e2(i2);
            } catch (e3) {
              t2(e3);
            }
          })), this._gateway.on(sx.NETWORK_QUALITY, ((e2) => {
            "normal" === this._networkQualitySensitivity && this.safeEmit(GO.NETWORK_QUALITY, e2);
          })), this._gateway.on(sx.STREAM_TYPE_CHANGE, ((e2, t2) => {
            this.safeEmit(GO.STREAM_TYPE_CHANGED, e2, t2);
            lP.reportApiInvoke(this._sessionId, { name: LO.STREAM_TYPE_CHANGE, options: [e2, t2], tag: kO.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
          })), this._gateway.isPreSub = () => "isPreSub" in this._p2pChannel && this._p2pChannel.isPreSub(), this._gateway.isPreallocation = () => "isPreallocation" in this._p2pChannel && this._p2pChannel.isPreallocation(), this._gateway.on(sx.IS_P2P_DISCONNECTED, ((e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          })), this._gateway.on(sx.REQUEST_P2P_CONNECTION_PARAMS, (async (e2, t2, i2) => {
            try {
              let i3 = await this._p2pChannel.getEstablishParams();
              i3 && "isPreallocation" in this._p2pChannel && this._p2pChannel.isPreallocation() || (i3 = await this._p2pChannel.startP2PConnection(e2)), t2(i3);
            } catch (e3) {
              i2(e3);
            }
          })), this._gateway.on(sx.JOIN_RESPONSE, ((e2, t2) => {
            if (this.store.useP2P) return;
            let i2;
            this._joinResponse = e2, e2.attributes ? i2 = e2.attributes.userAttributes.preSubSsrcs : iP.debug("no attributes in joinResponse");
            const n2 = DF(e2.ortc, t2, i2);
            this._p2pChannel.connect(n2);
          })), this._gateway.on(sx.PRE_CONNECT_PC, (async (e2, t2, i2) => {
            const { candidates: n2, fingerprint: r2, turnServer: o2 } = e2;
            if (this._joinInfo && n2.length > 0 && !this._p2pChannel.isPlanB) {
              const { cert: e3, cid: a2 } = this._joinInfo.apResponse, c2 = "".concat(a2, "_").concat(e3);
              if (c2.length < 4 || c2.length > 256) return void iP.debug("[".concat(this._clientId, "] ufrag length is not valid, length: ").concat(c2.length));
              await this._p2pChannel.startP2PConnection({ turnServer: o2, cloudProxyServer: this._joinInfo.cloudProxyServer, isPreallocation: true });
              try {
                var s2;
                t2(await this._p2pChannel.connect({ iceParameters: { iceUfrag: "".concat(a2, "_").concat(e3), icePwd: "".concat(a2, "_").concat(e3) }, dtlsParameters: { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (s2 = CD("FINGERPRINT")) && void 0 !== s2 ? s2 : r2 }] }, candidates: n2, rtpCapabilities: { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, setup: "active", cname: "o/i14u9pJrxRKAsu", preallocation: true }));
              } catch (e4) {
                e4.code && e4.code === hO.EXCHANGE_SDP_FAILED && await this._p2pChannel.startP2PConnection({ turnServer: o2, cloudProxyServer: this._joinInfo.cloudProxyServer }, true), i2(e4);
              }
            }
          })), this._gateway.on(sx.VOS_FALLBACK, ((e2) => {
            "fallback_hls" === e2 && this.safeEmit(GO.FALLBACK_TO_HLS, WO.VOSERROR);
          })), this._gateway.on(sx.RESET_SIGNAL, (() => {
            this._p2pChannel instanceof EG && this._p2pChannel.fallbackConnection(), this._handleGatewaySignalEvents();
          })), this._gateway.on(sx.DATACHANNEL_FAILBACK, (() => {
            lP.reportApiInvoke(this._sessionId, { name: LO.DATACHANNEL_FAILBACK, options: {}, tag: kO.TRACER }).onSuccess(), this._joinGateway();
          }));
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(jV.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(jV.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(jV.ON_ADD_AUDIO_STREAM, ((e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.pt, e2.uint_id, e2.ortc))), this._gateway.signal.on(jV.ON_ADD_VIDEO_STREAM, ((e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.pt, e2.uint_id, e2.ortc, e2.rtxSsrcId))), this._gateway.signal.on(jV.ON_REMOTE_DATASTREAM_UPDATE, ((e2) => {
            this._handleUpdateDataChannel(e2);
          })), this._gateway.signal.on(jV.ON_REMOTE_FULL_DATASTREAM_INFO, ((e2) => {
            this._handleUpdateDataChannel({ added: e2.datastreams || [], deleted: [] }, true);
          })), this._gateway.signal.on(jV.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(jV.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(jV.MUTE_AUDIO, ((e2) => this._handleMuteStream(e2.uid, fx.AUDIO, true))), this._gateway.signal.on(jV.UNMUTE_AUDIO, ((e2) => this._handleMuteStream(e2.uid, fx.AUDIO, false))), this._gateway.signal.on(jV.MUTE_VIDEO, ((e2) => this._handleMuteStream(e2.uid, fx.VIDEO, true))), this._gateway.signal.on(jV.UNMUTE_VIDEO, ((e2) => this._handleMuteStream(e2.uid, fx.VIDEO, false))), this._gateway.signal.on(jV.RECEIVE_METADATA, ((e2) => {
            const t2 = lN(e2.metadata);
            this.safeEmit(GO.RECEIVE_METADATA, e2.uid, t2);
          })), this._gateway.signal.on(jV.ON_DATA_STREAM, (async (e2) => {
            var t2;
            if (!e2) return;
            let i2 = lN(e2.payload);
            if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Ln(t2 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t2, this._encryptionMode)) {
              if (e2.payload.length < ND) throw new uP(hO.UNEXPECTED_RESPONSE, "payload length ".concat(e2.payload.length, " is less than header length ").concat(ND));
              const t3 = await (async function(e3, t4, i3) {
                const n3 = i3.subarray(0, ND), r2 = n3.slice(8, ND), o2 = (r2[0] << 8) + r2[1], s2 = (n3[6] << 8) + n3[7], a2 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: e3, tagLength: bD, additionalData: new Uint8Array(IN(o2, 2)) }, t4, i3.subarray(ND));
                return new Uint8Array(a2).subarray(0, s2);
              })(this._encryptDataStreamIv, this._encryptDataStreamKey, i2);
              i2 = t3;
            }
            let n2 = 0;
            if (e2.ordered || e2.syncWithAudio) {
              const t3 = this._p2pChannel.getStats(), i3 = this.remoteUsers.find(((t4) => t4.uid === e2.uid)), r2 = null == t3 ? void 0 : t3.audioRecv.find(((e3) => e3.ssrc === (null == i3 ? void 0 : i3._audioSSRC)));
              n2 = null == r2 ? void 0 : r2.jitterBufferMs;
            }
            (null == n2 || Number.isNaN(n2)) && (n2 = 0), IG(vH(vH({}, e2), {}, { payload: i2 }), n2, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
          })), this._gateway.signal.on(jV.ON_CRYPT_ERROR, (() => {
            dN((() => {
              iP.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(GO.CRYPT_ERROR);
            }), this._sessionId);
          })), this._gateway.signal.on(jV.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(jV.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => {
            iP.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, VO.TOKEN_EXPIRE), this.safeEmit(GO.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          })), this._gateway.signal.on(jV.ON_STREAM_FALLBACK_UPDATE, ((e2) => {
            iP.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(GO.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
          })), this._gateway.signal.on(jV.ENABLE_MULTI_STREAM, ((e2) => {
            this._dualStreamMode === BO.AUTO_SIMULCAST_STREAM && this.enableDualStream().catch(((e3) => {
              iP.debug("[".concat(this._clientId, "] set dual stream mode error"), e3.toString());
            }));
          })), this._gateway.signal.on(jV.ON_PUBLISH_STREAM, ((e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), iP.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
          })), this._gateway.signal.on(jV.ENABLE_LOCAL_VIDEO, ((e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          })), this._gateway.signal.on(jV.DISABLE_LOCAL_VIDEO, ((e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          })), this._gateway.signal.on(xV.REQUEST_TIMEOUT, ((e2, t2) => {
            if (this._joinInfo) switch (e2) {
              case FV.PUBLISH: {
                if (!t2) return;
                const e3 = t2.ortc;
                if (e3) {
                  var i2, n2;
                  const r2 = e3.some(((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === ox.Audio;
                  })), o2 = e3.some(((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== ox.Audio;
                  })), s2 = e3.some(((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === ox.Screen || t3 === ox.ScreenLow;
                  }));
                  "offer" === t2.state && lP.publish(this._joinInfo.sid, { eventElapse: tj.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: hO.TIMEOUT, audio: r2, video: o2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: s2, audioName: r2 ? null === (i2 = e3.find(((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === ox.Audio;
                  }))) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId.toString() : void 0, videoName: o2 ? null === (n2 = e3.find(((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== ox.Audio;
                  }))) || void 0 === n2 || null === (n2 = n2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0 });
                }
                break;
              }
              case FV.SUBSCRIBE:
                t2 && lP.subscribe(this._joinInfo.sid, { succ: false, ec: hO.TIMEOUT, audio: t2.stream_type === fx.AUDIO, video: t2.stream_type === fx.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: tj.measureFromSubscribeStart(this.store.clientId, t2.ssrcId), preSsrc: this._p2pChannel.isPreSubScribe(t2.ssrcId) });
            }
          })), this._gateway.signal.on(jV.ON_P2P_OK, ((e2) => {
            this.uid, this._uid;
          })), this._gateway.signal.on(jV.ON_PUBLISHED_USER_LIST, ((e2) => {
            if (null == e2 || !e2.users) return;
            CD("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter(((e3) => !zU(e3.string_id || e3.stream_id, this.channelName))));
            const t2 = [], i2 = [];
            for (const n2 of e2.users) {
              let e3 = this._users.find(((e4) => e4._uintid === n2.stream_id));
              e3 ? e3._trust_in_room_ = true : (e3 = new aj(n2.string_id || n2.stream_id, n2.stream_id), this._users.push(e3), this.store.firstVideoFrameDecoded(e3.uid, { userJoinNotify: Date.now() }), 0 === this.getListeners(GO.PUBLISHED_USER_LIST).length && (iP.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(GO.USER_JOINED, e3)));
              const r2 = cx.Audio & n2.stream_type, o2 = (cx.Video | cx.LwoVideo) & n2.stream_type, s2 = 0 != (65280 & n2.stream_type), a2 = r2 && e3.hasAudio, c2 = o2 && e3.hasVideo;
              o2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !a2 && 0 === this.getListeners(GO.PUBLISHED_USER_LIST).length && (iP.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(GO.USER_PUBLISHED, e3, "audio")), o2 && !c2 && 0 === this.getListeners(GO.PUBLISHED_USER_LIST).length && (iP.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(GO.USER_PUBLISHED, e3, "video")), (r2 && !a2 || o2 && !c2 || s2) && t2.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i2.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i2.push({ user: e3, mediaType: "audio" });
            }
            i2.length > 0 && (iP.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map(((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType))).join("; "), " ")), this.massSubscribe(i2).catch(((e3) => {
              iP.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            }))), this.getListeners(GO.PUBLISHED_USER_LIST).length > 0 ? CD("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t2 : (iP.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map(((e3) => e3.uid)).join(", "))), this.safeEmit(GO.PUBLISHED_USER_LIST, t2)) : iP.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map(((e3) => e3.uid)).join(", ")));
          })), this._gateway.signal.on(jV.ON_RTP_CAPABILITY_CHANGE, ((e2) => {
            const { video_codec: t2 } = e2;
            if (this._p2pChannel instanceof EG) {
              if ("audience" === this.role && CD("UPDATE_RTP_CAP_IN_HOST")) return this._pendingRtpCapabilityChange = e2, void iP.debug("[".concat(this._clientId, "] no need to change rtp capability because of audience, params: ").concat(JSON.stringify(e2)));
              this._p2pChannel.updateRemoteRTPCapabilities(t2.map(((e3) => e3.toLowerCase())).filter(((e3) => {
                var t3;
                return Ln(t3 = Object.keys(AD)).call(t3, e3);
              })));
            }
          })), this._gateway.signal.on(xV.VOS_FALLBACK_PROMISE, (async (e2, t2, i2) => {
            if ("FALLBACKCN" === e2 && CD("ENABLE_QUALITY_FALLBACK")) {
              if (!this._joinInfo) return i2(new uP(hO.UNEXPECTED_ERROR, "can not recover, no join info"));
              iP.info("[".concat(this._clientId, "] try fallback to cn, start request new server info"));
              const r2 = this._joinInfo.apRequestDetail;
              try {
                this._joinInfo.apRequestDetail = e2;
                const n3 = await jB(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || kN, this.store);
                if (CD("QUALITY_FALLBACK_REHEARSAL")) return lP.reportApiInvoke(this._sessionId, { name: LO.VOS_FALLBACK_CN, options: { cur: n3.gatewayInfo.gatewayAddrs, prev: this._joinInfo.gatewayAddrs, is_done: false }, tag: kO.TRACER }).onSuccess(), this._joinInfo.apRequestDetail = r2, void i2();
                this._fallbackServerInfo = n3, t2();
              } catch (e3) {
                var n2;
                const t3 = null == e3 || null === (n2 = e3.data) || void 0 === n2 ? void 0 : n2.desc;
                CD("QUALITY_FALLBACK_REHEARSAL") ? (lP.reportApiInvoke(this._sessionId, { name: LO.VOS_FALLBACK_CN, options: { cur: "failed, errorReason: " + t3 || "unknown", prev: this._joinInfo.gatewayAddrs, is_done: false }, tag: kO.TRACER }).onSuccess(), this._joinInfo.apRequestDetail = r2) : Array.isArray(t3) && Ln(t3).call(t3, "request downgrade fallback") && this.safeEmit(GO.FALLBACK_TO_HLS, WO.AP_ERROR), i2(e3);
              }
            } else i2();
          }));
        }
        _handleP2PEvents() {
          this._gateway.signal.on(jV.ON_USER_OFFLINE, (() => {
            this._p2pChannel.disconnectForReconnect();
          })), this._gateway.signal.on(Lx.PUBLISH, ((e2, t2, i2) => {
            const { uid: n2 } = e2;
            e2.forEach(((e3) => {
              const { kind: r2, ssrcs: o2, mid: s2, isMuted: a2 } = e3;
              this._handleP2PAddAudioOrVideoStream(r2, n2, o2[0].ssrcId, s2);
              const c2 = this._users.find(((e4) => e4.uid === n2));
              return c2 && this.store.useP2P ? this._p2pChannel.mockSubscribe(c2, r2, o2[0].ssrcId, s2).then((() => {
                t2();
              })).catch(i2) : t2(), this._handleMuteStream(n2, r2, !!a2);
            }));
          })), this._gateway.signal.on(Lx.CALL, (async (e2, t2, i2) => {
            if (this.store.useP2P) try {
              var n2;
              t2(await this._p2pChannel.startP2P({ turnServer: null === (n2 = this._joinInfo) || void 0 === n2 ? void 0 : n2.turnServer }, e2));
            } catch (e3) {
              i2(e3);
            }
          })), this._gateway.signal.on(xV.P2P_CONNECTION, (async (e2) => {
            this.store.useP2P && (await this._p2pChannel).p2pConnect(e2);
          })), this._gateway.signal.on(Lx.UNPUBLISH, (async (e2, t2, i2) => {
            if (this.store.useP2P) {
              const { unpubMsg: n2, uid: r2 } = e2, o2 = this._users.find(((e3) => e3.uid === r2));
              if (!o2) return iP.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t2();
              try {
                n2.forEach((async (e3) => {
                  let { stream_type: t3 } = e3;
                  const i3 = t3 === ox.Audio ? fx.AUDIO : fx.VIDEO;
                  await this._p2pChannel.unsubscribe(o2, i3), this._handleMuteStream(r2, i3, true);
                })), t2();
              } catch (e3) {
                i2(e3);
              }
            }
          })), this._gateway.signal.on(Lx.CONTROL, (async (e2, t2) => {
            const { action: i2 } = e2;
            switch (i2) {
              case Mx.MUTE_LOCAL_VIDEO:
                this._handleMuteStream(t2, fx.VIDEO, true);
                break;
              case Mx.MUTE_LOCAL_AUDIO:
                this._handleMuteStream(t2, fx.AUDIO, true);
                break;
              case Mx.UNMUTE_LOCAL_VIDEO:
                this._handleP2PAddAudioOrVideoStream("video", t2), this._handleMuteStream(t2, fx.VIDEO, false);
                break;
              case Mx.UNMUTE_LOCAL_AUDIO:
                this._handleP2PAddAudioOrVideoStream("audio", t2), this._handleMuteStream(t2, fx.AUDIO, false);
            }
          })), this._gateway.signal.on(Lx.RESTART_ICE, (async (e2, t2, i2) => {
            if (this.store.useP2P) try {
              const { direction: i3, iceParameter: n2 } = e2;
              if (i3 !== GV.SEND_ONLY || n2) {
                t2(await this._p2pChannel.restartICE(i3, n2));
              } else this._p2pChannel.handleDisconnect(i3), t2();
            } catch (e3) {
              i2(e3);
            }
          })), this._gateway.signal.on(Lx.CANDIDATE, ((e2) => {
            if (this.store.useP2P) {
              const { candidate: t2, direction: i2 } = e2;
              this._p2pChannel.addRemoteCandidate(t2, i2);
            }
          })), this._p2pChannel.on(vx.RequestP2PRestartICE, (async (e2, t2, i2) => {
            try {
              const { direction: i3 } = e2;
              t2(await this._gateway.sendExtensionMessage(Lx.RESTART_ICE, e2, i3 === GV.SEND_ONLY));
            } catch (e3) {
              i2(e3);
            }
          })), this._p2pChannel.on(vx.LocalCandidate, ((e2) => {
            this._gateway.sendExtensionMessage(Lx.CANDIDATE, JSON.stringify(e2), true);
          })), this._p2pChannel.on(vx.RequestP2PMuteLocal, (async (e2, t2, i2) => {
            try {
              await this._gateway.sendExtensionMessage(Lx.CONTROL, e2, true), t2();
            } catch (e3) {
              i2(e3);
            }
          })), this._p2pChannel.on(vx.RequestP2PUnmuteRemote, (async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === hO.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          })), this._p2pChannel.on(vx.RequestP2PMuteRemote, (async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === hO.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          })), this._p2pChannel.on(vx.StateChange, ((e2, t2) => {
            t2 === Cx.Connected && this._p2pChannel.republish();
          }));
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(vx.PeerConnectionStateChange, ((e2) => {
            const t2 = this._peerConnectionState;
            e2 !== t2 && (this.safeEmit(GO.PEERCONNECTION_STATE_CHANGE, e2, t2), this._peerConnectionState = e2);
          })), this._p2pChannel.on(vx.RequestMuteLocal, (async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === hO.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          })), this._p2pChannel.on(vx.RequestUnmuteLocal, (async (e2, t2, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === hO.DISCONNECT_P2P ? t2() : i2(e3);
            }
            else t2();
          })), this._p2pChannel.on(vx.RequestRePublish, ((e2, t2, i2) => {
            this.publish(e2, false).then(t2).catch(i2);
          })), this._p2pChannel.on(vx.RequestRePublishDataChannel, ((e2, t2, i2) => {
            rp.all(e2.map((async (e3) => {
              const t3 = await this._p2pChannel.publishDataChannel([e3]);
              try {
                t3.forEach(((e4) => {
                  this._uid && this._gateway.publishDataChannel(this._uid, e4, true);
                }));
              } catch (e4) {
                if (e4.code !== hO.DISCONNECT_P2P) throw e4;
              }
            }))).then(t2).catch(i2);
          })), this._p2pChannel.on(vx.RequestReSubscribe, (async (e2, t2, i2) => {
            try {
              for (const { user: t3, kind: i3 } of e2) i3 === fx.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
              t2();
            } catch (e3) {
              i2(e3);
            }
          })), this._p2pChannel.on(vx.RequestUpload, ((e2, t2) => {
            this._gateway.upload(e2, t2);
          })), this._p2pChannel.on(vx.RequestUploadStats, ((e2) => {
            this._gateway.uploadWRTCStats(e2);
          })), this._p2pChannel.on(vx.MediaReconnectStart, ((e2) => {
            this.safeEmit(GO.MEDIA_RECONNECT_START, e2);
          })), this._p2pChannel.on(vx.MediaReconnectEnd, ((e2) => {
            this.safeEmit(GO.MEDIA_RECONNECT_END, e2);
          })), this._p2pChannel.on(vx.NeedSignalRTT, ((e2) => {
            e2(this._gateway.getSignalRTT());
          })), this._p2pChannel.on(vx.RequestRestartICE, (async (e2) => {
            if (this.store.useP2P) return;
            const t2 = await this._p2pChannel.restartICE(e2), i2 = await t2.next();
            if (i2.done) return;
            const n2 = i2.value;
            let r2;
            try {
              r2 = await this._gateway.restartICE({ iceParameters: n2 });
            } catch (e3) {
              return void t2.throw(e3);
            }
            const { iceParameters: o2 } = (function(e3) {
              const t3 = e3.iceParameters;
              return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
            })(r2);
            await t2.next({ remoteIceParameters: o2 });
          })), this._p2pChannel.on(vx.RequestReconnect, (async () => {
            this._gateway.reconnect();
          })), this._p2pChannel.on(vx.RequestReconnectPC, (async () => {
            var e2;
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 }), s2 = DF(r2, o2);
            await this._p2pChannel.connect(s2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          })), this._p2pChannel.on(vx.RequestUnpublishForReconnectPC, (async (e2, t2, i2) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i2();
          })), this._p2pChannel.on(vx.P2PLost, (() => {
            this.safeEmit(GO.P2P_LOST, this.store.uid);
          })), this._p2pChannel.on(vx.UpdateVideoEncoder, ((e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          })), this._p2pChannel.on(vx.ConnectionTypeChange, ((e2) => {
            this.safeEmit(GO.IS_USING_CLOUD_PROXY, e2), this._gateway.setUsingProxy(e2);
          })), this._p2pChannel.on(vx.FirstVideoBufferReady, ((e2, t2) => {
            this.safeEmit(GO.FIRST_VIDEO_BUFFER_READY, e2, t2);
          })), this._p2pChannel.on(vx.FirstVideoPreRender, ((e2, t2) => {
            this.safeEmit(GO.FIRST_VIDEO_PRE_RENDER, e2, t2);
          })), this._p2pChannel.on(vx.RequestLowStreamParameter, ((e2) => {
            e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          })), this._p2pChannel.on(vx.QueryClientConnectionState, ((e2) => {
            e2(this.connectionState);
          })), this._p2pChannel.on(vx.AudioMetadata, ((e2) => {
            this.safeEmit(GO.AUDIO_METADATA, e2);
          })), this._p2pChannel.on(vx.AudioPts, ((e2) => {
            this.safeEmit(GO.AUDIO_PTS, Number(e2));
          }));
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e2) {
          if (!this._joinInfo || "CONNECTED" !== this.connectionState) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] can not create content inspect, please join channel first"));
          if (this._inspect) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          try {
            const i2 = (t2 = { config: e2 }, oB("ContentInspect").create(t2));
            this._inspect = i2, this.handleVideoInspectEvents(i2);
            const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
            await i2.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, kN);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
          var t2;
        }
        handleVideoInspectEvents(e2) {
          e2.on(Ax.CONNECTION_STATE_CHANGE, ((t2, i2) => {
            if (this.safeEmit(GO.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i2), i2 === yx.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) return void this.safeEmit(GO.CONTENT_INSPECT_ERROR, new uP(hO.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
              e2.inspectImage();
            }
          })), e2.on(Ax.INSPECT_RESULT, ((e3, t2) => {
            var i2;
            if ((null == t2 ? void 0 : t2.code) === hO.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return iP.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
            this.safeEmit(GO.CONTENT_INSPECT_RESULT, e3, t2);
          })), e2.on(Ax.CLIENT_LOCAL_VIDEO_TRACK, ((e3) => {
            e3(this.localTracks.filter(((e4) => "video" === e4.trackMediaType))[0]);
          }));
        }
        async disableContentInspect() {
          if (!this._inspect) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
            throw Array.isArray(e2) ? e2[0] : e2;
          }
        }
        async setImageModeration(e2, t2) {
          if (_O(e2, "enabled"), e2) {
            if (!t2) throw new uP(hO.INVALID_PARAMS, "config is required");
            if (DW(t2), !this._joinInfo) throw new uP(hO.INVALID_OPERATION, "can not create image moderation, please join channel first");
            try {
              if (this._moderation) this._moderation.updateConfig(t2);
              else {
                const e3 = (i2 = { config: t2 }, oB("ImageModeration").create(i2));
                this._moderation = e3, this.handleImageModerationEvents(e3);
                const { appId: n2, cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 } = this._joinInfo;
                await e3.init({ appId: n2, areaCode: "", cname: r2, sid: o2, token: s2, uid: a2, cid: c2, vid: d2 ? Number(d2) : 0 }, kN);
              }
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          } else {
            var i2;
            if (!this._moderation) throw new uP(hO.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
            try {
              this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
        }
        handleImageModerationEvents(e2) {
          e2.on(Dx.CONNECTION_STATE_CHANGE, ((t2, i2) => {
            if (this.safeEmit(GO.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i2), t2 === Nx.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) throw this.setImageModeration(false), new uP(hO.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
              e2.inspectImage();
            }
          })), e2.on(Dx.CLIENT_LOCAL_VIDEO_TRACK, ((e3) => {
            e3(this.localTracks.filter(((e4) => "video" === e4.trackMediaType))[0]);
          }));
        }
        setP2PTransport(e2) {
          if ((function(e3) {
            EO(e3, "transport", ["default", "auto", "relay", "sd-rtn"]);
          })(e2), "p2p" !== this.mode) throw new uP(hO.INVALID_OPERATION, "only p2p mode can set p2pTransport");
          this.store.p2pTransport = e2, iP.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(e2));
        }
        getJoinChannelServiceRecords() {
          return iP.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e2) {
          _O(e2, "enabled"), RD("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
        }
        _setRteInfo(e2, t2) {
          this.store.rteUrl = e2, this.store.rteSid = t2;
        }
        _isPreRender() {
          return "isPreRender" in this._p2pChannel && this._p2pChannel.isPreRender();
        }
        _handleResetAddStream(e2, t2) {
          switch (t2) {
            case "audio":
              e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
          }
        }
      }, DV(RH.prototype, "leave", [LW], Object.getOwnPropertyDescriptor(RH.prototype, "leave"), RH.prototype), DV(RH.prototype, "publish", [kW], Object.getOwnPropertyDescriptor(RH.prototype, "publish"), RH.prototype), DV(RH.prototype, "unpublish", [MW], Object.getOwnPropertyDescriptor(RH.prototype, "unpublish"), RH.prototype), DV(RH.prototype, "subscribe", [UW], Object.getOwnPropertyDescriptor(RH.prototype, "subscribe"), RH.prototype), DV(RH.prototype, "presubscribe", [VW], Object.getOwnPropertyDescriptor(RH.prototype, "presubscribe"), RH.prototype), DV(RH.prototype, "massSubscribe", [xW], Object.getOwnPropertyDescriptor(RH.prototype, "massSubscribe"), RH.prototype), DV(RH.prototype, "unsubscribe", [FW], Object.getOwnPropertyDescriptor(RH.prototype, "unsubscribe"), RH.prototype), DV(RH.prototype, "massUnsubscribe", [BW], Object.getOwnPropertyDescriptor(RH.prototype, "massUnsubscribe"), RH.prototype), DV(RH.prototype, "setLowStreamParameter", [jW], Object.getOwnPropertyDescriptor(RH.prototype, "setLowStreamParameter"), RH.prototype), DV(RH.prototype, "setDualStreamMode", [GW], Object.getOwnPropertyDescriptor(RH.prototype, "setDualStreamMode"), RH.prototype), DV(RH.prototype, "enableDualStream", [WW], Object.getOwnPropertyDescriptor(RH.prototype, "enableDualStream"), RH.prototype), DV(RH.prototype, "disableDualStream", [HW], Object.getOwnPropertyDescriptor(RH.prototype, "disableDualStream"), RH.prototype), DV(RH.prototype, "setClientRole", [KW], Object.getOwnPropertyDescriptor(RH.prototype, "setClientRole"), RH.prototype), DV(RH.prototype, "_setClientRoleOptions", [YW], Object.getOwnPropertyDescriptor(RH.prototype, "_setClientRoleOptions"), RH.prototype), DV(RH.prototype, "setProxyServer", [zW], Object.getOwnPropertyDescriptor(RH.prototype, "setProxyServer"), RH.prototype), DV(RH.prototype, "setTurnServer", [qW], Object.getOwnPropertyDescriptor(RH.prototype, "setTurnServer"), RH.prototype), DV(RH.prototype, "setLicense", [XW], Object.getOwnPropertyDescriptor(RH.prototype, "setLicense"), RH.prototype), DV(RH.prototype, "startProxyServer", [JW], Object.getOwnPropertyDescriptor(RH.prototype, "startProxyServer"), RH.prototype), DV(RH.prototype, "stopProxyServer", [QW], Object.getOwnPropertyDescriptor(RH.prototype, "stopProxyServer"), RH.prototype), DV(RH.prototype, "setLocalAccessPointsV2", [ZW], Object.getOwnPropertyDescriptor(RH.prototype, "setLocalAccessPointsV2"), RH.prototype), DV(RH.prototype, "setLocalAccessPoints", [$W], Object.getOwnPropertyDescriptor(RH.prototype, "setLocalAccessPoints"), RH.prototype), DV(RH.prototype, "setRemoteDefaultVideoStreamType", [eH], Object.getOwnPropertyDescriptor(RH.prototype, "setRemoteDefaultVideoStreamType"), RH.prototype), DV(RH.prototype, "setRemoteVideoStreamType", [tH], Object.getOwnPropertyDescriptor(RH.prototype, "setRemoteVideoStreamType"), RH.prototype), DV(RH.prototype, "setStreamFallbackOption", [iH], Object.getOwnPropertyDescriptor(RH.prototype, "setStreamFallbackOption"), RH.prototype), DV(RH.prototype, "setEncryptionConfig", [nH], Object.getOwnPropertyDescriptor(RH.prototype, "setEncryptionConfig"), RH.prototype), DV(RH.prototype, "renewToken", [rH], Object.getOwnPropertyDescriptor(RH.prototype, "renewToken"), RH.prototype), DV(RH.prototype, "enableAudioVolumeIndicator", [oH], Object.getOwnPropertyDescriptor(RH.prototype, "enableAudioVolumeIndicator"), RH.prototype), DV(RH.prototype, "startLiveStreaming", [sH], Object.getOwnPropertyDescriptor(RH.prototype, "startLiveStreaming"), RH.prototype), DV(RH.prototype, "setLiveTranscoding", [aH], Object.getOwnPropertyDescriptor(RH.prototype, "setLiveTranscoding"), RH.prototype), DV(RH.prototype, "stopLiveStreaming", [cH], Object.getOwnPropertyDescriptor(RH.prototype, "stopLiveStreaming"), RH.prototype), DV(RH.prototype, "startChannelMediaRelay", [dH], Object.getOwnPropertyDescriptor(RH.prototype, "startChannelMediaRelay"), RH.prototype), DV(RH.prototype, "updateChannelMediaRelay", [lH], Object.getOwnPropertyDescriptor(RH.prototype, "updateChannelMediaRelay"), RH.prototype), DV(RH.prototype, "stopChannelMediaRelay", [uH], Object.getOwnPropertyDescriptor(RH.prototype, "stopChannelMediaRelay"), RH.prototype), DV(RH.prototype, "sendCustomReportMessage", [hH], Object.getOwnPropertyDescriptor(RH.prototype, "sendCustomReportMessage"), RH.prototype), DV(RH.prototype, "pickSVCLayer", [pH], Object.getOwnPropertyDescriptor(RH.prototype, "pickSVCLayer"), RH.prototype), DV(RH.prototype, "setRTMConfig", [_H], Object.getOwnPropertyDescriptor(RH.prototype, "setRTMConfig"), RH.prototype), DV(RH.prototype, "enableContentInspect", [EH], Object.getOwnPropertyDescriptor(RH.prototype, "enableContentInspect"), RH.prototype), DV(RH.prototype, "disableContentInspect", [mH], Object.getOwnPropertyDescriptor(RH.prototype, "disableContentInspect"), RH.prototype), DV(RH.prototype, "setImageModeration", [fH], Object.getOwnPropertyDescriptor(RH.prototype, "setImageModeration"), RH.prototype), DV(RH.prototype, "setP2PTransport", [SH], Object.getOwnPropertyDescriptor(RH.prototype, "setP2PTransport"), RH.prototype), DV(RH.prototype, "getJoinChannelServiceRecords", [gH], Object.getOwnPropertyDescriptor(RH.prototype, "getJoinChannelServiceRecords"), RH.prototype), DV(RH.prototype, "setPublishAudioFilterEnabled", [TH], Object.getOwnPropertyDescriptor(RH.prototype, "setPublishAudioFilterEnabled"), RH.prototype), RH);
      function IH() {
        var e2;
        let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const i2 = SN(5, "client-"), n2 = lP.reportApiInvoke(null, { id: i2, name: LO.CREATE_CLIENT, options: [t2], tag: kO.TRACER });
        try {
          !(function(e3) {
            EO(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), EO(e3.mode, "config.mode", ["rtc", "live", "p2p"]), void 0 !== e3.audioCodec && EO(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && SO(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && FO(e3.turnServer), void 0 !== e3.httpRetryConfig && MO(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && MO(e3.websocketRetryConfig);
          })(t2);
        } catch (e3) {
          throw n2.onError(e3), e3;
        }
        return (Xw(16, 0, true) || Jw(16, 0, true)) && ("vp9" === t2.codec && (t2.codec = "vp8", iP.debug("browser not support vp9, force use vp8")), RD("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === t2.audioCodec && (t2.audioCodec = "opus"), n2.onSuccess(), new yH(vH(vH({ forceWaitGatewayResponse: true }, t2), {}, { role: Ln(e2 = ["rtc", "p2p"]).call(e2, t2.mode) ? "host" : t2.role || "audience" }), i2);
      }
      function AH() {
        let e2 = false;
        const t2 = Dw();
        return (t2.name === bw.CHROME && Number(t2.version) >= 58 && ("WebKit" !== Ow.engine.name || (function() {
          const e3 = Dw();
          if (Mw()) {
            if (e3.os === Aw.MAC_OS) return true;
            if (e3.os === Aw.IOS) {
              const e4 = Ow.os.version && Ow.os.version.split(".");
              if (e4 && 14 === Number(e4[0]) && e4[1] && Number(e4[1]) >= 3) return true;
              if (e4 && Number(e4[0]) > 14) return true;
            }
          }
          return false;
        })()) || t2.name === bw.FIREFOX && Number(t2.version) >= 56 || t2.name === bw.OPERA && Number(t2.version) >= 45 || t2.name === bw.SAFARI && Number(t2.version) >= 11 || "WebKit" === t2.name && (jw() || iO()) && t2.osVersion && Number(t2.osVersion.split(".")[0]) >= 11 || nO() || Dw().name === bw.QQ) && (e2 = true), e2;
      }
      class bH {
        constructor(e2, t2) {
          iA(this, "id", 0), iA(this, "element", void 0), iA(this, "peerPair", void 0), iA(this, "context", void 0), iA(this, "audioPlayerElement", void 0), iA(this, "audioTrack", void 0), bH.count += 1, this.id = bH.count, this.element = e2, this.context = t2;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t2 = document.createElement("audio");
            t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
          };
        }
        async switchSdp() {
          if (!this.peerPair) return;
          const e2 = async (e3, t3) => {
            const i2 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(i2), "complete" === e3.iceGatheringState ? e3.localDescription : new rp(((t4) => {
              e3.onicegatheringstatechange = () => {
                "complete" === e3.iceGatheringState && t4(e3.localDescription);
              };
            }));
          }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
          try {
            const i2 = await e2(this.peerPair[0], "offer");
            await t2(this.peerPair[1], i2);
            const n2 = await e2(this.peerPair[1], "answer");
            await t2(this.peerPair[0], n2);
          } catch (e3) {
            throw new uP(hO.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack) return this.audioTrack;
          let t2;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t2);
          } catch (e3) {
            throw new uP(hO.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t2) {
            throw new uP(hO.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i2 = t2.stream.getAudioTracks()[0];
          return this.audioTrack = i2, i2;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
        }
        close() {
          iP.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach(((e2) => {
            e2.close();
          })), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var wH, OH;
      iA(bH, "count", 0);
      const NH = window.AudioContext || window.webkitAudioContext;
      const DH = new (wH = dP({ report: lP }), DV((OH = class {
        constructor() {
          iA(this, "units", []), iA(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC()) return iP.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new NH());
          let t2 = this.units.find(((t3) => t3 && t3.getElement() === e2));
          return t2 || (t2 = new bH(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), iP.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
        }
        _doesEnvironmentNeedAEC() {
          return Dw().name !== bw.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [wH], Object.getOwnPropertyDescriptor(OH.prototype, "processExternalMediaAEC"), OH.prototype), OH)();
      function PH(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function LH(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? PH(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : PH(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      const kH = window || document;
      function MH(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!kH) return;
        const i2 = RJ._cspEventHandlerPointer;
        if (i2 && t2) return void console.error(i2, t2);
        const n2 = (e3) => {
          if (!(e3 && e3.blockedURI && (RJ.onSecurityPolicyViolation || RJ.getListeners(Ox.SECURITY_POLICY_VIOLATION).length > 0))) return;
          const t3 = e3.blockedURI;
          CD("CSP_DETECTED_HOSTNAME_LIST").some(((e4) => Ln(t3).call(t3, e4))) && (RJ.onSecurityPolicyViolation && "function" == typeof RJ.onSecurityPolicyViolation && RJ.onSecurityPolicyViolation(e3), RJ.getListeners(Ox.SECURITY_POLICY_VIOLATION).length > 0 && RJ.safeEmit(Ox.SECURITY_POLICY_VIOLATION, e3));
        };
        i2 && kH.removeEventListener("securitypolicyviolation", i2), (t2 || e2 && "function" == typeof e2 || RJ.getListeners(Ox.SECURITY_POLICY_VIOLATION).length > 0) && kH.addEventListener("securitypolicyviolation", n2), RJ._cspEventHandlerPointer = n2;
      }
      var UH = l, VH = rT, xH = RegExp.prototype, FH = function(e2) {
        return e2 === xH || UH(xH, e2) ? VH(e2) : e2.flags;
      }, BH = i(FH);
      function jH(e2) {
        let t2 = e2.length;
        for (; --t2 >= 0; ) e2[t2] = 0;
      }
      const GH = 256, WH = 286, HH = 30, KH = 15, YH = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), zH = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), qH = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), XH = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), JH = new Array(576);
      jH(JH);
      const QH = new Array(60);
      jH(QH);
      const ZH = new Array(512);
      jH(ZH);
      const $H = new Array(256);
      jH($H);
      const eK = new Array(29);
      jH(eK);
      const tK = new Array(HH);
      function iK(e2, t2, i2, n2, r2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = i2, this.elems = n2, this.max_length = r2, this.has_stree = e2 && e2.length;
      }
      let nK, rK, oK;
      function sK(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      jH(tK);
      const aK = (e2) => e2 < 256 ? ZH[e2] : ZH[256 + (e2 >>> 7)], cK = (e2, t2) => {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }, dK = (e2, t2, i2) => {
        e2.bi_valid > 16 - i2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, cK(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += i2 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += i2);
      }, lK = (e2, t2, i2) => {
        dK(e2, i2[2 * t2], i2[2 * t2 + 1]);
      }, uK = (e2, t2) => {
        let i2 = 0;
        do {
          i2 |= 1 & e2, e2 >>>= 1, i2 <<= 1;
        } while (--t2 > 0);
        return i2 >>> 1;
      }, hK = (e2, t2, i2) => {
        const n2 = new Array(16);
        let r2, o2, s2 = 0;
        for (r2 = 1; r2 <= KH; r2++) s2 = s2 + i2[r2 - 1] << 1, n2[r2] = s2;
        for (o2 = 0; o2 <= t2; o2++) {
          let t3 = e2[2 * o2 + 1];
          0 !== t3 && (e2[2 * o2] = uK(n2[t3]++, t3));
        }
      }, pK = (e2) => {
        let t2;
        for (t2 = 0; t2 < WH; t2++) e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < HH; t2++) e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < 19; t2++) e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.sym_next = e2.matches = 0;
      }, _K = (e2) => {
        e2.bi_valid > 8 ? cK(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }, EK = (e2, t2, i2, n2) => {
        const r2 = 2 * t2, o2 = 2 * i2;
        return e2[r2] < e2[o2] || e2[r2] === e2[o2] && n2[t2] <= n2[i2];
      }, mK = (e2, t2, i2) => {
        const n2 = e2.heap[i2];
        let r2 = i2 << 1;
        for (; r2 <= e2.heap_len && (r2 < e2.heap_len && EK(t2, e2.heap[r2 + 1], e2.heap[r2], e2.depth) && r2++, !EK(t2, n2, e2.heap[r2], e2.depth)); ) e2.heap[i2] = e2.heap[r2], i2 = r2, r2 <<= 1;
        e2.heap[i2] = n2;
      }, fK = (e2, t2, i2) => {
        let n2, r2, o2, s2, a2 = 0;
        if (0 !== e2.sym_next) do {
          n2 = 255 & e2.pending_buf[e2.sym_buf + a2++], n2 += (255 & e2.pending_buf[e2.sym_buf + a2++]) << 8, r2 = e2.pending_buf[e2.sym_buf + a2++], 0 === n2 ? lK(e2, r2, t2) : (o2 = $H[r2], lK(e2, o2 + GH + 1, t2), s2 = YH[o2], 0 !== s2 && (r2 -= eK[o2], dK(e2, r2, s2)), n2--, o2 = aK(n2), lK(e2, o2, i2), s2 = zH[o2], 0 !== s2 && (n2 -= tK[o2], dK(e2, n2, s2)));
        } while (a2 < e2.sym_next);
        lK(e2, 256, t2);
      }, SK = (e2, t2) => {
        const i2 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, r2 = t2.stat_desc.has_stree, o2 = t2.stat_desc.elems;
        let s2, a2, c2, d2 = -1;
        for (e2.heap_len = 0, e2.heap_max = 573, s2 = 0; s2 < o2; s2++) 0 !== i2[2 * s2] ? (e2.heap[++e2.heap_len] = d2 = s2, e2.depth[s2] = 0) : i2[2 * s2 + 1] = 0;
        for (; e2.heap_len < 2; ) c2 = e2.heap[++e2.heap_len] = d2 < 2 ? ++d2 : 0, i2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, r2 && (e2.static_len -= n2[2 * c2 + 1]);
        for (t2.max_code = d2, s2 = e2.heap_len >> 1; s2 >= 1; s2--) mK(e2, i2, s2);
        c2 = o2;
        do {
          s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], mK(e2, i2, 1), a2 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = a2, i2[2 * c2] = i2[2 * s2] + i2[2 * a2], e2.depth[c2] = (e2.depth[s2] >= e2.depth[a2] ? e2.depth[s2] : e2.depth[a2]) + 1, i2[2 * s2 + 1] = i2[2 * a2 + 1] = c2, e2.heap[1] = c2++, mK(e2, i2, 1);
        } while (e2.heap_len >= 2);
        e2.heap[--e2.heap_max] = e2.heap[1], ((e3, t3) => {
          const i3 = t3.dyn_tree, n3 = t3.max_code, r3 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, a3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
          let d3, l2, u2, h2, p2, _2, E2 = 0;
          for (h2 = 0; h2 <= KH; h2++) e3.bl_count[h2] = 0;
          for (i3[2 * e3.heap[e3.heap_max] + 1] = 0, d3 = e3.heap_max + 1; d3 < 573; d3++) l2 = e3.heap[d3], h2 = i3[2 * i3[2 * l2 + 1] + 1] + 1, h2 > c3 && (h2 = c3, E2++), i3[2 * l2 + 1] = h2, l2 > n3 || (e3.bl_count[h2]++, p2 = 0, l2 >= a3 && (p2 = s3[l2 - a3]), _2 = i3[2 * l2], e3.opt_len += _2 * (h2 + p2), o3 && (e3.static_len += _2 * (r3[2 * l2 + 1] + p2)));
          if (0 !== E2) {
            do {
              for (h2 = c3 - 1; 0 === e3.bl_count[h2]; ) h2--;
              e3.bl_count[h2]--, e3.bl_count[h2 + 1] += 2, e3.bl_count[c3]--, E2 -= 2;
            } while (E2 > 0);
            for (h2 = c3; 0 !== h2; h2--) for (l2 = e3.bl_count[h2]; 0 !== l2; ) u2 = e3.heap[--d3], u2 > n3 || (i3[2 * u2 + 1] !== h2 && (e3.opt_len += (h2 - i3[2 * u2 + 1]) * i3[2 * u2], i3[2 * u2 + 1] = h2), l2--);
          }
        })(e2, t2), hK(i2, d2, e2.bl_count);
      }, gK = (e2, t2, i2) => {
        let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === s2 && (c2 = 138, d2 = 3), t2[2 * (i2 + 1) + 1] = 65535, n2 = 0; n2 <= i2; n2++) r2 = s2, s2 = t2[2 * (n2 + 1) + 1], ++a2 < c2 && r2 === s2 || (a2 < d2 ? e2.bl_tree[2 * r2] += a2 : 0 !== r2 ? (r2 !== o2 && e2.bl_tree[2 * r2]++, e2.bl_tree[32]++) : a2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4));
      }, TK = (e2, t2, i2) => {
        let n2, r2, o2 = -1, s2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
        for (0 === s2 && (c2 = 138, d2 = 3), n2 = 0; n2 <= i2; n2++) if (r2 = s2, s2 = t2[2 * (n2 + 1) + 1], !(++a2 < c2 && r2 === s2)) {
          if (a2 < d2) do {
            lK(e2, r2, e2.bl_tree);
          } while (0 != --a2);
          else 0 !== r2 ? (r2 !== o2 && (lK(e2, r2, e2.bl_tree), a2--), lK(e2, 16, e2.bl_tree), dK(e2, a2 - 3, 2)) : a2 <= 10 ? (lK(e2, 17, e2.bl_tree), dK(e2, a2 - 3, 3)) : (lK(e2, 18, e2.bl_tree), dK(e2, a2 - 11, 7));
          a2 = 0, o2 = r2, 0 === s2 ? (c2 = 138, d2 = 3) : r2 === s2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4);
        }
      };
      let RK = false;
      const CK = (e2, t2, i2, n2) => {
        dK(e2, 0 + (n2 ? 1 : 0), 3), _K(e2), cK(e2, i2), cK(e2, ~i2), i2 && e2.pending_buf.set(e2.window.subarray(t2, t2 + i2), e2.pending), e2.pending += i2;
      };
      var vK = (e2) => {
        RK || ((() => {
          let e3, t2, i2, n2, r2;
          const o2 = new Array(16);
          for (i2 = 0, n2 = 0; n2 < 28; n2++) for (eK[n2] = i2, e3 = 0; e3 < 1 << YH[n2]; e3++) $H[i2++] = n2;
          for ($H[i2 - 1] = n2, r2 = 0, n2 = 0; n2 < 16; n2++) for (tK[n2] = r2, e3 = 0; e3 < 1 << zH[n2]; e3++) ZH[r2++] = n2;
          for (r2 >>= 7; n2 < HH; n2++) for (tK[n2] = r2 << 7, e3 = 0; e3 < 1 << zH[n2] - 7; e3++) ZH[256 + r2++] = n2;
          for (t2 = 0; t2 <= KH; t2++) o2[t2] = 0;
          for (e3 = 0; e3 <= 143; ) JH[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (; e3 <= 255; ) JH[2 * e3 + 1] = 9, e3++, o2[9]++;
          for (; e3 <= 279; ) JH[2 * e3 + 1] = 7, e3++, o2[7]++;
          for (; e3 <= 287; ) JH[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (hK(JH, 287, o2), e3 = 0; e3 < HH; e3++) QH[2 * e3 + 1] = 5, QH[2 * e3] = uK(e3, 5);
          nK = new iK(JH, YH, 257, WH, KH), rK = new iK(QH, zH, 0, HH, KH), oK = new iK(new Array(0), qH, 0, 19, 7);
        })(), RK = true), e2.l_desc = new sK(e2.dyn_ltree, nK), e2.d_desc = new sK(e2.dyn_dtree, rK), e2.bl_desc = new sK(e2.bl_tree, oK), e2.bi_buf = 0, e2.bi_valid = 0, pK(e2);
      }, yK = (e2, t2, i2, n2) => {
        let r2, o2, s2 = 0;
        e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = ((e3) => {
          let t3, i3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, i3 >>>= 1) if (1 & i3 && 0 !== e3.dyn_ltree[2 * t3]) return 0;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return 1;
          for (t3 = 32; t3 < GH; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return 1;
          return 0;
        })(e2)), SK(e2, e2.l_desc), SK(e2, e2.d_desc), s2 = ((e3) => {
          let t3;
          for (gK(e3, e3.dyn_ltree, e3.l_desc.max_code), gK(e3, e3.dyn_dtree, e3.d_desc.max_code), SK(e3, e3.bl_desc), t3 = 18; t3 >= 3 && 0 === e3.bl_tree[2 * XH[t3] + 1]; t3--) ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        })(e2), r2 = e2.opt_len + 3 + 7 >>> 3, o2 = e2.static_len + 3 + 7 >>> 3, o2 <= r2 && (r2 = o2)) : r2 = o2 = i2 + 5, i2 + 4 <= r2 && -1 !== t2 ? CK(e2, t2, i2, n2) : 4 === e2.strategy || o2 === r2 ? (dK(e2, 2 + (n2 ? 1 : 0), 3), fK(e2, JH, QH)) : (dK(e2, 4 + (n2 ? 1 : 0), 3), ((e3, t3, i3, n3) => {
          let r3;
          for (dK(e3, t3 - 257, 5), dK(e3, i3 - 1, 5), dK(e3, n3 - 4, 4), r3 = 0; r3 < n3; r3++) dK(e3, e3.bl_tree[2 * XH[r3] + 1], 3);
          TK(e3, e3.dyn_ltree, t3 - 1), TK(e3, e3.dyn_dtree, i3 - 1);
        })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), fK(e2, e2.dyn_ltree, e2.dyn_dtree)), pK(e2), n2 && _K(e2);
      }, IK = (e2, t2, i2) => (e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2, e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2 >> 8, e2.pending_buf[e2.sym_buf + e2.sym_next++] = i2, 0 === t2 ? e2.dyn_ltree[2 * i2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * ($H[i2] + GH + 1)]++, e2.dyn_dtree[2 * aK(t2)]++), e2.sym_next === e2.sym_end), AK = (e2) => {
        dK(e2, 2, 3), lK(e2, 256, JH), ((e3) => {
          16 === e3.bi_valid ? (cK(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        })(e2);
      }, bK = { _tr_init: vK, _tr_stored_block: CK, _tr_flush_block: yK, _tr_tally: IK, _tr_align: AK };
      var wK = (e2, t2, i2, n2) => {
        let r2 = 65535 & e2 | 0, o2 = e2 >>> 16 & 65535 | 0, s2 = 0;
        for (; 0 !== i2; ) {
          s2 = i2 > 2e3 ? 2e3 : i2, i2 -= s2;
          do {
            r2 = r2 + t2[n2++] | 0, o2 = o2 + r2 | 0;
          } while (--s2);
          r2 %= 65521, o2 %= 65521;
        }
        return r2 | o2 << 16 | 0;
      };
      const OK = new Uint32Array((() => {
        let e2, t2 = [];
        for (var i2 = 0; i2 < 256; i2++) {
          e2 = i2;
          for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[i2] = e2;
        }
        return t2;
      })());
      var NK = (e2, t2, i2, n2) => {
        const r2 = OK, o2 = n2 + i2;
        e2 ^= -1;
        for (let i3 = n2; i3 < o2; i3++) e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t2[i3])];
        return -1 ^ e2;
      }, DK = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, PK = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: LK, _tr_stored_block: kK, _tr_flush_block: MK, _tr_tally: UK, _tr_align: VK } = bK, { Z_NO_FLUSH: xK, Z_PARTIAL_FLUSH: FK, Z_FULL_FLUSH: BK, Z_FINISH: jK, Z_BLOCK: GK, Z_OK: WK, Z_STREAM_END: HK, Z_STREAM_ERROR: KK, Z_DATA_ERROR: YK, Z_BUF_ERROR: zK, Z_DEFAULT_COMPRESSION: qK, Z_FILTERED: XK, Z_HUFFMAN_ONLY: JK, Z_RLE: QK, Z_FIXED: ZK, Z_DEFAULT_STRATEGY: $K, Z_UNKNOWN: eY, Z_DEFLATED: tY } = PK, iY = 286, nY = 30, rY = 19, oY = 2 * iY + 1, sY = 15, aY = 258, cY = 262, dY = 42, lY = 113, uY = 666, hY = (e2, t2) => (e2.msg = DK[t2], t2), pY = (e2) => 2 * e2 - (e2 > 4 ? 9 : 0), _Y = (e2) => {
        let t2 = e2.length;
        for (; --t2 >= 0; ) e2[t2] = 0;
      }, EY = (e2) => {
        let t2, i2, n2, r2 = e2.w_size;
        t2 = e2.hash_size, n2 = t2;
        do {
          i2 = e2.head[--n2], e2.head[n2] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t2);
        t2 = r2, n2 = t2;
        do {
          i2 = e2.prev[--n2], e2.prev[n2] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t2);
      };
      let mY = (e2, t2, i2) => (t2 << e2.hash_shift ^ i2) & e2.hash_mask;
      const fY = (e2) => {
        const t2 = e2.state;
        let i2 = t2.pending;
        i2 > e2.avail_out && (i2 = e2.avail_out), 0 !== i2 && (e2.output.set(t2.pending_buf.subarray(t2.pending_out, t2.pending_out + i2), e2.next_out), e2.next_out += i2, t2.pending_out += i2, e2.total_out += i2, e2.avail_out -= i2, t2.pending -= i2, 0 === t2.pending && (t2.pending_out = 0));
      }, SY = (e2, t2) => {
        MK(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, fY(e2.strm);
      }, gY = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2;
      }, TY = (e2, t2) => {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }, RY = (e2, t2, i2, n2) => {
        let r2 = e2.avail_in;
        return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (e2.avail_in -= r2, t2.set(e2.input.subarray(e2.next_in, e2.next_in + r2), i2), 1 === e2.state.wrap ? e2.adler = wK(e2.adler, t2, r2, i2) : 2 === e2.state.wrap && (e2.adler = NK(e2.adler, t2, r2, i2)), e2.next_in += r2, e2.total_in += r2, r2);
      }, CY = (e2, t2) => {
        let i2, n2, r2 = e2.max_chain_length, o2 = e2.strstart, s2 = e2.prev_length, a2 = e2.nice_match;
        const c2 = e2.strstart > e2.w_size - cY ? e2.strstart - (e2.w_size - cY) : 0, d2 = e2.window, l2 = e2.w_mask, u2 = e2.prev, h2 = e2.strstart + aY;
        let p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
        e2.prev_length >= e2.good_match && (r2 >>= 2), a2 > e2.lookahead && (a2 = e2.lookahead);
        do {
          if (i2 = t2, d2[i2 + s2] === _2 && d2[i2 + s2 - 1] === p2 && d2[i2] === d2[o2] && d2[++i2] === d2[o2 + 1]) {
            o2 += 2, i2++;
            do {
            } while (d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && o2 < h2);
            if (n2 = aY - (h2 - o2), o2 = h2 - aY, n2 > s2) {
              if (e2.match_start = t2, s2 = n2, n2 >= a2) break;
              p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
            }
          }
        } while ((t2 = u2[t2 & l2]) > c2 && 0 != --r2);
        return s2 <= e2.lookahead ? s2 : e2.lookahead;
      }, vY = (e2) => {
        const t2 = e2.w_size;
        let i2, n2, r2;
        do {
          if (n2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - cY) && (e2.window.set(e2.window.subarray(t2, t2 + t2 - n2), 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, e2.insert > e2.strstart && (e2.insert = e2.strstart), EY(e2), n2 += t2), 0 === e2.strm.avail_in) break;
          if (i2 = RY(e2.strm, e2.window, e2.strstart + e2.lookahead, n2), e2.lookahead += i2, e2.lookahead + e2.insert >= 3) for (r2 = e2.strstart - e2.insert, e2.ins_h = e2.window[r2], e2.ins_h = mY(e2, e2.ins_h, e2.window[r2 + 1]); e2.insert && (e2.ins_h = mY(e2, e2.ins_h, e2.window[r2 + 3 - 1]), e2.prev[r2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = r2, r2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); ) ;
        } while (e2.lookahead < cY && 0 !== e2.strm.avail_in);
      }, yY = (e2, t2) => {
        let i2, n2, r2, o2 = e2.pending_buf_size - 5 > e2.w_size ? e2.w_size : e2.pending_buf_size - 5, s2 = 0, a2 = e2.strm.avail_in;
        do {
          if (i2 = 65535, r2 = e2.bi_valid + 42 >> 3, e2.strm.avail_out < r2) break;
          if (r2 = e2.strm.avail_out - r2, n2 = e2.strstart - e2.block_start, i2 > n2 + e2.strm.avail_in && (i2 = n2 + e2.strm.avail_in), i2 > r2 && (i2 = r2), i2 < o2 && (0 === i2 && t2 !== jK || t2 === xK || i2 !== n2 + e2.strm.avail_in)) break;
          s2 = t2 === jK && i2 === n2 + e2.strm.avail_in ? 1 : 0, kK(e2, 0, 0, s2), e2.pending_buf[e2.pending - 4] = i2, e2.pending_buf[e2.pending - 3] = i2 >> 8, e2.pending_buf[e2.pending - 2] = ~i2, e2.pending_buf[e2.pending - 1] = ~i2 >> 8, fY(e2.strm), n2 && (n2 > i2 && (n2 = i2), e2.strm.output.set(e2.window.subarray(e2.block_start, e2.block_start + n2), e2.strm.next_out), e2.strm.next_out += n2, e2.strm.avail_out -= n2, e2.strm.total_out += n2, e2.block_start += n2, i2 -= n2), i2 && (RY(e2.strm, e2.strm.output, e2.strm.next_out, i2), e2.strm.next_out += i2, e2.strm.avail_out -= i2, e2.strm.total_out += i2);
        } while (0 === s2);
        return a2 -= e2.strm.avail_in, a2 && (a2 >= e2.w_size ? (e2.matches = 2, e2.window.set(e2.strm.input.subarray(e2.strm.next_in - e2.w_size, e2.strm.next_in), 0), e2.strstart = e2.w_size, e2.insert = e2.strstart) : (e2.window_size - e2.strstart <= a2 && (e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, e2.insert > e2.strstart && (e2.insert = e2.strstart)), e2.window.set(e2.strm.input.subarray(e2.strm.next_in - a2, e2.strm.next_in), e2.strstart), e2.strstart += a2, e2.insert += a2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : a2), e2.block_start = e2.strstart), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), s2 ? 4 : t2 !== xK && t2 !== jK && 0 === e2.strm.avail_in && e2.strstart === e2.block_start ? 2 : (r2 = e2.window_size - e2.strstart, e2.strm.avail_in > r2 && e2.block_start >= e2.w_size && (e2.block_start -= e2.w_size, e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, r2 += e2.w_size, e2.insert > e2.strstart && (e2.insert = e2.strstart)), r2 > e2.strm.avail_in && (r2 = e2.strm.avail_in), r2 && (RY(e2.strm, e2.window, e2.strstart, r2), e2.strstart += r2, e2.insert += r2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : r2), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), r2 = e2.bi_valid + 42 >> 3, r2 = e2.pending_buf_size - r2 > 65535 ? 65535 : e2.pending_buf_size - r2, o2 = r2 > e2.w_size ? e2.w_size : r2, n2 = e2.strstart - e2.block_start, (n2 >= o2 || (n2 || t2 === jK) && t2 !== xK && 0 === e2.strm.avail_in && n2 <= r2) && (i2 = n2 > r2 ? r2 : n2, s2 = t2 === jK && 0 === e2.strm.avail_in && i2 === n2 ? 1 : 0, kK(e2, e2.block_start, i2, s2), e2.block_start += i2, fY(e2.strm)), s2 ? 3 : 1);
      }, IY = (e2, t2) => {
        let i2, n2;
        for (; ; ) {
          if (e2.lookahead < cY) {
            if (vY(e2), e2.lookahead < cY && t2 === xK) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = mY(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== i2 && e2.strstart - i2 <= e2.w_size - cY && (e2.match_length = CY(e2, i2)), e2.match_length >= 3) if (n2 = UK(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = mY(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (0 != --e2.match_length);
            e2.strstart++;
          } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = mY(e2, e2.ins_h, e2.window[e2.strstart + 1]);
          else n2 = UK(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (SY(e2, false), 0 === e2.strm.avail_out)) return 1;
        }
        return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === jK ? (SY(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (SY(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      }, AY = (e2, t2) => {
        let i2, n2, r2;
        for (; ; ) {
          if (e2.lookahead < cY) {
            if (vY(e2), e2.lookahead < cY && t2 === xK) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = mY(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== i2 && e2.prev_length < e2.max_lazy_match && e2.strstart - i2 <= e2.w_size - cY && (e2.match_length = CY(e2, i2), e2.match_length <= 5 && (e2.strategy === XK || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
            r2 = e2.strstart + e2.lookahead - 3, n2 = UK(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
            do {
              ++e2.strstart <= r2 && (e2.ins_h = mY(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
            } while (0 != --e2.prev_length);
            if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n2 && (SY(e2, false), 0 === e2.strm.avail_out)) return 1;
          } else if (e2.match_available) {
            if (n2 = UK(e2, 0, e2.window[e2.strstart - 1]), n2 && SY(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return 1;
          } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = UK(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === jK ? (SY(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (SY(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      };
      function bY(e2, t2, i2, n2, r2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = i2, this.max_chain = n2, this.func = r2;
      }
      const wY = [new bY(0, 0, 0, 0, yY), new bY(4, 4, 8, 4, IY), new bY(4, 5, 16, 8, IY), new bY(4, 6, 32, 32, IY), new bY(4, 4, 16, 16, AY), new bY(8, 16, 32, 32, AY), new bY(8, 16, 128, 128, AY), new bY(8, 32, 128, 256, AY), new bY(32, 128, 258, 1024, AY), new bY(32, 258, 258, 4096, AY)];
      function OY() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = tY, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * oY), this.dyn_dtree = new Uint16Array(2 * (2 * nY + 1)), this.bl_tree = new Uint16Array(2 * (2 * rY + 1)), _Y(this.dyn_ltree), _Y(this.dyn_dtree), _Y(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(sY + 1), this.heap = new Uint16Array(2 * iY + 1), _Y(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * iY + 1), _Y(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const NY = (e2) => {
        if (!e2) return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.status !== dY && 57 !== t2.status && 69 !== t2.status && 73 !== t2.status && 91 !== t2.status && 103 !== t2.status && t2.status !== lY && t2.status !== uY ? 1 : 0;
      }, DY = (e2) => {
        if (NY(e2)) return hY(e2, KK);
        e2.total_in = e2.total_out = 0, e2.data_type = eY;
        const t2 = e2.state;
        return t2.pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = 2 === t2.wrap ? 57 : t2.wrap ? dY : lY, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = -2, LK(t2), WK;
      }, PY = (e2) => {
        const t2 = DY(e2);
        return t2 === WK && ((e3) => {
          e3.window_size = 2 * e3.w_size, _Y(e3.head), e3.max_lazy_match = wY[e3.level].max_lazy, e3.good_match = wY[e3.level].good_length, e3.nice_match = wY[e3.level].nice_length, e3.max_chain_length = wY[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = 2, e3.match_available = 0, e3.ins_h = 0;
        })(e2.state), t2;
      }, LY = (e2, t2, i2, n2, r2, o2) => {
        if (!e2) return KK;
        let s2 = 1;
        if (t2 === qK && (t2 = 6), n2 < 0 ? (s2 = 0, n2 = -n2) : n2 > 15 && (s2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || i2 !== tY || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || o2 < 0 || o2 > ZK || 8 === n2 && 1 !== s2) return hY(e2, KK);
        8 === n2 && (n2 = 9);
        const a2 = new OY();
        return e2.state = a2, a2.strm = e2, a2.status = dY, a2.wrap = s2, a2.gzhead = null, a2.w_bits = n2, a2.w_size = 1 << a2.w_bits, a2.w_mask = a2.w_size - 1, a2.hash_bits = r2 + 7, a2.hash_size = 1 << a2.hash_bits, a2.hash_mask = a2.hash_size - 1, a2.hash_shift = ~~((a2.hash_bits + 3 - 1) / 3), a2.window = new Uint8Array(2 * a2.w_size), a2.head = new Uint16Array(a2.hash_size), a2.prev = new Uint16Array(a2.w_size), a2.lit_bufsize = 1 << r2 + 6, a2.pending_buf_size = 4 * a2.lit_bufsize, a2.pending_buf = new Uint8Array(a2.pending_buf_size), a2.sym_buf = a2.lit_bufsize, a2.sym_end = 3 * (a2.lit_bufsize - 1), a2.level = t2, a2.strategy = o2, a2.method = i2, PY(e2);
      };
      var kY = (e2, t2) => {
        if (NY(e2) || t2 > GK || t2 < 0) return e2 ? hY(e2, KK) : KK;
        const i2 = e2.state;
        if (!e2.output || 0 !== e2.avail_in && !e2.input || i2.status === uY && t2 !== jK) return hY(e2, 0 === e2.avail_out ? zK : KK);
        const n2 = i2.last_flush;
        if (i2.last_flush = t2, 0 !== i2.pending) {
          if (fY(e2), 0 === e2.avail_out) return i2.last_flush = -1, WK;
        } else if (0 === e2.avail_in && pY(t2) <= pY(n2) && t2 !== jK) return hY(e2, zK);
        if (i2.status === uY && 0 !== e2.avail_in) return hY(e2, zK);
        if (i2.status === dY && 0 === i2.wrap && (i2.status = lY), i2.status === dY) {
          let t3 = tY + (i2.w_bits - 8 << 4) << 8, n3 = -1;
          if (n3 = i2.strategy >= JK || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t3 |= n3 << 6, 0 !== i2.strstart && (t3 |= 32), t3 += 31 - t3 % 31, TY(i2, t3), 0 !== i2.strstart && (TY(i2, e2.adler >>> 16), TY(i2, 65535 & e2.adler)), e2.adler = 1, i2.status = lY, fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
        }
        if (57 === i2.status) {
          if (e2.adler = 0, gY(i2, 31), gY(i2, 139), gY(i2, 8), i2.gzhead) gY(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), gY(i2, 255 & i2.gzhead.time), gY(i2, i2.gzhead.time >> 8 & 255), gY(i2, i2.gzhead.time >> 16 & 255), gY(i2, i2.gzhead.time >> 24 & 255), gY(i2, 9 === i2.level ? 2 : i2.strategy >= JK || i2.level < 2 ? 4 : 0), gY(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (gY(i2, 255 & i2.gzhead.extra.length), gY(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69;
          else if (gY(i2, 0), gY(i2, 0), gY(i2, 0), gY(i2, 0), gY(i2, 0), gY(i2, 9 === i2.level ? 2 : i2.strategy >= JK || i2.level < 2 ? 4 : 0), gY(i2, 3), i2.status = lY, fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
        }
        if (69 === i2.status) {
          if (i2.gzhead.extra) {
            let t3 = i2.pending, n3 = (65535 & i2.gzhead.extra.length) - i2.gzindex;
            for (; i2.pending + n3 > i2.pending_buf_size; ) {
              let r3 = i2.pending_buf_size - i2.pending;
              if (i2.pending_buf.set(i2.gzhead.extra.subarray(i2.gzindex, i2.gzindex + r3), i2.pending), i2.pending = i2.pending_buf_size, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex += r3, fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
              t3 = 0, n3 -= r3;
            }
            let r2 = new Uint8Array(i2.gzhead.extra);
            i2.pending_buf.set(r2.subarray(i2.gzindex, i2.gzindex + n3), i2.pending), i2.pending += n3, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex = 0;
          }
          i2.status = 73;
        }
        if (73 === i2.status) {
          if (i2.gzhead.name) {
            let t3, n3 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - n3, n3)), fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
                n3 = 0;
              }
              t3 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, gY(i2, t3);
            } while (0 !== t3);
            i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - n3, n3)), i2.gzindex = 0;
          }
          i2.status = 91;
        }
        if (91 === i2.status) {
          if (i2.gzhead.comment) {
            let t3, n3 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - n3, n3)), fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
                n3 = 0;
              }
              t3 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, gY(i2, t3);
            } while (0 !== t3);
            i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = NK(e2.adler, i2.pending_buf, i2.pending - n3, n3));
          }
          i2.status = 103;
        }
        if (103 === i2.status) {
          if (i2.gzhead.hcrc) {
            if (i2.pending + 2 > i2.pending_buf_size && (fY(e2), 0 !== i2.pending)) return i2.last_flush = -1, WK;
            gY(i2, 255 & e2.adler), gY(i2, e2.adler >> 8 & 255), e2.adler = 0;
          }
          if (i2.status = lY, fY(e2), 0 !== i2.pending) return i2.last_flush = -1, WK;
        }
        if (0 !== e2.avail_in || 0 !== i2.lookahead || t2 !== xK && i2.status !== uY) {
          let n3 = 0 === i2.level ? yY(i2, t2) : i2.strategy === JK ? ((e3, t3) => {
            let i3;
            for (; ; ) {
              if (0 === e3.lookahead && (vY(e3), 0 === e3.lookahead)) {
                if (t3 === xK) return 1;
                break;
              }
              if (e3.match_length = 0, i3 = UK(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, i3 && (SY(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t3 === jK ? (SY(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (SY(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t2) : i2.strategy === QK ? ((e3, t3) => {
            let i3, n4, r2, o2;
            const s2 = e3.window;
            for (; ; ) {
              if (e3.lookahead <= aY) {
                if (vY(e3), e3.lookahead <= aY && t3 === xK) return 1;
                if (0 === e3.lookahead) break;
              }
              if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (r2 = e3.strstart - 1, n4 = s2[r2], n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2])) {
                o2 = e3.strstart + aY;
                do {
                } while (n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && n4 === s2[++r2] && r2 < o2);
                e3.match_length = aY - (o2 - r2), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= 3 ? (i3 = UK(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (i3 = UK(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), i3 && (SY(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t3 === jK ? (SY(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (SY(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t2) : wY[i2.level].func(i2, t2);
          if (3 !== n3 && 4 !== n3 || (i2.status = uY), 1 === n3 || 3 === n3) return 0 === e2.avail_out && (i2.last_flush = -1), WK;
          if (2 === n3 && (t2 === FK ? VK(i2) : t2 !== GK && (kK(i2, 0, 0, false), t2 === BK && (_Y(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), fY(e2), 0 === e2.avail_out)) return i2.last_flush = -1, WK;
        }
        return t2 !== jK ? WK : i2.wrap <= 0 ? HK : (2 === i2.wrap ? (gY(i2, 255 & e2.adler), gY(i2, e2.adler >> 8 & 255), gY(i2, e2.adler >> 16 & 255), gY(i2, e2.adler >> 24 & 255), gY(i2, 255 & e2.total_in), gY(i2, e2.total_in >> 8 & 255), gY(i2, e2.total_in >> 16 & 255), gY(i2, e2.total_in >> 24 & 255)) : (TY(i2, e2.adler >>> 16), TY(i2, 65535 & e2.adler)), fY(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? WK : HK);
      }, MY = (e2, t2) => {
        let i2 = t2.length;
        if (NY(e2)) return KK;
        const n2 = e2.state, r2 = n2.wrap;
        if (2 === r2 || 1 === r2 && n2.status !== dY || n2.lookahead) return KK;
        if (1 === r2 && (e2.adler = wK(e2.adler, t2, i2, 0)), n2.wrap = 0, i2 >= n2.w_size) {
          0 === r2 && (_Y(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
          let e3 = new Uint8Array(n2.w_size);
          e3.set(t2.subarray(i2 - n2.w_size, i2), 0), t2 = e3, i2 = n2.w_size;
        }
        const o2 = e2.avail_in, s2 = e2.next_in, a2 = e2.input;
        for (e2.avail_in = i2, e2.next_in = 0, e2.input = t2, vY(n2); n2.lookahead >= 3; ) {
          let e3 = n2.strstart, t3 = n2.lookahead - 2;
          do {
            n2.ins_h = mY(n2, n2.ins_h, n2.window[e3 + 3 - 1]), n2.prev[e3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = e3, e3++;
          } while (--t3);
          n2.strstart = e3, n2.lookahead = 2, vY(n2);
        }
        return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, e2.next_in = s2, e2.input = a2, e2.avail_in = o2, n2.wrap = r2, WK;
      }, UY = { deflateInit: (e2, t2) => LY(e2, t2, tY, 15, 8, $K), deflateInit2: LY, deflateReset: PY, deflateResetKeep: DY, deflateSetHeader: (e2, t2) => NY(e2) || 2 !== e2.state.wrap ? KK : (e2.state.gzhead = t2, WK), deflate: kY, deflateEnd: (e2) => {
        if (NY(e2)) return KK;
        const t2 = e2.state.status;
        return e2.state = null, t2 === lY ? hY(e2, YK) : WK;
      }, deflateSetDictionary: MY, deflateInfo: "pako deflate (from Nodeca project)" };
      const VY = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      var xY = { assign: function(e2) {
        const t2 = Array.prototype.slice.call(arguments, 1);
        for (; t2.length; ) {
          const i2 = t2.shift();
          if (i2) {
            if ("object" != typeof i2) throw new TypeError(i2 + "must be non-object");
            for (const t3 in i2) VY(i2, t3) && (e2[t3] = i2[t3]);
          }
        }
        return e2;
      }, flattenChunks: (e2) => {
        let t2 = 0;
        for (let i3 = 0, n2 = e2.length; i3 < n2; i3++) t2 += e2[i3].length;
        const i2 = new Uint8Array(t2);
        for (let t3 = 0, n2 = 0, r2 = e2.length; t3 < r2; t3++) {
          let r3 = e2[t3];
          i2.set(r3, n2), n2 += r3.length;
        }
        return i2;
      } };
      let FY = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        FY = false;
      }
      const BY = new Uint8Array(256);
      for (let e2 = 0; e2 < 256; e2++) BY[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
      BY[254] = BY[254] = 1;
      var jY = { string2buf: (e2) => {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e2);
        let t2, i2, n2, r2, o2, s2 = e2.length, a2 = 0;
        for (r2 = 0; r2 < s2; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), a2 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
        for (t2 = new Uint8Array(a2), o2 = 0, r2 = 0; o2 < a2; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), i2 < 128 ? t2[o2++] = i2 : i2 < 2048 ? (t2[o2++] = 192 | i2 >>> 6, t2[o2++] = 128 | 63 & i2) : i2 < 65536 ? (t2[o2++] = 224 | i2 >>> 12, t2[o2++] = 128 | i2 >>> 6 & 63, t2[o2++] = 128 | 63 & i2) : (t2[o2++] = 240 | i2 >>> 18, t2[o2++] = 128 | i2 >>> 12 & 63, t2[o2++] = 128 | i2 >>> 6 & 63, t2[o2++] = 128 | 63 & i2);
        return t2;
      }, buf2string: (e2, t2) => {
        const i2 = t2 || e2.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e2.subarray(0, t2));
        let n2, r2;
        const o2 = new Array(2 * i2);
        for (r2 = 0, n2 = 0; n2 < i2; ) {
          let t3 = e2[n2++];
          if (t3 < 128) {
            o2[r2++] = t3;
            continue;
          }
          let s2 = BY[t3];
          if (s2 > 4) o2[r2++] = 65533, n2 += s2 - 1;
          else {
            for (t3 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; s2 > 1 && n2 < i2; ) t3 = t3 << 6 | 63 & e2[n2++], s2--;
            s2 > 1 ? o2[r2++] = 65533 : t3 < 65536 ? o2[r2++] = t3 : (t3 -= 65536, o2[r2++] = 55296 | t3 >> 10 & 1023, o2[r2++] = 56320 | 1023 & t3);
          }
        }
        return ((e3, t3) => {
          if (t3 < 65534 && e3.subarray && FY) return String.fromCharCode.apply(null, e3.length === t3 ? e3 : e3.subarray(0, t3));
          let i3 = "";
          for (let n3 = 0; n3 < t3; n3++) i3 += String.fromCharCode(e3[n3]);
          return i3;
        })(o2, r2);
      }, utf8border: (e2, t2) => {
        (t2 = t2 || e2.length) > e2.length && (t2 = e2.length);
        let i2 = t2 - 1;
        for (; i2 >= 0 && 128 == (192 & e2[i2]); ) i2--;
        return i2 < 0 || 0 === i2 ? t2 : i2 + BY[e2[i2]] > t2 ? i2 : t2;
      } };
      var GY = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
      const WY = Object.prototype.toString, { Z_NO_FLUSH: HY, Z_SYNC_FLUSH: KY, Z_FULL_FLUSH: YY, Z_FINISH: zY, Z_OK: qY, Z_STREAM_END: XY, Z_DEFAULT_COMPRESSION: JY, Z_DEFAULT_STRATEGY: QY, Z_DEFLATED: ZY } = PK;
      function $Y(e2) {
        this.options = xY.assign({ level: JY, method: ZY, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: QY }, e2 || {});
        let t2 = this.options;
        t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new GY(), this.strm.avail_out = 0;
        let i2 = UY.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (i2 !== qY) throw new Error(DK[i2]);
        if (t2.header && UY.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          let e3;
          if (e3 = "string" == typeof t2.dictionary ? jY.string2buf(t2.dictionary) : "[object ArrayBuffer]" === WY.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, i2 = UY.deflateSetDictionary(this.strm, e3), i2 !== qY) throw new Error(DK[i2]);
          this._dict_set = true;
        }
      }
      function ez(e2, t2) {
        const i2 = new $Y(t2);
        if (i2.push(e2, true), i2.err) throw i2.msg || DK[i2.err];
        return i2.result;
      }
      $Y.prototype.push = function(e2, t2) {
        const i2 = this.strm, n2 = this.options.chunkSize;
        let r2, o2;
        if (this.ended) return false;
        for (o2 = t2 === ~~t2 ? t2 : true === t2 ? zY : HY, "string" == typeof e2 ? i2.input = jY.string2buf(e2) : "[object ArrayBuffer]" === WY.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) if (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), (o2 === KY || o2 === YY) && i2.avail_out <= 6) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
        else {
          if (r2 = UY.deflate(i2, o2), r2 === XY) return i2.next_out > 0 && this.onData(i2.output.subarray(0, i2.next_out)), r2 = UY.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === qY;
          if (0 !== i2.avail_out) {
            if (o2 > 0 && i2.next_out > 0) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
            else if (0 === i2.avail_in) break;
          } else this.onData(i2.output);
        }
        return true;
      }, $Y.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, $Y.prototype.onEnd = function(e2) {
        e2 === qY && (this.result = xY.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var tz = { Deflate: $Y, deflate: ez, deflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, ez(e2, t2);
      }, gzip: function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, ez(e2, t2);
      }, constants: PK };
      const iz = 16209;
      var nz = function(e2, t2) {
        let i2, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p2, _2, E2, m2, f2, S2, g2, T2, R2, C2, v2, y2, I2;
        const A2 = e2.state;
        i2 = e2.next_in, y2 = e2.input, n2 = i2 + (e2.avail_in - 5), r2 = e2.next_out, I2 = e2.output, o2 = r2 - (t2 - e2.avail_out), s2 = r2 + (e2.avail_out - 257), a2 = A2.dmax, c2 = A2.wsize, d2 = A2.whave, l2 = A2.wnext, u2 = A2.window, h2 = A2.hold, p2 = A2.bits, _2 = A2.lencode, E2 = A2.distcode, m2 = (1 << A2.lenbits) - 1, f2 = (1 << A2.distbits) - 1;
        e: do {
          p2 < 15 && (h2 += y2[i2++] << p2, p2 += 8, h2 += y2[i2++] << p2, p2 += 8), S2 = _2[h2 & m2];
          t: for (; ; ) {
            if (g2 = S2 >>> 24, h2 >>>= g2, p2 -= g2, g2 = S2 >>> 16 & 255, 0 === g2) I2[r2++] = 65535 & S2;
            else {
              if (!(16 & g2)) {
                if (0 == (64 & g2)) {
                  S2 = _2[(65535 & S2) + (h2 & (1 << g2) - 1)];
                  continue t;
                }
                if (32 & g2) {
                  A2.mode = 16191;
                  break e;
                }
                e2.msg = "invalid literal/length code", A2.mode = iz;
                break e;
              }
              T2 = 65535 & S2, g2 &= 15, g2 && (p2 < g2 && (h2 += y2[i2++] << p2, p2 += 8), T2 += h2 & (1 << g2) - 1, h2 >>>= g2, p2 -= g2), p2 < 15 && (h2 += y2[i2++] << p2, p2 += 8, h2 += y2[i2++] << p2, p2 += 8), S2 = E2[h2 & f2];
              i: for (; ; ) {
                if (g2 = S2 >>> 24, h2 >>>= g2, p2 -= g2, g2 = S2 >>> 16 & 255, !(16 & g2)) {
                  if (0 == (64 & g2)) {
                    S2 = E2[(65535 & S2) + (h2 & (1 << g2) - 1)];
                    continue i;
                  }
                  e2.msg = "invalid distance code", A2.mode = iz;
                  break e;
                }
                if (R2 = 65535 & S2, g2 &= 15, p2 < g2 && (h2 += y2[i2++] << p2, p2 += 8, p2 < g2 && (h2 += y2[i2++] << p2, p2 += 8)), R2 += h2 & (1 << g2) - 1, R2 > a2) {
                  e2.msg = "invalid distance too far back", A2.mode = iz;
                  break e;
                }
                if (h2 >>>= g2, p2 -= g2, g2 = r2 - o2, R2 > g2) {
                  if (g2 = R2 - g2, g2 > d2 && A2.sane) {
                    e2.msg = "invalid distance too far back", A2.mode = iz;
                    break e;
                  }
                  if (C2 = 0, v2 = u2, 0 === l2) {
                    if (C2 += c2 - g2, g2 < T2) {
                      T2 -= g2;
                      do {
                        I2[r2++] = u2[C2++];
                      } while (--g2);
                      C2 = r2 - R2, v2 = I2;
                    }
                  } else if (l2 < g2) {
                    if (C2 += c2 + l2 - g2, g2 -= l2, g2 < T2) {
                      T2 -= g2;
                      do {
                        I2[r2++] = u2[C2++];
                      } while (--g2);
                      if (C2 = 0, l2 < T2) {
                        g2 = l2, T2 -= g2;
                        do {
                          I2[r2++] = u2[C2++];
                        } while (--g2);
                        C2 = r2 - R2, v2 = I2;
                      }
                    }
                  } else if (C2 += l2 - g2, g2 < T2) {
                    T2 -= g2;
                    do {
                      I2[r2++] = u2[C2++];
                    } while (--g2);
                    C2 = r2 - R2, v2 = I2;
                  }
                  for (; T2 > 2; ) I2[r2++] = v2[C2++], I2[r2++] = v2[C2++], I2[r2++] = v2[C2++], T2 -= 3;
                  T2 && (I2[r2++] = v2[C2++], T2 > 1 && (I2[r2++] = v2[C2++]));
                } else {
                  C2 = r2 - R2;
                  do {
                    I2[r2++] = I2[C2++], I2[r2++] = I2[C2++], I2[r2++] = I2[C2++], T2 -= 3;
                  } while (T2 > 2);
                  T2 && (I2[r2++] = I2[C2++], T2 > 1 && (I2[r2++] = I2[C2++]));
                }
                break;
              }
            }
            break;
          }
        } while (i2 < n2 && r2 < s2);
        T2 = p2 >> 3, i2 -= T2, p2 -= T2 << 3, h2 &= (1 << p2) - 1, e2.next_in = i2, e2.next_out = r2, e2.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), e2.avail_out = r2 < s2 ? s2 - r2 + 257 : 257 - (r2 - s2), A2.hold = h2, A2.bits = p2;
      };
      const rz = 15, oz = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), sz = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), az = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), cz = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var dz = (e2, t2, i2, n2, r2, o2, s2, a2) => {
        const c2 = a2.bits;
        let d2, l2, u2, h2, p2, _2, E2 = 0, m2 = 0, f2 = 0, S2 = 0, g2 = 0, T2 = 0, R2 = 0, C2 = 0, v2 = 0, y2 = 0, I2 = null;
        const A2 = new Uint16Array(16), b2 = new Uint16Array(16);
        let w2, O2, N2, D2 = null;
        for (E2 = 0; E2 <= rz; E2++) A2[E2] = 0;
        for (m2 = 0; m2 < n2; m2++) A2[t2[i2 + m2]]++;
        for (g2 = c2, S2 = rz; S2 >= 1 && 0 === A2[S2]; S2--) ;
        if (g2 > S2 && (g2 = S2), 0 === S2) return r2[o2++] = 20971520, r2[o2++] = 20971520, a2.bits = 1, 0;
        for (f2 = 1; f2 < S2 && 0 === A2[f2]; f2++) ;
        for (g2 < f2 && (g2 = f2), C2 = 1, E2 = 1; E2 <= rz; E2++) if (C2 <<= 1, C2 -= A2[E2], C2 < 0) return -1;
        if (C2 > 0 && (0 === e2 || 1 !== S2)) return -1;
        for (b2[1] = 0, E2 = 1; E2 < rz; E2++) b2[E2 + 1] = b2[E2] + A2[E2];
        for (m2 = 0; m2 < n2; m2++) 0 !== t2[i2 + m2] && (s2[b2[t2[i2 + m2]]++] = m2);
        if (0 === e2 ? (I2 = D2 = s2, _2 = 20) : 1 === e2 ? (I2 = oz, D2 = sz, _2 = 257) : (I2 = az, D2 = cz, _2 = 0), y2 = 0, m2 = 0, E2 = f2, p2 = o2, T2 = g2, R2 = 0, u2 = -1, v2 = 1 << g2, h2 = v2 - 1, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592) return 1;
        for (; ; ) {
          w2 = E2 - R2, s2[m2] + 1 < _2 ? (O2 = 0, N2 = s2[m2]) : s2[m2] >= _2 ? (O2 = D2[s2[m2] - _2], N2 = I2[s2[m2] - _2]) : (O2 = 96, N2 = 0), d2 = 1 << E2 - R2, l2 = 1 << T2, f2 = l2;
          do {
            l2 -= d2, r2[p2 + (y2 >> R2) + l2] = w2 << 24 | O2 << 16 | N2 | 0;
          } while (0 !== l2);
          for (d2 = 1 << E2 - 1; y2 & d2; ) d2 >>= 1;
          if (0 !== d2 ? (y2 &= d2 - 1, y2 += d2) : y2 = 0, m2++, 0 == --A2[E2]) {
            if (E2 === S2) break;
            E2 = t2[i2 + s2[m2]];
          }
          if (E2 > g2 && (y2 & h2) !== u2) {
            for (0 === R2 && (R2 = g2), p2 += f2, T2 = E2 - R2, C2 = 1 << T2; T2 + R2 < S2 && (C2 -= A2[T2 + R2], !(C2 <= 0)); ) T2++, C2 <<= 1;
            if (v2 += 1 << T2, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592) return 1;
            u2 = y2 & h2, r2[u2] = g2 << 24 | T2 << 16 | p2 - o2 | 0;
          }
        }
        return 0 !== y2 && (r2[p2 + y2] = E2 - R2 << 24 | 64 << 16 | 0), a2.bits = g2, 0;
      };
      const { Z_FINISH: lz, Z_BLOCK: uz, Z_TREES: hz, Z_OK: pz, Z_STREAM_END: _z, Z_NEED_DICT: Ez, Z_STREAM_ERROR: mz, Z_DATA_ERROR: fz, Z_MEM_ERROR: Sz, Z_BUF_ERROR: gz, Z_DEFLATED: Tz } = PK, Rz = 16180, Cz = 16190, vz = 16191, yz = 16192, Iz = 16194, Az = 16199, bz = 16200, wz = 16206, Oz = 16209, Nz = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      function Dz() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const Pz = (e2) => {
        if (!e2) return 1;
        const t2 = e2.state;
        return !t2 || t2.strm !== e2 || t2.mode < Rz || t2.mode > 16211 ? 1 : 0;
      }, Lz = (e2) => {
        if (Pz(e2)) return mz;
        const t2 = e2.state;
        return e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = Rz, t2.last = 0, t2.havedict = 0, t2.flags = -1, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, pz;
      }, kz = (e2) => {
        if (Pz(e2)) return mz;
        const t2 = e2.state;
        return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, Lz(e2);
      }, Mz = (e2, t2) => {
        let i2;
        if (Pz(e2)) return mz;
        const n2 = e2.state;
        return t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 5 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? mz : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i2, n2.wbits = t2, kz(e2));
      }, Uz = (e2, t2) => {
        if (!e2) return mz;
        const i2 = new Dz();
        e2.state = i2, i2.strm = e2, i2.window = null, i2.mode = Rz;
        const n2 = Mz(e2, t2);
        return n2 !== pz && (e2.state = null), n2;
      };
      let Vz, xz, Fz = true;
      const Bz = (e2) => {
        if (Fz) {
          Vz = new Int32Array(512), xz = new Int32Array(32);
          let t2 = 0;
          for (; t2 < 144; ) e2.lens[t2++] = 8;
          for (; t2 < 256; ) e2.lens[t2++] = 9;
          for (; t2 < 280; ) e2.lens[t2++] = 7;
          for (; t2 < 288; ) e2.lens[t2++] = 8;
          for (dz(1, e2.lens, 0, 288, Vz, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
          dz(2, e2.lens, 0, 32, xz, 0, e2.work, { bits: 5 }), Fz = false;
        }
        e2.lencode = Vz, e2.lenbits = 9, e2.distcode = xz, e2.distbits = 5;
      }, jz = (e2, t2, i2, n2) => {
        let r2;
        const o2 = e2.state;
        return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new Uint8Array(o2.wsize)), n2 >= o2.wsize ? (o2.window.set(t2.subarray(i2 - o2.wsize, i2), 0), o2.wnext = 0, o2.whave = o2.wsize) : (r2 = o2.wsize - o2.wnext, r2 > n2 && (r2 = n2), o2.window.set(t2.subarray(i2 - n2, i2 - n2 + r2), o2.wnext), (n2 -= r2) ? (o2.window.set(t2.subarray(i2 - n2, i2), 0), o2.wnext = n2, o2.whave = o2.wsize) : (o2.wnext += r2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += r2))), 0;
      };
      var Gz = (e2, t2) => {
        let i2, n2, r2, o2, s2, a2, c2, d2, l2, u2, h2, p2, _2, E2, m2, f2, S2, g2, T2, R2, C2, v2, y2 = 0;
        const I2 = new Uint8Array(4);
        let A2, b2;
        const w2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (Pz(e2) || !e2.output || !e2.input && 0 !== e2.avail_in) return mz;
        i2 = e2.state, i2.mode === vz && (i2.mode = yz), s2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, o2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, u2 = a2, h2 = c2, v2 = pz;
        e: for (; ; ) switch (i2.mode) {
          case Rz:
            if (0 === i2.wrap) {
              i2.mode = yz;
              break;
            }
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (2 & i2.wrap && 35615 === d2) {
              0 === i2.wbits && (i2.wbits = 15), i2.check = 0, I2[0] = 255 & d2, I2[1] = d2 >>> 8 & 255, i2.check = NK(i2.check, I2, 2, 0), d2 = 0, l2 = 0, i2.mode = 16181;
              break;
            }
            if (i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
              e2.msg = "incorrect header check", i2.mode = Oz;
              break;
            }
            if ((15 & d2) !== Tz) {
              e2.msg = "unknown compression method", i2.mode = Oz;
              break;
            }
            if (d2 >>>= 4, l2 -= 4, C2 = 8 + (15 & d2), 0 === i2.wbits && (i2.wbits = C2), C2 > 15 || C2 > i2.wbits) {
              e2.msg = "invalid window size", i2.mode = Oz;
              break;
            }
            i2.dmax = 1 << i2.wbits, i2.flags = 0, e2.adler = i2.check = 1, i2.mode = 512 & d2 ? 16189 : vz, d2 = 0, l2 = 0;
            break;
          case 16181:
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (i2.flags = d2, (255 & BH(i2)) !== Tz) {
              e2.msg = "unknown compression method", i2.mode = Oz;
              break;
            }
            if (57344 & BH(i2)) {
              e2.msg = "unknown header flags set", i2.mode = Oz;
              break;
            }
            i2.head && (i2.head.text = d2 >> 8 & 1), 512 & BH(i2) && 4 & i2.wrap && (I2[0] = 255 & d2, I2[1] = d2 >>> 8 & 255, i2.check = NK(i2.check, I2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16182;
          case 16182:
            for (; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.time = d2), 512 & BH(i2) && 4 & i2.wrap && (I2[0] = 255 & d2, I2[1] = d2 >>> 8 & 255, I2[2] = d2 >>> 16 & 255, I2[3] = d2 >>> 24 & 255, i2.check = NK(i2.check, I2, 4, 0)), d2 = 0, l2 = 0, i2.mode = 16183;
          case 16183:
            for (; l2 < 16; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.xflags = 255 & d2, i2.head.os = d2 >> 8), 512 & BH(i2) && 4 & i2.wrap && (I2[0] = 255 & d2, I2[1] = d2 >>> 8 & 255, i2.check = NK(i2.check, I2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16184;
          case 16184:
            if (1024 & BH(i2)) {
              for (; l2 < 16; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              i2.length = d2, i2.head && (i2.head.extra_len = d2), 512 & BH(i2) && 4 & i2.wrap && (I2[0] = 255 & d2, I2[1] = d2 >>> 8 & 255, i2.check = NK(i2.check, I2, 2, 0)), d2 = 0, l2 = 0;
            } else i2.head && (i2.head.extra = null);
            i2.mode = 16185;
          case 16185:
            if (1024 & BH(i2) && (p2 = i2.length, p2 > a2 && (p2 = a2), p2 && (i2.head && (C2 = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Uint8Array(i2.head.extra_len)), i2.head.extra.set(n2.subarray(o2, o2 + p2), C2)), 512 & BH(i2) && 4 & i2.wrap && (i2.check = NK(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, i2.length -= p2), i2.length)) break e;
            i2.length = 0, i2.mode = 16186;
          case 16186:
            if (2048 & BH(i2)) {
              if (0 === a2) break e;
              p2 = 0;
              do {
                C2 = n2[o2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.name += String.fromCharCode(C2));
              } while (C2 && p2 < a2);
              if (512 & BH(i2) && 4 & i2.wrap && (i2.check = NK(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, C2) break e;
            } else i2.head && (i2.head.name = null);
            i2.length = 0, i2.mode = 16187;
          case 16187:
            if (4096 & BH(i2)) {
              if (0 === a2) break e;
              p2 = 0;
              do {
                C2 = n2[o2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.comment += String.fromCharCode(C2));
              } while (C2 && p2 < a2);
              if (512 & BH(i2) && 4 & i2.wrap && (i2.check = NK(i2.check, n2, p2, o2)), a2 -= p2, o2 += p2, C2) break e;
            } else i2.head && (i2.head.comment = null);
            i2.mode = 16188;
          case 16188:
            if (512 & BH(i2)) {
              for (; l2 < 16; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (65535 & i2.check)) {
                e2.msg = "header crc mismatch", i2.mode = Oz;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.head && (i2.head.hcrc = BH(i2) >> 9 & 1, i2.head.done = true), e2.adler = i2.check = 0, i2.mode = vz;
            break;
          case 16189:
            for (; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            e2.adler = i2.check = Nz(d2), d2 = 0, l2 = 0, i2.mode = Cz;
          case Cz:
            if (0 === i2.havedict) return e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, Ez;
            e2.adler = i2.check = 1, i2.mode = vz;
          case vz:
            if (t2 === uz || t2 === hz) break e;
          case yz:
            if (i2.last) {
              d2 >>>= 7 & l2, l2 -= 7 & l2, i2.mode = wz;
              break;
            }
            for (; l2 < 3; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            switch (i2.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
              case 0:
                i2.mode = 16193;
                break;
              case 1:
                if (Bz(i2), i2.mode = Az, t2 === hz) {
                  d2 >>>= 2, l2 -= 2;
                  break e;
                }
                break;
              case 2:
                i2.mode = 16196;
                break;
              case 3:
                e2.msg = "invalid block type", i2.mode = Oz;
            }
            d2 >>>= 2, l2 -= 2;
            break;
          case 16193:
            for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
              e2.msg = "invalid stored block lengths", i2.mode = Oz;
              break;
            }
            if (i2.length = 65535 & d2, d2 = 0, l2 = 0, i2.mode = Iz, t2 === hz) break e;
          case Iz:
            i2.mode = 16195;
          case 16195:
            if (p2 = i2.length, p2) {
              if (p2 > a2 && (p2 = a2), p2 > c2 && (p2 = c2), 0 === p2) break e;
              r2.set(n2.subarray(o2, o2 + p2), s2), a2 -= p2, o2 += p2, c2 -= p2, s2 += p2, i2.length -= p2;
              break;
            }
            i2.mode = vz;
            break;
          case 16196:
            for (; l2 < 14; ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (i2.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
              e2.msg = "too many length or distance symbols", i2.mode = Oz;
              break;
            }
            i2.have = 0, i2.mode = 16197;
          case 16197:
            for (; i2.have < i2.ncode; ) {
              for (; l2 < 3; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              i2.lens[w2[i2.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
            }
            for (; i2.have < 19; ) i2.lens[w2[i2.have++]] = 0;
            if (i2.lencode = i2.lendyn, i2.lenbits = 7, A2 = { bits: i2.lenbits }, v2 = dz(0, i2.lens, 0, 19, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, v2) {
              e2.msg = "invalid code lengths set", i2.mode = Oz;
              break;
            }
            i2.have = 0, i2.mode = 16198;
          case 16198:
            for (; i2.have < i2.nlen + i2.ndist; ) {
              for (; y2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = y2 >>> 24, f2 = y2 >>> 16 & 255, S2 = 65535 & y2, !(m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              if (S2 < 16) d2 >>>= m2, l2 -= m2, i2.lens[i2.have++] = S2;
              else {
                if (16 === S2) {
                  for (b2 = m2 + 2; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  if (d2 >>>= m2, l2 -= m2, 0 === i2.have) {
                    e2.msg = "invalid bit length repeat", i2.mode = Oz;
                    break;
                  }
                  C2 = i2.lens[i2.have - 1], p2 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
                } else if (17 === S2) {
                  for (b2 = m2 + 3; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
                } else {
                  for (b2 = m2 + 7; l2 < b2; ) {
                    if (0 === a2) break e;
                    a2--, d2 += n2[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
                }
                if (i2.have + p2 > i2.nlen + i2.ndist) {
                  e2.msg = "invalid bit length repeat", i2.mode = Oz;
                  break;
                }
                for (; p2--; ) i2.lens[i2.have++] = C2;
              }
            }
            if (i2.mode === Oz) break;
            if (0 === i2.lens[256]) {
              e2.msg = "invalid code -- missing end-of-block", i2.mode = Oz;
              break;
            }
            if (i2.lenbits = 9, A2 = { bits: i2.lenbits }, v2 = dz(1, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, v2) {
              e2.msg = "invalid literal/lengths set", i2.mode = Oz;
              break;
            }
            if (i2.distbits = 6, i2.distcode = i2.distdyn, A2 = { bits: i2.distbits }, v2 = dz(2, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, A2), i2.distbits = A2.bits, v2) {
              e2.msg = "invalid distances set", i2.mode = Oz;
              break;
            }
            if (i2.mode = Az, t2 === hz) break e;
          case Az:
            i2.mode = bz;
          case bz:
            if (a2 >= 6 && c2 >= 258) {
              e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, nz(e2, h2), s2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, o2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, i2.mode === vz && (i2.back = -1);
              break;
            }
            for (i2.back = 0; y2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = y2 >>> 24, f2 = y2 >>> 16 & 255, S2 = 65535 & y2, !(m2 <= l2); ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (f2 && 0 == (240 & f2)) {
              for (g2 = m2, T2 = f2, R2 = S2; y2 = i2.lencode[R2 + ((d2 & (1 << g2 + T2) - 1) >> g2)], m2 = y2 >>> 24, f2 = y2 >>> 16 & 255, S2 = 65535 & y2, !(g2 + m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              d2 >>>= g2, l2 -= g2, i2.back += g2;
            }
            if (d2 >>>= m2, l2 -= m2, i2.back += m2, i2.length = S2, 0 === f2) {
              i2.mode = 16205;
              break;
            }
            if (32 & f2) {
              i2.back = -1, i2.mode = vz;
              break;
            }
            if (64 & f2) {
              e2.msg = "invalid literal/length code", i2.mode = Oz;
              break;
            }
            i2.extra = 15 & f2, i2.mode = 16201;
          case 16201:
            if (i2.extra) {
              for (b2 = i2.extra; l2 < b2; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              i2.length += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            i2.was = i2.length, i2.mode = 16202;
          case 16202:
            for (; y2 = i2.distcode[d2 & (1 << i2.distbits) - 1], m2 = y2 >>> 24, f2 = y2 >>> 16 & 255, S2 = 65535 & y2, !(m2 <= l2); ) {
              if (0 === a2) break e;
              a2--, d2 += n2[o2++] << l2, l2 += 8;
            }
            if (0 == (240 & f2)) {
              for (g2 = m2, T2 = f2, R2 = S2; y2 = i2.distcode[R2 + ((d2 & (1 << g2 + T2) - 1) >> g2)], m2 = y2 >>> 24, f2 = y2 >>> 16 & 255, S2 = 65535 & y2, !(g2 + m2 <= l2); ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              d2 >>>= g2, l2 -= g2, i2.back += g2;
            }
            if (d2 >>>= m2, l2 -= m2, i2.back += m2, 64 & f2) {
              e2.msg = "invalid distance code", i2.mode = Oz;
              break;
            }
            i2.offset = S2, i2.extra = 15 & f2, i2.mode = 16203;
          case 16203:
            if (i2.extra) {
              for (b2 = i2.extra; l2 < b2; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              i2.offset += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            if (i2.offset > i2.dmax) {
              e2.msg = "invalid distance too far back", i2.mode = Oz;
              break;
            }
            i2.mode = 16204;
          case 16204:
            if (0 === c2) break e;
            if (p2 = h2 - c2, i2.offset > p2) {
              if (p2 = i2.offset - p2, p2 > i2.whave && i2.sane) {
                e2.msg = "invalid distance too far back", i2.mode = Oz;
                break;
              }
              p2 > i2.wnext ? (p2 -= i2.wnext, _2 = i2.wsize - p2) : _2 = i2.wnext - p2, p2 > i2.length && (p2 = i2.length), E2 = i2.window;
            } else E2 = r2, _2 = s2 - i2.offset, p2 = i2.length;
            p2 > c2 && (p2 = c2), c2 -= p2, i2.length -= p2;
            do {
              r2[s2++] = E2[_2++];
            } while (--p2);
            0 === i2.length && (i2.mode = bz);
            break;
          case 16205:
            if (0 === c2) break e;
            r2[s2++] = i2.length, c2--, i2.mode = bz;
            break;
          case wz:
            if (i2.wrap) {
              for (; l2 < 32; ) {
                if (0 === a2) break e;
                a2--, d2 |= n2[o2++] << l2, l2 += 8;
              }
              if (h2 -= c2, e2.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e2.adler = i2.check = BH(i2) ? NK(i2.check, r2, h2, s2 - h2) : wK(i2.check, r2, h2, s2 - h2)), h2 = c2, 4 & i2.wrap && (BH(i2) ? d2 : Nz(d2)) !== i2.check) {
                e2.msg = "incorrect data check", i2.mode = Oz;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16207;
          case 16207:
            if (i2.wrap && BH(i2)) {
              for (; l2 < 32; ) {
                if (0 === a2) break e;
                a2--, d2 += n2[o2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (4294967295 & i2.total)) {
                e2.msg = "incorrect length check", i2.mode = Oz;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16208;
          case 16208:
            v2 = _z;
            break e;
          case Oz:
            v2 = fz;
            break e;
          case 16210:
            return Sz;
          default:
            return mz;
        }
        return e2.next_out = s2, e2.avail_out = c2, e2.next_in = o2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, (i2.wsize || h2 !== e2.avail_out && i2.mode < Oz && (i2.mode < wz || t2 !== lz)) && jz(e2, e2.output, e2.next_out, h2 - e2.avail_out), u2 -= e2.avail_in, h2 -= e2.avail_out, e2.total_in += u2, e2.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e2.adler = i2.check = BH(i2) ? NK(i2.check, r2, h2, e2.next_out - h2) : wK(i2.check, r2, h2, e2.next_out - h2)), e2.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === vz ? 128 : 0) + (i2.mode === Az || i2.mode === Iz ? 256 : 0), (0 === u2 && 0 === h2 || t2 === lz) && v2 === pz && (v2 = gz), v2;
      }, Wz = { inflateReset: kz, inflateReset2: Mz, inflateResetKeep: Lz, inflateInit: (e2) => Uz(e2, 15), inflateInit2: Uz, inflate: Gz, inflateEnd: (e2) => {
        if (Pz(e2)) return mz;
        let t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, pz;
      }, inflateGetHeader: (e2, t2) => {
        if (Pz(e2)) return mz;
        const i2 = e2.state;
        return 0 == (2 & i2.wrap) ? mz : (i2.head = t2, t2.done = false, pz);
      }, inflateSetDictionary: (e2, t2) => {
        const i2 = t2.length;
        let n2, r2, o2;
        return Pz(e2) ? mz : (n2 = e2.state, 0 !== n2.wrap && n2.mode !== Cz ? mz : n2.mode === Cz && (r2 = 1, r2 = wK(r2, t2, i2, 0), r2 !== n2.check) ? fz : (o2 = jz(e2, t2, i2, i2), o2 ? (n2.mode = 16210, Sz) : (n2.havedict = 1, pz)));
      }, inflateInfo: "pako inflate (from Nodeca project)" };
      var Hz = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
      const Kz = Object.prototype.toString, { Z_NO_FLUSH: Yz, Z_FINISH: zz, Z_OK: qz, Z_STREAM_END: Xz, Z_NEED_DICT: Jz, Z_STREAM_ERROR: Qz, Z_DATA_ERROR: Zz, Z_MEM_ERROR: $z } = PK;
      function eq(e2) {
        this.options = xY.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
        const t2 = this.options;
        t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new GY(), this.strm.avail_out = 0;
        let i2 = Wz.inflateInit2(this.strm, t2.windowBits);
        if (i2 !== qz) throw new Error(DK[i2]);
        if (this.header = new Hz(), Wz.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = jY.string2buf(t2.dictionary) : "[object ArrayBuffer]" === Kz.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i2 = Wz.inflateSetDictionary(this.strm, t2.dictionary), i2 !== qz))) throw new Error(DK[i2]);
      }
      function tq(e2, t2) {
        const i2 = new eq(t2);
        if (i2.push(e2), i2.err) throw i2.msg || DK[i2.err];
        return i2.result;
      }
      eq.prototype.push = function(e2, t2) {
        const i2 = this.strm, n2 = this.options.chunkSize, r2 = this.options.dictionary;
        let o2, s2, a2;
        if (this.ended) return false;
        for (s2 = t2 === ~~t2 ? t2 : true === t2 ? zz : Yz, "[object ArrayBuffer]" === Kz.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
          for (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), o2 = Wz.inflate(i2, s2), o2 === Jz && r2 && (o2 = Wz.inflateSetDictionary(i2, r2), o2 === qz ? o2 = Wz.inflate(i2, s2) : o2 === Zz && (o2 = Jz)); i2.avail_in > 0 && o2 === Xz && i2.state.wrap > 0 && 0 !== e2[i2.next_in]; ) Wz.inflateReset(i2), o2 = Wz.inflate(i2, s2);
          switch (o2) {
            case Qz:
            case Zz:
            case Jz:
            case $z:
              return this.onEnd(o2), this.ended = true, false;
          }
          if (a2 = i2.avail_out, i2.next_out && (0 === i2.avail_out || o2 === Xz)) if ("string" === this.options.to) {
            let e3 = jY.utf8border(i2.output, i2.next_out), t3 = i2.next_out - e3, r3 = jY.buf2string(i2.output, e3);
            i2.next_out = t3, i2.avail_out = n2 - t3, t3 && i2.output.set(i2.output.subarray(e3, e3 + t3), 0), this.onData(r3);
          } else this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
          if (o2 !== qz || 0 !== a2) {
            if (o2 === Xz) return o2 = Wz.inflateEnd(this.strm), this.onEnd(o2), this.ended = true, true;
            if (0 === i2.avail_in) break;
          }
        }
        return true;
      }, eq.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, eq.prototype.onEnd = function(e2) {
        e2 === qz && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = xY.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var iq = { Inflate: eq, inflate: tq, inflateRaw: function(e2, t2) {
        return (t2 = t2 || {}).raw = true, tq(e2, t2);
      }, ungzip: tq, constants: PK };
      const { Deflate: nq, deflate: rq, deflateRaw: oq, gzip: sq } = tz, { Inflate: aq, inflate: cq, inflateRaw: dq, ungzip: lq } = iq;
      var uq = rq, hq = oq, pq = cq, _q = dq, Eq = (function(e2) {
        return e2[e2.ONE_BYTE = 0] = "ONE_BYTE", e2[e2.TWO_BYTE = 1] = "TWO_BYTE", e2;
      })(Eq || {});
      class mq {
        constructor() {
          iA(this, "_sequence", 0), iA(this, "_startTime", Date.now()), iA(this, "isUseOneByte", true);
        }
        get startTime() {
          const e2 = Date.now() - this._startTime;
          return e2 < Math.pow(2, 16) ? e2 : (this._startTime += Math.pow(2, 16), this.startTime);
        }
        get sequence() {
          return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
        }
        serialize(e2) {
          const t2 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e2 };
          if (e2.byteLength > 128) {
            const i3 = new Uint8Array(4);
            i3.set([1, 0, 0, 0]);
            const n3 = { id: 0, length: 4, data: i3.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n3] };
            t2.commonPacketHeader.extension = 1, t2.extension = r3, t2.payload = this.compress(e2), t2.commonPacketHeader.length = 8 + (t2.extension.length + 2) + t2.payload.byteLength;
          } else t2.commonPacketHeader.length = 8 + t2.payload.byteLength;
          CD("SHOW_DATASTREAM2_LOG") && iP.debug("send data header: ".concat(JSON.stringify(t2.commonPacketHeader)));
          const i2 = new ArrayBuffer(t2.commonPacketHeader.length), n2 = new Uint8Array(i2), r2 = new DataView(i2);
          let o2 = 0;
          if (r2.setUint16(o2, t2.commonPacketHeader.extension << 15 | t2.commonPacketHeader.reserved << 14 | t2.commonPacketHeader.length, true), o2 += 2, r2.setUint32(o2, t2.commonPacketHeader.sequence, true), o2 += 4, r2.setUint16(o2, t2.commonStreamHeader, true), o2 += 2, t2.extension) {
            const e3 = this.serializeExtension(t2.extension);
            n2.set(new Uint8Array(e3), o2), o2 += e3.byteLength;
          }
          if (n2.set(new Uint8Array(t2.payload), o2), o2 += t2.payload.byteLength, o2 !== t2.commonPacketHeader.length) throw Error("serialize error!");
          return i2;
        }
        deserialize(e2) {
          if (e2.byteLength < 4) return new ArrayBuffer(0);
          const t2 = new DataView(e2);
          let i2 = 0;
          const n2 = t2.getUint16(i2, true);
          i2 += 2;
          const r2 = { length: 16383 & n2, reserved: (16384 & n2) >> 14, extension: (32768 & n2) >> 15, sequence: t2.getUint16(i2 + 2, true) << 16 | t2.getUint16(i2, true) };
          let o2, s2;
          if (i2 += 4, CD("SHOW_DATASTREAM2_LOG") && iP.debug("receive data header: ".concat(JSON.stringify(r2))), t2.getUint16(i2, true), i2 += 2, r2.extension) {
            s2 = this.deserializeExtension(e2.slice(i2)), i2 += 2 + s2.length, o2 = e2.slice(i2);
            let t3 = false;
            if (s2.datas.length > 0) {
              const e3 = s2.datas.find(((e4) => 0 === e4.id));
              if (e3) {
                t3 = 1 == (1 & new DataView(e3.data).getUint32(0, true));
              }
            }
            o2 = t3 ? this.decompress(o2) : o2;
          } else o2 = e2.slice(8);
          return o2;
        }
        serializeExtension(e2) {
          const { profile: t2, length: i2, datas: n2 } = e2, r2 = new ArrayBuffer(i2 + 2), o2 = new Uint8Array(r2), s2 = new DataView(r2);
          let a2 = 0;
          if (s2.setUint8(a2++, t2), s2.setUint8(a2++, i2), n2.forEach(((e3) => {
            t2 ? (s2.setUint8(a2++, e3.id), s2.setUint8(a2++, e3.length), o2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength) : (s2.setUint8(a2++, e3.id | e3.length << 4), o2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength);
          })), a2 !== i2 + 2) throw Error("serialize extension error, is ".concat(a2, "!==").concat(i2 + 2));
          return r2;
        }
        deserializeExtension(e2) {
          const t2 = new DataView(e2);
          let i2 = 0;
          const n2 = t2.getUint8(i2);
          i2++;
          const r2 = t2.getUint8(i2);
          i2++;
          const o2 = n2 === Eq.TWO_BYTE, s2 = [], a2 = new DataView(e2, 2);
          let c2 = 0;
          for (; c2 < r2; ) {
            let e3 = 0, t3 = 0, i3 = new ArrayBuffer(0);
            o2 ? (e3 = a2.getUint8(c2), c2++, t3 = a2.getUint8(c2), c2++) : (e3 = 15 & a2.getUint8(c2), t3 = a2.getUint8(c2) >> 4, c2++), t3 > 0 && (i3 = a2.buffer.slice(c2 + 2, c2 + 2 + t3), c2 += i3.byteLength), s2.push({ id: e3, length: t3, data: i3 });
          }
          if (c2 !== r2) throw Error("parse error");
          return { profile: n2, length: r2, datas: s2 };
        }
        decompress(e2) {
          return pq(new Uint8Array(e2));
        }
        compress(e2) {
          return uq(new Uint8Array(e2));
        }
      }
      const fq = { name: "DataStream", create: (e2, t2) => {
        const i2 = t2 ? new iU(e2) : new nU(e2);
        return i2.useDataStream(new mq()), i2;
      } };
      class Sq extends NO {
        constructor(e2, t2, i2) {
          super(), iA(this, "ws", void 0), iA(this, "requestId", 1), iA(this, "heartBeatTimer", void 0), iA(this, "joinInfo", void 0), iA(this, "clientId", void 0), iA(this, "onOpen", (() => {
            this.emit("open"), this.startHeartBeatCheck();
          })), iA(this, "onClose", ((e3) => {
            this.emit("close"), this.dispose();
          })), iA(this, "onMessage", ((e3) => {
            const t3 = JSON.parse(e3.data);
            if (!t3 || "serverResponse" !== t3.command || !t3.requestId) return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
            this.emit("req_".concat(t3.requestId), t3);
          })), this.joinInfo = e2, this.clientId = t2, this.ws = new $x("cross-channel-".concat(this.clientId), i2), this.ws.on(WV.RECONNECTING, (() => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          })), this.ws.on(WV.CONNECTED, this.onOpen), this.ws.on(WV.ON_MESSAGE, this.onMessage), this.ws.on(WV.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
        }
        waitStatus(e2) {
          return new rp(((t2, i2) => {
            const n2 = window.setTimeout((() => {
              i2(new uP(hO.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }), 5e3);
            this.once(e2, ((r2) => {
              window.clearTimeout(n2), r2.state && 0 !== r2.state ? i2(new uP(hO.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
            })), this.once("dispose", (() => {
              window.clearTimeout(n2), i2(new uP(hO.WS_ABORT));
            }));
          }));
        }
        async request(e2) {
          if ("closed" === this.ws.state) throw new uP(hO.WS_DISCONNECT);
          const t2 = () => new rp(((e3, t3) => {
            this.ws.once(WV.CLOSED, (() => t3(new uP(hO.WS_ABORT)))), this.ws.once(WV.CONNECTED, e3);
          }));
          "connected" !== this.ws.state && await t2();
          const i2 = this.sendMessage(e2), n2 = new rp(((e3, t3) => {
            const n3 = () => {
              t3(new uP(hO.WS_ABORT));
            };
            this.ws.once(WV.RECONNECTING, n3), this.ws.once(WV.CLOSED, n3), this.once("req_".concat(i2), e3), fN(3e3).then((() => {
              this.removeAllListeners("req_".concat(i2)), this.ws.off(WV.RECONNECTING, n3), this.ws.off(WV.CLOSED, n3), t3(new uP(hO.TIMEOUT, "cross channel ws request timeout"));
            }));
          })), r2 = await n2;
          if (!r2 || 200 !== r2.code) throw new uP(hO.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
          return r2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(WV.REQUEST_NEW_URLS), this.ws.on(WV.REQUEST_NEW_URLS, ((t2) => {
            t2(e2);
          })), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, this.ws.sendMessage(e2), t2;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval((() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
          }), 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class gq extends NO {
        set state(e2) {
          e2 !== this._state && (e2 !== nx.RELAY_STATE_FAILURE && (this.errorCode = rx.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t2, i2, n2, r2) {
          super(), iA(this, "joinInfo", void 0), iA(this, "sid", void 0), iA(this, "clientId", void 0), iA(this, "cancelToken", Tw.CancelToken.source()), iA(this, "workerToken", void 0), iA(this, "requestId", 0), iA(this, "signal", void 0), iA(this, "prevChannelMediaConfig", void 0), iA(this, "httpRetryConfig", void 0), iA(this, "_resolution", void 0), iA(this, "_state", nx.RELAY_STATE_IDLE), iA(this, "errorCode", rx.RELAY_OK), iA(this, "onStatus", ((e3) => {
            iP.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", ix.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", ix.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = rx.SRC_TOKEN_EXPIRED, this.state = nx.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = rx.DEST_TOKEN_EXPIRED, this.state = nx.RELAY_STATE_FAILURE));
          })), iA(this, "onReconnect", (async () => {
            iP.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", ix.NETWORK_DISCONNECTED), this.state = nx.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(((e3) => {
              this.state !== nx.RELAY_STATE_IDLE && (iP.error("auto restart channel media relay failed", e3.toString()), this.errorCode = rx.SERVER_CONNECTION_LOST, this.state = nx.RELAY_STATE_FAILURE);
            }));
          })), this.joinInfo = e2, this.clientId = t2, this.sid = gN(), this.signal = new Sq(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n2, this._resolution = r2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== nx.RELAY_STATE_IDLE) throw new uP(hO.INVALID_OPERATION);
          this.state = nx.RELAY_STATE_CONNECTING, await this.connect(), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command) throw new uP(hO.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command) throw new uP(hO.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command) throw new uP(hO.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== nx.RELAY_STATE_RUNNING) throw new uP(hO.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async setVideoProfile(e2) {
          if (this._resolution = e2, this.state !== nx.RELAY_STATE_RUNNING) throw new uP(hO.INVALID_OPERATION);
          const t2 = this.genMessage(tx.SetVideoProfile);
          await this.signal.request(t2), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), iP.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = nx.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          iP.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = Tw.CancelToken.source(), this.state = nx.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await qB(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", ix.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t2 = this.genMessage(tx.SetSdkProfile, e2);
          await this.signal.request(t2), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const i2 = this.genMessage(tx.SetSourceChannel, e2);
          await this.signal.request(i2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", ix.PACKET_JOINED_SRC_CHANNEL), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const n2 = this.genMessage(tx.SetSourceUserId, e2);
          await this.signal.request(n2), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const r2 = this.genMessage(tx.SetDestChannel, e2);
          await this.signal.request(r2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", ix.PACKET_JOINED_DEST_CHANNEL), iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const o2 = this.genMessage(tx.StartPacketTransfer, e2);
          await this.signal.request(o2), this.emit("event", ix.PACKET_SENT_TO_DEST_CHANNEL), this.state = nx.RELAY_STATE_RUNNING, iP.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
        }
        async sendUpdateMessage(e2) {
          const t2 = this.genMessage(tx.UpdateDestChannel, e2);
          await this.signal.request(t2), this.emit("event", ix.PACKET_UPDATE_DEST_CHANNEL), iP.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage(tx.StopPacketTransfer);
          await this.signal.request(e2), iP.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t2) {
          const i2 = [], n2 = [], r2 = [];
          this.requestId += 1;
          const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: hD, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.24.2" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
          let s2 = null, a2 = null;
          switch (e2) {
            case tx.SetSdkProfile:
              return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
            case tx.SetSourceChannel:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new uP(hO.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
            case tx.SetSourceUserId:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2) throw new uP(hO.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
            case tx.SetDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2) throw new uP(hO.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach(((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              })), o2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
            case tx.StartPacketTransfer:
              return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
            case tx.Reconnect:
              return o2.clientRequest = { command: "Reconnect" }, o2;
            case tx.StopPacketTransfer:
              return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
            case tx.UpdateDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2) throw new uP(hO.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach(((e3) => {
                i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              })), o2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n2, token: r2 }, o2;
            case tx.SetVideoProfile:
              o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
          }
          return o2;
        }
      }
      const Tq = { name: "ChannelMediaRelay", create: function(e2) {
        return new gq(e2.joinInfo, e2.clientId, e2.websocketRetryConfig || kN, e2.httpRetryConfig || kN, e2.resolution);
      } };
      function Rq(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Cq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? Rq(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Rq(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class vq extends NO {
        constructor(e2, t2, i2, n2) {
          super(), iA(this, "spec", void 0), iA(this, "token", void 0), iA(this, "websocket", void 0), iA(this, "pingpongTimer", void 0), iA(this, "reconnectMode", "retry"), iA(this, "serviceMode", void 0), iA(this, "reqId", 0), iA(this, "commandReqId", 0), iA(this, "handleWebSocketOpen", (() => {
            this.reconnectMode = "retry", this.startPingPong();
          })), iA(this, "handleWebSocketMessage", ((e3) => {
            if (!e3.data) return;
            const t3 = JSON.parse(e3.data);
            t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : (lP.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === YV.TRANSCODE ? 1 : 2 }), this.emit(QV.PUBLISH_STREAM_STATUS, t3));
          })), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new $x("live-streaming", i2), this.websocket.on(WV.CONNECTED, this.handleWebSocketOpen), this.websocket.on(WV.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(WV.REQUEST_NEW_URLS, ((e3, t3) => {
            zO(this, QV.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
          })), this.websocket.on(WV.RECONNECTING, (() => {
            this.websocket.reconnectMode = this.reconnectMode;
          }));
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t2, i2, n2) {
          this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
          const r2 = this.commandReqId, o2 = this.reqId;
          if (!o2 || !this.websocket) throw new uP(hO.UNEXPECTED_ERROR);
          const s2 = Cq({ command: e2, sdkVersion: "4.24.2" === hD ? "0.0.1" : hD, seq: o2, requestId: o2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
          if ("closed" === this.websocket.state) throw new uP(hO.WS_DISCONNECT);
          const a2 = () => new rp(((e3, t3) => {
            this.websocket.once(WV.CLOSED, (() => t3(new uP(hO.WS_ABORT)))), this.websocket.once(WV.CONNECTED, e3);
          }));
          "connected" !== this.websocket.state && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
          const c2 = new rp(((e3, t3) => {
            const i3 = () => {
              t3(new uP(hO.WS_ABORT));
            };
            this.websocket.once(WV.RECONNECTING, i3), this.websocket.once(WV.CLOSED, i3), this.once("@".concat(o2, "-").concat(this.spec.sid), ((t4) => {
              e3(t4);
            }));
          }));
          n2 && lP.workerEvent(this.spec.sid, Cq(Cq({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(s2);
          let l2 = null;
          try {
            l2 = await c2;
          } catch (n3) {
            if ("closed" === this.websocket.state) throw n3;
            return await a2(), await this.request(e2, t2, i2);
          }
          return n2 && lP.workerEvent(this.spec.sid, Cq(Cq({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = "4.24.2" === hD ? "0.0.1" : hD;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case $V.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void iP.warning("live stream response already exists stream");
            case $V.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case $V.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case $V.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new uP(hO.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case $V.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              throw new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case $V.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new uP(hO.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case $V.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t2 = new uP(hO.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(QV.WARNING, t2, e2.serverResponse.url);
            }
            case $V.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t2 = new uP(hO.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(QV.WARNING, t2, e2.serverResponse.url);
            }
            case $V.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case $V.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new uP(hO.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case $V.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t2 = new uP(hO.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(QV.WARNING, t2, e2.serverResponse.url);
            }
            case $V.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case $V.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case $V.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case $V.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              throw new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case $V.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command) return new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case $V.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new uP(hO.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval((() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(TN);
          }), 6e3);
        }
      }
      function yq(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function Iq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? yq(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yq(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class Aq extends NO {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : kN, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : kN;
          super(), iA(this, "onLiveStreamWarning", void 0), iA(this, "onLiveStreamError", void 0), iA(this, "spec", void 0), iA(this, "retryTimeout", 1e4), iA(this, "connection", void 0), iA(this, "httpRetryConfig", void 0), iA(this, "wsRetryConfig", void 0), iA(this, "streamingTasks", /* @__PURE__ */ new Map()), iA(this, "isStartingStreamingTask", false), iA(this, "taskMutex", new PN("live-streaming")), iA(this, "cancelToken", Tw.CancelToken.source()), iA(this, "transcodingConfig", void 0), iA(this, "uapResponse", void 0), iA(this, "lastTaskId", 1), iA(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i2, this.wsRetryConfig = t2;
        }
        async setTranscodingConfig(e2) {
          const t2 = Iq(Iq({}, JV), e2);
          66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (iP.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map(((e3) => Iq(Iq(Iq({}, zV), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 })))), (function(e3) {
            TO(e3.width) || mO(e3.width, "config.width", 0, 1e4), TO(e3.height) || mO(e3.height, "config.height", 0, 1e4), TO(e3.videoBitrate) || mO(e3.videoBitrate, "config.videoBitrate", 1, 1e6), TO(e3.videoFrameRate) || mO(e3.videoFrameRate, "config.videoFrameRate"), TO(e3.lowLatency) || _O(e3.lowLatency, "config.lowLatency"), TO(e3.audioSampleRate) || EO(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), TO(e3.audioBitrate) || mO(e3.audioBitrate, "config.audioBitrate", 1, 128), TO(e3.audioChannels) || EO(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), TO(e3.videoGop) || mO(e3.videoGop, "config.videoGop"), TO(e3.videoCodecProfile) || EO(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), TO(e3.userCount) || mO(e3.userCount, "config.userCount", 0, 17), TO(e3.backgroundColor) || mO(e3.backgroundColor, "config.backgroundColor", 0, 16777215), TO(e3.userConfigExtraInfo) || SO(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !TO(e3.transcodingUsers) && (gO(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach(((e4, t3) => {
              KV(e4.uid), TO(e4.x) || mO(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), TO(e4.y) || mO(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), TO(e4.width) || mO(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), TO(e4.height) || mO(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), TO(e4.zOrder) || mO(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), TO(e4.alpha) || mO(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
            }))), TO(e3.watermark) || XV(e3.watermark, "watermark"), TO(e3.backgroundImage) || XV(e3.backgroundImage, "backgroundImage"), e3.images && !TO(e3.images) && (gO(e3.images, "config.images"), e3.images.forEach(((e4, t3) => {
              XV(e4, "images[".concat(t3, "]"));
            })));
          })(t2);
          const i2 = [];
          t2.images && i2.push(...t2.images.map(((e3) => Iq(Iq(Iq({}, qV), e3), {}, { zOrder: 255 })))), t2.backgroundImage && (i2.push(Iq(Iq(Iq({}, qV), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i2.push(Iq(Iq(Iq({}, qV), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map(((e3) => Iq({}, e3))), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
          const n2 = (t2.userConfigs || []).map(((e3) => "number" == typeof e3.uid ? rp.resolve(e3.uid) : WB(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig)));
          if ((await rp.all(n2)).forEach(((e3, i3) => {
            t2.userConfigs && t2.userConfigs[i3] && (t2.userConfigs[i3].uid = e3);
          })), this.transcodingConfig = t2, this.connection) try {
            var r2;
            const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(pp(r2 = this.streamingTasks).call(r2)).map(((e4) => e4.taskId)).join("#") });
            iP.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
          } catch (e3) {
            if (!e3.data || !e3.data.retry) throw e3;
            e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach(((t3) => {
              iP.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then((() => {
                iP.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
              })).catch(((e4) => {
                iP.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
              }));
            }));
          }
        }
        async startLiveStreamingTask(e2, t2, i2) {
          if (!this.transcodingConfig && t2 === YV.TRANSCODE) throw new uP(hO.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          const n2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          iP.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
          const r2 = await this.taskMutex.lock();
          if (!this.connection && i2) return void r2();
          if (this.streamingTasks.get(e2) && !i2) return r2(), new uP(hO.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t2));
          } catch (e3) {
            throw r2(), e3;
          }
          switch (t2) {
            case YV.TRANSCODE:
              n2.transcodingConfig = Iq({}, this.transcodingConfig);
            case YV.RAW:
          }
          this.uapResponse && this.uapResponse.vid && (n2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const o2 = this.lastTaskId++;
          try {
            const s2 = new rp(((t3, n3) => {
              fN(this.retryTimeout).then((() => {
                if (i2) return n3(i2);
                const t4 = this.statusError.get(e2);
                return t4 ? (this.statusError.delete(e2), n3(t4)) : void 0;
              }));
            })), a2 = await rp.race([this.connection.request("request", { clientRequest: n2 }, true, { url: e2, command: "PublishStream", workerType: t2 === YV.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: o2.toString() }), s2]);
            this.isStartingStreamingTask = false, iP.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: n2, mode: t2, url: e2, taskId: o2 }), r2();
          } catch (n3) {
            if (r2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i2) throw n3;
            return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
          }
        }
        stopLiveStreamingTask(e2) {
          return new rp(((t2, i2) => {
            const n2 = this.streamingTasks.get(e2);
            if (!n2 || !this.connection) return new uP(hO.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const r2 = n2.mode;
            n2.abortTask = () => {
              iP.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
            }, this.connection.request("request", { clientRequest: { command: "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === YV.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then(((i3) => {
              iP.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && (this.connection && this.connection.close(), this.connection = void 0), t2();
            })).catch(i2);
          }));
        }
        resetAllTask() {
          var e2;
          const t2 = Array.from(pp(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t2) this.startLiveStreamingTask(e3.url, e3.mode).catch(((t3) => {
            this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
          }));
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = Tw.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection) throw new uP(hO.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t2 = await zO(this, ZV.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t2, this.connection = new vq(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(QV.WARNING, ((e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3))), this.connection.on(QV.PUBLISH_STREAM_STATUS, ((e3) => this.handlePublishStreamServer(e3))), this.connection.on(QV.REQUEST_NEW_ADDRESS, ((t3, i2) => {
            if (!this.connection) return i2(new uP(hO.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            zO(this, ZV.REQUEST_WORKER_MANAGER_LIST, e2).then(((e3) => {
              this.uapResponse = e3, t3(e3.addressList);
            })).catch(i2);
          })), await this.connection.init(t2.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t2), n2 = e2.reason;
          switch (e2.code) {
            case $V.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case $V.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const n3 = new uP(hO.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (i2) return iP.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
              if (!this.isStartingStreamingTask) return;
              this.statusError.set(t2, n3);
            }
            case $V.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new uP(hO.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
            }
            case $V.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case $V.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var r2;
              if (!this.connection) return;
              this.connection.tryNextAddress();
              const t3 = Array.from(pp(r2 = this.streamingTasks).call(r2));
              for (const i3 of t3) i3.abortTask ? i3.abortTask() : (iP.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new uP(hO.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then((() => {
                iP.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
              })).catch(((e3) => {
                iP.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e3);
              })));
              return;
            }
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      const bq = { name: "LiveStreaming", create: function(e2) {
        return new Aq(e2.joinInfo, e2.websocketRetryConfig || kN, e2.httpRetryConfig || kN);
      } };
      function wq(e2) {
        let t2 = Fq();
        return (function(e3, t3) {
          let i2 = e3.appId;
          void 0 !== i2 && ($q(t3, 10), Yq(t3, i2));
          let n2 = e3.cid;
          void 0 !== n2 && ($q(t3, 16), $q(t3, n2));
          let r2 = e3.cname;
          void 0 !== r2 && ($q(t3, 26), Yq(t3, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && ($q(t3, 34), Yq(t3, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && ($q(t3, 40), eX(t3, s2));
          let a2 = e3.fileSize;
          void 0 !== a2 && ($q(t3, 48), eX(t3, Vq(a2)));
          let c2 = e3.height;
          void 0 !== c2 && ($q(t3, 56), eX(t3, Vq(c2)));
          let d2 = e3.jpg;
          void 0 !== d2 && ($q(t3, 66), $q(t3, d2.length), (function(e4, t4) {
            let i3 = Wq(e4, t4.length);
            e4.bytes.set(t4, i3);
          })(t3, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && ($q(t3, 72), eX(t3, Vq(l2)));
          let u2 = e3.osType;
          void 0 !== u2 && ($q(t3, 80), eX(t3, Vq(u2)));
          let h2 = e3.requestId;
          void 0 !== h2 && ($q(t3, 90), Yq(t3, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && ($q(t3, 98), Yq(t3, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && ($q(t3, 104), eX(t3, Vq(_2)));
          let E2 = e3.sid;
          void 0 !== E2 && ($q(t3, 114), Yq(t3, E2));
          let m2 = e3.timestamp;
          void 0 !== m2 && ($q(t3, 120), eX(t3, m2));
          let f2 = e3.uid;
          void 0 !== f2 && ($q(t3, 128), $q(t3, f2));
          let S2 = e3.vid;
          void 0 !== S2 && ($q(t3, 136), $q(t3, S2));
          let g2 = e3.width;
          void 0 !== g2 && ($q(t3, 144), eX(t3, Vq(g2)));
          let T2 = e3.service;
          void 0 !== T2 && ($q(t3, 152), $q(t3, T2));
          let R2 = e3.callbackData;
          void 0 !== R2 && ($q(t3, 162), Yq(t3, R2));
          let C2 = e3.jpgEncryption;
          void 0 !== C2 && ($q(t3, 168), $q(t3, C2));
          let v2 = e3.requestType;
          void 0 !== v2 && ($q(t3, 176), $q(t3, v2));
          let y2 = e3.scorePorn;
          void 0 !== y2 && ($q(t3, 185), Qq(t3, y2));
          let I2 = e3.scoreSexy;
          void 0 !== I2 && ($q(t3, 193), Qq(t3, I2));
          let A2 = e3.scoreNeutral;
          void 0 !== A2 && ($q(t3, 201), Qq(t3, A2));
          let b2 = e3.scene;
          void 0 !== b2 && ($q(t3, 208), $q(t3, b2));
          let w2 = e3.ossFilePrefix;
          void 0 !== w2 && ($q(t3, 218), Yq(t3, w2));
          let O2 = e3.serviceVendor;
          if (void 0 !== O2) for (let e4 of O2) {
            $q(t3, 226);
            let i3 = Fq();
            Dq(e4, i3), $q(t3, i3.limit), zq(t3, i3), Bq(i3);
          }
        })(e2, t2), (function(e3) {
          let t3 = e3.bytes, i2 = e3.limit;
          return t3.length === i2 ? t3 : t3.subarray(0, i2);
        })(t2);
      }
      function Oq(e2) {
        return (function(e3) {
          let t3 = {};
          e: for (; !Gq(e3); ) {
            let i2 = Zq(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = Zq(e3);
                break;
              case 2:
                t3.msg = Kq(e3, Zq(e3));
                break;
              case 3: {
                let i3 = Pq(e3);
                t3.data = Nq(e3), e3.limit = i3;
                break;
              }
              default:
                Lq(e3, 7 & i2);
            }
          }
          return t3;
        })({ bytes: t2 = e2, offset: 0, limit: t2.length });
        var t2;
      }
      function Nq(e2) {
        let t2 = {};
        e: for (; !Gq(e2); ) {
          let i2 = Zq(e2);
          switch (i2 >>> 3) {
            case 0:
              break e;
            case 1:
              t2.requestId = Kq(e2, Zq(e2));
              break;
            case 2:
              t2.requestType = Zq(e2) >>> 0;
              break;
            case 3:
              t2.scorePorn = Jq(e2);
              break;
            case 4:
              t2.scoreSexy = Jq(e2);
              break;
            case 5:
              t2.scoreNeutral = Jq(e2);
              break;
            case 6:
              t2.requestScene = Zq(e2) >>> 0;
              break;
            case 7:
              t2.scene = Zq(e2) >>> 0;
              break;
            default:
              Lq(e2, 7 & i2);
          }
        }
        return t2;
      }
      function Dq(e2, t2) {
        let i2 = e2.service;
        void 0 !== i2 && ($q(t2, 8), $q(t2, i2));
        let n2 = e2.vendor;
        void 0 !== n2 && ($q(t2, 16), $q(t2, n2));
        let r2 = e2.token;
        void 0 !== r2 && ($q(t2, 26), Yq(t2, r2));
        let o2 = e2.callbackUrl;
        void 0 !== o2 && ($q(t2, 34), Yq(t2, o2));
      }
      function Pq(e2) {
        let t2 = Zq(e2), i2 = e2.limit;
        return e2.limit = e2.offset + t2, i2;
      }
      function Lq(e2, t2) {
        switch (t2) {
          case 0:
            for (; 128 & qq(e2); ) ;
            break;
          case 2:
            jq(e2, Zq(e2));
            break;
          case 5:
            jq(e2, 4);
            break;
          case 1:
            jq(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t2);
        }
      }
      let kq = new Float32Array(1);
      new Uint8Array(kq.buffer);
      let Mq = new Float64Array(1), Uq = new Uint8Array(Mq.buffer);
      function Vq(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let xq = [];
      function Fq() {
        const e2 = xq.pop();
        return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function Bq(e2) {
        xq.push(e2);
      }
      function jq(e2, t2) {
        if (e2.offset + t2 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t2;
      }
      function Gq(e2) {
        return e2.offset >= e2.limit;
      }
      function Wq(e2, t2) {
        let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
        if (o2 > i2.length) {
          let t3 = new Uint8Array(2 * o2);
          t3.set(i2), e2.bytes = t3;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
      }
      function Hq(e2, t2) {
        let i2 = e2.offset;
        if (i2 + t2 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t2, i2;
      }
      function Kq(e2, t2) {
        let i2 = Hq(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t2; e3++) {
          let a2, c2, d2, l2, u2 = r2[e3 + i2];
          0 == (128 & u2) ? s2 += n2(u2) : 192 == (224 & u2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? s2 += o2 : (l2 = (31 & u2) << 6 | 63 & a2, l2 < 128 ? s2 += o2 : (s2 += n2(l2), e3++))) : 224 == (240 & u2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n2(l2), e3 += 2))) : 240 == (248 & u2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function Yq(e2, t2) {
        let i2 = t2.length, n2 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t2.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        $q(e2, n2);
        let r2 = Wq(e2, n2), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n3 = t2.charCodeAt(e3);
          n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
        }
      }
      function zq(e2, t2) {
        let i2 = Wq(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
        for (let e3 = 0, o2 = t2.limit; e3 < o2; e3++) n2[e3 + i2] = r2[e3];
      }
      function qq(e2) {
        return e2.bytes[Hq(e2, 1)];
      }
      function Xq(e2, t2) {
        let i2 = Wq(e2, 1);
        e2.bytes[i2] = t2;
      }
      function Jq(e2) {
        let t2 = Hq(e2, 8), i2 = e2.bytes;
        return Uq[0] = i2[t2++], Uq[1] = i2[t2++], Uq[2] = i2[t2++], Uq[3] = i2[t2++], Uq[4] = i2[t2++], Uq[5] = i2[t2++], Uq[6] = i2[t2++], Uq[7] = i2[t2++], Mq[0];
      }
      function Qq(e2, t2) {
        let i2 = Wq(e2, 8), n2 = e2.bytes;
        Mq[0] = t2, n2[i2++] = Uq[0], n2[i2++] = Uq[1], n2[i2++] = Uq[2], n2[i2++] = Uq[3], n2[i2++] = Uq[4], n2[i2++] = Uq[5], n2[i2++] = Uq[6], n2[i2++] = Uq[7];
      }
      function Zq(e2) {
        let t2, i2 = 0, n2 = 0;
        do {
          t2 = qq(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
        } while (128 & t2);
        return n2;
      }
      function $q(e2, t2) {
        for (t2 >>>= 0; t2 >= 128; ) Xq(e2, 127 & t2 | 128), t2 >>>= 7;
        Xq(e2, t2);
      }
      function eX(e2, t2) {
        let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = Wq(e2, o2), a2 = e2.bytes;
        switch (o2) {
          case 10:
            a2[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
          case 7:
            a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
          case 6:
            a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
          case 5:
            a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
          case 4:
            a2[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a2[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a2[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a2[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      function tX(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      const iX = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class nX extends NO {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t2 = this._connectionState;
          this._connectionState = e2, this.emit(Ax.CONNECTION_STATE_CHANGE, t2, e2);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e2) {
          var t2;
          this._inspectMode = nr(t2 = e2.map(((e3) => iX.get(e3) || 0))).call(t2, ((e3, t3) => e3 + t3)), this._inspectType = e2;
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout((() => {
            this.quality = this._quality / this.qualityRatio;
          }), 6e4));
        }
        constructor(e2) {
          super(), iA(this, "name", "AgoraRTCVideoContentInspect"), iA(this, "_connectionState", yx.CONNECTING), iA(this, "_innerConnectionState", void 0), iA(this, "sequence", 0), iA(this, "inspectStartTime", void 0), iA(this, "workerManagerConnection", void 0), iA(this, "workerConnection", void 0), iA(this, "workerMessageLengthLimit", void 0), iA(this, "inspectIntervalMinimum", void 0), iA(this, "qualityRatio", void 0), iA(this, "_connectInfo", void 0), iA(this, "_cancelTokenSource", Tw.CancelToken.source()), iA(this, "_retryConfig", void 0), iA(this, "wmSequence", 0), iA(this, "inspectInterval", void 0), iA(this, "inspectTimer", null), iA(this, "ossFilePrefix", void 0), iA(this, "extraInfo", void 0), iA(this, "_inspectType", void 0), iA(this, "_inspectMode", void 0), iA(this, "_quality", 1), iA(this, "qualityTimer", null), iA(this, "_inspectId", void 0), iA(this, "_needWorkUrlOnly", false), iA(this, "inspectImage", (() => {
            if (this.connectionState !== yx.CONNECTED) throw new uP(hO.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval((() => {
              this.connectionState === yx.CONNECTED ? this.requestToInspectImage() : iP.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
            }), this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          })), this._inspectId = SN(5, "inspect-"), this.workerMessageLengthLimit = CD("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = CD("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = CD("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new $x("worker-manager-" + this._inspectId, kN), this.on(Ax.STATE_CHANGE, ((e3, t2) => {
            this._innerConnectionState = e3, iP.debug("[".concat(this._inspectId, "] Inspect operation :").concat(Ix[e3], " ").concat(t2 || ""));
          })), this.handleWorkerManagerEvents(), this.workerConnection = new $x("worker-" + this._inspectId, kN), this.handleWorkerEvents();
        }
        async init(e2, t2) {
          this.emit(Ax.STATE_CHANGE, Ix.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t2, new rp(((n2, r2) => {
            this.on(Ax.CONNECTION_STATE_CHANGE, ((e3, t3) => {
              t3 === yx.CONNECTED && n2();
            })), this.requestAP(e2, i2, t2).then(((e3) => {
              this.connectWorkerManager(e3);
            })).catch(((e3) => {
              r2(e3);
            }));
          }));
        }
        async requestAP(e2, t2, i2) {
          const n2 = CD("WEBCS_DOMAIN").map(((e3) => "https://".concat(e3, "/api/v1"))), r2 = await (function(e3, t3, i3, n3) {
            let { appId: r3, areaCode: o3, cname: s2, sid: a2, token: c2, uid: d2 } = t3;
            UB++;
            const l2 = "image_moderation_api", u2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: UB, seq: UB, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return UN((async () => {
              h2 = Date.now();
              const e4 = await _B(_2, { data: u2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t5 = new uP(hO.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw iP.error(t5.toString()), t5;
              }
              const t4 = JSON.parse(e4.json_body);
              if (200 !== t4.code) {
                const e5 = new uP(hO.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                throw iP.error(e5.toString()), e5;
              }
              if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                const e5 = new uP(hO.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p2 });
                throw iP.error(e5.toString()), e5;
              }
              const n4 = CD("VIDEO_INSPECT_WORKER_MANAGER_WSS");
              if (n4) return { addressList: [n4], workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
              const r4 = CD("VIDEO_INSPECT_WORKER_MANAGER_HOST"), o4 = CD("VIDEO_INSPECT_WORKER_MANAGER_PORT"), s3 = t4.servers.map(((e5) => {
                let { address: t5, wss: i4 } = e5;
                if (t5 && i4) return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(r4, ":").concat(o4 || i4);
              })).filter(((e5) => !!e5));
              return { addressList: s3, workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
            }), ((t4, i4) => (lP.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false)), ((t4, i4) => (lP.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== hO.OPERATION_ABORTED && t4.code !== hO.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true))), n3);
          })(n2, e2, t2, i2);
          this.emit(Ax.STATE_CHANGE, Ix.AP_CONNECTED);
          const { addressList: o2 } = r2;
          return this.wmSequence++, o2;
        }
        async connectWorkerManager(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t2, this.emit(Ax.STATE_CHANGE, Ix.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
        }
        async connectWorker(e2) {
          await this.workerConnection.init([e2]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(WV.CONNECTED, (async () => {
            this.emit(Ax.STATE_CHANGE, Ix.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.24.2", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          })), this.workerManagerConnection.on(WV.CLOSED, (() => {
            this._innerConnectionState < Ix.GET_WORKER_MANAGER_RESPONSE && iP.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
          })), this.workerManagerConnection.on(WV.FAILED, (() => {
            this._innerConnectionState < Ix.GET_WORKER_MANAGER_RESPONSE && iP.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
          })), this.workerManagerConnection.on(WV.RECONNECTING, (() => {
            this._innerConnectionState < Ix.GET_WORKER_MANAGER_RESPONSE && iP.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
          })), this.workerManagerConnection.on(WV.ON_MESSAGE, (async (e2) => {
            this.emit(Ax.STATE_CHANGE, Ix.GET_WORKER_MANAGER_RESPONSE);
            const t2 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i2 = JSON.parse(e2.data);
            if (200 !== i2.code) throw iP.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new uP(hO.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
            if (!(i2.serverResponse && i2.serverResponse.portWss && t2)) throw iP.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new uP(hO.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
            {
              const e3 = CD("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
              this.emit(Ax.STATE_CHANGE, Ix.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(Ax.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
            }
          })), this.workerManagerConnection.on(WV.WILL_RECONNECT, ((e2, t2, i2) => {
            i2(e2);
          })), this.workerManagerConnection.on(WV.REQUEST_NEW_URLS, ((e2, t2) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
          }));
        }
        handleWorkerEvents() {
          this.workerConnection.on(WV.CONNECTED, (async () => {
            this.emit(Ax.STATE_CHANGE, Ix.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = yx.CONNECTED;
          })), this.workerConnection.on(WV.ON_MESSAGE, (async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const i2 = Oq(new Uint8Array(e2.data));
              if (CD("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && iP.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(Ax.INSPECT_RESULT, void 0, void 0);
                if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
                  var t2;
                  const e3 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n2 = nr(t2 = Object.keys(e3)).call(t2, ((t3, i3) => e3[t3] > e3[i3] ? t3 : i3), "porn"), r2 = Object.keys(e3).find(((e4) => e4 === n2));
                  this.emit(Ax.INSPECT_RESULT, r2);
                } else this.emit(Ax.INSPECT_RESULT, void 0, new uP(hO.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
              } else this.emit(Ax.INSPECT_RESULT, void 0, new uP(hO.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
            } else iP.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(Ax.INSPECT_RESULT, void 0, new uP(hO.UNEXPECTED_RESPONSE, "invalid worker message type"));
          })), this.workerConnection.on(WV.CLOSED, (() => {
            this.connectionState = yx.CLOSED;
          })), this.workerConnection.on(WV.FAILED, (() => {
            this.connectionState = yx.CLOSED;
          })), this.workerConnection.on(WV.RECONNECTING, (() => {
            this.connectionState = this.connectionState === yx.CONNECTED ? yx.RECONNECTING : yx.CONNECTING;
          })), this.workerConnection.on(WV.WILL_RECONNECT, ((e2, t2, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          })), this.workerConnection.on(WV.REQUEST_NEW_URLS, ((e2, t2) => {
            this.workerManagerConnection.close(), this.once(Ax.REQUEST_NEW_WORKER_URL, ((t3) => {
              e2([t3]);
            })), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(((e3) => {
              this.connectWorkerManager(e3, true);
            })).catch(((e3) => {
              t2(e3);
            }));
          }));
        }
        async requestToInspectImage() {
          this.sequence++;
          const e2 = XO(this, Ax.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void this.emit(Ax.INSPECT_RESULT, void 0, new uP(hO.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i2 = await this.generateRequestData(e2, t2);
            this.workerConnection.sendMessage(i2, true, true);
          } else this.emit(Ax.INSPECT_RESULT, void 0, new uP(hO.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e2, t2) {
          let { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
          const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await QL(d2, i2, n2), u2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + SN(12, ""), h2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: (p2 = Number(c2 - this.inspectStartTime), { low: p2 |= 0, high: p2 >> 31, unsigned: p2 >= 0 }), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u2, sdkVersion: "4.24.2", sequence: this.sequence, sid: s2, timestamp: wW(c2), uid: a2, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          var p2;
          void 0 === this.extraInfo && delete h2.callbackData, void 0 === this.ossFilePrefix && delete h2.ossFilePrefix;
          const _2 = wq(h2);
          if (_2.byteLength < this.workerMessageLengthLimit) {
            if (CD("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e3 = (function(e4) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i3 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? tX(Object(i3), true).forEach((function(t4) {
                    iA(e4, t4, i3[t4]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : tX(Object(i3)).forEach((function(t4) {
                    Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                  }));
                }
                return e4;
              })({}, h2);
              delete e3.jpg, iP.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
            }
            return _2;
          }
          {
            const t3 = this.quality * this.qualityRatio;
            return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = Tw.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = yx.CLOSED, this.emit(Ax.STATE_CHANGE, Ix.CLOSED);
        }
      }
      const rX = { name: "ContentInspect", create: function(e2) {
        let { config: t2 } = e2;
        return (function(e3) {
          if (!e3) throw new uP(hO.INVALID_PARAMS, "inspectConfig is necessary.");
          if (!e3.inspectType || !Array.isArray(e3.inspectType)) throw new uP(hO.INVALID_PARAMS, "inspectConfig.inspectType is necessary and is an instance of Array.");
          {
            const t3 = [...new Set(e3.inspectType)];
            t3.forEach(((e4) => {
              var t4;
              if (!Ln(t4 = ["supervise", "moderation"]).call(t4, e4)) throw new uP(hO.INVALID_PARAMS, "".concat(e4, " is not a valid inspect type."));
            })), e3.inspectType = t3;
          }
          if (e3 && e3.extraInfo && e3.extraInfo.length > 1024) throw new uP(hO.INVALID_PARAMS, "inspectConfig.extraInfo length cannot exceed 1024 bytes");
        })(t2), new nX(t2);
      } };
      var oX = i($.Object.getOwnPropertySymbols), sX = Oi, aX = qi.indexOf, cX = Wn, dX = y([].indexOf), lX = !!dX && 1 / dX([1], 1, -0) < 0;
      sX({ target: "Array", proto: true, forced: lX || !cX("indexOf") }, { indexOf: function(e2) {
        var t2 = arguments.length > 1 ? arguments[1] : void 0;
        return lX ? dX(this, e2, t2) || 0 : aX(this, e2, t2);
      } });
      var uX = Zi("Array", "indexOf"), hX = l, pX = uX, _X = Array.prototype, EX = function(e2) {
        var t2 = e2.indexOf;
        return e2 === _X || hX(_X, e2) && t2 === _X.indexOf ? pX : t2;
      }, mX = i(EX);
      function fX(e2, t2) {
        if (null == e2) return {};
        var i2, n2, r2 = (function(e3, t3) {
          if (null == e3) return {};
          var i3 = {};
          for (var n3 in e3) if ({}.hasOwnProperty.call(e3, n3)) {
            if (-1 !== mX(t3).call(t3, n3)) continue;
            i3[n3] = e3[n3];
          }
          return i3;
        })(e2, t2);
        if (oX) {
          var o2 = oX(e2);
          for (n2 = 0; n2 < o2.length; n2++) i2 = o2[n2], -1 === mX(t2).call(t2, i2) && {}.propertyIsEnumerable.call(e2, i2) && (r2[i2] = e2[i2]);
        }
        return r2;
      }
      let SX = class {
        get localCapabilities() {
          return sN(this._localCapabilities);
        }
        get rtpCapabilities() {
          return sN(this._rtpCapabilities);
        }
        get candidates() {
          return sN(this._candidates);
        }
        get iceParameters() {
          return sN(this._iceParameters);
        }
        get dtlsParameters() {
          return sN(this._dtlsParameters);
        }
        constructor(e2) {
          iA(this, "sessionDesc", void 0), iA(this, "_localCapabilities", void 0), iA(this, "_rtpCapabilities", void 0), iA(this, "_candidates", void 0), iA(this, "_iceParameters", void 0), iA(this, "_dtlsParameters", void 0), iA(this, "setup", void 0), iA(this, "currentMidIndex", void 0), iA(this, "cname", "o/i14u9pJrxRKAsu"), iA(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = sN(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, localCapabilities: o2, direction: s2, setup: a2, videoCodec: c2, audioCodec: d2 } = e2;
          let l2;
          this.setup = a2, l2 = s2 === GV.RECEIVE_ONLY ? LD("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n") : LD("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"), this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = o2;
          const u2 = s2 === GV.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h2 = s2 === GV.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p2 = s2 === GV.RECEIVE_ONLY ? r2.send.videoCodecs : YF(fx.VIDEO, u2, h2, c2), _2 = s2 === GV.RECEIVE_ONLY ? r2.send.audioCodecs : YF(fx.AUDIO, u2, h2, d2);
          for (const e3 of l2.mediaDescriptions) e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = p2.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = p2, e3.attributes.extmaps = u2.videoExtensions), "audio" === e3.media.mediaType && (e3.media.fmts = _2.map(((e4) => e4.payloadType.toString(10))), e3.attributes.payloads = _2, e3.attributes.extmaps = u2.audioExtensions, KF(e3));
          this.sessionDesc = l2, this.currentMidIndex = l2.mediaDescriptions.length - 1;
        }
        toString() {
          return kD(this.sessionDesc);
        }
        hasMid(e2) {
          return Array.isArray(e2) ? e2.every(((e3) => this.hasMid(e3))) : this.sessionDesc.mediaDescriptions.some(((t2) => t2.attributes.mid === e2));
        }
        send(e2, t2, i2, n2, r2) {
          i2 = i2.replace(/ /g, "-");
          const { ssrcs: o2, ssrcGroups: s2 } = LF(t2, this.cname, CD("SYNC_GROUP") ? i2 : void 0), a2 = this.findPreloadMediaDesc(o2);
          if (a2) {
            if (Bw() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, a2.attributes.mid), r2 && (r2.twcc || r2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(a2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(a2, r2), { mid: a2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: a2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2, o2, n2);
            let i3;
            return -1 === t3 ? (i3 = this.createOrRecycleSendMedia(e2, o2, s2, "sendonly", n2, r2), this.updateBundleMids()) : (i3 = sN(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = o2, i3.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, r2)), Bw() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, i3.attributes.mid), { needExchangeSDP: true, mid: i3.attributes.mid };
          }
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid)));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach(((e3) => {
            e3.attributes.ssrcs = [];
          })), this.updateBundleMids();
        }
        receive(e2, t2, i2) {
          const n2 = [];
          return e2.forEach(((e3) => {
            const r2 = e3._mediaStreamTrack.kind, o2 = this.findAvailableRecvMediaIndex(r2);
            let s2, a2 = false;
            -1 === o2 ? (a2 = true, s2 = this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2), this.updateBundleMids()) : (s2 = sN(this.sessionDesc.mediaDescriptions[o2]), s2.attributes.direction = "recvonly"), n2.push({ mid: s2.attributes.mid, needCreateTransceiver: a2 });
          })), n2;
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => -1 !== e2.indexOf(t3.attributes.mid)));
          if (t2.length !== e2.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach(((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          })), this.updateBundleMids();
        }
        addRemoteCandidate(e2) {
          const { foundation: t2, protocol: i2, address: n2, port: r2, type: o2, relatedAddress: s2, relatedPort: a2, priority: c2 } = new RTCIceCandidate(e2), d2 = { foundation: null != t2 ? t2 : "", componentId: "1", transport: null != i2 ? i2 : "", priority: c2 ? c2 + "" : "", connectionAddress: null != n2 ? n2 : "", port: r2 ? r2 + "" : "", type: o2 ? o2 + "" : "", relAddr: null != s2 ? s2 : "", relPort: a2 ? a2 + "" : "", extension: {} };
          this.candidates.some(((e3) => e3.priority === d2.priority && e3.connectionAddress === d2.connectionAddress && e3.port === d2.port)) || (this._candidates.push(d2), this.sessionDesc.mediaDescriptions.forEach(((e3) => {
            e3.attributes.candidates = this.candidates;
          })));
        }
        clearRemoteCandidate() {
          this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
        }
        createOrRecycleRecvMedia(e2, t2, i2, n2, r2) {
          const o2 = e2._mediaStreamTrack.kind, s2 = this.rtpCapabilities.recv, a2 = YF(o2, s2, this.localCapabilities.send, o2 === fx.AUDIO ? r2 : n2), c2 = o2 === fx.VIDEO ? s2.videoExtensions : s2.audioExtensions, d2 = "".concat(++this.currentMidIndex);
          let l2 = { media: { mediaType: o2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map(((e3) => e3.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
          l2 = this.mungRecvMediaDsec(l2, e2);
          const u2 = this.findFirstClosedMedia(o2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = l2;
          } else this.sessionDesc.mediaDescriptions.push(l2);
          return l2;
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => Ln(e2).call(e2, t3.attributes.mid || "")));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach(((e3) => {
            e3.attributes.direction = "inactive";
          }));
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter(((t3) => Ln(e2).call(e2, t3.attributes.mid || "")));
          if (t2.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach(((e3) => {
            e3.attributes.direction = "recvonly";
          }));
        }
        findAvailableMediaIndex(e2, t2, i2) {
          return this.sessionDesc.mediaDescriptions.findIndex(((n2) => {
            const r2 = n2.media.mediaType === e2 && "0" !== n2.media.port && ("sendonly" === n2.attributes.direction || "sendrecv" === n2.attributes.direction) && 0 === n2.attributes.ssrcs.length;
            if (Bw()) {
              if (r2) {
                const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                return !(e3 || "0" !== n2.attributes.mid && "1" !== n2.attributes.mid) || !(!e3 || e3 !== n2.attributes.mid);
              }
              return false;
            }
            return r2 && n2.attributes.mid === i2;
          }));
        }
        findAvailableRecvMediaIndex(e2) {
          return this.sessionDesc.mediaDescriptions.findIndex(((t2) => {
            const i2 = t2.media.mediaType === e2 && "0" !== t2.media.port && ("recvonly" === t2.attributes.direction || "sendrecv" === t2.attributes.direction);
            return "0" !== t2.attributes.mid && "1" !== t2.attributes.mid && i2;
          }));
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        restartICE(e2) {
          e2 = sN(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach(((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          }));
        }
        createOrRecycleSendMedia(e2, t2, i2, n2, r2, o2) {
          const s2 = this.rtpCapabilities.send, a2 = e2 === fx.VIDEO ? s2.videoCodecs : s2.audioCodecs, c2 = e2 === fx.VIDEO ? s2.videoExtensions : s2.audioExtensions;
          Bw() && (r2 = "".concat(++this.currentMidIndex));
          let d2 = { media: { mediaType: e2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a2.map(((e3) => e3.payloadType.toString(10))) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: a2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: r2 } };
          d2 = this.mungSendMediaDesc(d2, o2);
          const l2 = this.findFirstClosedMedia(e2);
          if (l2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        mungRecvMediaDsec(e2, t2, i2) {
          const n2 = sN(e2);
          return MF(n2), kF(n2, t2), UF(n2, t2), VF(n2), xF(n2, i2, this.localCapabilities.send), n2;
        }
        mungSendMediaDesc(e2, t2) {
          const i2 = sN(e2);
          return xF(i2, t2, this.localCapabilities.recv), KF(i2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex(((t3) => t3.attributes.mid === e2));
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(((e2) => "0" !== e2.media.port)).map(((e2) => e2.attributes.mid));
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find(((t2) => {
            var i2;
            return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          }));
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find(((t2) => Bw() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port));
        }
      };
      const gX = ["sdp"];
      var TX;
      function RX(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function CX(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? RX(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : RX(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let vX = (TX = class e2 extends Ex {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [];
        }
        set isInRestartIce(e3) {
          this._isInRestartIce = e3;
        }
        get isInRestartIce() {
          return this._isInRestartIce;
        }
        constructor(t2, i2, n2) {
          super(t2, i2), iA(this, "direction", void 0), iA(this, "name", void 0), iA(this, "store", void 0), iA(this, "spec", void 0), iA(this, "peerConnection", void 0), iA(this, "initialOffer", void 0), iA(this, "transport", void 0), iA(this, "statsFilter", void 0), iA(this, "localCandidateCount", 0), iA(this, "_isInRestartIce", false), iA(this, "mutex", void 0), iA(this, "onLocalCandidate", void 0), iA(this, "remoteSDP", void 0), iA(this, "pendingCandidates", []), iA(this, "localCapabilities", void 0), iA(this, "isReady", false), iA(this, "restartCnt", 0), iA(this, "curTurnServerIndex", 0), this.store = i2, this.spec = t2, this.mutex = new PN("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2, i2.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = null != n2 ? n2 : GV.SEND_ONLY, this.name = this.direction === GV.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = dD(this.peerConnection, CD("STATS_UPDATE_INTERVAL"), void 0, Bw() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish(e3) {
          try {
            const t2 = await jF();
            if (this.localCapabilities = HF(t2), e3) {
              const { sdp: t3 } = e3, i2 = fX(e3, gX), n2 = (function() {
                const e4 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t4 = wF(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "sendonly"), i3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
                if (WF(t4, e4, "videoExtensions", i3, n3, r3), WF(t4, e4, "videoCodecs", i3, n3, r3), WF(t4, e4, "audioExtensions", i3, n3, r3), WF(t4, e4, "audioCodecs", i3, n3, r3), CD("RAISE_H264_BASELINE_PRIORITY")) {
                  const e5 = r3.videoCodecs.findIndex(((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" === e6.fmtp.parameters["profile-level-id"]));
                  if (-1 !== e5) {
                    const t5 = r3.videoCodecs.findIndex(((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase()));
                    if (t5 < e5) {
                      iP.debug("raising H264 baseline profile priority");
                      const i4 = r3.videoCodecs[e5];
                      r3.videoCodecs.splice(e5, 1), r3.videoCodecs.splice(t5, 0, i4);
                    }
                    -1 !== t5 && CD("FILTER_SEND_H264_BASELINE") && (i3.videoCodecs = i3.videoCodecs.filter(((e6) => !(e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" !== e6.fmtp.parameters["profile-level-id"]))));
                  }
                }
                return { send: i3, recv: n3, sendrecv: r3 };
              })({}, {}, t3);
              this.remoteSDP = new SX({ remoteIceParameters: i2.iceParameters, remoteDtlsParameters: i2.dtlsParameters, candidates: [], remoteRTPCapabilities: n2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
              const r2 = await this.peerConnection.createAnswer();
              if (!r2.sdp) throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
              const o2 = OF(r2.sdp);
              await this.peerConnection.setLocalDescription(r2);
              const s2 = await GF({}, {}, r2.sdp);
              this.localCapabilities = HF(s2);
              const a2 = this.peerConnection.getTransceivers()[0];
              return null != a2 && a2.receiver && a2.receiver.transport && this.tryBindTransportEvents(a2.receiver.transport), CX(CX({}, o2), {}, { sdp: r2.sdp });
            }
            {
              this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
              const e4 = await this.peerConnection.createOffer();
              if (!e4.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t3 = OF(e4.sdp);
              return this.initialOffer = e4, CX(CX({}, t3), {}, { sdp: e4.sdp });
            }
          } catch (e4) {
            throw new pO(hO.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            await this.peerConnection.setLocalDescription(this.initialOffer);
            const { sdp: t2, iceParameters: i2, dtlsParameters: n2 } = e3, r2 = await GF({}, {}, t2);
            this.remoteSDP = new SX({ remoteIceParameters: i2, remoteDtlsParameters: n2, candidates: [], remoteRTPCapabilities: r2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
            const o2 = this.peerConnection.getTransceivers()[0];
            null != o2 && o2.sender && o2.sender.transport && this.tryBindTransportEvents(o2.sender.transport);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async addRemoteCandidate(e3) {
          try {
            e3 && this.pendingCandidates.push(e3), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach(((e4) => {
              this.peerConnection.addIceCandidate(e4);
            })), this.pendingCandidates = []);
          } catch (e4) {
            throw new pO(hO.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.mutex.lock("From P2PConnection.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = n2.remoteSDP.receive(e3, t2, i2);
              e3.forEach(((e4, t3) => {
                if (s2[t3].needCreateTransceiver) {
                  const t4 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                  o2.push(t4), e4._updateRtpTransceiver(t4);
                } else {
                  const i3 = n2.peerConnection.getTransceivers().find(((e5) => e5.mid === s2[t3].mid));
                  if (!i3) throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(s2[t3].mid));
                  o2.push(i3), e4._updateRtpTransceiver(i3);
                }
              })), Bw() && true === CD("SIMULCAST") && (yield Vb(n2.applySimulcastForFirefox(o2, e3)));
              const a2 = s2.map(((e4) => e4.mid)), c2 = yield Vb(n2.peerConnection.createOffer()), d2 = n2.mungSendOfferSDP(c2.sdp, e3, a2), l2 = LD(d2), u2 = a2.map(((e4) => {
                const t3 = l2.mediaDescriptions.find(((t4) => t4.attributes.mid === e4));
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return NF(t3, CD("USE_PUB_RTX"));
              })), h2 = o2.map(((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3 };
              }));
              yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }));
              try {
                yield h2;
              } catch (e4) {
                const t3 = n2.remoteSDP.toString();
                throw yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: t3 })), yield Vb(n2.stopSending(a2, true)), e4;
              }
              yield Vb(n2.applySimulcastEncodings(o2, e3)), yield Vb(n2.applySendEncodings(o2, e3));
              const p2 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return null == _2 || _2(p2), yield Vb(n2.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map(((e4, t3) => {
                const i3 = a2[t3];
                return { localSSRC: u2[t3], id: i3 };
              }));
            } catch (e4) {
              throw e4 instanceof pO ? e4 : new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          }))();
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter(((t4) => -1 !== e3.indexOf(t4.mid)));
            if (t3.length !== e3.length) throw new Error("Transceivers' length (".concat(t3.length, ") doesn't match mids' length (").concat(e3.length, ") when trying to call P2PConnection.stopSending."));
            t3.map(((e4) => {
              var t4;
              e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            }));
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), iP.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else iP.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === r2));
            if (!s2 || null === s2.mid) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, mid: s2.mid, transceiver: s2 };
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async mockReceive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t3 });
              const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), iP.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else iP.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async restartICE(t2) {
          try {
            if (this.store.p2pTransport === _D.Auto && (this.store.p2pTransport = _D.SdRtn, pP().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, pP().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t2) {
              this.restartCnt++, this.isReady = false;
              const e3 = await this.peerConnection.createOffer({ iceRestart: true });
              if (!e3.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const { iceParameters: t3 } = OF(e3.sdp);
              return this.store.descriptionStart(), this.direction === GV.SEND_ONLY && await this.peerConnection.setLocalDescription(e3), t3;
            }
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            if (this.remoteSDP.restartICE(t2), this.store.descriptionStart(), this.direction === GV.RECEIVE_ONLY) {
              this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
              const e3 = await this.peerConnection.createAnswer();
              if (!e3.sdp) throw new Error("Cannot get answer sdp when trying to iceRestart.");
              const { iceParameters: t3 } = OF(e3.sdp);
              return await this.peerConnection.setLocalDescription(e3), t3;
            }
            await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
          } catch (e3) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        close() {
          var e3;
          this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid === e3));
          1 === i2.length && (this.isVP8Simulcast(t2) ? Bw() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === t2));
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: CX(CX({}, zN), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: CX(CX({}, zN), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3, t2;
            Ln(e3 = ["connected", "completed"]).call(e3, this.peerConnection.iceConnectionState) && (this.isReady = false), null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 || t2.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.startICECandidate();
        }
        startICECandidate() {
          this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e3) => {
            if (e3.candidate) {
              var t2;
              if (e3.candidate.candidate) null === (t2 = this.onLocalCandidate) || void 0 === t2 || t2.call(this, e3.candidate.toJSON());
              this.localCandidateCount += 1;
            } else iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
          });
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2, i2) {
          let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const r2 = { iceServers: [] };
          var o2;
          t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (xO(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers, i2, n2)), CD("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway, i2, n2)), Ln(o2 = [_D.Relay, _D.SdRtn]).call(o2, i2) && (r2.iceTransportPolicy = "relay"), CD("FORCE_TURN_TCP") ? r2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach(((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          }))));
          return CD("ENABLE_ENCODED_TRANSFORM") && pP().supportWebRTCEncodedTransform && (r2.encodedInsertableStreams = true), iP.debug("P2PConnection p2pTransport is ".concat(i2)), r2;
        }
        static turnServerConfigToIceServers(e3, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const n2 = [], r2 = e3.filter(((e4) => e4.tcpport));
          iP.debug("P2PConnection turnServers is ".concat(r2, ", current index is ").concat(i2));
          const o2 = r2.length > i2 ? r2[i2] : r2[0];
          switch (t2) {
            case _D.SdRtn:
              const t3 = e3.filter(((e4) => {
                var t4;
                return Ln(t4 = e4.username).call(t4, "glb:") && e4.turnServerURL == e4.turnServerURL;
              })), r3 = t3.length > i2 ? t3[i2] : t3[0];
              r3 && (n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turn:".concat(sF(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=udp") }), n2.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turns:".concat(sF(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=tcp") }));
              break;
            case _D.Relay:
              o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(sF(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }));
              break;
            default:
              o2 && (n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(sF(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }), n2.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "stun:".concat(o2.turnServerURL, ":").concat(o2.tcpport) }));
          }
          return n2;
        }
        tryBindTransportEvents(e3) {
          if (e3) {
            this.transport = e3, e3.onstatechange = () => {
              var t3;
              null != e3 && e3.state && (null === (t3 = this.onDTLSTransportStateChange) || void 0 === t3 || t3.call(this, e3.state));
            }, e3.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const t2 = e3.iceTransport;
            t2 && (t2.onstatechange = () => {
              const t3 = null == e3 ? void 0 : e3.iceTransport.state;
              var i2;
              t3 && (null === (i2 = this.onICETransportStateChange) || void 0 === i2 || i2.call(this, t3));
            }, t2.getSelectedCandidatePair && (t2.onselectedcandidatepairchange = () => {
              if (t2.getSelectedCandidatePair()) {
                const { local: e4, remote: i2 } = t2.getSelectedCandidatePair() || {};
                if (e4 && i2) {
                  const t3 = e4.address + ":" + e4.port, n2 = i2.address + ":" + i2.port;
                  iP.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify(mF(t3)), ", remote ").concat(JSON.stringify(mF(n2))));
                }
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i2;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find(((t3) => t3.track === e3._mediaStreamTrack));
          }
          if (!t2) return iP.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return iP.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!pP().supportSetRtpSenderParameters) return iP.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (e3._encoderConfig) {
            var o2;
            const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (r2.maxBitrate = 1e3 * t3), Ln(o2 = e3._hints).call(o2, VP.LOW_STREAM) && (i3 && (r2.maxFramerate = dF(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
          }
          if (CD("DSCP_TYPE") && sO()) {
            var s2;
            const e4 = CD("DSCP_TYPE");
            Ln(s2 = ["very-low", "low", "medium", "high"]).call(s2, e4) && (r2.networkPriority = e4);
          }
          const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
          Bw() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), iP.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!pP().supportSetRtpSenderParameters) return;
            if (e3.length !== t2.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = e3[i2], r2 = t2[i2];
              r2 instanceof kM && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            iP.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          const n2 = LD(e3);
          return t2.forEach(((e4, t3) => {
            const r2 = i2[t3], o2 = n2.mediaDescriptions.find(((e5) => e5.attributes.mid === r2));
            o2 && (kF(o2, e4), FF(o2, e4, this.store.codec));
          })), kD(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length) for (let a2 = 0; a2 < e3.length; a2++) {
            var i2, n2, r2, o2, s2;
            const c2 = e3[a2], d2 = t2[a2];
            if (d2 instanceof kM && !Ln(i2 = d2._hints).call(i2, VP.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Bw() && e3.length === t2.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof kM && this.isVP8Simulcast(n2)) {
              const t3 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(s2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2, o2;
          return !!(e3 instanceof kM && CD("SIMULCAST") && "vp8" === this.store.codec && !Ln(t2 = e3._hints).call(t2, VP.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (CD("SDP_LOGGING")) return iP.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(((e4) => {
              e4.direction = "inactive";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((async (e4) => {
              e4.direction = "sendonly";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3, t2) {
          var i2;
          if (t2 = null != t2 ? t2 : null === (i2 = this.currentRemoteDescription) || void 0 === i2 ? void 0 : i2.sdp) {
            var n2;
            const i3 = null === (n2 = LD(t2).mediaDescriptions.find(((t3) => t3.attributes.mid === e3))) || void 0 === n2 ? void 0 : n2.attributes.ssrcs;
            return null == i3 ? void 0 : i3[0].ssrcId;
          }
        }
        async setRemoteDescription(e3) {
          var t2;
          await this.peerConnection.setRemoteDescription(e3), Ln(t2 = ["connected", "completed"]).call(t2, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
        }
        mungReceiveAnswerSDP(e3, t2, i2) {
          const n2 = LD(e3), r2 = n2.mediaDescriptions.find(((e4) => e4.attributes.mid === t2));
          return r2 && i2 === fx.AUDIO && "audio" === r2.media.mediaType && KF(r2), kD(n2);
        }
      }, DV(TX.prototype, "establish", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "establish"), TX.prototype), DV(TX.prototype, "connect", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "connect"), TX.prototype), DV(TX.prototype, "receive", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "receive"), TX.prototype), DV(TX.prototype, "mockReceive", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "mockReceive"), TX.prototype), DV(TX.prototype, "stopReceiving", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "stopReceiving"), TX.prototype), DV(TX.prototype, "restartICE", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "restartICE"), TX.prototype), DV(TX.prototype, "close", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "close"), TX.prototype), DV(TX.prototype, "updateEncoderConfig", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "updateEncoderConfig"), TX.prototype), DV(TX.prototype, "updateSendParameters", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "updateSendParameters"), TX.prototype), DV(TX.prototype, "replaceTrack", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "replaceTrack"), TX.prototype), DV(TX.prototype, "muteLocal", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "muteLocal"), TX.prototype), DV(TX.prototype, "unmuteLocal", [yX], Object.getOwnPropertyDescriptor(TX.prototype, "unmuteLocal"), TX.prototype), TX);
      function yX(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      let IX = (function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      })({});
      var AX, bX, wX, OX, NX, DX, PX, LX, kX, MX, UX, VX;
      function xX(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function FX(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? xX(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xX(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let BX = (AX = jX(IX.SEND_ONLY), bX = jX(IX.SEND_ONLY), wX = jX(), OX = jX(IX.RECEIVE_ONLY), NX = jX(IX.RECEIVE_ONLY), DX = jX(IX.RECEIVE_ONLY), PX = jX(IX.RECEIVE_ONLY), LX = jX(IX.RECEIVE_ONLY), kX = jX(IX.RECEIVE_ONLY), MX = jX(), UX = jX(IX.RECEIVE_ONLY), VX = class extends NO {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(vx.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), iA(this, "isPlanB", false), iA(this, "store", void 0), iA(this, "statsUploader", void 0), iA(this, "sendConnection", void 0), iA(this, "recvConnection", void 0), iA(this, "localTrackMap", /* @__PURE__ */ new Map()), iA(this, "remoteUserMap", /* @__PURE__ */ new Map()), iA(this, "localDataChannels", []), iA(this, "pendingLocalTracks", []), iA(this, "pendingRemoteTracks", []), iA(this, "statsCollector", void 0), iA(this, "dtlsFailedCount", 0), iA(this, "sendMutex", void 0), iA(this, "recvMutex", void 0), iA(this, "_state", Cx.Disconnected), iA(this, "_restartStates", ["disconnected", "failed"]), iA(this, "reconnectInterval", void 0), iA(this, "uploadUnplinkStarted", false), iA(this, "uploadDownlinkStarted", false), iA(this, "uplinkStateUploadInterval", void 0), iA(this, "downlinkStatsUploadInterval", void 0), iA(this, "handleMuteLocalTrack", (async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== Cx.Connected) return void i2(new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
              const s2 = this.filterTobeMutedTracks(e3);
              if (0 === s2.length) return void t3();
              const a2 = s2.find(((e4) => "videoLowTrack" === e4[0]));
              if (a2) {
                a2[1].track._originMediaStreamTrack.stop();
              }
              await this.sendConnection.muteLocal(s2.map(((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              })));
              let c2 = false;
              var r2, o2;
              if ("video" === e3.trackMediaType) c2 = !(null === (r2 = this.localTrackMap.get(Rx.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
              else c2 = void 0 === (null === (o2 = this.localTrackMap.get(Rx.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.id);
              const d2 = this.createMuteMessage(s2);
              await qO(this, vx.RequestMuteLocal, d2);
              const l2 = "video" === e3.trackMediaType ? Mx.MUTE_LOCAL_VIDEO : Mx.MUTE_LOCAL_AUDIO;
              await qO(this, vx.RequestP2PMuteLocal, { action: l2, message: d2, isMuteAll: c2 }), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleUnmuteLocalTrack", (async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== Cx.Connected) return void i2(new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t3();
              await this.sendConnection.unmuteLocal(r2.map(((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              })));
              const o2 = this.createUnmuteMessage(r2), s2 = "video" === e3.trackMediaType ? Mx.UNMUTE_LOCAL_VIDEO : Mx.UNMUTE_LOCAL_AUDIO;
              await qO(this, vx.RequestP2PMuteLocal, { action: s2, message: o2 }), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleUpdateVideoEncoder", (async (e3, t3, i2, n2) => {
            let r2;
            "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoEncoder"));
            try {
              const i3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== Cx.Connected) return void t3();
              const { id: n3, track: s2 } = i3;
              n3 && (await this.sendConnection.updateSendParameters(n3, s2), await this.sendConnection.updateEncoderConfig(n3, s2), this.emit(vx.UpdateVideoEncoder, s2)), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          })), iA(this, "handleUpdateVideoSendParameters", (async (e3, t3, i2) => {
            const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoSendParameters");
            try {
              const i3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== Cx.Connected) return void t3();
              const { id: r2, track: o2 } = i3;
              r2 && await this.sendConnection.updateSendParameters(r2, o2), t3();
            } catch (e4) {
              i2(e4);
            } finally {
              n2();
            }
          })), iA(this, "handleReplaceTrack", (async (e3, t3, i2, n2) => {
            let r2;
            iP.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
            try {
              var o2;
              const i3 = Array.from(this.localTrackMap.entries()).find(((t4) => {
                let [, { track: i4 }] = t4;
                return e3 === i4;
              }));
              if (!this.sendConnection || !i3 || void 0 === i3[1].id || this.state !== Cx.Connected) return void t3();
              if (await (null === (o2 = this.sendConnection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i3[1].id)), i3[0] === Rx.LocalVideoTrack && pP().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
                if (t4) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new rp(((e4, i5) => {
                    this.handleReplaceTrack(t4.track, e4, i5, true);
                  }));
                }
              }
              t3();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          })), iA(this, "handleGetLocalVideoStats", ((e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          })), iA(this, "handleGetLocalAudioStats", ((e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          })), iA(this, "handleGetRemoteVideoStats", ((e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid])), iA(this, "handleGetRemoteAudioStats", ((e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid])), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new iG(e2), this.bindStatsUploaderEvents(), this.sendMutex = new PN("P2PChannel2-send-mutex", e2.clientId), this.recvMutex = new PN("P2PChannel2-recv-mutex", e2.clientId), this.reconnectInterval = window.setInterval((() => {
            [this.sendConnection, this.recvConnection].forEach(((e3) => {
              e3 && ("disconnected" !== e3.iceConnectionState && "failed" !== e3.iceConnectionState || this.handleDisconnect(e3.direction));
            }));
          }), CD("ICE_RESTART_INTERVAL"));
        }
        async startP2PConnection(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
        }
        async connect(e2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support connect.");
        }
        async startP2P(e2, t2) {
          let i2;
          try {
            if (t2) {
              this.recvConnection && (iP.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i2 = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new vX(e2, this.store, GV.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
              const n2 = await this.recvConnection.establish(t2);
              return { iceParameters: n2.iceParameters, dtlsParameters: n2.dtlsParameters, sdp: n2.sdp };
            }
            {
              this.state = Cx.New, this.sendConnection && (iP.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i2 = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new vX(e2, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
              const t3 = await this.sendConnection.establish();
              return { iceParameters: t3.iceParameters, dtlsParameters: t3.dtlsParameters, sdp: t3.sdp };
            }
          } finally {
            i2 && i2();
          }
        }
        async p2pConnect(e2) {
          if (!this.sendConnection) throw new pO(hO.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
          this.store.peerConnectionStart(), await this.sendConnection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Cx.Connected;
        }
        async addRemoteCandidate(e2, t2) {
          if (t2 === GV.RECEIVE_ONLY) {
            if (!this.sendConnection) throw new pO(hO.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.sendConnection.addRemoteCandidate(e2);
          } else {
            if (!this.recvConnection) throw new pO(hO.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.recvConnection.addRemoteCandidate(e2);
          }
        }
        publish(e2, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.sendMutex.lock("From P2PChannel.publish"));
            try {
              if (!n2.sendConnection || n2.state !== Cx.Connected) {
                n2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter(((e3) => -1 === n2.pendingLocalTracks.indexOf(e3)));
                return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
              }
              n2.store.pubId = n2.store.pubId + 1, tj.markPublishStart(n2.store.clientId, n2.store.pubId);
              const o2 = n2.filterTobePublishedTracks(e2, t2, i2);
              if (0 === o2.length) return void (yield Vb(n2.tryToUnmuteAudio(e2)));
              o2.forEach(((e3) => {
                let { track: t3, type: i3 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i3 === Rx.LocalAudioTrack ? "audio" : "video", r3);
              })), n2.bindLocalTrackEvents(o2);
              const s2 = yield Vb(n2.sendConnection.send(o2.map(((e3) => {
                let { track: t3 } = e3;
                return t3;
              })), n2.store.codec, n2.store.audioCodec)), a2 = (yield Vb(s2.next())).value, c2 = n2.createGatewayPublishMessage(o2, a2);
              try {
                yield c2;
              } catch (e3) {
                throw s2.throw(e3), (null == e3 ? void 0 : e3.code) === hO.WS_ABORT && o2.forEach(((e4) => {
                  let { track: t3 } = e4;
                  -1 === n2.pendingLocalTracks.indexOf(t3) && n2.pendingLocalTracks.push(t3);
                })), n2.unbindLocalTrackEvents(o2), e3;
              }
              yield Vb(s2.next()), o2.forEach(((e3) => {
                let { type: t3 } = e3;
                n2.statsCollector.addLocalStats(t3);
              })), n2.statsUploader.startUploadOutboundStats(), n2.assignLocalTracks(o2, a2), o2.forEach(((e3) => {
                let { track: t3, type: i3 } = e3;
                const r3 = Date.now();
                n2.store.publish(t3.getTrackId(), i3 === Rx.LocalAudioTrack ? "audio" : "video", void 0, r3);
              })), n2.startUploadUplinkState();
            } finally {
              r2();
            }
          }))();
        }
        async unpublish(e2) {
          if (!this.sendConnection || this.state !== Cx.Connected) return void (0 === e2.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter(((t3) => !Ln(e2).call(e2, t3))));
          const t2 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t2.length) return;
          const i2 = t2.find(((e3) => "videoLowTrack" === e3[0]));
          if (i2) {
            i2[1].track.close();
          }
          const n2 = this.createGatewayUnpublishMessage(t2);
          if (await this.sendConnection.stopSending(t2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }))), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map(((e3) => {
            let [t3, { track: i3 }] = e3;
            return { type: t3, track: i3 };
          }))), t2.forEach(((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          })), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === Cx.Connected) {
            if (i2) {
              i2[1].track.close();
            }
            return n2;
          }
          e2.forEach(((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          }));
        }
        startUploadUplinkState() {
          if (this.uploadUnplinkStarted) return;
          this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
          const e2 = () => {
            const e3 = [], t2 = [];
            Array.from(this.localTrackMap.entries()).forEach(((i2) => {
              let [n2, { track: r2, ssrcs: o2 }] = i2;
              const s2 = { stream_type: Oj(r2, n2), ssrcs: o2 };
              r2._muted || !r2._enabled ? e3.push(s2) : t2.push(s2);
            })), e3.length > 0 && e3.forEach(((e4) => {
              qO(this, vx.RequestMuteLocal, [e4]);
            })), t2.length > 0 && t2.forEach(((e4) => {
              qO(this, vx.RequestUnmuteLocal, [e4]);
            }));
          };
          e2(), this.uplinkStateUploadInterval = window.setInterval((() => {
            e2();
          }), 3e3);
        }
        stopUploadUplinkState() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
        }
        publishLowStream(e2) {
          return Mb((function* () {
            throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
          }))();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (iP.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await zO(this, vx.RequestRePublish, this.pendingLocalTracks), this.emit(vx.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async unpublishLowStream() {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
        }
        async subscribe(e2, t2, i2, n2) {
          var r2;
          if (!this.recvConnection) throw new pO(hO.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          if (null !== (r2 = this.remoteUserMap.get(e2)) && void 0 !== r2 && r2.has(t2)) return;
          const { track: o2, mid: s2, transceiver: a2 } = await this.recvConnection.receive(t2, [{ ssrcId: i2 }], String(e2.uid), n2);
          t2 === fx.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(o2) : (e2._audioTrack = new $M(o2, e2.uid, e2._uintid, this.store), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), a2 && e2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoSSRC = i2, e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(o2) : (e2._videoTrack = new ZM(o2, e2.uid, e2._uintid, this.store), iP.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), a2 && e2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const c2 = this.remoteUserMap.get(e2);
          c2 ? c2.set(t2, s2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, s2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
          const d2 = this.pendingRemoteTracks.findIndex(((i3) => {
            let { user: n3, kind: r3 } = i3;
            return n3.uid === e2.uid && t2 === r3;
          }));
          -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(vx.MediaReconnectEnd, e2.uid));
        }
        async mockSubscribe(e2, t2, i2, n2) {
          if (!this.recvConnection) throw new pO(hO.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          await this.recvConnection.mockReceive(t2, [{ ssrcId: i2 }], String(e2.uid), n2);
        }
        async unsubscribe(e2, t2, i2) {
          const n2 = this.pendingRemoteTracks.filter(((i3) => {
            let { user: n3, kind: r3 } = i3;
            return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
          }));
          if (n2.forEach(((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          })), this.recvConnection || i2 || n2.forEach(((t3) => {
            let { kind: i3 } = t3;
            var n3;
            if (i3 === fx.AUDIO) null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
            else if (i3 === fx.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          })), !this.recvConnection) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
          0 !== r2.length && (await this.recvConnection.stopReceiving(r2.map(((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }))), this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r2.forEach(((e3) => {
            let [t3, { kind: n3 }] = e3;
            var r3, o2;
            n3 === fx.VIDEO && t3._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (n3 === fx.VIDEO) this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (o2 = t3._videoTrack) || void 0 === o2 || o2._destroy(), t3._videoTrack = void 0);
            else if (n3 === fx.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2) null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
            }
          })), r2.forEach(((e3) => {
            let [, { kind: t3 }] = e3;
            qO(this, vx.RequestP2PMuteRemote, t3);
          })));
        }
        startUploadDownlinkState() {
          if (this.uploadDownlinkStarted) return;
          this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
          const e2 = () => Array.from(this.remoteUserMap.entries()).forEach(((e3) => {
            let [, t2] = e3;
            [fx.VIDEO, fx.AUDIO].forEach(((e4) => {
              t2.has(e4) ? qO(this, vx.RequestP2PUnmuteRemote, e4) : qO(this, vx.RequestP2PMuteRemote, e4);
            }));
          }));
          e2(), this.downlinkStatsUploadInterval = window.setInterval((() => {
            e2();
          }), 3e3);
        }
        stopUploadDownlinkState() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        async massSubscribe(e2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
        }
        async massSubscribeNoLock(e2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
        }
        async massUnsubscribe(e2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
        }
        async massUnsubscribeNoLock(e2) {
          throw new pO(hO.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
        }
        async muteRemote(e2, t2) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t2)) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          const n2 = t2 === fx.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n2 && this.recvConnection.setStatsRemoteVideoIsReady(n2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void iP.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t2) || iP.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if ((null == t2 ? void 0 : t2.track) instanceof Wk) {
            const i2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter(((e3) => {
              let [t3] = e3;
              return t3 !== Rx.LocalAudioTrack;
            })).filter(((t3) => {
              let [i3] = t3;
              return !(e2 && i3 === Rx.LocalVideoLowTrack);
            })).map(((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            })).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter(((t3) => {
            let [i2] = t3;
            return !(e2 && i2 === Rx.LocalVideoLowTrack);
          })).map(((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          }));
        }
        reportPublishEvent(e2, t2, i2, n2, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(Rx.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(Rx.LocalVideoLowTrack) : this.localTrackMap.get(Rx.LocalVideoTrack);
            lP.publish(this.store.sessionId, { eventElapse: tj.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(VP.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i2 || (i2 = []);
            const s2 = i2.find(((e3) => e3 instanceof Bk)), a2 = n2 ? null === (o2 = this.localTrackMap.get(Rx.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find(((e3) => e3 instanceof kM));
            lP.publish(this.store.sessionId, { eventElapse: tj.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(VP.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t2, i2, n2) {
          const r2 = n2 === fx.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && lP.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === fx.VIDEO, audio: n2 === fx.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === fx.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: tj.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          iP.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new PN("P2PChannel2-send-mutex", this.store.clientId), this.sendMutex = new PN("P2PChannel2-recv-mutex", this.store.clientId), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof Wk) {
            if (e2.track.trackList.length > 0) {
              const t2 = e2.track;
              e2.track.trackList.forEach(((e3) => {
                t2.removeAudioTrack(e3);
              }));
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = Cx.Disconnected;
        }
        getStats(e2) {
          var t2, i2;
          return e2 ? null === (i2 = this.recvConnection) || void 0 === i2 ? void 0 : i2.getStats() : null === (t2 = this.sendConnection) || void 0 === t2 ? void 0 : t2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return (null === (t2 = this.recvConnection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(Rx.LocalVideoTrack);
          if (e2) return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof kM || t2 && t2.track instanceof Bk ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t2 || i2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3.uid === e2));
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map(((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          }));
          const t2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Qp(e2).call(e2, ((e3, t3) => e3.level - t3.level)), e2;
        }
        async disconnectForReconnect() {
          this.sendConnection && this.recvConnection && (iP.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = Cx.Reconnecting, CD("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2] = e2;
            var i2;
            t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
          })), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(((e2) => {
            var t2;
            let [i2, { track: n2 }] = e2;
            switch (i2) {
              case Rx.LocalVideoTrack:
                Ln(t2 = n2._hints).call(t2, VP.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                break;
              case Rx.LocalAudioTrack:
                n2 instanceof Wk ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
              case Rx.LocalVideoLowTrack:
            }
          })), this.emit(vx.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            Array.from(WD(i2).call(i2)).forEach(((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            })), this.emit(vx.MediaReconnectStart, t2.uid);
          })), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), iP.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n2, kind: r2 } = i2;
            if ((e2 instanceof aj ? e2.uid : e2) === n2.uid && t2 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        async restartICE(e2, t2) {
          let i2, n2;
          if (e2 === GV.SEND_ONLY) {
            if (!this.sendConnection) throw new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
            i2 = await this.sendMutex.lock("From P2PChannel.restartICE"), n2 = this.sendConnection;
          } else {
            if (!this.recvConnection) throw new pO(hO.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
            i2 = await this.recvMutex.lock("From P2PChannel.restartICE"), n2 = this.recvConnection;
          }
          try {
            if (t2) {
              const e3 = await n2.restartICE(t2);
              return n2.isInRestartIce = false, e3;
            }
            {
              const e3 = await n2.restartICE();
              if (e3) {
                const t3 = await zO(this, vx.RequestP2PRestartICE, { direction: GV.RECEIVE_ONLY, iceParameter: e3 });
                await n2.restartICE(t3), n2.isInRestartIce = false;
              }
            }
          } finally {
            i2();
          }
        }
        getUplinkNetworkQuality() {
          if (!this.sendConnection) return 0;
          const e2 = this.sendConnection.getStats(), t2 = this.localTrackMap.get(Rx.LocalVideoTrack), i2 = this.localTrackMap.get(Rx.LocalAudioTrack), n2 = e2.videoSend.find(((e3) => {
            var i3;
            return e3.ssrc === (null == t2 || null === (i3 = t2.ssrcs) || void 0 === i3 ? void 0 : i3[0].ssrcId);
          })), r2 = e2.audioSend.find(((e3) => {
            var t3;
            return e3.ssrc === (null == i2 || null === (t3 = i2.ssrcs) || void 0 === t3 ? void 0 : t3[0].ssrcId);
          }));
          if (!n2 || !r2) return 1;
          const o2 = XO(this, vx.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t2 ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(VP.SCREEN_TRACK)) {
            const t3 = h2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t3 && i3) {
              const e3 = (1e3 * t3 - i3) / (1e3 * t3);
              return HU[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u2];
            }
          }
          return u2;
        }
        getDownlinkNetworkQuality() {
          if (!this.recvConnection) return 0;
          const e2 = this.recvConnection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach(((i2) => {
            let [n2] = i2;
            const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find(((e3) => e3.ssrc === r2)), a2 = e2.videoRecv.find(((e3) => e3.ssrc === o2));
            if (!s2 && !a2) return void (t2 += 1);
            const c2 = XO(this, vx.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, u2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u2 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u2 / 400);
            t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          })), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new rp(((t2, i2) => {
            this.handleMuteLocalTrack(e2, t2, i2);
          }));
        }
        filterTobePublishedTracks(e2, t2, i2) {
          const n2 = [], r2 = pP(), o2 = this.getAllTracks();
          e2 = rN(e2 = e2.filter(((e3) => -1 === o2.indexOf(e3))));
          let s2 = false, a2 = false;
          for (const o3 of e2) {
            if (o3 instanceof kM && (this.localTrackMap.has(Rx.LocalVideoTrack) || s2 ? new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: o3, type: Rx.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(o3, i2);
              n2.push({ track: e3, type: Rx.LocalVideoLowTrack });
            }
            if (o3 instanceof Bk) {
              const e3 = this.localTrackMap.get(Rx.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof Wk)) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
              } else if (a2) {
                const e4 = n2.find(((e5) => {
                  let { type: t3 } = e5;
                  return t3 === Rx.LocalAudioTrack;
                }));
                if (!(e4.track instanceof Wk)) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o3);
              } else {
                if (!r2.webAudioMediaStreamDest || o3 instanceof Wk || o3._bypassWebAudio) n2.push({ track: o3, type: Rx.LocalAudioTrack });
                else {
                  const e4 = new Wk();
                  e4.addAudioTrack(o3), n2.push({ track: e4, type: Rx.LocalAudioTrack });
                }
                a2 = true;
              }
            }
          }
          return n2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], i2 = this.getAllTracks();
          e2 = rN(e2 = e2.filter(((e3) => -1 !== i2.indexOf(e3))));
          for (const i3 of e2) {
            if (i3 instanceof Bk) {
              const e3 = this.localTrackMap.get(Rx.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof Wk ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([Rx.LocalAudioTrack, e3]), e3.track.close())) : t2.push([Rx.LocalAudioTrack, e3]);
            }
            if (i3 instanceof kM) {
              const e3 = this.localTrackMap.get(Rx.LocalVideoTrack);
              if (!e3) continue;
              t2.push([Rx.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
              i4 && t2.push([Rx.LocalVideoLowTrack, i4]);
            }
          }
          return t2;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach(((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case Rx.LocalVideoTrack:
                t2.addListener(UP.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(UP.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.addListener(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Rx.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
              case Rx.LocalVideoLowTrack:
            }
          }));
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof Wk ? e2.trackList.forEach(((e3) => {
            e3.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(UP.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          })) : (e2.addListener(UP.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map(((e3) => {
            let [t2, { track: i2 }] = e3;
            return { track: i2, type: t2 };
          }))), e2.forEach(((e3) => {
            let { track: t2, type: i2 } = e3;
            switch (i2) {
              case Rx.LocalVideoTrack:
                t2.off(UP.GET_STATS, this.handleGetLocalVideoStats), t2.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(UP.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(UP.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t2.off(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Rx.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
              case Rx.LocalVideoLowTrack:
            }
          }));
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof Wk ? e2.trackList.forEach(((e3) => {
            e3.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(UP.GET_STATS, this.handleGetLocalAudioStats), e3.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          })) : (e2.off(UP.GET_STATS, this.handleGetLocalAudioStats), e2.off(UP.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(UP.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(UP.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(UP.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(UP.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof ZM && t2.addListener(UP.GET_STATS, ((t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          })), t2 instanceof $M && t2.addListener(UP.GET_STATS, ((t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          }));
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(UP.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            i2.has(fx.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(fx.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          }));
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map(((e3, i2) => {
            var n2;
            let r2, { track: o2, type: s2 } = e3;
            switch (s2) {
              case Rx.LocalAudioTrack:
                r2 = ox.Audio;
                break;
              case Rx.LocalVideoTrack:
                r2 = Ln(n2 = o2._hints).call(n2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalVideoLowTrack:
                r2 = ox.Low;
            }
            return { kind: s2 === Rx.LocalAudioTrack ? fx.AUDIO : fx.VIDEO, stream_type: r2, mid: t2[i2].id, ssrcs: t2[i2].localSSRC, isMuted: o2.muted || !o2.enabled };
          }));
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        assignLocalTracks(e2, t2) {
          e2.forEach(((e3, i2) => {
            let { track: n2, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
          }));
        }
        withdrawLocalTracks(e2) {
          e2.forEach(((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          }));
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            var i2;
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(e2.name, ".onConnectionStateChange(").concat(t2, ")")), this.emit(vx.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (e2.isInRestartIce = false), Ln(i2 = this._restartStates).call(i2, t2) && !e2.isInRestartIce && ("disconnected" === t2 && await fN(800), "disconnected" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || this.handleDisconnect(e2.direction));
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), lP.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: kO.TRACER }).onSuccess(), this.emit(vx.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._audioSSRC === e3));
            var n2;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(WP.FIRST_FRAME_DECODED), lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_AUDIO_DECODE, aP.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._audioSSRC === e3));
            i2 && lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_AUDIO_RECEIVED, aP.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
            this.reportVideoFirstFrameDecoded(e3, t2, i2);
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const i2 = Array.from(WD(t2 = this.remoteUserMap).call(t2)).find(((t3) => t3._videoSSRC === e3));
            i2 && lP.firstRemoteFrame(this.store.sessionId, sP.FIRST_VIDEO_RECEIVED, aP.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
            "unknown" !== t2.candidateType && i2 === n2 || this.emit(vx.ConnectionTypeChange, i2), iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(EF(t2)), " -> ").concat(JSON.stringify(EF(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            iP.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(EF(t2)), " -> ").concat(JSON.stringify(EF(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.onLocalCandidate = (t2) => {
            this.emit(vx.LocalCandidate, { candidate: t2, direction: e2.direction });
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0, e2.onLocalCandidate = void 0;
        }
        async handleDisconnect(e2) {
          const t2 = e2 === GV.SEND_ONLY ? this.sendConnection : this.recvConnection;
          t2 && !t2.isInRestartIce && (t2.isInRestartIce = true, iP.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(t2.name, "] start use restartICE")), e2 === GV.SEND_ONLY ? this.restartICE(e2) : zO(this, vx.RequestP2PRestartICE, { direction: GV.SEND_ONLY }));
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t2;
          const i2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2 instanceof Bk && (null == i2 ? void 0 : i2.track) instanceof Wk) return i2.track.isActive || t2.push([Rx.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find(((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          }));
          if (n2 && (t2.push(n2), n2[0] === Rx.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
            e3 && t2.push([Rx.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], i2 = this.localTrackMap.get(Rx.LocalAudioTrack);
          if (e2 instanceof Bk && (null == i2 ? void 0 : i2.track) instanceof Wk) return i2.track.isActive && t2.push([Rx.LocalAudioTrack, i2]), t2;
          const n2 = Array.from(this.localTrackMap.entries()).find(((t3) => {
            let [, { track: i3 }] = t3;
            return e2 === i3;
          }));
          if (n2) if (n2[0] === Rx.LocalVideoTrack) {
            t2.push(n2);
            const e3 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
            e3 && t2.push([Rx.LocalVideoLowTrack, e3]);
          } else t2.push(n2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        createUnmuteMessage(e2) {
          return e2.map(((e3) => {
            var t2;
            let i2, [n2, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n2) {
              case Rx.LocalAudioTrack:
                i2 = ox.Audio;
                break;
              case Rx.LocalVideoTrack:
                i2 = Ln(t2 = r2._hints).call(t2, VP.SCREEN_TRACK) ? ox.Screen : ox.High;
                break;
              case Rx.LocalVideoLowTrack:
                i2 = ox.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          }));
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const i2 = [], n2 = this.remoteUserMap.get(e2);
          if (!n2) return i2;
          if (t2) {
            const r2 = n2.get(t2);
            if (!r2) return i2;
            i2.push([e2, { kind: t2, id: r2 }]);
          } else Array.from(n2.entries()).forEach(((t3) => {
            let [n3, r2] = t3;
            i2.push([e2, { kind: n3, id: r2 }]);
          }));
          return i2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach(((e3) => {
            let [i2, { kind: n2, id: r2 }] = e3;
            switch (n2) {
              case fx.VIDEO:
                return void (i2._videoSSRC && t2.push({ stream_type: fx.VIDEO, ssrcId: i2._videoSSRC }));
              case fx.AUDIO:
                return void (i2._audioSSRC && t2.push({ stream_type: fx.AUDIO, ssrcId: i2._audioSSRC }));
            }
          })), t2;
        }
        withdrawRemoteTracks(e2) {
          e2.forEach(((e3) => {
            let [t2, { kind: i2 }] = e3;
            const n2 = this.remoteUserMap.get(t2);
            n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
          }));
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(Rx.LocalVideoTrack), i2 = this.localTrackMap.get(Rx.LocalVideoLowTrack);
          t2 && (await t2.track.setBitrateLimit(e2.uplink), await new rp(((e3, i3) => {
            this.handleUpdateVideoEncoder(t2.track, e3, i3, true);
          }))), i2 && e2.low_stream_uplink && (await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new rp(((e3, t3) => {
            this.handleUpdateVideoEncoder(i2.track, e3, t3, true);
          })));
        }
        isP2PDisconnected() {
          if (this.sendConnection && this.recvConnection) {
            const e2 = this.sendConnection.peerConnectionState, t2 = this.recvConnection.peerConnectionState;
            return "connected" !== e2 && "connected" !== t2;
          }
          return true;
        }
        async tryToUnmuteAudio(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) if (e2[t2] instanceof Bk) {
            const i2 = this.filterTobeUnmutedTracks(e2[t2]);
            if (0 === i2.length) continue;
            const n2 = this.createUnmuteMessage(i2);
            return void await qO(this, vx.RequestUnmuteLocal, n2);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = (e2) => this.getStats(e2), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter(((e2) => {
            let [, { ssrcs: t2 }] = e2;
            return !!t2;
          })), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !(null === (t2 = this.recvConnection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(vx.RequestUpload, e2, t2), this.statsUploader.requestUploadStats = (e2) => this.emit(vx.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await fN(MN(this.dtlsFailedCount, kN)), this.emit(vx.RequestReconnect);
        }
        async reconnectP2P() {
        }
        canPublishLowStream() {
          return this.localTrackMap.has(Rx.LocalVideoTrack) || this.pendingLocalTracks.some(((e2) => e2 instanceof kM));
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter(((e3) => e3 instanceof kM)).length > 1) throw new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter(((e3) => e3 instanceof Bk)).length > 1 && (e2.some(((e3) => e3 instanceof Bk && e3._bypassWebAudio)) || !pP().webAudioMediaStreamDest)) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof kM && this.pendingLocalTracks.some(((e3) => e3 instanceof kM))) throw new pO(hO.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof Bk && this.pendingLocalTracks.some(((e3) => e3 instanceof Bk)) && (!pP().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some(((e3) => e3 instanceof Bk && e3._bypassWebAudio)))) throw new pO(hO.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const i2 = !CD("DISABLE_DUAL_STREAM_USE_ENCODING") && pP().supportDualStreamEncoding, n2 = FX(FX({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let r2;
          r2 = i2 ? e2._mediaStreamTrack.clone() : jj(e2, n2);
          const o2 = SN(8, "track-low-"), s2 = new kM(r2, FX(FX({}, i2 && { scaleResolutionDownBy: _F(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, o2);
          return s2.on(jP.TRANSCEIVER_UPDATED, ((t3) => {
            e2._updateRtpTransceiver(t3, xP.LOW_STREAM);
          })), s2._hints.push(VP.LOW_STREAM), e2.addListener(UP.NEED_CLOSE, (() => {
            s2.close();
          })), s2;
        }
        async globalLock() {
          return this.recvMutex.lock("From P2PChannel2.globalLock");
        }
        reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
          var r2;
          const o2 = Array.from(WD(r2 = this.remoteUserMap).call(r2)).find(((t3) => t3._videoSSRC === e2));
          if (o2) {
            n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find(((e3) => e3.userId === o2.uid && "video" === e3.type));
            lP.firstRemoteVideoDecode(this.store.sessionId, sP.FIRST_VIDEO_DECODE, aP.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: tj.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t2, i2) {
          if (!this.recvConnection) return false;
          const n2 = this.remoteUserMap.get(e2);
          if (!n2) return false;
          const r2 = n2.get(t2);
          if (!r2) return false;
          const o2 = await this.recvConnection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i2;
        }
        isPreSubScribe(e2) {
          return false;
        }
        async publishDataChannel(e2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        async unpublishDataChannel(e2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        async subscribeDataChannel(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        async unsubscribeDataChannel(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        hasPendingRemoteDataChannel(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        setPendingRemoteDataChannel(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        async preConnect(e2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        getEstablishParams() {
          throw new pO(hO.NOT_SUPPORTED);
        }
        async reSubscribe(e2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        reportVideoFirstFrameRender(e2) {
        }
        async updateVideoStreamParameter(e2, t2) {
          throw new pO(hO.NOT_SUPPORTED);
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach(((e2) => {
            let [t2, { track: i2 }] = e2;
            t2 === Rx.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, xP.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          }));
        }
      }, DV(VX.prototype, "p2pConnect", [AX], Object.getOwnPropertyDescriptor(VX.prototype, "p2pConnect"), VX.prototype), DV(VX.prototype, "unpublish", [bX], Object.getOwnPropertyDescriptor(VX.prototype, "unpublish"), VX.prototype), DV(VX.prototype, "unpublishLowStream", [wX], Object.getOwnPropertyDescriptor(VX.prototype, "unpublishLowStream"), VX.prototype), DV(VX.prototype, "subscribe", [OX], Object.getOwnPropertyDescriptor(VX.prototype, "subscribe"), VX.prototype), DV(VX.prototype, "mockSubscribe", [NX], Object.getOwnPropertyDescriptor(VX.prototype, "mockSubscribe"), VX.prototype), DV(VX.prototype, "unsubscribe", [DX], Object.getOwnPropertyDescriptor(VX.prototype, "unsubscribe"), VX.prototype), DV(VX.prototype, "muteRemote", [PX], Object.getOwnPropertyDescriptor(VX.prototype, "muteRemote"), VX.prototype), DV(VX.prototype, "unmuteRemote", [LX], Object.getOwnPropertyDescriptor(VX.prototype, "unmuteRemote"), VX.prototype), DV(VX.prototype, "hasRemoteMediaWithLock", [kX], Object.getOwnPropertyDescriptor(VX.prototype, "hasRemoteMediaWithLock"), VX.prototype), DV(VX.prototype, "disconnectForReconnect", [MX], Object.getOwnPropertyDescriptor(VX.prototype, "disconnectForReconnect"), VX.prototype), DV(VX.prototype, "remoteMediaSsrcChanged", [UX], Object.getOwnPropertyDescriptor(VX.prototype, "remoteMediaSsrcChanged"), VX.prototype), VX);
      function jX(e2) {
        return function(t2, i2, n2) {
          const r2 = t2[i2];
          if ("function" != typeof r2) throw new Error("Cannot use mutex on object property.");
          return n2.value = async function() {
            for (var t3 = arguments.length, n3 = new Array(t3), o2 = 0; o2 < t3; o2++) n3[o2] = arguments[o2];
            switch (e2) {
              case IX.SEND_ONLY: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              case IX.RECEIVE_ONLY: {
                const e3 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3();
                }
              }
              default: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2)), t4 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n3);
                } finally {
                  e3(), t4();
                }
              }
            }
          }, n2;
        };
      }
      class GX extends NO {
        constructor(e2, t2) {
          super(), iA(this, "signal", void 0), iA(this, "token", void 0), iA(this, "tokenTimeout", void 0), iA(this, "tokenInterval", void 0), iA(this, "_sequence", 0), iA(this, "userMap", /* @__PURE__ */ new Map()), iA(this, "encoder", new TextEncoder()), this.signal = e2, this.token = t2;
          const i2 = () => {
            this.signal.connectionState === VV.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i2, 1e3) : this.tokenInterval = window.setTimeout(i2, 3 * CD("P2P_TOKEN_INTERVAL"));
          };
          i2();
        }
        async send(e2, t2, i2, n2, r2) {
          var o2;
          if (0 === this.userMap.size) return;
          const s2 = Array.from(pp(o2 = this.userMap).call(o2))[0].token;
          "string" != typeof t2 && (t2 = JSON.stringify(t2)), n2 = null != n2 ? n2 : SN(6, ""), r2 = null != r2 ? r2 : this._sequence++;
          const a2 = { _id: n2, _type: e2, _seq: r2, _message: t2, token: "".concat(this.token, "_").concat(s2) };
          CD("SHOW_P2P_LOG") && iP.debug("send message", a2, "noNeedResponse : ".concat(i2));
          this.splitMessage(JSON.stringify(a2)).forEach(((e3) => {
            this.signal.request(FV.DATA_STREAM, { payload: uN(this.encoder.encode(e3)) });
          }));
          const c2 = new rp(((t3, r3) => {
            const o3 = window.setTimeout((() => {
              this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), d2), this.off(kx.ABORT, c3), iP.debug("[external-signal] request timeout, type: ".concat(e2, ", requestId: ").concat(n2)), 0 === this.userMap.size ? r3(new pO(hO.INVALID_REMOTE_USER)) : r3(new pO(hO.TIMEOUT));
            }), CD("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), s3 = () => {
              o3 && window.clearTimeout(o3), this.off(kx.ABORT, c3), i2 && t3();
            }, c3 = () => {
              o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off("res-@".concat(n2), d2), r3(new pO(hO.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e2, ", requestId: ").concat(n2)));
            };
            this.once(kx.ABORT, c3), this.once("res-@".concat(n2, "_ack"), s3);
            const d2 = (i3, a3) => {
              l2 = true, o3 && window.clearTimeout(o3), this.off("res-@".concat(n2, "_ack"), s3), this.off(kx.ABORT, c3), "success" === i3 ? t3(a3) : r3(new pO(hO.P2P_MESSAGE_FAILED, "request ".concat(e2, " failed, requestId: ").concat(n2)));
            };
            let l2 = false;
            i2 || (this.once("res-@".concat(n2), d2), fN(CD("SIGNAL_REQUEST_TIMEOUT")).then((() => {
              l2 || iP.warning("external_signal request timeout, type: ".concat(e2, ", requestId: ").concat(n2, ", ").concat(a2));
            })));
          }));
          try {
            return await c2;
          } catch (o3) {
            if (o3.code === hO.TIMEOUT) return await this.send(e2, t2, i2, n2, r2);
            throw o3;
          }
        }
        onMessage(e2) {
          var t2;
          const { _uid: i2 } = e2;
          let n2, r2 = this.userMap.get(i2);
          if (r2) n2 = r2.splitMessageMap;
          else {
            if (this.userMap.size > 0 || !("_type" in e2) || e2._type !== Lx.CHECK) return;
            const { token: t3 } = e2;
            n2 = /* @__PURE__ */ new Map(), r2 = { uid: i2, isStart: true, token: t3, splitMessageMap: n2, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i2, r2), this.signal.emit(jV.ON_USER_ONLINE, { uid: i2 }), this.handleUserOnline();
          }
          if ("id" in e2 && "total" in e2) {
            var o2;
            const { id: t3, total: r3 } = e2, s3 = null !== (o2 = n2.get(t3)) && void 0 !== o2 ? o2 : [];
            if (s3.push(e2), n2.has(t3) || n2.set(t3, s3), s3.length !== r3) return;
            {
              const r4 = Qp(s3).call(s3, ((e3, t4) => e3.index - t4.index)).map(((e3) => e3.payload)).join("");
              n2.delete(t3), (e2 = JSON.parse(r4))._uid = i2;
            }
          }
          const { _type: s2, token: a2 } = e2;
          if (Ln(t2 = [Lx.ACK, Lx.CHECK]).call(t2, s2)) return s2 === Lx.CHECK && this.handleCheckToken(r2, a2), void this.receiveMessage(e2);
          a2 === "".concat(r2.token, "_").concat(this.token) ? this.handleReceivedMessage(e2) : iP.debug('Receive unexpected message", '.concat(a2, ", cur_token: ").concat(r2.token, "_").concat(this.token), e2);
        }
        check() {
          const e2 = { _id: SN(6, ""), token: this.token, _type: Lx.CHECK };
          CD("SHOW_P2P_LOG") && iP.debug("send message", e2), this.signal.request(FV.DATA_STREAM, { payload: uN(this.encoder.encode(JSON.stringify(e2))) });
        }
        ack(e2) {
          const t2 = { _id: e2, _type: Lx.ACK, token: this.token };
          CD("SHOW_P2P_LOG") && iP.debug("send message", t2), this.signal.request(FV.DATA_STREAM, { payload: uN(this.encoder.encode(JSON.stringify(t2))) });
        }
        response(e2, t2, i2) {
          this.send(Lx.RESPONSE, JSON.stringify({ success: !i2, message: t2 }), true, e2);
        }
        handleReceivedMessage(e2) {
          const t2 = () => {
            this.userMap.forEach(((e3) => {
              const { receivedMessagesMap: t3, nextExpectedSequenceNumber: i3 } = e3;
              for (; t3.has(i3); ) {
                const n3 = t3.get(i3);
                t3.delete(i3), this.receiveMessage(n3), e3.nextExpectedSequenceNumber++;
              }
            }));
          };
          if (!e2) return void t2();
          const { _uid: i2, _seq: n2 } = e2, r2 = this.userMap.get(i2), { receivedMessagesMap: o2, isStart: s2, nextExpectedSequenceNumber: a2 } = r2;
          if (n2 < a2) return this.ack(e2._id), void iP.debug("[external-signal] receive old message, seq: ".concat(n2, ", ").concat(e2._message));
          o2.set(n2, e2), s2 && n2 === a2 && (this.receiveMessage(e2), o2.delete(a2), r2.nextExpectedSequenceNumber++, t2());
        }
        receiveMessage(e2) {
          const { _id: t2, _type: i2, _message: n2, _uid: r2 } = e2;
          if (CD("SHOW_P2P_LOG") && iP.debug("receive message", e2), t2) {
            let o2;
            switch (e2._type !== Lx.ACK && (n2 && (o2 = JSON.parse(n2)), this.ack(e2._id)), e2._type) {
              case Lx.CANDIDATE:
              case Lx.CONTROL:
                this.signal.emit(i2, o2, r2);
                break;
              case Lx.PUBLISH:
              case Lx.UNPUBLISH:
              case Lx.RESTART_ICE:
              case Lx.CALL:
                o2.uid = r2, zO(this.signal, i2, o2).then(((t3) => {
                  this.response(e2._id, t3);
                })).catch((() => {
                  this.response(e2._id, void 0, true);
                }));
                break;
              case Lx.ACK:
                this.getListeners("res-@".concat(t2, "_ack")).length > 0 && this.emit("res-@".concat(t2, "_ack"));
                break;
              case Lx.RESPONSE: {
                const { success: e3, message: i3 } = o2;
                this.emit("res-@".concat(t2), e3 ? "success" : "failed", i3);
                break;
              }
            }
          }
        }
        splitMessage(e2) {
          if (e2.length < GX.MAX_MESSAGE_SIZE) return [e2];
          const t2 = [], { remoteToken: i2 } = JSON.parse(e2), n2 = SN(6, "");
          let r2 = 0, o2 = 800;
          const s2 = Math.ceil(e2.length / o2);
          for (; e2.length > 0; ) {
            r2++;
            const a2 = { id: n2, index: r2, total: s2, payload: e2.slice(0, o2), token: "".concat(this.token, "_").concat(i2) };
            JSON.stringify(a2).length > GX.MAX_MESSAGE_SIZE ? o2 -= 50 : (t2.push(a2), e2 = e2.slice(o2));
          }
          return t2.map(((e3) => JSON.stringify(e3)));
        }
        handleCheckToken(e2, t2) {
          return e2.token !== t2 ? (iP.debug("token changed, from ".concat(e2.token, " to ").concat(t2)), this.reset(e2.uid, t2), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout((() => {
            iP.debug("token timeout, ".concat(t2)), this.reset(e2.uid);
          }), CD("MAX_P2P_TIMEOUT")), true);
        }
        async handleUserOnline() {
          const e2 = await zO(this.signal, Lx.CALL, void 0), t2 = await this.send(Lx.CALL, e2);
          this.signal.emit(xV.P2P_CONNECTION, t2, true);
        }
        async reset(e2, t2) {
          const i2 = this.userMap.get(e2);
          i2 && (this.emit(kx.ABORT), this.signal.emit(jV.ON_USER_OFFLINE, { uid: i2.uid, reason: Ux.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), t2 || (iP.debug("change local token from ".concat(t2, " to ").concat(t2)), this.token = SN(6, "")));
        }
        clear() {
          this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(kx.ABORT);
        }
      }
      iA(GX, "MAX_SIZE", 1), iA(GX, "MAX_MESSAGE_SIZE", 1024);
      class WX extends NO {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === VV.CONNECTED ? this.emit(xV.WS_CONNECTED) : e2 === VV.RECONNECTING ? this.emit(xV.WS_RECONNECTING, this._websocketReconnectReason) : e2 === VV.CLOSED && this.emit(xV.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), iA(this, "__name__", "P2PSignal"), iA(this, "_disconnectedReason", void 0), iA(this, "_websocketReconnectReason", void 0), iA(this, "_connectionState", VV.CLOSED), iA(this, "reconnectToken", void 0), iA(this, "p2pToken", void 0), iA(this, "websocket", void 0), iA(this, "openConnectionTime", void 0), iA(this, "clientId", void 0), iA(this, "lastMsgTime", Date.now()), iA(this, "uploadCache", []), iA(this, "uploadCacheInterval", void 0), iA(this, "rttRolling", new xN(5)), iA(this, "pingpongTimer", void 0), iA(this, "pingpongTimeoutCount", 0), iA(this, "joinResponse", void 0), iA(this, "multiIpOption", void 0), iA(this, "initError", void 0), iA(this, "spec", void 0), iA(this, "store", void 0), iA(this, "_external_signal", void 0), iA(this, "onWebsocketMessage", ((e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(xV.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
              switch (t3._type) {
                case jV.ON_DATA_STREAM:
                  return void this.handleDataStream(t3._message);
                case jV.MUTE_AUDIO:
                case jV.MUTE_VIDEO:
                case jV.ON_P2P_LOST:
                case jV.ON_USER_ONLINE:
                  return;
                case jV.ON_USER_OFFLINE:
                  const { uid: e4 } = t3._message;
                  return iP.debug("[".concat(this.clientId, "] user-offline uid: ").concat(e4)), void this._external_signal.reset(e4);
              }
              if (this.emit(t3._type, t3._message), t3._type === jV.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === jV.ON_USER_BANNED) switch (t3._message.error_code) {
                case 14:
                  this.close(VO.UID_BANNED);
                  break;
                case 15:
                  this.close(VO.IP_BANNED);
                  break;
                case 16:
                  this.close(VO.CHANNEL_BANNED);
              }
              if (t3._type === jV.ON_USER_LICENSE_BANNED) switch (t3._message.error_code) {
                case UV.ERR_LICENSE_MISSING:
                  this.close(VO.LICENSE_MISSING);
                  break;
                case UV.ERR_LICENSE_EXPIRED:
                  this.close(VO.LICENSE_EXPIRED);
                  break;
                case UV.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(VO.LICENSE_MINUTES_EXCEEDED);
                  break;
                case UV.ERR_LICENSE_PERIOD_INVALID:
                  this.close(VO.LICENSE_PERIOD_INVALID);
                  break;
                case UV.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(VO.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case UV.ERR_LICENSE_ILLEGAL:
                  this.close(VO.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          })), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new Zx("gateway-".concat(this.clientId), this.spec.retryConfig, true, CD("JOIN_GATEWAY_USE_DUAL_DOMAIN"), CD("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", (() => {
            this.connectionState === VV.CONNECTED && this.reconnect("retry", HO.OFFLINE);
          })), this.p2pToken = SN(6, ""), this._external_signal = new GX(this, this.p2pToken);
        }
        async request(e2, t2, i2, n2) {
          const r2 = SN(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new rp(((e3, t3) => {
            if (this.connectionState === VV.CONNECTED) return e3();
            const i3 = () => {
              this.off(xV.WS_CLOSED, n3), e3();
            }, n3 = () => {
              this.off(xV.WS_CONNECTED, i3), t3(new pO(hO.WS_ABORT));
            };
            this.once(xV.WS_CONNECTED, i3), this.once(xV.WS_CLOSED, n3);
          }));
          if (this.connectionState !== VV.CONNECTING && this.connectionState !== VV.RECONNECTING || e2 === FV.JOIN || e2 === FV.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2) return;
          const c2 = new rp(((i3, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.emit(xV.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new pO(hO.WS_ABORT, "type: ".concat(e2))), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(xV.WS_CLOSED, c3), this.once(xV.WS_RECONNECTING, c3), fN(CD("SIGNAL_REQUEST_TIMEOUT")).then((() => {
              this.websocket.connectionID !== s2 || o3 || (iP.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(xV.REQUEST_TIMEOUT, e2, t2));
            }));
          }));
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === VV.CLOSED || e2 === FV.LEAVE) throw new pO(hO.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === FV.JOIN || e2 === FV.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = Bx(l2), h2 = new pO(hO.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u2.desc });
          return "success" === u2.action ? d2.message : (iP.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === UV.ERR_TOO_MANY_BROADCASTERS ? e2 === FV.JOIN || e2 === FV.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === UV.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, iP.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", HO.MULTI_IP)) : this.reconnect(u2.action, HO.SERVER_ERROR), e2 === FV.JOIN || e2 === FV.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new rp(((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          }));
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void iP.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(BV.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = CD("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval((() => {
              if (this.connectionState !== VV.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }), CD("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(i2);
        }
        async sendExtensionMessage(e2, t2, i2) {
          return await this._external_signal.send(e2, t2, i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new rp(((t2, i2) => {
            this.once(xV.WS_CONNECTED, (() => t2(this.joinResponse))), this.once(xV.WS_CLOSED, (() => i2(this.initError || new pO(hO.WS_ABORT)))), this.connectionState = VV.CONNECTING, this.websocket.init(e2).catch(i2);
          }));
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e2 || VO.LEAVE, this.connectionState = VV.CLOSED, iP.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), this.p2pToken = SN(6, ""), this._external_signal.clear(), this._external_signal = new GX(this, this.p2pToken);
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(xV.ABORT_P2P_EXECUTION);
            const e2 = await zO(this, xV.REQUEST_JOIN_INFO), t2 = await this.request(FV.JOIN, e2);
            if (!t2) return this.emit(xV.REPORT_JOIN_GATEWAY, hO.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(xV.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        async downgradeCodec(e2) {
          return false;
        }
        handleDataStream(e2) {
          try {
            var t2;
            const i2 = lN(e2.payload), n2 = new TextDecoder().decode(i2), r2 = JSON.parse(n2);
            "total" in r2 && "id" in r2 || Ln(t2 = Object.values(Lx)).call(t2, r2._type) ? (r2._uid = e2.uid, this._external_signal.onMessage(r2)) : this.emit(jV.ON_DATA_STREAM, e2);
          } catch (t3) {
            this.emit(jV.ON_DATA_STREAM, e2);
          }
        }
        handleNotification(e2) {
          iP.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = Bx(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? e2.code === UV.ERR_REPEAT_JOIN_CHANNEL && CD("IGNORE_UID_CHECK") ? void this.close(VO.UID_CONFLICT) : ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(VO.UID_BANNED), void this.close()) : void this.reconnect(t2.action, HO.SERVER_ERROR);
            iP.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = CD("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (iP.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > CD("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", HO.TIMEOUT) : this.request(FV.PING, void 0, true).then((() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), CD("REPORT_STATS") && this.send(FV.PING_BACK, { pingpongElapse: e3 });
          })).catch(((e3) => {
          }));
        }
        handleWebsocketEvents() {
          this.websocket.on(WV.RECONNECT_CREATE_CONNECTION, ((e2) => {
            this.emit(xV.WS_RECONNECT_CREATE_CONNECTION, e2);
          })), this.websocket.on(WV.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(WV.CLOSED, (() => {
            this.connectionState = VV.CLOSED;
          })), this.websocket.on(WV.FAILED, (() => {
            this._disconnectedReason = VO.NETWORK_ERROR, this.connectionState = VV.CLOSED;
          })), this.websocket.on(WV.RECONNECTING, ((e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === VV.CONNECTED ? this.connectionState = VV.RECONNECTING : this.connectionState = VV.CONNECTING;
          })), this.websocket.on(WV.WILL_RECONNECT, ((e2, t2, i2) => {
            "retry" !== e2 ? (iP.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0) : iP.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i2(e2);
          })), this.websocket.on(WV.CONNECTED, (() => {
            this.openConnectionTime = Date.now(), this.join().catch(((e2) => {
              if (this.emit(xV.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof pO && e2.code === hO.UNEXPECTED_RESPONSE && e2.data.code === UV.ERR_NO_AUTHORIZED) return iP.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", HO.SERVER_ERROR);
              iP.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", HO.SERVER_ERROR) : (this.initError = e2, this.close());
            }));
          })), this.websocket.on(WV.REQUEST_NEW_URLS, ((e2, t2) => {
            zO(this, xV.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          })), this.websocket.on(WV.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => {
            this.emit(jV.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }));
        }
      }
      const HX = { name: "P2PChannel", create: function(e2) {
        let { store: t2, statsCollector: i2 } = e2;
        return new BX(t2, i2);
      }, createSubmodule: function(e2) {
        let { store: t2, spec: i2 } = e2;
        return new WX(i2, t2);
      } };
      function KX(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function YX(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? KX(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : KX(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      class zX {
        constructor(e2) {
          iA(this, "sessionDesc", void 0), iA(this, "localCapabilities", void 0), iA(this, "rtpCapabilities", void 0), iA(this, "candidates", void 0), iA(this, "_originCandidates", void 0), iA(this, "iceParameters", void 0), iA(this, "dtlsParameters", void 0), iA(this, "setup", void 0), iA(this, "currentMidIndex", void 0), iA(this, "cname", void 0), e2 = sN(e2);
          const { iceParameters: t2, dtlsParameters: i2, candidates: n2, rtpCapabilities: r2, setup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e2, d2 = LD("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = r2, this.candidates = n2, this._originCandidates = sN(n2), this.iceParameters = t2, this.dtlsParameters = i2, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
          for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
            const s3 = d2.mediaDescriptions[e3];
            if (s3.attributes.iceUfrag = t2.iceUfrag, s3.attributes.icePwd = t2.icePwd, s3.attributes.fingerprints = i2.fingerprints, s3.attributes.candidates = n2, s3.attributes.setup = o2, "video" === s3.media.mediaType) {
              s3.media.fmts = r2.videoCodecs.map(((e5) => e5.payloadType.toString(10)));
              const e4 = r2.videoCodecs.filter(((e5) => {
                var t4, i3;
                return null === (t4 = e5.rtpMap) || void 0 === t4 ? void 0 : Ln(i3 = t4.encodingName.toLowerCase()).call(i3, a2);
              })), t3 = r2.videoCodecs.filter(((t4) => !Ln(e4).call(e4, t4)));
              s3.attributes.payloads = [...e4, ...t3], s3.attributes.extmaps = r2.videoExtensions;
            }
            "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map(((e4) => e4.payloadType.toString(10))), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return kD(this.sessionDesc);
        }
        send(e2, t2, i2) {
          const { ssrcs: n2, ssrcGroups: r2 } = LF(t2, this.cname), o2 = this.sessionDesc.mediaDescriptions.find(((t3) => e2 === fx.VIDEO ? "video" === t3.media.mediaType : "audio" === t3.media.mediaType)), s2 = n2[0].attributes.label, a2 = n2[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a2 };
        }
        batchSend(e2) {
          return e2.map(((e3) => {
            let { kind: t2, ssrcMsg: i2 } = e3;
            return this.send(t2, i2, void 0);
          }));
        }
        stopSending(e2) {
          this.sessionDesc.mediaDescriptions.forEach(((t2) => {
            const i2 = [], n2 = [], r2 = [];
            t2.attributes.ssrcs.forEach(((t3) => {
              Ln(e2).call(e2, t3.attributes.label || "") ? r2.push(t3) : i2.push(t3);
            })), t2.attributes.ssrcGroups.forEach(((e3) => {
              var t3;
              Ln(t3 = r2.map(((e4) => e4.ssrcId))).call(t3, e3.ssrcIds[0]) || n2.push(e3);
            })), t2.attributes.ssrcs = i2, t2.attributes.ssrcGroups = n2;
          }));
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find(((t3) => t3.attributes.mid === e2));
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find(((t3) => t3.attributes.mid === e2));
          if (!t2) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        receive(e2, t2, i2) {
          e2.forEach(((e3, t3) => {
            const i3 = e3._mediaStreamTrack, n2 = this.sessionDesc.mediaDescriptions.findIndex(((e4) => e4.attributes.mid === i3.kind)), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n2], e3);
            this.sessionDesc.mediaDescriptions[n2] = r2;
          }));
        }
        stopReceiving(e2) {
        }
        updateCandidates(e2) {
          const t2 = this._originCandidates.filter(((e3) => "udp" === e3.transport)), i2 = [];
          if (t2.forEach(((e3) => {
            i2.push(YX(YX({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          })), 0 !== t2.length) {
            switch (e2) {
              case Sx.TCP_RELAY:
                this.candidates = i2;
                break;
              case Sx.UDP_TCP_RELAY:
              case Sx.RELAY:
                this.candidates = [...t2, ...i2];
                break;
              default:
                this.candidates = t2;
            }
            for (const e3 of this.sessionDesc.mediaDescriptions) e3.attributes.candidates = this.candidates;
          }
        }
        restartICE(e2) {
          e2 = sN(e2), this.iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach(((t2) => {
            t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
          }));
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let i2 = 0; i2 < e2; i2++) t2.push((this.currentMidIndex + i2 + 1).toString(10));
          return t2;
        }
        mungRecvMediaDsec(e2, t2) {
          const i2 = sN(e2);
          return kF(i2, t2), UF(i2, t2), i2;
        }
        updateRecvMedia(e2, t2) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex(((t3) => t3.attributes.mid === e2));
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        updateTrackLabel(e2, t2, i2) {
          const n2 = this.sessionDesc.mediaDescriptions.find(((t3) => e2 === fx.VIDEO ? "video" === t3.attributes.mid : "audio" === t3.attributes.mid));
          if (n2) {
            const e3 = n2.attributes.ssrcs.find(((e4) => e4.attributes.label === t2));
            var r2;
            if (e3) e3.attributes.label = i2, null === (r2 = e3.attributes.msid) || void 0 === r2 || r2.replace(t2, i2);
          }
        }
        mungMediaDesc(e2) {
          const t2 = sN(e2);
          return MF(t2), (function(e3) {
            const t3 = e3.attributes.extmaps.find(((e4) => IF(e4.extensionName)));
            t3 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t3), 1), e3.attributes.payloads.forEach(((e4) => {
              const t4 = e4.rtcpFeedbacks.findIndex(((e5) => "transport-cc" === e5.type));
              -1 !== t4 && e4.rtcpFeedbacks.splice(t4, 1);
            }));
          })(t2), t2;
        }
        getSSRC(e2) {
          for (const t2 of this.sessionDesc.mediaDescriptions) for (const i2 of t2.attributes.ssrcs) if (i2.attributes.label === e2) return [i2];
        }
      }
      var qX;
      function XX(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function JX(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? XX(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : XX(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let QX = (qX = class e2 extends mx {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map(((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "")).filter(((e3) => {
            var t2;
            return Ln(t2 = Object.keys(AD)).call(t2, e3);
          })))];
        }
        constructor(t2, i2) {
          super(t2, i2), iA(this, "store", void 0), iA(this, "peerConnection", void 0), iA(this, "remoteSDP", void 0), iA(this, "initialOffer", void 0), iA(this, "statsFilter", void 0), iA(this, "useRTX", false), iA(this, "localCapabilities", void 0), iA(this, "localCandidateCount", 0), iA(this, "allCandidatesReceived", false), iA(this, "establishPromise", void 0), iA(this, "mutex", void 0), this.store = i2, this.mutex = new PN("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = dD(this.peerConnection, CD("STATS_UPDATE_INTERVAL"), void 0, Bw() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e3.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = OF(e3.sdp), i2 = wF(e3.sdp, { filterRTX: !this.useRTX, filterVideoFec: CD("FILTER_VIDEO_FEC"), filterAudioFec: CD("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
            return this.localCapabilities = i2, this.initialOffer = e3, JX(JX({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e3.sdp });
          } catch (e3) {
            throw new pO(hO.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async updateRemoteConnect() {
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new zX(JX(JX({}, e3), {}, { rtpCapabilities: e3.rtpCapabilities.send, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec }));
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          throw new pO(hO.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        getPreMedia(e3) {
        }
        send(e3, t2) {
          var i2 = this;
          return Mb((function* () {
            const n2 = yield Vb(i2.mutex.lock());
            try {
              if (!i2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const r2 = e3.map(((e4) => i2.peerConnection.addTrack(e4._mediaStreamTrack))), o2 = yield Vb(i2.peerConnection.createOffer()), s2 = LD(o2.sdp), a2 = e3.map(((e4) => {
                const t3 = e4._mediaStreamTrack, n3 = s2.mediaDescriptions.find(((e5) => e5.attributes.mid === t3.kind));
                if (!n3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return (function(e5, t4, i3) {
                  const n4 = e5.attributes.ssrcs.filter(((e6) => e6.attributes.label === t4)), r3 = e5.attributes.ssrcGroups;
                  if (0 === n4.length) throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (r3 && n4.length > 1) {
                    const e6 = r3.find(((e7) => -1 !== e7.ssrcIds.indexOf(n4[0].ssrcId)));
                    return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: i3 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                  }
                  return [{ ssrcId: n4[0].ssrcId }];
                })(n3, t3.id, i2.useRTX);
              }));
              let c2;
              try {
                c2 = yield a2;
              } catch (e4) {
                throw r2.forEach(((e5) => {
                  Vw() && e5.replaceTrack(null), i2.peerConnection.removeTrack(e5);
                })), e4;
              }
              const d2 = i2.mungSendOfferSDP(o2.sdp, e3);
              i2.remoteSDP.receive(e3, t2, c2);
              const l2 = i2.remoteSDP.toString();
              return yield Vb(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(i2.applySendEncodings(r2, e3)), yield Vb(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e3.map(((e4, t3) => {
                const i3 = e4._mediaStreamTrack.id;
                return { localSSRC: a2[t3], id: i3 };
              }));
            } catch (e4) {
              throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              n2();
            }
          }))();
        }
        async stopSending(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t2 = this.peerConnection.getSenders().filter(((t3) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            }));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t2.map(((e4) => {
              Vw() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
            }));
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e3);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { id: i3, mslabel: r2 } = this.remoteSDP.send(e3, t2, n2), o2 = new rp(((t3, n3) => {
              const o3 = setTimeout((() => {
                n3(new Error("Cannot receive track, id: ".concat(i3)));
              }), 1e4), s3 = (n4) => {
                const a3 = Dw();
                if (("Safari" === a3.name && 11 === Number(a3.version) || jw()) && n4.track.id !== i3 && n4.streams[0].id === r2) {
                  var c2;
                  const r3 = n4.streams[0].getTracks()[0];
                  return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e3, i3, n4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(r3);
                }
                if (n4.track.id === i3) return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n4.track);
              };
              this.peerConnection.addEventListener("track", s3);
            })), s2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const a2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a2);
            return { track: await o2, id: i3 };
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
        }
        async unmuteRemote(e3) {
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter(((t3) => {
              var i2;
              return -1 !== e3.indexOf((null === (i2 = t3.track) || void 0 === i2 ? void 0 : i2.id) || "");
            }));
            if (t2.length !== e3.length) throw new Error("sender' length doesn't match mids' length.");
            t2.map(((e4) => {
              if (Vw() && e4.track) e4.track.enabled = false;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach(((e5) => e5.active = false)), e4.setParameters(t3);
              }
            }));
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter(((t3) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
            }));
            if (t2.length !== e3.length) throw new Error("Senders' length doesn't match mids' length.");
            t2.map((async (e4) => {
              if (Vw() && e4.track) e4.track.enabled = true;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach(((e5) => e5.active = true)), await e4.setParameters(t3);
              }
            }));
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return Mb((function* () {
            const i2 = yield Vb(t2.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              const n2 = pP().supportPCSetConfiguration;
              if (e3 === Sx.RELAY && !n2) return;
              if (n2) {
                const i3 = t2.peerConnection.getConfiguration(), n3 = e3 === Sx.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n3 && (iP.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
              }
              e3 !== Sx.RELAY && t2.remoteSDP.updateCandidates(e3);
              const r2 = yield Vb(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!r2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const o2 = OF(r2.sdp), { remoteIceParameters: s2 } = yield o2.iceParameters;
              t2.remoteSDP.restartICE(s2);
              const a2 = t2.remoteSDP.toString();
              yield Vb(t2.peerConnection.setLocalDescription(r2)), yield Vb(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: a2 }));
            } catch (e4) {
              iP.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          }))();
        }
        close() {
          var e3;
          this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e4 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e4.sdp, [t2]);
            this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
            const n2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getSenders().filter(((t3) => {
            var i3;
            return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e3;
          }));
          1 === i2.length && await this.applySendEncodings(i2, [t2]);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getSenders().find(((e4) => {
            var i3;
            return (null === (i3 = e4.track) || void 0 === i3 ? void 0 : i3.id) === t2;
          }));
          i2 && await i2.replaceTrack(e3._mediaStreamTrack);
        }
        createDataChannels(e3, t2) {
          throw new pO(hO.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        stopDataChannels(e3) {
          throw new pO(hO.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout((() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }), CD("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [], sdpSemantics: "plan-b" };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (xO(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), CD("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach(((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          })))), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          })), t2;
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i2;
          if (!t2) {
            t2 = this.peerConnection.getSenders().find(((t3) => {
              var i3;
              return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e3._mediaStreamTrack.id;
            }));
          }
          if (!t2) return iP.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (!pP().supportSetRtpSenderParameters) return iP.warn("Browser not support set rtp-sender parameters");
          const n2 = {}, r2 = {};
          if (e3 instanceof kM) switch (e3._optimizationMode) {
            case "motion":
              n2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n2.degradationPreference = "maintain-resolution";
              break;
            default:
              n2.degradationPreference = "balanced";
          }
          if (CD("DSCP_TYPE") && sO()) {
            var o2;
            const e4 = CD("DSCP_TYPE");
            Ln(o2 = ["very-low", "low", "medium", "high"]).call(o2, e4) && (r2.networkPriority = e4);
          }
          const s2 = t2.getParameters(), a2 = null === (i2 = s2.encodings) || void 0 === i2 ? void 0 : i2[0];
          a2 && Object.assign(a2, r2), Object.assign(s2, n2), iP.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(s2.encodings))), await t2.setParameters(s2);
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!pP().supportSetRtpSenderParameters) return;
            if (e3.length !== t2.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = e3[i2], r2 = t2[i2];
              n2 && r2 && await this.updateRtpSenderEncodings(r2, n2);
            }
          } catch (e4) {
            iP.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2) {
          const i2 = LD(e3);
          return t2.forEach(((e4, t3) => {
            const n2 = e4._mediaStreamTrack, r2 = i2.mediaDescriptions.find(((e5) => e5.attributes.mid === n2.kind));
            r2 && kF(r2, e4);
          })), kD(i2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t2 = this.remoteSDP.batchSend(e3).map(((t3, i3) => {
              let { id: n3, mslabel: r2 } = t3;
              const { kind: o2 } = e3[i3];
              return new rp(((e4, t4) => {
                const i4 = setTimeout((() => {
                  t4(new Error("Cannot receive track, id: ".concat(n3)));
                }), 1e4), s2 = (t5) => {
                  const a2 = Dw();
                  if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                    var c2;
                    const r3 = t5.streams[0].getTracks()[0];
                    return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(o2, n3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: r3, id: n3 });
                  }
                  if (t5.track.id === n3) return this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: t5.track, id: n3 });
                };
                this.peerConnection.addEventListener("track", s2);
              }));
            })), i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
            const n2 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(n2), await rp.all(t2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return null == t2 ? void 0 : t2[0].ssrcId;
        }
        setConfiguration(t2) {
          if (pP().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
        }
      }, DV(qX.prototype, "connect", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "connect"), qX.prototype), DV(qX.prototype, "stopSending", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "stopSending"), qX.prototype), DV(qX.prototype, "receive", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "receive"), qX.prototype), DV(qX.prototype, "stopReceiving", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "stopReceiving"), qX.prototype), DV(qX.prototype, "muteRemote", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "muteRemote"), qX.prototype), DV(qX.prototype, "unmuteRemote", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "unmuteRemote"), qX.prototype), DV(qX.prototype, "muteLocal", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "muteLocal"), qX.prototype), DV(qX.prototype, "unmuteLocal", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "unmuteLocal"), qX.prototype), DV(qX.prototype, "close", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "close"), qX.prototype), DV(qX.prototype, "updateEncoderConfig", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "updateEncoderConfig"), qX.prototype), DV(qX.prototype, "updateSendParameters", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "updateSendParameters"), qX.prototype), DV(qX.prototype, "replaceTrack", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "replaceTrack"), qX.prototype), DV(qX.prototype, "getRemoteSSRC", [ZX], Object.getOwnPropertyDescriptor(qX.prototype, "getRemoteSSRC"), qX.prototype), qX);
      function ZX(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("Locking from P2PConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      const $X = { name: "PlanBConnection", create: function(e2) {
        let { store: t2, spec: i2 } = e2;
        return new QX(i2, t2);
      } }, eJ = { interceptLocalAudioFrame: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!pP().supportWebRTCEncodedTransform) return void iP.warning("browser not support audio encoded transform");
        if (hU.has(e2)) return;
        if (!e2.track) return;
        const i2 = { track: e2.track };
        if (Uw()) {
          if (!e2.createEncodedStreams) return void iP.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void iP.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const o2 = new TransformStream({ transform(r3, o3) {
            i2.controller || (i2.controller = o3), e2.track && e2.track.id !== i2.track.id && (iP.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2));
            const s2 = t2.metadata && t2.metadata();
            s2 ? (function(e3, t3) {
              const { chunk: i3, controller: n3 } = t3, r4 = lU.METADATA;
              i3.data = (function(e4, t4, i4) {
                const n4 = i4.byteLength, r5 = n4 + cU + dU, o4 = sU + aU + r5, s3 = new ArrayBuffer(e4.byteLength + o4), a2 = new DataView(s3);
                a2.setUint8(0, oU), a2.setUint16(1, r5), a2.setUint8(3, t4), a2.setUint16(4, n4);
                for (let e5 = 0; e5 < n4; e5++) a2.setUint8(6 + e5, i4[e5]);
                const c2 = new Uint8Array(a2.buffer);
                return c2.set(new Uint8Array(e4), o4), c2.buffer;
              })(i3.data, r4, e3), n3.enqueue(i3);
            })(s2, { sender: e2, chunk: r3, controller: o3 }) : o3.enqueue(r3);
          } });
          r2.readable.pipeThrough(o2).pipeTo(r2.writable);
        } else if (Vw()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void iP.warning("browser not support RTCRtpScriptTransform");
          const r2 = rU(), o2 = new MessageChannel();
          await new rp(((e3) => r2.onmessage = (t3) => {
            "registered" === t3.data && e3(void 0);
          }));
          const s2 = new RTCRtpScriptTransform(r2, { name: "audio-metadata-tx", port: o2.port2 }, [o2.port2]);
          e2.transform = s2, await new rp(((e3) => r2.onmessage = (t3) => {
            "started" === t3.data && e3(void 0);
          })), o2.port1.onmessage = (r3) => {
            var s3;
            if (r3.data.transformed && e2.track && (null === (s3 = e2.track) || void 0 === s3 ? void 0 : s3.id) !== i2.track.id) iP.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2);
            else if (r3.data.getMetadata) {
              const e3 = t2.metadata && t2.metadata();
              e3 && o2.port1.postMessage({ metadata: e3 });
            }
          }, i2.worker = r2;
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n2);
          }
          const t3 = hU.get(e2);
          if (t3) {
            hU.delete(e2);
            try {
              var i3, r2;
              null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (r2 = t3.worker) || void 0 === r2 || r2.terminate();
            } catch (e3) {
              iP.warning(e3 && e3.message);
            }
          }
        }
        hU.set(e2, i2), e2.track.addEventListener("ended", n2);
      }, interceptRemoteAudioFrame: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!pP().supportWebRTCEncodedTransform) return void iP.warning("browser not support audio encoded transform");
        if (kU.has(e2)) return;
        const i2 = { track: e2.track, onMetadata: t2.onMetadata, onPts: t2.onPts };
        if (Uw() && !jw()) {
          if (!e2.createEncodedStreams) return void iP.warning("browser not support createEncodedStreams() API");
          Hw(bw.CHROME, 87, 116) || (t2.enableTopn = false);
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void iP.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const o2 = new TransformStream({ transform(r3, o3) {
            i2.controller || (i2.controller = o3), e2.track && e2.track.id !== i2.track.id && (iP.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2)), t2.enableTopn ? (function(e3, t3, i3) {
              var n3;
              const r4 = uU(new DataView(t3.data));
              if (!r4) return i3.enqueue(t3);
              const o4 = e3.track.id;
              MU.set(o4, e3.track);
              const s2 = null === (n3 = r4.tlv.find(((e4) => e4.tag === lU.AUDIO_LEVEL))) || void 0 === n3 ? void 0 : n3.value;
              let a2 = 0;
              "number" == typeof s2 && (a2 = 127 - s2);
              const c2 = Math.round(Math.pow(10, a2 / 60) - 1), { selected: d2, speaker: l2 } = (function(e4, t4) {
                let i4 = yU.get(e4);
                if (i4 || (i4 = (function(e5) {
                  const t5 = new TU();
                  return yU.set(e5, t5), IU || (IU = new vU(CD("TOPN_SILENCE_THRESHOLD") || 500), IU.on("ActiveSpeakerChanged", ((e6) => {
                    null != e6 && (AU = e6);
                  }))), IU.addSpeakers([t5]), t5;
                })(e4)), yU.size <= bU) return { selected: true, speaker: i4 };
                if (!IU) throw new Error("no active speaker detector");
                return IU.levelChanged(i4.id, t4), wU = IU.loudest.map(((e5) => e5.id)), AU && !Ln(wU).call(wU, AU) && wU.length >= bU && wU.pop(), { selected: Ln(wU).call(wU, i4.id) || i4.id === AU, speaker: i4 };
              })(e3, c2), u2 = (function(e4, t4, i4) {
                const n4 = OU.get(e4) || new DU(e4, t4);
                return n4.score = i4, OU.set(e4, n4), (function(e5) {
                  if (NU.set(e5, true), !PU) return void (PU = Date.now());
                  const t5 = Date.now();
                  t5 - PU > 1e3 && (NU.get(e5) ? NU.set(e5, false) : (LU(e5), NU.delete(e5)), PU = t5);
                })(e4), n4;
              })(o4, e3.track, l2.energyScore);
              u2.addSample(d2), u2.active && (t3.data = r4.frame.buffer, i3.enqueue(t3));
            })(e2, r3, o3) : t2.enableMetadata || t2.enablePts ? (function(e3, t3, i3, n3) {
              const r4 = new DataView(e3.data), o4 = r4.getUint8(0);
              let s2;
              if (0 != (128 & o4) && 71 !== o4) {
                const t4 = (function(e4) {
                  if (e4.byteLength <= 0) return [];
                  const t5 = [];
                  let i4 = 0;
                  for (; i4 < e4.byteLength; ) {
                    const n5 = (128 & e4.getUint8(i4)) >> 7, r5 = 127 & e4.getUint8(i4);
                    if (!(n5 && i4 + 4 <= e4.byteLength)) {
                      i4++;
                      break;
                    }
                    {
                      const n6 = e4.getUint32(i4, false), o5 = (16776192 & n6) >> 10, s3 = 1023 & n6;
                      t5.push({ pt: r5, ts_offset: o5, length: s3, data: new Uint8Array() }), i4 += 4;
                    }
                  }
                  let n4 = e4.byteLength - i4;
                  for (const r5 of t5) {
                    if (r5.length > n4) return console.warn("Broken red payload"), [];
                    r5.length > 0 && (r5.data = new Uint8Array(e4.buffer, e4.byteOffset + i4, r5.length), i4 += r5.length, n4 -= r5.length);
                  }
                  if (n4 > 0) {
                    const r5 = { pt: t5.length > 0 ? t5[t5.length - 1].pt : 0, ts_offset: 0, length: n4, data: new Uint8Array(e4.buffer, e4.byteOffset + i4, n4) };
                    t5.push(r5);
                  }
                  return t5;
                })(r4);
                if (t4.length > 0) {
                  const i4 = (function(e4) {
                    let t5 = 0;
                    for (let i6 = 0; i6 < e4.length; i6++) t5 += i6 < e4.length - 1 ? 4 : 1, t5 += e4[i6].length;
                    const i5 = new Uint8Array(t5);
                    let n4 = 0;
                    for (let t6 = 0; t6 < e4.length; t6++) if (t6 < e4.length - 1) {
                      const r5 = (2147483648 | (127 & e4[t6].pt) << 24 | (262143 & e4[t6].ts_offset) << 10 | 1023 & e4[t6].length) >>> 0;
                      i5[n4++] = r5 >> 24 & 255, i5[n4++] = r5 >> 16 & 255, i5[n4++] = r5 >> 8 & 255, i5[n4++] = 255 & r5;
                    } else i5[n4++] = 127 & e4[t6].pt;
                    for (const t6 of e4) i5.set(t6.data, n4), n4 += t6.length;
                    return i5;
                  })(t4.map(((e4) => {
                    const t5 = new Uint8Array(e4.length);
                    t5.set(e4.data);
                    const i5 = uU(new DataView(t5.buffer));
                    return null != i5 && i5.frame && (e4.data = null == i5 ? void 0 : i5.frame), s2 = i5, e4;
                  })));
                  e3.data = i4.buffer;
                }
              } else s2 = uU(r4), s2 && (e3.data = s2.frame.buffer);
              if (t3.enqueue(e3), !s2) return;
              const a2 = s2.tlv.find(((e4) => e4.tag === lU.METADATA));
              a2 && i3 && a2.value instanceof Uint8Array && i3(a2.value);
              const c2 = s2.tlv.find(((e4) => e4.tag === lU.AUDIO_64_BIT_PTS));
              c2 && n3 && c2.value instanceof Uint8Array && 8 == c2.value.length && n3(new DataView(c2.value.buffer).getBigUint64(0, true));
            })(r3, o3, t2.onMetadata, t2.onPts) : o3.enqueue(r3);
          } });
          r2.readable.pipeThrough(o2).pipeTo(r2.writable);
        } else {
          if ("undefined" == typeof RTCRtpScriptTransform) return void iP.warning("browser not support RTCRtpScriptTransform");
          const t3 = rU(), r2 = new MessageChannel();
          await new rp(((e3) => t3.onmessage = (t4) => {
            "registered" === t4.data && e3(void 0);
          }));
          const o2 = new RTCRtpScriptTransform(t3, { name: "audio-metadata-rx", port: r2.port2 }, [r2.port2]);
          e2.transform = o2, await new rp(((e3) => t3.onmessage = (t4) => {
            "started" === t4.data && e3(void 0);
          })), r2.port1.onmessage = (t4) => {
            var r3;
            t4.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id ? (iP.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2)) : t4.data.metadata && i2.onMetadata ? i2.onMetadata(t4.data.metadata) : t4.data.pts && i2.onPts && i2.onPts(t4.data.pts);
          }, i2.worker = t3;
        }
        function n2() {
          e2.track.removeEventListener("ended", n2), (function(e3) {
            const t3 = kU.get(e3);
            if (t3) {
              !(function(e4) {
                const t4 = yU.get(e4);
                t4 && (yU.delete(e4), IU && (IU.removeSpeakers([t4]), 0 === yU.size && (IU.destroy(), IU = null)));
              })(e3), LU(e3.track.id), kU.delete(e3);
              try {
                var i3, n3;
                null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (n3 = t3.worker) || void 0 === n3 || n3.terminate();
              } catch (e4) {
                iP.warning(e4 && e4.message);
              }
            }
          })(e2);
        }
        kU.set(e2, i2), e2.track.addEventListener("ended", n2);
      }, interceptLocalVideoFrame: async function(e2, t2) {
        if (!pP().supportWebRTCEncodedTransform) return void iP.warning("browser not support video encoded transform");
        if (jU.has(e2)) return;
        if (!e2.track) return;
        const i2 = { track: e2.track };
        if (Uw()) {
          if (!e2.createEncodedStreams) return void iP.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void iP.error("create video-encoded-streams error", e3 && e3.message);
          }
          const o2 = [];
          t2.on("sei-to-send", ((e3) => {
            o2.push(e3);
          }));
          const s2 = new TransformStream({ transform(t3, r3) {
            i2.controller || (i2.controller = r3), e2.track && e2.track.id !== i2.track.id && (iP.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2));
            const s3 = BU(new Uint8Array(t3.data)), a2 = o2.shift();
            if (a2) {
              const e3 = (function(e4, t4, i3) {
                switch (i3) {
                  case UU:
                    return (function(e5, t5) {
                      const i4 = FU(t5), n3 = i4.length, r4 = Math.floor(n3 / 255), o3 = n3 % 255, s4 = new Uint8Array(6 + r4 + 1 + n3 + e5.byteLength);
                      s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 6, s4[5] = 101;
                      let a3 = 0;
                      for (; a3 < r4; ) s4[6 + a3] = 255, a3++;
                      return s4[6 + a3] = o3, a3++, s4.set(i4, 6 + a3), s4.set(new Uint8Array(e5), 6 + a3 + n3), s4.buffer;
                    })(e4, t4);
                  case VU:
                    return (function(e5, t5) {
                      const i4 = FU(t5), n3 = i4.length, r4 = Math.floor(n3 / 255), o3 = n3 % 255, s4 = new Uint8Array(7 + r4 + 1 + n3 + 1 + e5.byteLength);
                      s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 78, s4[5] = 1, s4[6] = 101;
                      let a3 = 0;
                      for (; a3 < r4; ) s4[7 + a3] = 255, a3++;
                      return s4[7 + a3] = o3, a3++, s4.set(i4, 7 + a3), a3 += n3, s4[7 + a3] = 128, a3++, s4.set(new Uint8Array(e5), 7 + a3), s4.buffer;
                    })(e4, t4);
                  default:
                    return null;
                }
              })(t3.data, a2, s3);
              e3 && (t3.data = e3);
            }
            r3.enqueue(t3);
          } });
          r2.readable.pipeThrough(s2).pipeTo(r2.writable);
        } else {
          if (!Vw()) return;
          {
            if ("undefined" == typeof RTCRtpScriptTransform) return void iP.warning("browser not support RTCRtpScriptTransform");
            const r2 = rU(), o2 = new MessageChannel();
            await new rp(((e3) => r2.onmessage = (t3) => {
              "registered" === t3.data && e3(void 0);
            }));
            const s2 = new RTCRtpScriptTransform(r2, { name: "sei-tx", port: o2.port2 }, [o2.port2]);
            e2.transform = s2, await new rp(((e3) => r2.onmessage = (t3) => {
              "started" === t3.data && e3(void 0);
            })), t2.on("sei-to-send", ((e3) => {
              o2.port1.postMessage({ sei: e3 });
            })), o2.port1.onmessage = (t3) => {
              var r3;
              t3.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id && (iP.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2));
            }, i2.worker = r2;
          }
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n2);
          }
          const t3 = jU.get(e2);
          if (t3) {
            jU.delete(e2);
            try {
              var i3, r2;
              null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (r2 = t3.worker) || void 0 === r2 || r2.terminate();
            } catch (e3) {
              iP.warning(e3 && e3.message);
            }
          }
        }
        jU.set(e2, i2), e2.track.addEventListener("ended", n2);
      }, interceptRemoteVideoFrame: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!pP().supportWebRTCEncodedTransform) return void iP.warning("browser not support video encoded transform");
        if (!e2.track) return;
        if (GU.has(e2)) {
          const i3 = GU.get(e2);
          return void (i3 && (i3.onSei = t2.onSei));
        }
        const i2 = { track: e2.track, onSei: t2.onSei };
        if (Uw()) {
          if (!e2.createEncodedStreams) return void iP.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void iP.error("create video-encoded-streams error", e3 && e3.message);
          }
          const o2 = new TransformStream({ transform(r3, o3) {
            if (i2.controller || (i2.controller = o3), !i2.firstFrameInfo) {
              var s2;
              const e3 = r3.getMetadata() || {};
              i2.firstFrameInfo = cL({ type: r3.type, rtpTimestamp: r3.timestamp, payloadType: e3.payloadType || 0, ssrc: e3.synchronizationSource || 0, length: r3.data.byteLength }, "mimeType" in e3 ? { mimeType: e3.mimeType } : {}), null === (s2 = t2.onFirstFrame) || void 0 === s2 || s2.call(t2, i2.firstFrameInfo);
            }
            e2.track && e2.track.id !== i2.track.id && (iP.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2));
            const a2 = (function(e3, t3) {
              switch (t3) {
                case UU:
                  return (function(e4) {
                    const t4 = new DataView(e4.data);
                    let i3 = 0;
                    for (; i3 + 4 < e4.data.byteLength; ) {
                      if (0 === t4.getUint8(i3 + 0) && 0 === t4.getUint8(i3 + 1) && 0 === t4.getUint8(i3 + 2) && 1 === t4.getUint8(i3 + 3) && 6 === t4.getUint8(i3 + 4)) {
                        let n3 = i3 + 6, r4 = 0, o4 = 0;
                        for (; 255 === (o4 = t4.getUint8(n3++)); ) r4 += 255;
                        r4 += o4;
                        const s3 = xU(e4.data, n3, r4);
                        return new Uint8Array(s3);
                      }
                      i3++;
                    }
                    return null;
                  })(e3);
                case VU:
                  return (function(e4) {
                    const t4 = new DataView(e4.data);
                    let i3 = 0;
                    for (; i3 + 5 < e4.data.byteLength; ) {
                      if (0 === t4.getUint8(i3 + 0) && 0 === t4.getUint8(i3 + 1) && 0 === t4.getUint8(i3 + 2) && 1 === t4.getUint8(i3 + 3) && 78 === t4.getUint8(i3 + 4) && 1 === t4.getUint8(i3 + 5) && 101 === t4.getUint8(i3 + 6)) {
                        let n3 = i3 + 7, r4 = 0, o4 = 0;
                        for (; 255 === (o4 = t4.getUint8(n3++)); ) r4 += 255;
                        r4 += o4;
                        const s3 = xU(e4.data, n3, r4);
                        return new Uint8Array(s3);
                      }
                      i3++;
                    }
                    return null;
                  })(e3);
                default:
                  return null;
              }
            })(r3, BU(new Uint8Array(r3.data)));
            a2 && i2.onSei && i2.onSei(a2), o3.enqueue(r3);
          } });
          r2.readable.pipeThrough(o2).pipeTo(r2.writable);
        } else if (Vw()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void iP.warning("browser not support RTCRtpScriptTransform");
          const r2 = rU(), o2 = new MessageChannel();
          await new rp(((e3) => r2.onmessage = (t3) => {
            "registered" === t3.data && e3(void 0);
          }));
          const s2 = new RTCRtpScriptTransform(r2, { name: "sei-rx", port: o2.port2 }, [o2.port2]);
          e2.transform = s2, await new rp(((e3) => r2.onmessage = (t3) => {
            "started" === t3.data && e3(void 0);
          })), o2.port1.onmessage = (r3) => {
            var o3;
            if (r3.data.transformed && e2.track && (null === (o3 = e2.track) || void 0 === o3 ? void 0 : o3.id) !== i2.track.id) iP.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n2), i2.track = e2.track, i2.track.addEventListener("ended", n2);
            else if (r3.data.sei && i2.onSei) i2.onSei(r3.data.sei);
            else if (r3.data.firstFrameInfo && t2.onFirstFrame) {
              var s3;
              null === (s3 = t2.onFirstFrame) || void 0 === s3 || s3.call(t2, r3.data.firstFrameInfo);
            }
          }, i2.worker = r2;
        }
        function n2() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n2);
          }
          !(function(e3) {
            const t3 = GU.get(e3);
            if (t3) {
              GU.delete(e3);
              try {
                var i3, n3;
                null === (i3 = t3.controller) || void 0 === i3 || i3.terminate(), null === (n3 = t3.worker) || void 0 === n3 || n3.terminate();
              } catch (e4) {
                iP.warning(e4 && e4.message);
              }
            }
          })(e2);
        }
        GU.set(e2, i2), e2.track.addEventListener("ended", n2);
      } }, tJ = { name: "InterceptFrame", create: () => eJ };
      var iJ;
      function nJ(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      function rJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? nJ(Object(i2), true).forEach((function(t3) {
            iA(e2, t3, i2[t3]);
          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : nJ(Object(i2)).forEach((function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
          }));
        }
        return e2;
      }
      let oJ = (iJ = class e2 extends mx {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map(((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "")).filter(((e3) => {
            var t2;
            return Ln(t2 = Object.keys(AD)).call(t2, e3);
          })))];
        }
        constructor(e3, t2, i2) {
          super(e3, t2), iA(this, "id", SN(5, "connection-")), iA(this, "store", void 0), iA(this, "peerConnection", void 0), iA(this, "forceTurn", false), iA(this, "remoteSDP", void 0), iA(this, "initialOffer", void 0), iA(this, "transportEventReceiver", void 0), iA(this, "statsFilter", void 0), iA(this, "extension", { useXR: CD("USE_XR") }), iA(this, "localCapabilities", void 0), iA(this, "remoteCodecs", void 0), iA(this, "localCandidateCount", 0), iA(this, "allCandidatesReceived", false), iA(this, "isPreallocation", false), iA(this, "preMediaMap", /* @__PURE__ */ new Map()), iA(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), iA(this, "establishPromise", void 0), iA(this, "recoveredDataChannelIds", []), iA(this, "currentDataChannelId", 1), iA(this, "supportAV1RtpSpec", false), iA(this, "mutex", void 0), iA(this, "qualityLimitationReason", tD.NONE), iA(this, "isFirstConnected", false), this.store = t2, this.forceTurn = Mj(e3), this.mutex = new PN("NVConnectionExtension-mutex", t2.clientId), this.peerConnection = i2, this.isFirstConnected = false, this.statsFilter = dD(this.peerConnection, CD("STATS_UPDATE_INTERVAL"), void 0, Bw() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, e3.isPreallocation && (this.isPreallocation = true), this.establishPromise = this.establish();
        }
        getPreMedia(e3) {
          return this.preMediaMap.get(e3);
        }
        isPreSub() {
          return this.preMediaMap.size > 0;
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          if (this.remoteCodecs = t2, !this.remoteSDP) return void iP.debug("[NVConnectionExtension] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t2));
          if (this.remoteSDP.updateRemoteCodec(e3, t2, this.store.codec)) {
            const e4 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e4.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e4);
            const i2 = this.remoteSDP.toString();
            null == t3 || t3(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } else iP.debug("[NVConnectionExtension] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const t2 = await this.peerConnection.createOffer();
            if (!t2.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const i2 = OF(t2.sdp), n2 = await jF({ filterRTX: !CD("USE_PUB_RTX") && !CD("USE_SUB_RTX"), filterVideoFec: CD("FILTER_VIDEO_FEC"), filterAudioFec: CD("FILTER_AUDIO_FEC"), filterVideoCodec: CD("FILTER_VIDEO_CODEC"), unsupportedVideoUplinkCodec: CD("UNSUPPORTED_VIDEO_UPLINK_CODEC"), unsupportedVideoDownlinkCodec: CD("UNSUPPORTED_VIDEO_DOWNLINK_CODEC") }, this.extension);
            if (this.localCapabilities = HF(n2), this.initialOffer = t2, CD("ENABLE_SVC") && "av1" == this.store.codec) {
              const t3 = await BF();
              var e3;
              if (t3) this.supportAV1RtpSpec = true, null === (e3 = n2.send) || void 0 === e3 || e3.videoExtensions.push(t3);
            }
            let r2;
            return t2.sdp && ZF(t2.sdp) && (r2 = sN(n2), TF(r2)), rJ(rJ({}, i2), {}, { rtpCapabilities: r2 || n2, offerSDP: t2.sdp });
          } catch (e4) {
            throw new pO(hO.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish NVConnectionExtension without initial offer.");
            this.initialOffer.sdp && ZF(this.initialOffer.sdp) && RF(e3.rtpCapabilities, this.localCapabilities), this.remoteSDP = new _j(rJ(rJ({}, e3), {}, { localCapabilities: this.localCapabilities }), this.supportAV1RtpSpec, !(!CD("ENABLE_PRE_SUB_WITH_PRE_PC") || !CD("PRE_USE_LOCAL_CODECS")) && mP(this.store), true), e3.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const t2 = this.remoteSDP.toString(), i2 = XF(this.initialOffer.sdp, this.extension), n2 = this.logSDPExchange(i2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), null == n2 || n2(t2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
            const r2 = this.peerConnection.getTransceivers()[0];
            if (null != r2 && r2.receiver && this.tryBindTransportEvents(r2.receiver), mP(this.store)) if (e3.preallocation && CD("ENABLE_PRE_SUB_WITH_PRE_PC")) {
              const e4 = CD("PRE_SUB_NUM"), { mids: t3, preSSRCs: i3 } = this.remoteSDP.preloadRemoteMedia(e4);
              await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [NVConnectionExtension] preload media, in pre pc,add preload ssrcs ").concat(i3)), this.presetMedia(t3, i3);
            } else {
              const { preSSRCs: t3 = [] } = e3, i3 = t3.map(((e4) => e4.ssrcMsg[0].ssrcId));
              if (0 === t3.length) return;
              const { mids: n3 } = this.remoteSDP.batchSend(t3.map(((e4) => Object.assign({}, e4))));
              await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[NVConnectionExtension.connect] preload media, after join, add preload ssrcs ".concat(i3)), this.presetMedia(n3, i3);
            }
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.connect failed; ".concat(e4.toString()));
          }
        }
        presetMedia(e3, t2) {
          e3.forEach(((e4, i2) => {
            this.peerConnection.getTransceivers().forEach(((n2) => {
              if (null != n2.mid && e4 === n2.mid && n2.receiver.track) {
                const r2 = n2.receiver.track;
                let o2;
                "video" === r2.kind && CD("ENABLE_PRE_RENDER") && (o2 = new Xk({ trackId: "track-".concat(r2.kind, "-unknown-").concat(this.store.clientId, "_").concat(SN(5, "")) }, true), o2.updateVideoTrack(r2), o2.onFirstVideoFrameRender = () => {
                  var e5;
                  const n3 = this.preMediaMap.get(t2[i2]);
                  n3 && (n3.firstVideoRender = Date.now()), null === (e5 = this.onFirstVideoRender) || void 0 === e5 || e5.call(this, t2[i2]);
                }, o2.onVideoBufferReady = () => {
                  var e5;
                  null === (e5 = this.onFirstVideoBufferReady) || void 0 === e5 || e5.call(this, t2[i2]);
                }, o2.play(this.store.sessionId || void 0)), this.preMediaMap.set(t2[i2], { mid: e4, track: r2, player: o2, transceiver: n2 });
              }
            })), this.store.peerReceiver();
          }));
        }
        checkDtlsParameters(e3) {
          return !!this.remoteSDP && (e3.length > 0 && this.remoteSDP.updateRemoteDtlsParameters(e3));
        }
        async updateRemoteConnect(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.updateRemoteConnect before remote SDP created");
            let t2 = false;
            const { rtpCapabilities: i2 } = e3;
            if ([, t2] = this.remoteSDP.updateRemoteRTPCapabilities(i2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) {
              const e4 = this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
              t2 = t2 || e4;
            }
            const { preSSRCs: n2 = [] } = e3, r2 = n2.map(((e4) => e4.ssrcMsg[0].ssrcId));
            if (!this.remoteSDP.checkPreloadSsrcs(r2)) {
              const e4 = [], t3 = [];
              if (Array.from(this.preMediaMap.entries()).every(((i3) => {
                let [n3, { mid: r3, player: o2, track: s2 }] = i3;
                return e4.push(r3), t3.push(n3), this.preMediaMap.delete(n3), o2 && o2.destroy(), true;
              })), e4.length > 0 && (this.remoteSDP.stopSending(e4), await qF(this.peerConnection, this.remoteSDP, this.extension), iP.warn("[NVConnectionExtension.updateRemoteConnect] preload media, failed, del preload ssrcs ".concat(t3)), lP.reportApiInvoke(this.store.sessionId, { name: LO.PRELOAD_MEDIA_FAILED, options: [n2, t3], tag: kO.TRACER }).onSuccess()), n2.length > 0) {
                const { mids: e5 } = this.remoteSDP.batchSend(n2.map(((e6) => Object.assign({}, e6))));
                await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[NVConnectionExtension.updateRemoteConnect] preload media, after join, add preload ssrcs ".concat(r2)), this.presetMedia(e5, r2);
              }
            }
            t2 ? (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[NVConnectionExtension] updateRemoteConnect by exchanging SDP.")) : iP.debug("[NVConnectionExtension] updateRemoteConnect no need to exchange SDP, because no need to update remote codecs (use local codecs)");
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.updateRemoteConnect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.mutex.lock("From NVConnectionExtension.send"));
            try {
              if (!n2.remoteSDP) throw new Error("Cannot call NVConnectionExtension.send before remote SDP created");
              const o2 = [], s2 = SF();
              e3.forEach(((e4) => {
                const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, rJ({ direction: "sendonly" }, "video" === e4.trackMediaType && n2.supportAV1RtpSpec && s2 ? { sendEncodings: [{ scalabilityMode: s2 }] } : {}));
                o2.push(t3), e4._updateRtpTransceiver(t3);
              })), Bw() && true === CD("SIMULCAST") && (yield Vb(n2.applySimulcastForFirefox(o2, e3)));
              const a2 = yield Vb(n2.peerConnection.createOffer()), c2 = n2.remoteSDP.predictReceivingMids(e3.length), d2 = n2.mungSendOfferSDP(a2.sdp, e3, c2), l2 = LD(d2), u2 = c2.map(((e4) => {
                const t3 = l2.mediaDescriptions.find(((t4) => t4.attributes.mid === e4));
                if (!t3) throw new Error("Cannot extract ssrc from mediaDescription.");
                return NF(t3, CD("USE_PUB_RTX"));
              }));
              let h2;
              try {
                h2 = yield u2;
              } catch (r3) {
                h2 = [], n2.remoteSDP.receive(e3, t2, i2, h2);
                const o3 = n2.remoteSDP.toString();
                throw yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield Vb(n2.stopSending(c2, true)), r3;
              }
              n2.remoteSDP.receive(e3, t2, i2, h2);
              const p2 = n2.remoteSDP.toString(), _2 = n2.logSDPExchange(d2, "offer", "local", "send");
              return yield Vb(n2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Vb(n2.applySimulcastEncodings(o2, e3)), yield Vb(n2.applySendEncodings(o2, e3)), null == _2 || _2(p2), yield Vb(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map(((e4, t3) => {
                const i3 = c2[t3];
                return { localSSRC: u2[t3], id: i3, transceiver: e4 };
              }));
            } catch (e4) {
              throw e4 instanceof pO ? e4 : new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          }))();
        }
        async createDataChannels(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.createDataChannels before remote SDP created");
            let i2 = this.dataStreamChannelMap.get(e3);
            if (i2 && "open" === i2.readyState) iP.debug("[NVConnectionExtension] Channels are already available and can be reused directly.");
            else {
              const t3 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
              if ("number" != typeof t3) throw new Error("create DataChannel error, because cannot get dc id");
              i2 = this.peerConnection.createDataChannel("datastream-channel", { id: t3, negotiated: true, ordered: false, maxRetransmits: CD("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e3, i2);
            }
            t2.forEach(((e4) => {
              e4._updateOriginDataChannel(i2);
            }));
            const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
            if (n2) {
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3), iP.debug("[NVConnectionExtension] createDataChannels by exchanging SDP.");
            } else iP.debug("[NVConnectionExtension] createDataChannels no need to exchange SDP.");
            return;
          } catch (e4) {
            throw e4 instanceof pO ? e4 : new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.createDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopDataChannels(e3) {
          try {
            const t2 = this.dataStreamChannelMap.get(e3);
            return t2 && (t2.id && this.recoveredDataChannelIds.push(t2.id), t2.close()), void this.dataStreamChannelMap.delete(e3);
          } catch (e4) {
            throw e4 instanceof pO ? e4 : new pO(hO.DATACHANNEL_FAILED, "NVConnectionExtension.stopDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopSending(e3, t2) {
          const i2 = t2 ? void 0 : await this.mutex.lock("From NVConnectionExtension.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter(((t4) => -1 !== e3.indexOf(t4.mid)));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call NVConnectionExtension.stopSending.");
            t3.map(((e4) => {
              var t4;
              wj(this.id + e4.mid, this), e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
            }));
            const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t2, i2, n2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i2, n2);
            o2 && (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [NVConnectionExtension] receive ").concat(e3, " by exchanging SDP.")));
            const s2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === r2));
            if (!s2) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2, transceiver: s2 };
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
            return i2 && (await qF(this.peerConnection, this.remoteSDP, this.extension), iP.debug("[".concat(this.store.clientId, "] [NVConnectionExtension] batchReceive by exchanging SDP."))), t2.map(((e4) => {
              const t3 = this.peerConnection.getTransceivers().find(((t4) => t4.mid === e4));
              if (!t3) throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4, transceiver: t3 };
            }));
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.stopReceiving before remote SDP created.");
            e3.forEach(((e4) => {
              Array.from(this.preMediaMap.entries()).some(((t3) => {
                let [i3, { mid: n3, player: r2 }] = t3;
                if (n3 === e4) return this.preMediaMap.delete(i3), r2 && r2.destroy(), true;
              }));
            })), this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const n2 = await this.peerConnection.createAnswer();
            null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(((e4) => {
              e4.direction = "inactive";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid && -1 !== e3.indexOf(t3.mid)));
            if (t2.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((async (e4, t3) => {
              e4.direction = "sendonly";
            }));
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec(e3, this.remoteCodecs, this.store.codec);
            const r2 = this.remoteSDP.toString();
            null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, "NVConnectionExtension.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t2 = this;
          return Mb((function* () {
            const i2 = yield Vb(t2.mutex.lock("From NVConnectionExtension.restartICE"));
            try {
              if (!t2.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              const n2 = pP().supportPCSetConfiguration, r2 = CD("FORCE_TURN_TCP") || t2.forceTurn;
              if (e3 === Sx.RELAY && !n2) return;
              if (n2 && !r2) {
                const i3 = e3 === Sx.RELAY ? "relay" : "all", n3 = t2.peerConnection.getConfiguration();
                n3.iceTransportPolicy !== i3 && (iP.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n3.iceTransportPolicy, "] to [").concat(i3, "]")), n3.iceTransportPolicy = i3, t2.peerConnection.setConfiguration(n3));
              }
              t2.remoteSDP.updateCandidates(e3);
              const o2 = yield Vb(t2.peerConnection.createOffer({ iceRestart: true }));
              if (!o2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const s2 = OF(o2.sdp), { remoteIceParameters: a2 } = yield s2.iceParameters;
              t2.remoteSDP.restartICE(a2);
              const c2 = t2.remoteSDP.toString(), d2 = t2.logSDPExchange(o2.sdp || "", "offer", "local", "restartICE");
              t2.store.descriptionStart(), yield Vb(t2.peerConnection.setLocalDescription(o2)), null == d2 || d2(c2), yield Vb(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: c2 }));
            } catch (e4) {
              iP.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          }))();
        }
        async extendCandidate() {
          if (!this.remoteSDP || this.isFirstConnected) return;
          const e3 = await this.mutex.lock("From NVConnectionExtension.extendCandidate");
          try {
            this.remoteSDP.updateCandidates(Sx.TCP_RELAY), await qF(this.peerConnection, this.remoteSDP, this.extension);
          } catch (e4) {
            iP.warning("[".concat(this.store.clientId, "] extend candidate failed, abort operation"), e4);
          } finally {
            e3();
          }
        }
        close() {
          var e3;
          this.peerConnection.getTransceivers().forEach(((e4) => {
            wj(this.id + e4.mid, this);
          })), this.preMediaMap.forEach(((e4) => {
            let { player: t2 } = e4;
            t2 && t2.destroy();
          })), this.preMediaMap.clear(), this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
        }
        getStats() {
          return rJ(rJ({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call NVConnectionExtension.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new pO(hO.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().filter(((t3) => t3.mid === e3));
          1 === i2.length && (this.isVP8Simulcast(t2) ? Bw() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const i2 = this.peerConnection.getTransceivers().find(((e4) => e4.mid === t2));
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
            return { local: rJ(rJ({}, zN), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: rJ(rJ({}, zN), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.isFirstConnected = true), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidateerror = (e3) => {
            if (e3 && (e3.errorCode || e3.errorText)) {
              var t2;
              const i2 = "code: ".concat(e3.errorCode, ", message: ").concat(e3.errorText), n2 = e3.port ? "local: ".concat(e3.port) : "", r2 = mF(e3.url || "");
              iP.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: NVConnectionExtension.onICECandidateError(").concat(i2, "), url: ").concat(r2 || "", ", host_candidate:").concat(n2)), null === (t2 = this.onICECandidateError) || void 0 === t2 || t2.call(this, i2);
            }
          }, this.peerConnection.onicegatheringstatechange = (e3) => {
            e3 && e3.target && "iceGatheringState" in e3.target && iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] RTCPeerConnection.onicegatheringstatechange(").concat(e3.target.iceGatheringState, ")"));
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout((() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, iP.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }), CD("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] }, n2 = t2.cloudProxyServer || "disabled";
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && (xO(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : CD("NEW_TURN_MODE") && i2.iceServers && "disabled" === n2 ? (CD("USE_TURN_SERVER_OF_GATEWAY") ? t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t2.turnServer.serversFromGateway)) : i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t2.turnServer.servers)), CD("NEW_FORCE_TURN") && (i2.iceTransportPolicy = "relay")) : "off" !== t2.turnServer.mode && (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), CD("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), CD("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach(((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          })))), CD("ENABLE_ENCODED_TRANSFORM") && pP().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !CD("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          })), t2;
        }
        static newTurnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            const i2 = CD("NEW_TURN_MODE");
            1 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }) : 2 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }) : 3 === i2 ? t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":443?transport=tcp") }) : 4 === i2 && (t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }), t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }), t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":443?transport=tcp") }));
          })), t2;
        }
        tryBindTransportEvents(e3) {
          const t2 = e3.transport;
          if (t2) {
            this.transportEventReceiver = e3, t2.onstatechange = () => {
              var e4;
              null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
            }, t2.onerror = (e4) => {
              var t3;
              null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
            };
            const i2 = t2.iceTransport;
            i2 && (i2.onstatechange = () => {
              const e4 = null == t2 ? void 0 : t2.iceTransport.state;
              var i3;
              e4 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e4));
            }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
              if (i2.getSelectedCandidatePair()) {
                const { local: e4, remote: t3 } = i2.getSelectedCandidatePair() || {};
                if (e4 && t3) {
                  const i3 = e4.address + ":" + e4.port, n2 = t3.address + ":" + t3.port;
                  iP.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify(mF(i3)), ", remote ").concat(JSON.stringify(mF(n2))));
                }
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t2) {
          var i2, n2;
          if (!t2) {
            const i3 = this.peerConnection.getSenders();
            t2 = i3.find(((t3) => t3.track === e3._mediaStreamTrack));
          }
          if (!t2) return iP.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return iP.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!pP().supportSetRtpSenderParameters) return iP.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const r2 = {}, o2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              r2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              r2.degradationPreference = "maintain-resolution";
              break;
            case "balanced":
              r2.degradationPreference = "balanced";
          }
          const s2 = fF(this.peerConnection, e3._mediaStreamTrack), a2 = JL(e3);
          if (Ij(e3) && s2 && t2 && a2 && this.getLocalVideoStats && Ln(i2 = ["vp8", "vp9"]).call(i2, this.store.codec)) {
            var c2;
            const i3 = r2.degradationPreference || (Ln(c2 = e3._hints).call(c2, VP.CUSTOM_TRACK) ? CD("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
            bj(this.id + s2.mid, a2, this, i3, ((e4) => {
              t2 && this.updateAdaptation(t2, e4);
            }), this.getLocalVideoStats.bind(this));
          }
          if (e3._encoderConfig) {
            var d2;
            const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e3._encoderConfig;
            t3 && (o2.maxBitrate = 1e3 * t3), (Ln(d2 = e3._hints).call(d2, VP.LOW_STREAM) || e3.isUseScaleResolutionDownBy) && (i3 && (o2.maxFramerate = dF(i3)), n3 && n3 >= 1 && (o2.scaleResolutionDownBy = n3));
          }
          const { maxFramerate: l2 } = CD("ENCODER_CONFIG_LIMIT");
          if (l2 && "number" == typeof l2 && (o2.maxFramerate = o2.maxFramerate ? Math.min(o2.maxFramerate, l2) : l2), CD("DSCP_TYPE") && sO()) {
            var u2;
            const e4 = CD("DSCP_TYPE");
            Ln(u2 = ["very-low", "low", "medium", "high"]).call(u2, e4) && (o2.networkPriority = e4);
          }
          const h2 = t2.getParameters(), p2 = null === (n2 = h2.encodings) || void 0 === n2 ? void 0 : n2[0];
          Bw() && !p2 && (r2.encodings = [o2]), p2 && Object.assign(p2, o2), Object.assign(h2, r2), iP.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(h2.encodings))), await t2.setParameters(h2), await QF(this.store.codec, t2, CD("SVC_MODE"));
        }
        async updateAdaptation(e3, t2) {
          var i2, n2;
          if (!e3) return iP.debug("[updateAdaptation] no rtpSender found");
          if (!pP().supportSetRtpSenderParameters) return iP.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
          const r2 = {}, { bitrateMax: o2, frameRate: s2, scaleResolutionDownBy: a2 } = t2;
          o2 && (r2.maxBitrate = 1e3 * o2), s2 && (r2.maxFramerate = dF(s2)), a2 && a2 >= 1 && Ln(i2 = ["vp8", "vp9"]).call(i2, this.store.codec) && (r2.scaleResolutionDownBy = a2);
          const c2 = e3.getParameters(), d2 = null === (n2 = c2.encodings) || void 0 === n2 ? void 0 : n2[0];
          d2 && Object.assign(d2, r2), Object.assign(c2, {});
          try {
            await e3.setParameters(c2), iP.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(c2.encodings)));
          } catch (t3) {
            !("transport" in e3) || e3.transport && "connected" === e3.transport.state ? "connected" !== this.peerConnectionState ? iP.debug("[updateAdaptation] peerConnection not connected}") : iP.debug("[updateAdaptation] updateRtpSenderEncodings failed", t3) : iP.debug("[updateAdaptation] rtpSender transport not connected}");
          }
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!pP().supportSetRtpSenderParameters) return;
            if (e3.length !== t2.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n2 = e3[i2], r2 = t2[i2];
              r2 instanceof kM && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
            }
          } catch (e4) {
            iP.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t2, i2) {
          const n2 = LD(e3);
          return t2.forEach(((e4, t3) => {
            const r2 = i2[t3], o2 = n2.mediaDescriptions.find(((e5) => e5.attributes.mid === r2));
            o2 && (kF(o2, e4), FF(o2, e4, this.store.codec));
          })), kD(n2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length) for (let a2 = 0; a2 < e3.length; a2++) {
            var i2, n2, r2, o2, s2;
            const c2 = e3[a2], d2 = t2[a2];
            if (d2 instanceof kM && !Ln(i2 = d2._hints).call(i2, VP.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i3 = c2.sender.getParameters();
              await c2.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!Bw() && e3.length === t2.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n2 = t2[i2];
            if (n2 instanceof kM && this.isVP8Simulcast(n2)) {
              const t3 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(s2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t2, i2, n2, r2, o2;
          return !!(e3 instanceof kM && CD("SIMULCAST") && "vp8" === this.store.codec && !Ln(t2 = e3._hints).call(t2, VP.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (CD("SDP_LOGGING")) return iP.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during NVConnectionExtension.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP) return;
          const t2 = this.remoteSDP.getSSRC(e3);
          return t2 && 0 !== t2.length ? t2[0].ssrcId : void 0;
        }
        setConfiguration(t2) {
          if (pP().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t2);
            this.peerConnection.setConfiguration(i2);
          }
          t2.isPreallocation && (this.isPreallocation = true);
        }
      }, DV(iJ.prototype, "updateRemoteRTPCapabilities", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "updateRemoteRTPCapabilities"), iJ.prototype), DV(iJ.prototype, "connect", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "connect"), iJ.prototype), DV(iJ.prototype, "updateRemoteConnect", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "updateRemoteConnect"), iJ.prototype), DV(iJ.prototype, "createDataChannels", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "createDataChannels"), iJ.prototype), DV(iJ.prototype, "receive", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "receive"), iJ.prototype), DV(iJ.prototype, "batchReceive", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "batchReceive"), iJ.prototype), DV(iJ.prototype, "stopReceiving", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "stopReceiving"), iJ.prototype), DV(iJ.prototype, "muteRemote", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "muteRemote"), iJ.prototype), DV(iJ.prototype, "unmuteRemote", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "unmuteRemote"), iJ.prototype), DV(iJ.prototype, "muteLocal", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "muteLocal"), iJ.prototype), DV(iJ.prototype, "unmuteLocal", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "unmuteLocal"), iJ.prototype), DV(iJ.prototype, "close", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "close"), iJ.prototype), DV(iJ.prototype, "updateEncoderConfig", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "updateEncoderConfig"), iJ.prototype), DV(iJ.prototype, "updateSendParameters", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "updateSendParameters"), iJ.prototype), DV(iJ.prototype, "replaceTrack", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "replaceTrack"), iJ.prototype), DV(iJ.prototype, "updateAdaptation", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "updateAdaptation"), iJ.prototype), DV(iJ.prototype, "getRemoteSSRC", [sJ], Object.getOwnPropertyDescriptor(iJ.prototype, "getRemoteSSRC"), iJ.prototype), iJ);
      function sJ(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From NVConnectionExtension.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      var aJ;
      function cJ(e2) {
        var t2, i2, n2, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = Fb, n2 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t2 = e2[i2])) return t2.call(e2);
          if (n2 && null != (t2 = e2[n2])) return new dJ(t2.call(e2));
          i2 = "@@asyncIterator", n2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function dJ(e2) {
        function t2(e3) {
          if (Object(e3) !== e3) return rp.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return rp.resolve(e3.value).then((function(e4) {
            return { value: e4, done: t3 };
          }));
        }
        return dJ = function(e3) {
          this.s = e3, this.n = e3.next;
        }, dJ.prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? rp.reject(e3) : t2(i2.apply(this.s, arguments));
        } }, new dJ(e2);
      }
      let lJ = (aJ = class e2 extends mx {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get localCodecs() {
          return this._p2pConnection.localCodecs;
        }
        constructor(t2, i2) {
          super(t2, i2), iA(this, "name", "DataChannelConnection"), iA(this, "store", void 0), iA(this, "peerConnection", void 0), iA(this, "cname", void 0), iA(this, "mutex", new PN("DataChannelConnection-mutex")), iA(this, "dataChannel", void 0), iA(this, "_p2pConnection", void 0), iA(this, "establishPromise", void 0), iA(this, "_nvMedia", void 0), this.store = i2, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new oJ(t2, i2, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;
        }
        getPreMedia(e3) {
          var t2;
          return null === (t2 = this._p2pConnection) || void 0 === t2 ? void 0 : t2.getPreMedia(e3);
        }
        isPreSub() {
          var e3, t2;
          return null !== (e3 = null === (t2 = this._p2pConnection) || void 0 === t2 ? void 0 : t2.isPreSub()) && void 0 !== e3 && e3;
        }
        async establish() {
          return await this._p2pConnection.establish();
        }
        getP2PConnectionParams() {
          return this._p2pConnection.establishPromise;
        }
        updateRtpSenderEncodings(e3) {
          return this._p2pConnection.updateRtpSenderEncodings(e3);
        }
        async connect(e3) {
          return this.cname = e3.cname, await this._p2pConnection.connect(e3), await new rp(((t2, i2) => {
            const n2 = setTimeout((() => {
              this.closeSignal(), i2(new uP(hO.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(e3.candidates))));
            }), CD("DC_CONNECTION_TIMEOUT"));
            this.dataChannel.onopen = () => {
              if ("open" === this.dataChannel.readyState) return clearTimeout(n2), void t2();
            }, this.dataChannel.onerror = (e4) => {
              this.closeSignal(), i2(e4);
            }, this.dataChannel.addEventListener("close", (() => {
              i2(new uP(hO.DATACHANNEL_CONNECTION_TIMEOUT));
            }));
          })), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
        }
        async updateRemoteRTPCapabilities(e3, t2) {
          return this._p2pConnection.updateRemoteRTPCapabilities(e3, t2);
        }
        send(e3, t2, i2) {
          var n2 = this;
          return Mb((function* () {
            const r2 = yield Vb(n2.mutex.lock("From DataChannelConnection.send"));
            try {
              return yield* xb(cJ(n2._p2pConnection.send(e3, t2, i2)));
            } finally {
              r2();
            }
          }))();
        }
        async stopSending(e3, t2) {
          return this._p2pConnection.stopSending(e3, t2);
        }
        async createDataChannels(e3, t2) {
          return this._p2pConnection.createDataChannels(e3, t2);
        }
        async stopDataChannels(e3) {
          return this._p2pConnection.stopDataChannels(e3);
        }
        async receive(e3, t2, i2, n2) {
          return this._nvMedia ? (iP.debug("[DataChannelConnection] receive ".concat(e3, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e3, t2, this.cname)) : (iP.debug("[DataChannelConnection] receive ".concat(e3, " by WebRTC.")), await this._p2pConnection.receive(e3, t2, i2, n2));
        }
        async batchReceive(e3) {
          return [...await this._p2pConnection.batchReceive(e3)];
        }
        async stopReceiving(e3) {
          return await this._p2pConnection.stopReceiving(e3);
        }
        async muteRemote(e3) {
          return await this._p2pConnection.muteRemote(e3);
        }
        async unmuteRemote(e3) {
          return await this._p2pConnection.unmuteRemote(e3);
        }
        async muteLocal(e3) {
          return await this._p2pConnection.muteLocal(e3);
        }
        async unmuteLocal(e3) {
          return await this._p2pConnection.unmuteLocal(e3);
        }
        restartICE(e3) {
          var t2 = this;
          return Mb((function* () {
            return yield* xb(cJ(t2._p2pConnection.restartICE(e3)));
          }))();
        }
        close() {
          var e3;
          null === (e3 = this._nvMedia) || void 0 === e3 || e3.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
        }
        getStats() {
          return this._p2pConnection.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this._p2pConnection.getRemoteVideoIsReady(e3);
        }
        updateRemoteConnect(e3) {
          var t2;
          return null === (t2 = this._nvMedia) || void 0 === t2 || t2.setRemoteRtpCapabilities(e3), this._p2pConnection.updateRemoteConnect(e3);
        }
        async updateEncoderConfig(e3, t2) {
          return await this._p2pConnection.updateEncoderConfig(e3, t2);
        }
        async updateSendParameters(e3, t2) {
          return await this._p2pConnection.updateSendParameters(e3, t2);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this._p2pConnection.setStatsRemoteVideoIsReady(e3, t2);
        }
        async replaceTrack(e3, t2) {
          return await this._p2pConnection.replaceTrack(e3, t2);
        }
        async getRemoteSSRC(e3) {
          return this._p2pConnection.getRemoteSSRC(e3);
        }
        logSDPExchange(e3, t2, i2, n2) {
          if (CD("SDP_LOGGING")) return iP.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during DataChannelConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
          } : void 0;
        }
        static resolvePCConfiguration(t2) {
          const i2 = { iceServers: [] };
          return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (xO(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), CD("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), CD("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach(((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          })))), CD("ENABLE_ENCODED_TRANSFORM") && pP().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach(((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(sF(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !CD("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          })), t2;
        }
        bindPCEvents() {
          this._p2pConnection.onICEConnectionStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onConnectionStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onDTLSTransportStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onDTLSTransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onDTLSTransportError = (e3) => {
            var t2;
            return null === (t2 = this.onDTLSTransportError) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onICETransportStateChange = (e3) => {
            var t2;
            return null === (t2 = this.onICETransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstAudioReceived = (e3) => {
            var t2;
            return null === (t2 = this.onFirstAudioReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoReceived = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstAudioDecoded = (e3) => {
            var t2;
            return null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoRender = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoRender) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoBufferReady = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoBufferReady) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onFirstVideoDecoded = (e3, t2, i2) => {
            var n2;
            return null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 ? void 0 : n2.call(this, e3, t2, i2);
          }, this._p2pConnection.onFirstVideoDecodedTimeout = (e3) => {
            var t2;
            return null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 ? void 0 : t2.call(this, e3);
          }, this._p2pConnection.onSelectedLocalCandidateChanged = (e3, t2) => {
            var i2;
            return null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e3, t2);
          }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var i2;
            return null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e3, t2);
          };
        }
        closeSignal() {
          this.dataChannel.close(), this.peerConnection.close();
        }
        unbindConnectionEvents(e3) {
          e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0;
        }
        setConfiguration(e3) {
          this._p2pConnection.setConfiguration(e3);
        }
      }, DV(aJ.prototype, "connect", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "connect"), aJ.prototype), DV(aJ.prototype, "updateRemoteRTPCapabilities", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "updateRemoteRTPCapabilities"), aJ.prototype), DV(aJ.prototype, "createDataChannels", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "createDataChannels"), aJ.prototype), DV(aJ.prototype, "receive", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "receive"), aJ.prototype), DV(aJ.prototype, "stopReceiving", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "stopReceiving"), aJ.prototype), DV(aJ.prototype, "muteRemote", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "muteRemote"), aJ.prototype), DV(aJ.prototype, "unmuteRemote", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "unmuteRemote"), aJ.prototype), DV(aJ.prototype, "muteLocal", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "muteLocal"), aJ.prototype), DV(aJ.prototype, "unmuteLocal", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "unmuteLocal"), aJ.prototype), DV(aJ.prototype, "close", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "close"), aJ.prototype), DV(aJ.prototype, "updateEncoderConfig", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "updateEncoderConfig"), aJ.prototype), DV(aJ.prototype, "updateSendParameters", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "updateSendParameters"), aJ.prototype), DV(aJ.prototype, "replaceTrack", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "replaceTrack"), aJ.prototype), DV(aJ.prototype, "getRemoteSSRC", [uJ], Object.getOwnPropertyDescriptor(aJ.prototype, "getRemoteSSRC"), aJ.prototype), aJ);
      function uJ(e2, t2, i2) {
        const n2 = e2[t2];
        if ("function" != typeof n2) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From DataChannelConnection.".concat(t2));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n2.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function hJ(e2, t2) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter((function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          }))), i2.push.apply(i2, n2);
        }
        return i2;
      }
      class pJ extends NO {
        get url() {
          return this._url ? this._url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t2;
          Ln(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(wx.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(wx.CONNECTED) : "closed" === this._state ? this.emit(wx.CLOSED) : "failed" === this._state && this.emit(wx.FAILED));
        }
        constructor(e2, t2, i2, n2) {
          super(), iA(this, "connectionID", 0), iA(this, "currentURLIndex", 0), iA(this, "reconnectReason", void 0), iA(this, "_reconnectMode", "tryNext"), iA(this, "_initMutex", void 0), iA(this, "_name", void 0), iA(this, "_state", "closed"), iA(this, "_reconnectInterrupter", void 0), iA(this, "_url", void 0), iA(this, "_retryConfig", void 0), iA(this, "_reconnectCount", 0), iA(this, "_forceCloseTimeout", 5e3), iA(this, "_onlineReconnectListener", void 0), iA(this, "_closeEstablishingTransmitter", (() => {
          })), iA(this, "_store", void 0), iA(this, "_joinChannelServiceRecordIndex", void 0), iA(this, "_transmitter", void 0), iA(this, "_useCompress", void 0), iA(this, "_inflateLength", 0), iA(this, "_deflateLength", 0), this._store = n2, this._name = e2, this._retryConfig = (function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? hJ(Object(i3), true).forEach((function(t4) {
                iA(e3, t4, i3[t4]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : hJ(Object(i3)).forEach((function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
              }));
            }
            return e3;
          })({}, t2), this._useCompress = i2;
        }
        resetReconnectCount(e2) {
          iP.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e2)), this._reconnectCount = 0;
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
            this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
            const e3 = this._transmitter;
            t2 ? setTimeout((() => e3.close()), 500) : e3.close(), this._transmitter = void 0;
          }
          this.state = e2 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
        }
        reconnect(e2, t2) {
          if (!this._transmitter) return void iP.warning("[".concat(this._name, "] can not reconnect, no websocket"));
          var i2;
          (void 0 !== e2 && (this.reconnectMode = e2), iP.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i2 = this._store) || void 0 === i2 || i2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this._joinChannelServiceRecordIndex));
          const n2 = this._transmitter.onclose;
          this._transmitter.onclose = null, this._transmitter.close(), n2 && n2.bind(this._transmitter)({ code: 9999, reason: t2 });
        }
        getInflateData() {
          const e2 = this._inflateLength, t2 = this._deflateLength;
          return this.clearInflateData(), { inflateLength: e2, deflateLength: t2 };
        }
        setInflateData(e2) {
          this._deflateLength = this._deflateLength + e2.originLength, this._inflateLength = this._inflateLength + e2.compressedLength;
        }
        clearInflateData() {
          this._inflateLength = 0, this._deflateLength = 0;
        }
      }
      let _J = (function(e2) {
        return e2[e2.Default = 0] = "Default", e2[e2.Ack = 1] = "Ack", e2;
      })({});
      class EJ {
        constructor(e2, t2, i2) {
          iA(this, "version", 1), iA(this, "initialRTO", void 0), iA(this, "maxBatchAckCount", void 0), iA(this, "maxRTO", void 0), iA(this, "initialRTT", void 0), iA(this, "ID", void 0), iA(this, "rtt", void 0), iA(this, "packetNumber", 1), iA(this, "rtoRatioMap", /* @__PURE__ */ new Map()), iA(this, "timeoutMap", /* @__PURE__ */ new Map()), iA(this, "unorderedPacketQueue", []), iA(this, "batchAckPacketQueue", []), iA(this, "lastOrderedPacketNumber", 0), iA(this, "batchAckTimer", void 0), iA(this, "sendImpl", void 0), iA(this, "receiveImpl", void 0), this.sendImpl = e2, this.receiveImpl = t2, this.ID = SN(7, "transmitter-"), this.initialRTO = void 0 !== (null == i2 ? void 0 : i2.initialRTO) ? i2.initialRTO : CD("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : CD("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : CD("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i2 ? void 0 : i2.maxBatchAckCount) ? i2.maxBatchAckCount : CD("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i2 ? void 0 : i2.maxRTO) ? i2.maxRTO : CD("TRANSMITTER_MAX_RTO");
        }
        packetize(e2, t2) {
          return { type: _J.Default, version: this.version, packetNumber: t2, payload: e2 };
        }
        serialize(e2) {
          switch (e2.type) {
            case _J.Default: {
              let t2;
              if ("string" == typeof e2.payload) {
                t2 = new TextEncoder().encode(e2.payload);
              } else t2 = e2.payload;
              const i2 = new ArrayBuffer(t2.length + 15), n2 = new DataView(i2);
              n2.setUint16(0, e2.version), n2.setUint8(2, e2.type), n2.setUint32(3, e2.packetNumber), vO(n2, 7, BigInt(e2.sendTs));
              return new Uint8Array(n2.buffer).set(t2, 15), i2;
            }
            case _J.Ack: {
              const t2 = new ArrayBuffer(16), i2 = new DataView(t2);
              return i2.setUint16(0, e2.version), i2.setUint8(2, e2.type), i2.setUint32(3, e2.maxAckPacketNumber), i2.setUint8(7, e2.shift), vO(i2, 8, BigInt(e2.ackSendTs)), t2;
            }
          }
        }
        deserialize(e2) {
          const t2 = new DataView(e2), i2 = t2.getUint16(0), n2 = t2.getUint8(2);
          switch (n2) {
            case _J.Default: {
              const r2 = t2.getUint32(3), o2 = CO(t2, 7), s2 = e2.slice(15), a2 = new Uint8Array(s2);
              return { version: i2, type: n2, packetNumber: r2, sendTs: Number(o2), payload: a2 };
            }
            case _J.Ack: {
              const e3 = t2.getUint32(3), r2 = t2.getUint8(7), o2 = CO(t2, 8);
              return { version: i2, type: n2, maxAckPacketNumber: e3, shift: r2, ackSendTs: Number(o2) };
            }
            default:
              throw iP.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n2)), new Error("Unrecognized packet type ".concat(n2));
          }
        }
        sendMessage(e2) {
          CD("DC_DEBUG_LOG") && "string" == typeof e2 && iP.debug("[".concat(this.ID, "] sending message packet"), JSON.parse(e2));
          const t2 = this.packetize(e2, this.packetNumber);
          this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
          const i2 = this.calculateRTO(t2), n2 = window.setTimeout((() => {
            this.resendMessage(t2);
          }), i2);
          this.timeoutMap.set(t2.packetNumber, n2), this.sendPacket(t2);
        }
        onData(e2) {
          const t2 = this.deserialize(e2);
          t2.type === _J.Default ? this.ack(t2) : t2.type === _J.Ack && (this.updateRTT(t2, Math.round(performance.now())), this.clearRTO(t2));
        }
        close() {
          this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach(((e2) => {
            let [t2, i2] = e2;
            window.clearTimeout(i2);
          })), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
        }
        resendMessage(e2) {
          const t2 = this.calculateRTO(e2), i2 = window.setTimeout((() => {
            CD("DC_DEBUG_LOG") && "string" == typeof e2.payload && iP.debug("[".concat(this.ID, "] resending message packet"), JSON.parse(e2.payload), "timeout: ".concat(t2)), this.resendMessage(e2);
          }), t2);
          this.timeoutMap.set(e2.packetNumber, i2), this.sendPacket(e2);
        }
        calculateRTO(e2) {
          const t2 = this.rtoRatioMap.get(e2.packetNumber);
          if (void 0 === t2) return this.rtoRatioMap.set(e2.packetNumber, 1), this.initialRTO;
          {
            const i2 = 9 * this.rtt / 8 * t2;
            return this.rtoRatioMap.set(e2.packetNumber, t2 + 1), i2 > this.maxRTO ? this.maxRTO : i2;
          }
        }
        updateRTT(e2, t2) {
          const i2 = e2.ackSendTs;
          this.rtt = this.rtt * (7 / 8) + (t2 - i2 - this.rtt) / 8;
        }
        ack(e2) {
          if (e2.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e2) : (this.batchAckPacketQueue.push(e2), this.batchAckTimer = window.setTimeout((() => {
            this.batchAck();
          }), this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e2.payload); ; ) {
            const e3 = this.unorderedPacketQueue[0];
            if (!e3) {
              this.unorderedPacketQueue.shift();
              break;
            }
            this.batchAckTimer && this.batchAck(), this.receiveImpl(e3.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
          }
          else if (e2.packetNumber <= this.lastOrderedPacketNumber) {
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: _J.Ack, version: this.version };
            CD("DC_DEBUG_LOG") && iP.debug("[".concat(this.ID, "] sending ack packet"), t2, "packetNumber: ".concat(e2.packetNumber)), this.sendPacket(t2);
          } else if (e2.packetNumber > this.lastOrderedPacketNumber) {
            this.unorderedPacketQueue[e2.packetNumber - this.lastOrderedPacketNumber - 2] = e2;
            const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: _J.Ack, version: this.version };
            CD("DC_DEBUG_LOG") && iP.debug("[".concat(this.ID, "] sending ack packet"), t2, "packetNumber: ".concat(e2.packetNumber)), this.sendPacket(t2);
          }
        }
        batchAck() {
          window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
          const e2 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: _J.Ack, version: this.version };
          CD("DC_DEBUG_LOG") && iP.debug("[".concat(this.ID, "] sending batch ack packet"), e2, "shift: ".concat(this.batchAckPacketQueue.length - 1)), this.sendPacket(e2), this.batchAckPacketQueue = [];
        }
        sendPacket(e2) {
          e2.type === _J.Default && (e2.sendTs = Math.round(performance.now()));
          const t2 = this.serialize(e2);
          this.sendImpl(t2);
        }
        clearRTO(e2) {
          for (let t2 = e2.maxAckPacketNumber - e2.shift; t2 <= e2.maxAckPacketNumber; t2++) {
            const e3 = this.timeoutMap.get(t2);
            void 0 !== e3 && window.clearTimeout(e3), this.timeoutMap.delete(t2), this.rtoRatioMap.delete(t2);
          }
        }
      }
      class mJ extends pJ {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), iA(this, "_initMutex", void 0), iA(this, "_reconnectInterrupter", void 0), iA(this, "_url", void 0), iA(this, "_transmitter", void 0), iA(this, "_addresses", void 0), iA(this, "_reliableTransmission", void 0), iA(this, "_textEncoder", void 0), iA(this, "_textDecoder", void 0), this._textEncoder = new TextEncoder(), this._textDecoder = new TextDecoder(), this._initMutex = new PN("datachannel");
          const { timeout: i2, timeoutFactor: n2 } = t2, r2 = Math.max(300, Math.floor(3 * i2 / 5)), o2 = Math.max(1.2, Math.floor(8 * n2) / 10);
          KO.ONLINE && (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2), QO.on(YO.NETWORK_STATE_CHANGE, ((e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === KO.ONLINE ? (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2) : (this._retryConfig.timeout = i2, this._retryConfig.timeoutFactor = n2));
          }));
        }
        getConnection() {
          if (this._reliableTransmission) return this._reliableTransmission;
        }
        async init(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          this._forceCloseTimeout = t2;
          const i2 = (t3, i3) => {
            this._addresses = e2, this.currentURLIndex = this._addresses.findIndex(((e3) => e3.fingerprint || CD("FINGERPRINT")));
            const n2 = this._addresses[this.currentURLIndex];
            this.state = "connecting", this.createTransmitterConnection(n2).then(t3).catch(i3), this.once(wx.CLOSED, (() => i3(new uP(hO.WS_DISCONNECT)))), this.once(wx.CONNECTED, (() => t3()));
          };
          return this._initMutex.lock().then(((e3) => new rp(((e4, t3) => {
            i2(e4, t3);
          })).then((() => {
            e3();
          })).catch((() => {
            e3();
          }))));
        }
        async sendMessage(e2) {
          let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this._transmitter || !this._reliableTransmission) throw new uP(hO.WS_ABORT, "datachannel is not ready");
          try {
            t2 || (e2 = JSON.stringify(e2));
            const i2 = this._textEncoder.encode(e2), n2 = hq(i2, { raw: true });
            this._reliableTransmission.sendMessage(n2);
          } catch (e3) {
            throw new uP(hO.WS_ERR, "send datachannel signal message error" + e3.toString());
          }
        }
        unbindDcCloseEventListener() {
          this._transmitter && (this._transmitter.onclose = null);
        }
        sendMessageWithJSON(e2) {
          const t2 = JSON.stringify(e2);
          return { compressed: t2, compressedLength: t2.length, origin: e2 };
        }
        sendMessageWithUint8Array(e2) {
          return { compressed: e2, compressedLength: e2.byteLength, origin: e2 };
        }
        createTransmitterConnection(e2) {
          return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e2.ip, ":").concat(e2.port), new rp(((t2, i2) => {
            var n2;
            const r2 = () => {
              iP.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "recover", this.state = "connected", this.resetReconnectCount("opened"), t2();
            }, o2 = async (e3) => {
              var n3;
              if (null === (n3 = this._closeEstablishingTransmitter) || void 0 === n3 || n3.call(this), iP.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
                "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const n4 = XO(this, wx.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(n4);
                if ("closed" === this.state) return void iP.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
                if (!r3) return i2(new uP(hO.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e3.code))), void this.close(true);
                t2();
              } else i2(new uP(hO.WS_DISCONNECT, "datachannel close: ".concat(e3.code))), this.close();
            }, s2 = async (e3) => {
              try {
                var t3;
                null === (t3 = this._reliableTransmission) || void 0 === t3 || t3.onData(e3.data);
              } catch (e4) {
                console.log(e4);
              }
            };
            this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), iP.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e2)));
            const a2 = null === (n2 = this._store) || void 0 === n2 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c2 = Date.now();
            zO(this, wx.TO_CONNECT_DATACHANNEL).then(((e3) => {
              var t3, i3;
              if (!e3) throw new Error("transmissonInfo not exist yet");
              const { transmitter: n3, close: d2 } = e3;
              this._transmitter = n3, null === (t3 = this._store) || void 0 === t3 || t3.signalChannelOpen();
              const l2 = Date.now() - c2;
              iP.debug("[choose dc] dc open cost ".concat(l2, "ms"));
              this._reliableTransmission = new EJ(((e4) => {
                var t4;
                this._transmitter && "open" === this._transmitter.readyState && (null === (t4 = this._transmitter) || void 0 === t4 || t4.send(e4));
              }), ((e4) => {
                if ("string" == typeof e4) this.emit(wx.ON_MESSAGE, e4);
                else {
                  const t4 = _q(e4, { raw: true }).buffer, i4 = this._textDecoder.decode(t4);
                  this.emit(wx.ON_MESSAGE, i4);
                }
              })), this._closeEstablishingTransmitter = () => {
                var e4;
                null === (e4 = this._reliableTransmission) || void 0 === e4 || e4.close(), this._reliableTransmission = void 0, d2();
              }, r2 && r2(), n3.onclose = o2, n3.onmessage = s2, null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this._joinChannelServiceRecordIndex = a2;
            })).catch(((e3) => {
              var t3;
              if (null === (t3 = this._store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof uP && e3.code === hO.WS_ABORT ? "aborted" : "error", errors: [e3] }, a2), "closed" !== this.state) {
                if (e3 instanceof uP && e3.code === hO.WS_ERR) {
                  const t4 = new uP(hO.WS_ERR, "init datachannel failed! Error: ".concat(e3.toString()));
                  return iP.error("[".concat(this._name, "]").concat(t4)), void i2(t4);
                }
                o2 && o2(e3);
              } else i2(new uP(hO.WS_DISCONNECT, "datachannel is closed: ".concat(e3.toString())));
            }));
          }));
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this._reconnectCount >= this._retryConfig.maxRetryCount) return false;
          if (!this._addresses) return false;
          if ("closed" === this.state) return false;
          this._onlineReconnectListener || QO.networkState !== KO.OFFLINE || (this._onlineReconnectListener = QO.onlineWaiter && QO.onlineWaiter.then((() => {
            this._onlineReconnectListener = void 0;
          })));
          let i2 = true;
          if (this._reconnectInterrupter = () => {
            i2 = false;
          }, t2) {
            const t3 = MN(this._reconnectCount, this._retryConfig);
            iP.debug("[".concat(this._name, "] wait ").concat(t3, "ms to reconnect datachannel, mode: ").concat(e2)), await rp.race([fN(t3), this._onlineReconnectListener || new rp((() => {
            }))]);
          }
          if ("closed" === this.state || !i2) return false;
          this._reconnectCount += 1;
          const n2 = async (e3, t3) => {
            this.emit(wx.RECONNECT_CREATE_CONNECTION, t3), await this.createTransmitterConnection(e3);
          };
          try {
            if ("retry" === e2) {
              const t3 = this._addresses[this.currentURLIndex];
              await n2(t3, e2);
            } else if ("tryNext" === e2) {
              this.currentURLIndex += 1;
              for (let e3 = this.currentURLIndex; e3 < this._addresses.length; e3++) {
                if (this._addresses[e3].fingerprint || CD("FINGERPRINT")) {
                  this.currentURLIndex = e3;
                  break;
                }
                this.currentURLIndex += 1;
              }
              if (this.currentURLIndex >= this._addresses.length) return iP.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
              iP.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
              const t3 = this._addresses[this.currentURLIndex];
              await n2(t3, e2);
            } else "recover" === e2 && (iP.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(wx.FAILBACK));
            return true;
          } catch (i3) {
            var r2, o2;
            return iP.error("[".concat(this._name, "] reconnect failed"), i3.toString()), null != i3 && null !== (r2 = i3.data) && void 0 !== r2 && r2.desc && Array.isArray(i3.data.desc) && i3.data.desc.length && Ln(o2 = i3.data.desc).call(o2, "dynamic key expired") ? (this.emit(wx.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
          }
        }
      }
      class fJ extends NO {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === VV.CONNECTED ? this.emit(xV.WS_CONNECTED) : e2 === VV.RECONNECTING ? this.emit(xV.WS_RECONNECTING, this._websocketReconnectReason) : e2 === VV.CLOSED && this.emit(xV.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        processPendingNotifications() {
          0 !== this.pendingNotifications.length && (iP.debug("[".concat(this.clientId, "] processing ").concat(this.pendingNotifications.length, " pending notifications")), this.pendingNotifications.forEach(((e2) => {
            let { type: t2, message: i2 } = e2;
            this.emit(t2, i2), t2 === jV.ON_NOTIFICATION && this.handleNotification(i2), t2 === jV.ON_USER_BANNED && this.handleUserBanned(i2);
          })), this.pendingNotifications = []);
        }
        handleUserBanned(e2) {
          switch (e2.error_code) {
            case 14:
              this.close(VO.UID_BANNED);
              break;
            case 15:
              this.close(VO.IP_BANNED);
              break;
            case 16:
              this.close(VO.CHANNEL_BANNED);
          }
        }
        constructor(e2, t2) {
          super(), iA(this, "__name__", "DataChannelSignal"), iA(this, "_disconnectedReason", void 0), iA(this, "_websocketReconnectReason", void 0), iA(this, "_connectionState", VV.CLOSED), iA(this, "reconnectToken", void 0), iA(this, "websocket", void 0), iA(this, "openConnectionTime", void 0), iA(this, "clientId", void 0), iA(this, "lastMsgTime", Date.now()), iA(this, "uploadCache", []), iA(this, "uploadCacheInterval", void 0), iA(this, "rttRolling", new xN(5)), iA(this, "pingpongTimer", void 0), iA(this, "inflateDataTimer", void 0), iA(this, "pingpongTimeoutCount", 0), iA(this, "ortc", void 0), iA(this, "joinResponse", void 0), iA(this, "multiIpOption", void 0), iA(this, "initError", void 0), iA(this, "spec", void 0), iA(this, "store", void 0), iA(this, "isJoining", false), iA(this, "pendingNotifications", []), iA(this, "onWebsocketMessage", ((e3) => {
            if (e3 instanceof ArrayBuffer) return void this.emit(xV.ON_BINARY_DATA, e3);
            const t3 = JSON.parse(e3);
            if (CD("DC_DEBUG_LOG") && iP.debug("[datachannel-signal] received packet", t3), this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else Object.prototype.hasOwnProperty.call(t3, "_type") && (this.isJoining ? t3._type === jV.ON_NOTIFICATION || t3._type === jV.ON_USER_BANNED ? (this.emit(t3._type, t3._message), t3._type === jV.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === jV.ON_USER_BANNED && this.handleUserBanned(t3._message)) : (this.pendingNotifications.push({ type: t3._type, message: t3._message }), iP.debug("[".concat(this.clientId, "] cached notification during join: ").concat(t3._type))) : (this.emit(t3._type, t3._message), t3._type === jV.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === jV.ON_USER_BANNED && this.handleUserBanned(t3._message)));
          })), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new mJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", (() => {
            this.connectionState === VV.CONNECTED && this.reconnect("retry", bx.OFFLINE);
          }));
        }
        async request(e2, t2, i2, n2) {
          const r2 = SN(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new rp(((t3, i3) => {
            if (this.connectionState === VV.CONNECTED) return t3();
            const n3 = () => {
              this.off(xV.WS_CLOSED, r3), t3();
            }, r3 = () => {
              this.off(xV.WS_CONNECTED, n3), i3(new uP(hO.WS_ABORT));
            };
            this.once(xV.WS_CONNECTED, n3), this.once(xV.WS_CLOSED, r3), e2 !== FV.PUBLISH && e2 !== FV.SUBSCRIBE && e2 !== FV.UNSUBSCRIBE && e2 !== FV.UNPUBLISH && e2 !== FV.CONTROL && e2 !== FV.RESTART_ICE || this.once(xV.DISCONNECT_P2P, (() => {
              i3(new uP(hO.DISCONNECT_P2P));
            })), e2 !== FV.PUBLISH && e2 !== FV.RESTART_ICE || this.once(xV.ABORT_P2P_EXECUTION, (() => {
              i3(new uP(hO.DISCONNECT_P2P));
            }));
          }));
          if (this.connectionState !== VV.CONNECTING && this.connectionState !== VV.RECONNECTING || e2 === FV.JOIN || e2 === FV.REJOIN || await a2(), e2 === FV.LEAVE && (this.websocket.unbindDcCloseEventListener(), n2 = true), CD("DC_DEBUG_LOG") && iP.debug("[datachannel-signal] sendMessage", o2), await this.websocket.sendMessage(o2, true, false), n2) return;
          const c2 = new rp(((i3, n3) => {
            let o3 = false;
            const a3 = (n4, r3) => {
              o3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.emit(xV.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(r2), a3);
            const c3 = () => {
              n3(new uP(hO.WS_ABORT, "type: ".concat(e2))), this.off(xV.WS_CLOSED, c3), this.off(xV.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
            };
            this.once(xV.WS_CLOSED, c3), this.once(xV.WS_RECONNECTING, c3), fN(CD("SIGNAL_REQUEST_TIMEOUT")).then((() => {
              this.websocket.connectionID !== s2 || o3 || (iP.warning("dc request timeout, type: ".concat(e2)), this.emit(xV.REQUEST_TIMEOUT, e2, t2));
            }));
          }));
          let d2 = null;
          try {
            d2 = await c2;
          } catch (n3) {
            if (this.connectionState === VV.CLOSED || e2 === FV.LEAVE) throw new uP(hO.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === FV.JOIN || e2 === FV.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u2 = Bx(l2), h2 = new uP(hO.UNEXPECTED_RESPONSE, "".concat(u2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
          return "success" === u2.action ? d2.message : (iP.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u2.desc, ", action: ").concat(u2.action)), l2 === UV.ERR_TOO_MANY_BROADCASTERS ? e2 === FV.JOIN || e2 === FV.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u2.action ? h2.throw() : "quit" === u2.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === UV.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, iP.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", bx.MULTI_IP)) : this.reconnect(u2.action, bx.SERVER_ERROR), e2 === FV.JOIN || e2 === FV.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new rp(((i2) => {
            const n2 = (r2) => {
              (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
            };
            this.on(e2, n2);
          }));
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void iP.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t2 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(BV.WRTC_STATS, t2);
        }
        upload(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t3 = CD("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval((() => {
              if (this.connectionState !== VV.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }), CD("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        async send(e2, t2) {
          const i2 = { _type: e2, _message: t2 };
          await this.websocket.sendMessage(i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new rp(((t2, i2) => {
            this.once(xV.WS_CONNECTED, (() => t2(this.joinResponse))), this.once(xV.WS_CLOSED, (() => i2(this.initError || new uP(hO.WS_ABORT)))), this.connectionState = VV.CONNECTING, this.websocket.init(e2).catch(i2), this.websocket.once(wx.FAILBACK, (() => {
              i2(new uP(hO.INIT_DATACHANNEL_TIMEOUT));
            })), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval((() => {
              this.handleInflateData();
            }), 2e4), setTimeout((() => {
              void 0 === this.openConnectionTime && (iP.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), i2(new uP(hO.INIT_DATACHANNEL_TIMEOUT)));
            }), CD("DC_JOIN_WITH_FAILBACK"));
          }));
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this.isJoining = false, this.pendingNotifications = [], this._disconnectedReason = e2 || VO.LEAVE, this.connectionState = VV.CLOSED, iP.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e2 === VO.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new mJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), CD("DC_PINGPONG_INTERVAL")), !this.joinResponse) {
            this.emit(xV.ABORT_P2P_EXECUTION), this.store.signalConnected();
            const e2 = await zO(this, xV.REQUEST_JOIN_INFO);
            this.store.joinReq(), this.isJoining = true, this.pendingNotifications = [];
            const t2 = await this.request(FV.JOIN, e2);
            if (this.store.joinRep(), this.ortc = null == e2 ? void 0 : e2.ortc, !t2) return this.emit(xV.REPORT_JOIN_GATEWAY, hO.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(xV.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = VV.CONNECTED, this.isJoining = false, this.processPendingNotifications(), true;
        }
        async rejoin() {
          if (!this.reconnectToken) throw new uP(hO.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = JO(this, xV.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(FV.REJOIN, e2);
          return !!t2 && (this.connectionState = VV.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), CD("DC_PINGPONG_INTERVAL")), t2.peers && t2.peers.forEach(((e3) => {
            this.emit(jV.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(jV.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(jV.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(jV.MUTE_AUDIO, { uid: e3.uid }) : this.emit(jV.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(jV.MUTE_VIDEO, { uid: e3.uid }) : this.emit(jV.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(jV.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(jV.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(jV.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(jV.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(jV.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          })), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        async downgradeCodec(e2) {
          if (!this.ortc) return false;
          const t2 = { downgrade_codec: e2, ortc: this.ortc };
          return !!await this.request(FV.DOWNGRADE_CODEC, t2);
        }
        handleNotification(e2) {
          iP.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t2 = Bx(e2.code);
          if ("success" !== t2.action) {
            if ("failed" !== t2.action) return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(VO.UID_BANNED), void this.close()) : void this.reconnect(t2.action, bx.SERVER_ERROR);
            iP.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1, CD("DC_DEBUG_LOG") && console.debug("[datachannel-signal] pingpongTimeoutCount: ".concat(this.pingpongTimeoutCount));
          const e2 = CD("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (iP.warning("[datachannel-signal] PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > CD("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("recover", bx.FALLBACK) : this.request(FV.PING, void 0, true).then((() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), CD("REPORT_STATS") && this.send(FV.PING_BACK, { pingpongElapse: e3 });
          })).catch(((e3) => {
          }));
        }
        handleInflateData() {
          const { inflateLength: e2, deflateLength: t2 } = this.websocket.getInflateData();
          0 !== e2 && 0 !== t2 && this.upload(BV.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(wx.RECONNECT_CREATE_CONNECTION, ((e2) => {
            this.emit(xV.WS_RECONNECT_CREATE_CONNECTION, e2);
          })), this.websocket.on(wx.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(wx.CLOSED, (() => {
            this.connectionState = VV.CLOSED;
          })), this.websocket.on(wx.FAILED, (() => {
            this._disconnectedReason = VO.NETWORK_ERROR, this.connectionState = VV.CLOSED;
          })), this.websocket.on(wx.RECONNECTING, ((e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === VV.CONNECTED ? this.connectionState = VV.RECONNECTING : this.connectionState = VV.CONNECTING;
          })), this.websocket.on(wx.WILL_RECONNECT, ((e2, t2) => {
            if (JO(this, xV.IS_P2P_DISCONNECTED) && "retry" === e2) return iP.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(xV.NEED_RENEW_SESSION), this.emit(xV.DISCONNECT_P2P), t2("tryNext");
            "retry" !== e2 && (iP.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(xV.NEED_RENEW_SESSION), this.emit(xV.DISCONNECT_P2P)), t2(e2);
          })), this.websocket.on(wx.CONNECTED, (() => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(((e2) => {
              iP.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", bx.SERVER_ERROR);
            })) : this.join().catch(((e2) => {
              if (this.emit(xV.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof uP && e2.code === hO.UNEXPECTED_RESPONSE && e2.data.code === UV.ERR_NO_AUTHORIZED) return iP.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", bx.SERVER_ERROR);
              iP.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", bx.SERVER_ERROR) : (this.initError = e2, this.close());
            }));
          })), this.websocket.on(wx.REQUEST_NEW_URLS, ((e2, t2) => {
            zO(this, xV.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          })), this.websocket.on(wx.ON_TOKEN_PRIVILEGE_DID_EXPIRE, (() => {
            this.emit(jV.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          })), this.websocket.on(wx.TO_CONNECT_DATACHANNEL, ((e2, t2) => {
            zO(this, xV.PRE_CONNECT_PC).then(e2).catch(t2);
          })), this.websocket.on(wx.FAILBACK, (() => {
            void 0 !== this.openConnectionTime && this.emit(xV.DATACHANNEL_FAILBACK);
          }));
        }
      }
      const SJ = { name: "DataChannelConnection", create: function(e2) {
        let { store: t2, spec: i2 } = e2;
        return new lJ(i2, t2);
      } };
      const gJ = { name: "DataChannelSignal", create: function(e2) {
        let { store: t2, spec: i2 } = e2;
        return new fJ(i2, t2);
      } };
      uD(), RD("PROCESS_ID", "process-".concat(SN(8, ""), "-").concat(SN(4, ""), "-").concat(SN(4, ""), "-").concat(SN(4, ""), "-").concat(SN(12, ""))), (function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void iP.error("Error loading sdk config", e3.message);
        }
        if (e2) try {
          const t2 = JSON.parse(window.atob(e2)), i2 = Date.now();
          iP.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach(((e3) => {
            if (Object.prototype.hasOwnProperty.call(TD, e3)) {
              const { value: n2, expires: r2 } = t2[e3];
              if (r2 && r2 <= i2) return;
              yD[e3] = n2, TD[e3] = n2;
            }
          }));
        } catch (t2) {
          iP.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
        }
      })(), Array.isArray(yD.AREAS) && yD.AREAS.length > 0 && vB(yD.AREAS, true);
      const TJ = (e2, t2, i2) => {
        iP.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), RD(e2, t2, i2);
      };
      rB(Tq, false), rB(bq, false), rB(PW, false), rB(rX, false), rB(fq, false), rB(HX, false), rB($X, false), rB(tJ, false), rB(SJ, false), rB(gJ, false);
      const RJ = (function(e2) {
        const t2 = new NO(), i2 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i3) => ((function(e4, t3) {
          e4 === Ox.SECURITY_POLICY_VIOLATION && MH(t3, true);
        })(e3, i3), t2.on.bind(t2)(e3, i3)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
        return LH(LH({}, i2), n2);
      })({ __TRACK_LIST__: kP, VERSION: hD, BUILD: SD, ESM_BUNDLER: false, ESM: false, UMD: true, DEV: false, setParameter: TJ, getParameter: CD, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t2 = new RTCPeerConnection();
          const i2 = await (async function(e3) {
            let t3;
            return pP().supportUnifiedPlan ? (e3.addTransceiver("video", { direction: "recvonly" }), e3.addTransceiver("audio", { direction: "recvonly" }), t3 = (await e3.createOffer()).sdp) : t3 = (await e3.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })).sdp, t3;
          })(t2);
          if (!i2) return e2;
          t2.close(), t2 = null, e2 = (function(e3) {
            const t3 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
          })(i2);
        } catch (e3) {
          throw new uP(hO.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        const t2 = lP.reportApiInvoke(null, { name: LO.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: kO.TRACER }), i2 = (function() {
          let e3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], t3 = false;
          try {
            const i3 = window.RTCPeerConnection, n3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, r3 = window.WebSocket;
            t3 = !(!i3 || !r3), e3 && !n3 && (t3 = false), t3 && aO() && Ww(75) && new i3().close();
          } catch (e4) {
            iP.error("check system requirement failed: ", e4), t3 = false;
          }
          return t3;
        })(e2), n2 = AH();
        iP.debug("checkSystemRequirements, api:", i2, "browser", n2);
        const r2 = i2 && n2;
        return t2.onSuccess(r2), CD("IGNORE_RTC_DEVICE_CHECK") ? i2 : r2;
      }, getDevices: function(e2) {
        return PL.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return PL.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return PL.getCamerasDevices(e2);
      }, getElectronScreenSources: yL, getPlaybackDevices: function(e2) {
        return PL.getSpeakers(e2);
      }, createClient: IH, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = CD("CAMERA_CAPTURE_CONFIG"), i2 = SN(8, "track-cam-"), n2 = lP.reportApiInvoke(null, { id: i2, tag: kO.TRACER, name: LO.CREATE_CAM_VIDEO_TRACK, options: [cL({}, e2), t2] });
        t2 && (e2.encoderConfig = t2);
        const r2 = zL(e2);
        let o2 = null;
        iP.info("start create camera video track with config", JSON.stringify(e2), "trackId", i2);
        try {
          o2 = (await wL({ video: r2 }, i2)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw n2.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new pO(hO.UNEXPECTED_ERROR, "can not find track in media stream");
          return n2.onError(e3), e3.throw(iP);
        }
        if (e2.optimizationMode && VM(i2, o2, e2, OP(e2.encoderConfig)), CD("USE_STANDARD_BITRATE_DEFAULT")) {
          const t3 = OP(e2.encoderConfig);
          e2.encoderConfig = t3, delete t3.bitrateMax, delete t3.bitrateMin;
        }
        const s2 = new MM(o2, e2, r2, e2.scalabiltyMode ? DP(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, i2);
        return n2.onSuccess(s2.getTrackId()), iP.info("create camera video success, trackId:", i2), s2;
      }, createCustomVideoTrack: function(e2) {
        const t2 = SN(8, "track-cus-"), i2 = lP.reportApiInvoke(null, { id: t2, tag: kO.TRACER, name: LO.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] });
        CD("USE_STANDARD_BITRATE_DEFAULT") && (delete e2.bitrateMax, delete e2.bitrateMin);
        const n2 = new kM(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? DP(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, t2, [VP.CUSTOM_TRACK]);
        return i2.onSuccess(n2.getTrackId()), iP.info("create custom video track success with config", e2, "trackId", n2.getTrackId()), n2;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i2 = "object" == typeof t2 ? (function(e3) {
          const t3 = qL(e3);
          return gP() && e3.suppressLocalAudioPlayback && (t3.suppressLocalAudioPlayback = e3.suppressLocalAudioPlayback), TP() && e3.restrictOwnAudio && (t3.restrictOwnAudio = true), t3;
        })(t2) : void 0;
        i2 && (t2 = "auto");
        const n2 = SN(8, "track-scr-v-"), r2 = lP.reportApiInvoke(null, { id: n2, tag: kO.TRACER, name: LO.CREATE_SCREEN_VIDEO_TRACK, options: [cL({}, e2), t2] });
        e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const o2 = (function(e3) {
          const t3 = {};
          e3.screenSourceType && (t3.mediaSource = e3.screenSourceType), e3.extensionId && Uw() && (t3.extensionId = e3.extensionId);
          const { displaySurface: i3, selfBrowserSurface: n3, surfaceSwitching: r3, systemAudio: o3, preferCurrentTab: s3, windowAudio: a3, monitorTypeSurfaces: c3 } = e3;
          (Gw(107) || Kw(107) || Qw(93)) && (i3 && (EO(i3, "displaySurface", ["browser", "window", "monitor"]), t3.displaySurface = i3), n3 ? (EO(n3, "selfBrowserSurface", ["exclude", "include"]), t3.selfBrowserSurface = n3) : t3.selfBrowserSurface = "include", r3 && (EO(r3, "surfaceSwitching", ["exclude", "include"]), t3.surfaceSwitching = r3)), (Gw(105) || Kw(105) || Qw(91)) && o3 && (EO(o3, "systemAudio", ["exclude", "include"]), t3.systemAudio = o3), (Gw(94) || Kw(94) || Qw(80)) && s3 && (t3.preferCurrentTab = true), (Gw(141) || Kw(141) || Qw(125)) && a3 && (EO(a3, "windowAudio", ["exclude", "system"]), t3.windowAudio = a3), (Gw(119) || Kw(119) || Qw(105)) && c3 && (EO(c3, "monitorTypeSurfaces", ["exclude", "include"]), t3.monitorTypeSurfaces = c3), e3.electronScreenSourceId && (t3.sourceId = e3.electronScreenSourceId);
          const d3 = e3.encoderConfig ? NP(e3.encoderConfig) : null;
          return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: d3 ? d3.width : void 0, maxHeight: d3 ? d3.height : void 0 }, d3 && (d3.frameRate && ("number" == typeof d3.frameRate ? (t3.mandatory.maxFrameRate = d3.frameRate, t3.mandatory.minFrameRate = d3.frameRate) : (t3.mandatory.maxFrameRate = d3.frameRate.max || d3.frameRate.ideal || d3.frameRate.exact || void 0, t3.mandatory.minFrameRate = d3.frameRate.min || d3.frameRate.ideal || d3.frameRate.exact || void 0), t3.frameRate = d3.frameRate), d3.width && (t3.width = d3.width), d3.height && (t3.height = d3.height)), t3;
        })(e2);
        let s2 = null, a2 = null;
        const c2 = pP();
        if (!c2.supportShareAudio && "enable" === t2) {
          const e3 = new pO(hO.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return r2.onError(e3), e3.throw(iP);
        }
        iP.info("start create screen video track with config", e2, "withAudio", t2, "trackId", n2);
        const d2 = c2.supportShareAudio && "disable" !== t2;
        try {
          const e3 = await wL({ screen: o2, screenAudio: d2 ? i2 || true : void 0 }, n2);
          s2 = e3.getVideoTracks()[0] || null, a2 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        if (!s2) {
          const e3 = new pO(hO.UNEXPECTED_ERROR, "can not find track in media stream");
          return r2.onError(e3), e3.throw(iP);
        }
        if (!a2 && "enable" === t2) {
          s2 && s2.stop();
          const e3 = new pO(hO.SHARE_AUDIO_NOT_ALLOWED);
          return r2.onError(e3), e3.throw(iP);
        }
        e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (VM(n2, s2, e2, e2.encoderConfig && NP(e2.encoderConfig) || void 0), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
        const l2 = new kM(s2, e2.encoderConfig ? NP(e2.encoderConfig) : {}, e2.scalabiltyMode ? DP(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2, [VP.SCREEN_TRACK]);
        if (!a2) return r2.onSuccess(l2.getTrackId()), iP.info("create screen video track success", "video:", l2.getTrackId()), l2;
        const u2 = new Bk(a2, void 0, SN(8, "track-scr-a-"), false);
        return r2.onSuccess([l2.getTrackId(), u2.getTrackId()]), iP.info("create screen video track success", "video:", l2.getTrackId(), "audio:", u2.getTrackId()), [l2, u2];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = CD("CAMERA_CAPTURE_CONFIG"), n2 = SN(8, "track-mic-"), r2 = SN(8, "track-cam-"), o2 = lP.reportApiInvoke(null, { id: "".concat(n2, "-").concat(r2), tag: kO.TRACER, name: LO.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2, i2] });
        i2 && (t2.encoderConfig = i2);
        const s2 = zL(t2), a2 = XL(e2);
        let c2 = null, d2 = null;
        iP.info("start create camera video track(".concat(r2, ") and microphone audio track(").concat(n2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
        try {
          const e3 = await wL({ audio: a2, video: s2 }, "".concat(n2, "-").concat(r2));
          c2 = e3.getAudioTracks()[0], d2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw o2.onError(e3), e3;
        }
        if (!c2 || !d2) {
          const e3 = new pO(hO.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return o2.onError(e3), e3.throw(iP);
        }
        if (t2.optimizationMode && VM(r2, d2, t2, OP(t2.encoderConfig)), CD("USE_STANDARD_BITRATE_DEFAULT")) {
          const e3 = OP(t2.encoderConfig);
          t2.encoderConfig = e3, delete e3.bitrateMax, delete e3.bitrateMin;
        }
        const l2 = new jk(c2, e2, a2, n2), u2 = new MM(d2, t2, s2, t2.scalabiltyMode ? DP(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, r2);
        return o2.onSuccess([l2.getTrackId(), u2.getTrackId()]), iP.info("create camera video track(".concat(r2, ") and microphone audio track(").concat(n2, ") success")), [l2, u2];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t2 = SN(8, "track-mic-"), i2 = lP.reportApiInvoke(null, { id: t2, tag: kO.TRACER, name: LO.CREATE_MIC_AUDIO_TRACK, options: [e2] }), n2 = XL(e2);
        let r2 = null;
        iP.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", t2);
        try {
          r2 = (await wL({ audio: n2 }, t2)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new pO(hO.UNEXPECTED_ERROR, "can not find track in media stream");
          return i2.onError(e3), e3.throw(iP);
        }
        const o2 = new jk(r2, e2, n2, t2);
        return i2.onSuccess(o2.getTrackId()), iP.info("create microphone audio track success, trackId:", t2), o2;
      }, createCustomAudioTrack: UM, createBufferSourceAudioTrack: async function(e2) {
        var t2;
        const { cacheOnlineFile: i2, encoderConfig: n2 } = e2;
        let { source: r2 } = e2;
        const o2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t2 = File.name) && void 0 !== t2 ? t2 : "File" : r2, cacheOnlineFile: i2, encoderConfig: n2 }, s2 = SN(8, "track-buf-"), a2 = lP.reportApiInvoke(null, { id: s2, tag: kO.TRACER, name: LO.CREATE_BUFFER_AUDIO_TRACK, options: [o2] });
        if (CD("DISABLE_WEBAUDIO")) throw new pO(hO.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
        iP.info("start create buffer source audio track with config", JSON.stringify(o2), "trackId", s2);
        const c2 = r2;
        if (!(r2 instanceof AudioBuffer)) try {
          r2 = await (async function(e3, t3) {
            let i3 = null;
            if ("string" == typeof e3) {
              const t4 = Kk.get(e3);
              if (t4) return iP.debug("use cached audio resource: ", e3), t4;
              try {
                i3 = (await UN((() => Tw.get(e3, { responseType: "arraybuffer" })), void 0, void 0, { maxRetryCount: 3 })).data;
              } catch (e4) {
                throw new pO(hO.FETCH_AUDIO_FILE_FAILED, e4.toString());
              }
            } else {
              const t4 = new rp(((t5, i4) => {
                const n4 = new FileReader();
                n4.onload = (e4) => {
                  e4.target ? t5(e4.target.result) : i4(new pO(hO.READ_LOCAL_AUDIO_FILE_ERROR));
                }, n4.onerror = () => {
                  i4(new pO(hO.READ_LOCAL_AUDIO_FILE_ERROR));
                }, n4.readAsArrayBuffer(e3);
              }));
              i3 = await t4;
            }
            const n3 = await (function(e4) {
              const t4 = EL();
              return new rp(((i4, n4) => {
                t4.decodeAudioData(e4, ((e5) => {
                  i4(e5);
                }), ((e5) => {
                  n4(new pO(hO.DECODE_AUDIO_FILE_FAILED, e5.toString()));
                }));
              }));
            })(i3);
            return "string" == typeof e3 && t3 && Kk.set(e3, n3), n3;
          })(r2, i2);
        } catch (e3) {
          return a2.onError(e3), e3.throw(iP);
        }
        const d2 = new Hk(r2), l2 = new Gk(c2, d2, n2 ? LP(n2) : {}, s2);
        return iP.info("create buffer source audio track success, trackId:", s2), a2.onSuccess(l2.getTrackId()), l2;
      }, setAppType: function(e2) {
        if (iP.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0)) throw iP.debug("Invalid appType"), new uP(hO.INVALID_PARAMS, "invalid app type", e2);
        RD("APP_TYPE", Math.floor(e2));
      }, setLogLevel: function(e2) {
        iP.setLogLevel(e2);
      }, enableLogUpload: function() {
        CD("USE_NEW_LOG") ? RD("UPLOAD_LOG", true) : iP.enableLogUpload();
      }, disableLogUpload: function() {
        CD("USE_NEW_LOG") ? RD("UPLOAD_LOG", false) : iP.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new oj();
      }, checkAudioTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = lP.reportApiInvoke(null, { tag: kO.TRACER, name: LO.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof Bk || e2 instanceof $M)) {
          const e3 = new uP(hO.INVALID_TRACK, "the parameter is not a audio track");
          return i2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof Bk ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
        let o2 = r2, s2 = r2;
        const a2 = Date.now();
        return new rp(((r3) => {
          const c2 = setInterval((() => {
            const d2 = e2.getVolumeLevel();
            o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
            const l2 = o2 - s2 > 1e-4, u2 = Date.now() - a2;
            if (l2 || u2 > t2) {
              clearInterval(c2);
              const t3 = l2, s3 = { duration: u2, deviceLabel: n2, maxVolumeLevel: o2, result: t3 };
              iP.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i2.onSuccess(s3), r3(t3);
            }
          }), 200);
        }));
      }, checkVideoTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = lP.reportApiInvoke(null, { tag: kO.TRACER, name: LO.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof kM || e2 instanceof ZM)) {
          const e3 = new uP(hO.INVALID_TRACK, "the parameter is not a video track");
          return i2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof kM ? e2.getTrackLabel() : "remote_track", r2 = e2.getMediaStreamTrack(true), o2 = document.createElement("video");
        o2.style.width = "1px", o2.style.height = "1px", o2.setAttribute("muted", ""), o2.muted = true, o2.setAttribute("playsinline", ""), o2.controls = false, (Vw() || Mw()) && (o2.style.opacity = "0.01", o2.style.position = "fixed", o2.style.left = "0", o2.style.top = "0", document.body.appendChild(o2)), o2.srcObject = new MediaStream([r2]), o2.play();
        const s2 = document.createElement("canvas");
        s2.width = 160, s2.height = 120;
        let a2 = 0, c2 = 0;
        try {
          const e3 = Date.now();
          a2 = await (function(e4, t3, i3, n3) {
            let r3, o3 = 0, s3 = null;
            return new rp(((a3, c3) => {
              function d3() {
                o3 > n3 && r3 && (r3(), a3(o3));
                const t4 = i3.getContext("2d");
                if (!t4) {
                  const e5 = new uP(hO.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                  return iP.error(e5.toString()), void c3(e5);
                }
                t4.drawImage(e4, 0, 0, 160, 120);
                const d4 = t4.getImageData(0, 0, i3.width, i3.height), l3 = Math.floor(d4.data.length / 3);
                if (s3) {
                  for (let e5 = 0; e5 < l3; e5 += 3) if (d4.data[e5] !== s3[e5]) return o3 += 1, void (s3 = d4.data);
                  s3 = d4.data;
                } else s3 = d4.data;
              }
              setTimeout((() => {
                r3 && (r3(), a3(o3));
              }), t3), r3 = SL((() => {
                d3();
              }), 30);
            }));
          })(o2, t2, s2, 4), c2 = Date.now() - e3;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        AG === bw.SAFARI && (o2.pause(), o2.remove()), o2.srcObject = null;
        const d2 = a2 > 4, l2 = { duration: c2, changedPicNum: a2, deviceLabel: n2, result: d2 };
        return iP.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), d2;
      }, setArea: vB, audioElementPlayCenter: xL, resumeAudioContext: function() {
        return xL.autoResumeAfterInterruption(true);
      }, processExternalMediaAEC: function(e2) {
        DH.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        const t2 = CD("PLUGIN_INFO") || [];
        e2.forEach(((e3) => {
          "name" in e3 && !Ln(t2).call(t2, e3.name) && t2.push(e3.name);
          const i2 = e3;
          i2.__registered__ = true, i2.logger.hookLog = iP.extLog, i2.reporter.hookApiInvoke = lP.extApiInvoke, i2.parameters && Object.keys(i2.parameters).forEach(((e4) => {
            i2.parameters[e4] = CD(e4);
          }));
        })), TJ("PLUGIN_INFO", t2);
      }, ChannelMediaRelayError: rx, ChannelMediaRelayEvent: ix, ChannelMediaRelayState: nx, RemoteStreamFallbackType: BP, RemoteStreamType: FP, ConnectionDisconnectedReason: VO, AudienceLatencyLevelType: UO, AREAS: dx, preload: async function(e2, t2, i2, n2) {
        return GG(e2, t2, i2, n2);
      }, startLastmileProbeTest: async function(e2, t2, i2, n2) {
        let r2 = { state: "unavailable" };
        await GG(e2, t2, i2, n2);
        const o2 = await WG({ appId: e2, cname: t2, token: i2 || e2, uid: n2, cloudProxyServer: "disabled" });
        if (!o2) return r2;
        await KG(o2);
        let s2, a2 = IH({ mode: "rtc", codec: "vp8" });
        try {
          s2 = await a2.join(e2, t2, i2, n2, { networkQualityProbe: true });
        } catch (e3) {
          return r2;
        }
        const c2 = new jG(), d2 = c2.createMuteAudioTrack();
        let l2 = await UM({ mediaStreamTrack: d2 });
        await a2.publish([l2]);
        let [u2, h2, p2] = await new rp(((e3, t3) => {
          const i3 = setTimeout((() => {
            clearTimeout(i3), e3([true, null, "audio"]);
          }), 5e3);
          a2.on("user-published", (async (t4, n3) => {
            t4.uid === s2 && (clearTimeout(i3), e3([false, t4, n3]));
          }));
        }));
        if (u2 || !h2) return await a2.unpublish([l2]), await a2.leave(), l2.close(), c2.close(), r2;
        await a2.subscribe(h2, p2), await new rp(((e3, t3) => {
          const i3 = setTimeout((() => {
            clearTimeout(i3), e3(null);
          }), 5e3);
        }));
        let _2 = a2.getRTCStats(), E2 = a2.getLocalAudioStats();
        const m2 = _2.RTT, f2 = E2.sendJitterMs, S2 = E2.currentPacketLossRate;
        return r2 = { state: "complete", rtt: m2, packetLossRate: S2, jitter: f2, networkQuality: ((e3, t3, i3) => {
          let n3 = 1;
          if (i3 > 0) {
            let e4 = Math.log(100 * i3) / Math.log(2) + 1;
            e4 = Math.min(5, Math.max(0, e4)), n3 = 1 - e4 / 5;
          }
          let r3 = 1;
          if (e3 > 0) {
            let t4 = Math.log(e3 / 40) / Math.log(2) + 1;
            t4 = Math.min(5, Math.max(0, t4)), r3 = 1 - t4 / 5;
          }
          let o3 = 1;
          if (t3 > 0) {
            let e4 = Math.log(t3 / 10) / Math.log(2.5) + 1;
            e4 = Math.min(5, Math.max(0, e4)), o3 = 1 - e4 / 5;
          }
          const s3 = 0.5 * n3 + 0.3 * r3 + 0.2 * o3;
          let a3 = 0;
          return a3 = s3 >= 0.8 ? 1 : s3 >= 0.6 ? 2 : s3 >= 0.4 ? 3 : s3 >= 0.2 ? 4 : 5, a3;
        })(m2, f2, S2) }, await a2.unsubscribe(h2), await a2.unpublish([l2]), await a2.leave(), l2.close(), c2.close(), await KG(o2), r2;
      } });
      return Object.defineProperties(RJ, { onAudioAutoplayFailed: { get: () => kL.onAudioAutoplayFailed, set: (e2) => {
        kL.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => kL.onAutoplayFailed, set: (e2) => {
        kL.onAutoplayFailed = e2;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => RJ._onSecurityPolicyViolation, set(e2) {
        RJ._onSecurityPolicyViolation = e2, MH(e2);
      } }, __CLIENT_LIST__: { get: () => CD("SHOW_GLOBAL_CLIENT_LIST") ? KU : [] } }), PL.on(eL.CAMERA_DEVICE_CHANGED, ((e2) => {
        iP.info("camera device changed", JSON.stringify(e2)), RJ.onCameraChanged && RJ.onCameraChanged(e2), RJ.safeEmit(Ox.CAMERA_CHANGED, e2);
      })), PL.on(eL.RECORDING_DEVICE_CHANGED, ((e2) => {
        iP.info("microphone device changed", JSON.stringify(e2)), RJ.onMicrophoneChanged && RJ.onMicrophoneChanged(e2), RJ.safeEmit(Ox.MICROPHONE_CHANGED, e2);
      })), PL.on(eL.PLAYOUT_DEVICE_CHANGED, ((e2) => {
        iP.debug("playout device changed", JSON.stringify(e2)), RJ.onPlaybackDeviceChanged && RJ.onPlaybackDeviceChanged(e2), RJ.safeEmit(Ox.PLAYBACK_DEVICE_CHANGED, e2);
      })), xL.onAutoplayFailed = () => {
        iP.info("detect audio element autoplay failed"), kL.onAudioAutoplayFailed && kL.onAudioAutoplayFailed();
      }, _L.on("autoplay-failed", (() => {
        iP.info("detect webaudio autoplay failed"), kL.onAudioAutoplayFailed && kL.onAudioAutoplayFailed(), RJ.safeEmit(Ox.AUTOPLAY_FAILED);
      })), _L.on(RP.STATE_CHANGE, ((e2, t2) => {
        iP.info("audio context state changed: ".concat(t2, " => ").concat(e2)), RJ.onAudioContextStateChanged && RJ.onAudioContextStateChanged(e2, t2), RJ.safeEmit(Ox.AUDIO_CONTEXT_STATE_CHANGED, e2, t2);
      })), QO.on(YO.NETWORK_STATE_CHANGE, ((e2, t2) => {
        iP.info("[network-indicator] network state changed, ".concat(t2, " => ").concat(e2));
      })), window && (window.__ARTC__ = RJ), RJ;
    }));
  }
});
export default require_AgoraRTC_N_production();
//# sourceMappingURL=agora-rtc-sdk-ng.js.map
